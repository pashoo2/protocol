import { IConnectionBridgeOptions, IConnectionBridge, TNativeConnectionType, IConnectionBridgeOptionsAuth } from './types/connection-bridge.types';
import { ESwarmStoreConnector } from '../swarm-store-class/swarm-store-class.const';
import { ICentralAuthorityOptions, ICentralAuthority } from '../central-authority-class/central-authority-class.types';
import { TSwarmMessageConstructorOptions, ISwarmMessageConstructor, TSwarmMessageInstance } from '../swarm-message/swarm-message-constructor.types';
import { ISwarmMessageStoreOptions, ISwarmMessageStore, ISwarmMessageStoreEvents, TSwarmMessagesStoreGrantAccessCallback, ISwarmMessageStoreAccessControlOptions } from '../swarm-message-store/types/swarm-message-store.types';
import { CONNECTION_BRIDGE_SESSION_STORAGE_KEYS } from './connection-bridge.const';
import { ISensitiveDataSessionStorage } from 'classes/sensitive-data-session-storage/sensitive-data-session-storage.types';
import { ISwarmMessageEncryptedCacheFabric, ISwarmMessageConstructorWithEncryptedCacheFabric } from '../swarm-message-encrypted-cache/swarm-message-encrypted-cache.types';
import { ISwarmMessageEncryptedCache } from '../swarm-message-encrypted-cache';
import { ISensitiveDataSessionStorageOptions } from '../sensitive-data-session-storage/sensitive-data-session-storage.types';
import { ISecretStorage, TSecretStorageAuthorizazionOptions } from '../secret-storage-class/secret-storage-class.types';
import { IStorageProviderOptions } from '../storage-providers/storage-providers.types';
import { TSwarmStoreDatabaseType, TSwarmStoreConnectorConnectionOptions, TSwarmStoreOptionsOfDatabasesKnownList } from '../swarm-store-class/swarm-store-class.types';
import { TSwarmMessageSerialized, ISwarmMessageInstanceEncrypted } from '../swarm-message/swarm-message-constructor.types';
import { IConnectionBridgeSwarmConnection, TNativeConnectionOptions, IConnectionBridgeOptionsGetMainConnectorFabric } from './types/connection-bridge.types';
import { ICentralAuthorityUserProfile } from '../central-authority-class/central-authority-class-types/central-authority-class-types-common';
import { ISwarmStoreConnectorBasic, ISwarmStoreConnector, TSwarmStoreConnectorBasicFabric } from '../swarm-store-class/swarm-store-class.types';
import { TSwarmStoreConnectorConstructorOptions, ISwarmStoreConnectorDatabasesPersistentList, ISwarmStoreConnectorDatabasesPersistentListConstructorParams } from '../swarm-store-class/swarm-store-class.types';
import { TSwarmMessageUserIdentifierSerialized } from '../central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-common-validator-user-identifier/central-authority-common-validator-user-identifier.types';
import { TConnectionBridgeCFODefault, ISwarmStoreDatabasesPersistentListFabric } from './types/connection-bridge.types';
import { PromiseResolveType } from '../../types/promise.types';
import { ISerializer } from '../../types/serialization.types';
import { IStorageCommon } from '../../types/storage.types';
import { ISwarmMessageDatabaseConstructors, ISwarmMessageStoreOptionsWithConnectorFabric } from '../swarm-message-store/types/swarm-message-store.types';
import { TSwarmStoreDatabaseOptions, ISwarmStoreProviderOptions, ISwarmStoreOptionsConnectorFabric } from '../swarm-store-class/swarm-store-class.types';
export declare class ConnectionBridge<P extends ESwarmStoreConnector, T extends TSwarmMessageSerialized, DbType extends TSwarmStoreDatabaseType<P>, DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>, ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO>, CO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic>, PO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, CO>, ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, CO>, CFO extends ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain>, CBFO extends TSwarmStoreConnectorBasicFabric<P, T, DbType, DBO, ConnectorBasic>, MSI extends TSwarmMessageInstance | T, GAC extends TSwarmMessagesStoreGrantAccessCallback<P, Exclude<MSI, ISwarmMessageInstanceEncrypted>>, MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric, ACO extends ISwarmMessageStoreAccessControlOptions<P, T, Exclude<MSI, ISwarmMessageInstanceEncrypted>, GAC>, O extends ISwarmMessageStoreOptionsWithConnectorFabric<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, CFO>, MSI, GAC, MCF, ACO>, CD extends boolean, CBO extends IConnectionBridgeOptions<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, MSI, GAC, MCF, ACO, CFO, CBFO, CD, O, SMS, SSDPLF, SRLZR>, SMS extends ISwarmMessageStore<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, CFO>, MSI, GAC, MCF, ACO, O> = ISwarmMessageStore<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, CFO>, MSI, GAC, MCF, ACO, O>, E extends ISwarmMessageStoreEvents<P, T, DbType, DBO> = ISwarmMessageStoreEvents<P, T, DbType, DBO>, DBL extends TSwarmStoreOptionsOfDatabasesKnownList<P, T, DbType, DBO> = TSwarmStoreOptionsOfDatabasesKnownList<P, T, DbType, DBO>, NC extends TNativeConnectionType<P> = TNativeConnectionType<P>, SSDPLF extends ISwarmStoreDatabasesPersistentListFabric<P, T, DbType, DBO, Record<DBO['dbName'], DBO>> = ISwarmStoreDatabasesPersistentListFabric<P, T, DbType, DBO, Record<DBO['dbName'], DBO>>, SRLZR extends ISerializer = ISerializer> implements IConnectionBridge<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, CFO, CBFO, MSI, GAC, MCF, ACO, O, CD, CBO, SMS, SSDPLF, SRLZR> {
    static joinKeyPartsUsedForStorageValue(...parts: string[]): string;
    get swarmMessageStore(): SMS | undefined;
    get centralAuthorityConnection(): ICentralAuthority | undefined;
    messageConstructor?: PromiseResolveType<ReturnType<NonNullable<MCF>>>;
    swarmMessageEncryptedCacheFabric?: ISwarmMessageEncryptedCacheFabric;
    swarmMessageConstructorFabric?: MCF;
    get secretStorage(): ISecretStorage | undefined;
    protected options?: CBO;
    protected _swarmMessageStore?: SMS;
    protected _centralAuthorityConnection?: ICentralAuthority;
    protected get swarmStoreConnectorType(): P | undefined;
    protected optionsCentralAuthority?: ICentralAuthorityOptions;
    protected optionsSwarmConnection?: TNativeConnectionOptions<P>;
    protected optionsMessageStorage?: ISwarmMessageStoreOptions<P, T, DbType, DBO, ConnectorBasic, CO, MSI, GAC, MCF, ACO>;
    protected sessionSensitiveStorage?: ISensitiveDataSessionStorage;
    protected connectionBridgeSessionDataStore?: ISensitiveDataSessionStorage;
    protected swarmMessageEncryptedCache?: ISwarmMessageEncryptedCache;
    protected _serializer: SRLZR | undefined;
    protected _swarmConnectorDatabasesPeristentList: PromiseResolveType<ReturnType<SSDPLF>> | undefined;
    protected _secretStorage?: ISecretStorage;
    protected swarmConnection: IConnectionBridgeSwarmConnection<P, NC> | undefined;
    protected get sensitiveDataStorageOptions(): ISensitiveDataSessionStorageOptions | undefined;
    connect(options: CBO): Promise<void>;
    checkSessionAvailable(options?: ISensitiveDataSessionStorageOptions | CBO): Promise<boolean>;
    close(): Promise<void>;
    protected isUserLogin(userLogin: unknown): userLogin is string;
    protected checkCurrentOptionsIsDefined(): this is {
        options: CBO;
    };
    protected _getOptions(): CBO;
    protected _getStorageOptions(): CBO['storage'];
    protected _getCentralAuthorityConnection(): ICentralAuthority;
    protected _setSerializer(serializer: SRLZR): void;
    protected _validateSerializerInstance(serializer: SRLZR): void;
    protected _getSerializerCurrentInstance(): SRLZR;
    protected _setSerializerInstanceFromOptionsOrDefault(options: {
        serializer: SRLZR;
    }): void;
    protected _getSerializer(): SRLZR;
    protected _unsetSerializer(): void;
    protected validatetCurrentUserOptions(): void;
    protected getOptionsForSensitiveDataStoreDuringCheckSessionAvailable(): ISensitiveDataSessionStorageOptions;
    protected createOptionsForCentralAuthority(authOptions: IConnectionBridgeOptionsAuth<CD>, userOptions: {
        profile?: Partial<ICentralAuthorityUserProfile> | undefined;
    }): ICentralAuthorityOptions;
    protected setOptionsCentralAuthority(optionsCentralAuthority: ICentralAuthorityOptions): void;
    protected createOptionsForCentralAuthorityWithCurrentConnectionBridgeOptions(): ICentralAuthorityOptions;
    protected createOptionsCentralAuthority(): ICentralAuthorityOptions;
    protected createOptionsMessageConstructor(): TSwarmMessageConstructorOptions;
    protected getConnectorBasicFabricToUseInSwarmStoreConnectionProviderOptionsForSwarmStoreConnector(): TSwarmStoreConnectorBasicFabric<P, T, DbType, DBO, ConnectorBasic>;
    protected getSwarmStoreConnectionProviderOptions<SC extends IConnectionBridgeSwarmConnection<P, NC>>(swarmConnection: SC): CO;
    protected getCurrentUserIdentityFromCurrentConnectionToCentralAuthority(): TSwarmMessageUserIdentifierSerialized;
    protected getSwarmStoreConnectionProviderOptionsFromCurrentOptions(): CO;
    protected _getDefaultSwarmMessageConstructor(): PromiseResolveType<ReturnType<NonNullable<MCF>>>;
    protected getMessageConstructorOptionsForMessageStoreFromCurrentOptions(): ISwarmMessageDatabaseConstructors<PromiseResolveType<ReturnType<NonNullable<MCF>>>>;
    protected getSecretStoreCredentialsOptionsForMessageStoreFromCurrentOptions(): TSecretStorageAuthorizazionOptions;
    protected getSwarmStoreOrbitDbConnectorConstructorOptionsByConnectionBridgeOptions(userId: TSwarmMessageUserIdentifierSerialized, credentials: TSecretStorageAuthorizazionOptions, storageOptions: CBO['storage']): TSwarmStoreConnectorConstructorOptions<ESwarmStoreConnector.OrbitDB, T, DbType>;
    protected getSwarmStoreConnectorConstructorOptionsByConnectionBridgeOptions: (userId: TSwarmMessageUserIdentifierSerialized, credentials: TSecretStorageAuthorizazionOptions) => TSwarmStoreConnectorConstructorOptions<P, T, DbType>;
    protected getConnectorMainFabricFromCurrentOptionsIfExists(): CFO | undefined;
    protected getMainConnectorFabricUtilFromCurrentOptionsIfExists(): IConnectionBridgeOptionsGetMainConnectorFabric<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain> | undefined;
    protected _getSwarmDatabasesListPersistentStorageFabricFromCurrentOptions(): SSDPLF;
    protected getUtilGetMainConnectorFabricForMessageStore(): IConnectionBridgeOptionsGetMainConnectorFabric<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain>;
    protected createMainConnectorFabricForMessageStoreByCurrentOptions(userId: TSwarmMessageUserIdentifierSerialized, credentials: TSecretStorageAuthorizazionOptions): ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain>;
    protected getMainConnectorFabricForSwarmMessageStore(userId: TSwarmMessageUserIdentifierSerialized, credentials: TSecretStorageAuthorizazionOptions): CFO | ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain>;
    protected _getPersistentEncryptedStorageForStoreDatabasesListPersistentStorage: (storagePrefix: string) => Promise<IStorageCommon>;
    protected _getKeyPrefixForDatabasesLisInPersistentStorageForCurrentUser(): Promise<ISwarmStoreConnectorDatabasesPersistentListConstructorParams['keyPrefixForDatabasesLisInPersistentStorage']>;
    protected _getSwarmDatabasesListPersistentStorageFabricOptionsFromCurrentOptions(): Promise<ISwarmStoreConnectorDatabasesPersistentListConstructorParams>;
    protected _setCurrentSwarmDatabasesListPersistentStorage(swarmDatabasesListPersistentStorage: PromiseResolveType<ReturnType<SSDPLF>>): void;
    protected _createSwarmDatabasesListPersistentStorageByCurrentOptions(): Promise<PromiseResolveType<ReturnType<SSDPLF>>>;
    protected _createSwarmDatabasesListPersistentStorageByCurrentOptionsAndSetAsCurrent(): Promise<PromiseResolveType<ReturnType<SSDPLF>>>;
    protected _getCurrentSwarmDatabasesListPersistentStorageOrCreateNew(): Promise<ISwarmStoreConnectorDatabasesPersistentList<P, T, DbType, DBO, DBL>>;
    protected _closeSwarmDatabasesListPersistentStorage(): Promise<void>;
    protected getAccessControlOptionsToUse(): ACO;
    protected getSwarmMessageStoreOptions(): Promise<ISwarmMessageStoreOptionsWithConnectorFabric<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, CFO>, MSI, GAC, MCF, ACO>>;
    protected getOptionsMessageStorage(): Promise<O>;
    protected createSensitiveDataStorageInstance(): ISensitiveDataSessionStorage;
    protected connectSensitiveDataStoreConnectionBridgeSession(dataStore: ISensitiveDataSessionStorage, options: ISensitiveDataSessionStorageOptions): Promise<void>;
    protected createSessionSensitiveDataStoreForConnectionBridgeSession(options: ISensitiveDataSessionStorageOptions): Promise<ISensitiveDataSessionStorage>;
    protected createAndSetSessionSensitiveDataStoreForConnectionBridgeSessionIfNotExists(): Promise<void>;
    protected setOptions(options: CBO): void;
    protected checkConnectionBridgeSessionDataStoreIsReady(): this is {
        connectionBridgeSessionDataStore: ISensitiveDataSessionStorage;
    };
    protected getAcitveConnectionBridgeSessionDataStore(): ISensitiveDataSessionStorage;
    protected setValueInConnectionBridgeSessionDataStore(key: CONNECTION_BRIDGE_SESSION_STORAGE_KEYS, value: unknown): Promise<void>;
    protected readUserLoginKeyValueFromConnectionBridgeSessionDataStore(connectionBridgeSessionActiveDataStore: ISensitiveDataSessionStorage): unknown;
    protected readUserLoginFromConnectionBridgeSessionStore(): Promise<string | undefined>;
    protected getUserLoginFromConnectionBridgeSessionDataStore(): Promise<string>;
    protected validateOptions(options: unknown): options is CBO;
    protected isOptionsWithCredentials(options: CBO): options is CBO & IConnectionBridgeOptions<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, MSI, GAC, MCF, ACO, CFO, CBFO, true, any, any, SSDPLF, SRLZR>;
    protected setUserLoginFromOptionsInConnectionBridgeSessionDataStore(options: {
        auth: {
            credentials: {
                login: string;
            };
        };
    }): Promise<void>;
    protected setOptionsWithUserCredentialsProvided(options: {
        auth: {
            credentials: {
                login: string;
            };
        };
    }): Promise<void>;
    protected setCurrentOptionsWithoutUserCredentials(options: CBO & IConnectionBridgeOptions<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, MSI, GAC, MCF, ACO, CFO, CBFO, false, any, any, SSDPLF, SRLZR>): Promise<void>;
    protected validateAndSetOptions(options: CBO): Promise<void>;
    protected getSensitiveDataStoragePrefixForSession(sessionParams: ISensitiveDataSessionStorageOptions): Promise<string>;
    protected connectToSensitiveDataStorage(sensitiveDataStorageParams: ISensitiveDataSessionStorageOptions): Promise<ISensitiveDataSessionStorage>;
    protected setCurrentSessionSensitiveDataStorage(sessionSensitiveStorage: ISensitiveDataSessionStorage): void;
    protected createMainSensitiveDataStorageForSession(sensitiveDataStorageOptions: ISensitiveDataSessionStorageOptions): Promise<ISensitiveDataSessionStorage>;
    protected createAndSetSensitiveDataStorageForMainSession(sensitiveDataStorageOptions: ISensitiveDataSessionStorageOptions): Promise<void>;
    protected createCentralAuthorityInstnace(optionsCentralAuthority: ICentralAuthorityOptions): Promise<ICentralAuthority>;
    protected setCurrentCentralAuthorityConnection(centralAuthority: ICentralAuthority): void;
    protected createAndStartConnectionWithCentralAuthority(): Promise<ICentralAuthority>;
    protected setCurrentSwarmMessageConstructor(swarmMessageConstructor: ISwarmMessageConstructor): void;
    protected createSwarmMessageConstructor(): Promise<ISwarmMessageConstructor>;
    protected createNativeConnection: () => Promise<TNativeConnectionType<P>>;
    protected setCurrentSwarmConnection: (swarmConnection: IConnectionBridgeSwarmConnection<P, NC>) => void;
    protected createSwarmConnection(): Promise<IConnectionBridgeSwarmConnection<P, NC>>;
    protected getCredentialsWithSession(): {
        login: string;
        password: string;
        session: ISensitiveDataSessionStorage;
    } | {
        login: string;
        password: undefined;
        session: ISensitiveDataSessionStorage;
    } | {
        login: string;
        password: string;
        session: undefined;
    };
    protected getDatabaseNamePrefixForEncryptedCahce(userLogin: string): string;
    protected setCurrentSwarmMessageEncryptedCacheFabric(swarmMessageEncryptedCacheFabric: ISwarmMessageEncryptedCacheFabric): void;
    protected createSwarmMessageEncryptedCacheFabric(): Promise<ISwarmMessageEncryptedCacheFabric>;
    protected getSwarmMessageConstructorOptions(): TSwarmMessageConstructorOptions;
    protected setCurrentSwarmMessageConstructorFabric(swarmMessageConstructorFabric: ISwarmMessageConstructorWithEncryptedCacheFabric): void;
    protected getSwarmMessageConstructorFabricFromOptions(): MCF | undefined;
    protected createSwarmMessageConstructorFabric(): Promise<ISwarmMessageConstructorWithEncryptedCacheFabric>;
    protected getSwarmMessageConstructorFabric(): Promise<ISwarmMessageConstructorWithEncryptedCacheFabric>;
    protected getDatabaseNameForEncryptedCacheInstance(dbNamePrefix: string): string;
    protected getOptionsForSwarmMessageEncryptedFabric(dbNamePrefix: string): {
        dbName: string;
    };
    protected startEncryptedCache(dbNamePrefix: string): Promise<ISwarmMessageEncryptedCache>;
    protected setCurrentSwarmMessageEncryptedCache(swarmMessageEncryptedCache: ISwarmMessageEncryptedCache): void;
    protected createSwarmMessageEncryptedCache(): Promise<ISwarmMessageEncryptedCache>;
    protected createSwarmMessageStoreInstanceByOptionsFabric(): SMS;
    protected createSwarmMessageStoreInstance(): SMS;
    protected connectToSwarmMessageStore: (swarmMessageStorage: ISwarmMessageStore<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, CO, PO, ConnectorMain, CFO>, MSI, GAC, MCF, ACO, O>) => Promise<void>;
    protected setCurrentSwarmMessageStorage: (swarmMessageStorage: SMS | undefined) => void;
    protected createAndStartSwarmMessageStorageConnection(): Promise<SMS>;
    protected closeStorage(): Promise<void>;
    protected closeMessageConstructor(): void;
    protected closeSwarmConnection(): Promise<void>;
    protected closeSwarmMessageEncryptedCacheFabric(): void;
    protected closeSwarmMessageConstructorFabric(): void;
    protected closeCurrentCentralAuthorityConnection(): Promise<void>;
    protected setFlagInSessionStorageSessionDataIsExists(): Promise<void>;
    protected markSessionAsStartedInStorageForSession(): Promise<void>;
    protected getSecretStorageDBName(): string;
    protected getSecretStorageDBOptions(): Partial<IStorageProviderOptions>;
    protected createSecretStorageInstance(): ISecretStorage;
    protected authorizeInSecretStorage(secretStorage: ISecretStorage): Promise<void>;
    protected setCurrentSecretStorageInstance(secretStorage: ISecretStorage): void;
    protected createAndAutorizeInSecretStorage(): Promise<ISecretStorage>;
    protected isConnectionBridgeOptionsWithSession(options: ISensitiveDataSessionStorageOptions | CBO): options is CBO;
    protected getSessionParamsOrUndefinedFromConnectionBridgeOrSensitiveDataSessionStorageOptions(options?: ISensitiveDataSessionStorageOptions | CBO): ISensitiveDataSessionStorageOptions | CBO | undefined;
    protected whetherAnySessionDataExistsInSensitiveDataSessionStorage(sensitiveDataStorage: ISensitiveDataSessionStorage): Promise<boolean>;
    protected createAndSetSequentlyDependenciesInstances(): Promise<void>;
    protected closeAndUnsetCurrentSessionSensitiveStorage(): Promise<void>;
    protected closeAndUnsetConnectionBridgeSessionDataStore(): Promise<void>;
    protected closeSensitiveDataStorages(): Promise<void>;
}
//# sourceMappingURL=connection-bridge.d.ts.map