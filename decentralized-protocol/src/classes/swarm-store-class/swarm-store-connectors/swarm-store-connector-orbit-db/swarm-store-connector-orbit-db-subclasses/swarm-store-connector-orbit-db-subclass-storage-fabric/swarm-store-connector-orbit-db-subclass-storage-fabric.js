import { __awaiter } from "tslib";
import Storage from 'orbit-db-storage-adapter';
import { ISecretStoreCredentials } from "../../../../../secret-storage-class/secret-storage-class.types";
import { SecretStorage } from "../../../../../secret-storage-class/secret-storage-class";
import { SwarmStoreConnectorOrbitDBSubclassStorageCache } from '../swarm-store-connector-orbit-db-subclass-storage-cache/swarm-store-connector-orbit-db-subclass-storage-cache';
import { SwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapter } from '../swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter';
import assert from 'assert';
import { swarmStoreConnectorOrbitDbUtilsAddressCreateOrbitDbAddressByDatabaseName } from '../../swarm-store-connector-orbit-db-utils/swarm-store-connector-orbit-db-utils-address/swarm-store-connector-orbit-db-utils-address';
import { swarmStoreConnectorOrbitDbUtilsAddresGetHashPathFull } from '../../swarm-store-connector-orbit-db-utils';
export class SwarmStoreConnectorOrbitDBSubclassStorageFabric {
    constructor({ credentials, rootPath }) {
        this.secretDatabasesNames = new Set();
        this.secretDatabasesPaths = new Set();
        this.addSecretDatabaseName = (dbName) => __awaiter(this, void 0, void 0, function* () {
            const databasePath = yield this.createPathForDb(dbName);
            this.secretDatabasesNames.add(dbName);
            this.secretDatabasesPaths.add(databasePath);
        });
        if (credentials) {
            this.applyCredentials(credentials);
        }
        this.setRootPath(rootPath);
        this.createStorage();
    }
    createStore(path) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ready;
            if (this.whetherUseSecretStorageForPath(path)) {
                return this.createSecretStorageForPath(path);
            }
            return this.createOpenStorageForPath(path);
        });
    }
    createStoreForDb(dbName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ready;
            const dbPath = yield this.createPathForDb(dbName);
            if (this.whetherUseSecretStorageForDB(dbName)) {
                return this.createSecretStorageForPath(dbPath);
            }
            return this.createOpenStorageForPath(dbPath);
        });
    }
    setRootPath(rootPath) {
        assert(typeof rootPath === 'string', 'Root path should be a string');
        this.rootPath = rootPath;
    }
    createStorage() {
        this.storage = Storage();
    }
    whetherUseSecretStorageForDB(dbName) {
        return this.secretDatabasesNames.has(dbName);
    }
    whetherUseSecretStorageForPath(path) {
        return this.secretDatabasesPaths.has(path);
    }
    applyCredentials(credentials) {
        this.ready = this.createKey(credentials);
    }
    createKey(credentials) {
        return __awaiter(this, void 0, void 0, function* () {
            const secretStorage = new SecretStorage();
            const cryptoKey = yield secretStorage.generateCryptoKey(credentials);
            if (cryptoKey instanceof Error) {
                console.error(`createKey::${cryptoKey}`);
                throw new Error('Failed to generate a key');
            }
            if (!(cryptoKey instanceof CryptoKey)) {
                throw new Error('createKey::the key generated by a password string must be a CryptoKey');
            }
            this.key = cryptoKey;
        });
    }
    createSecretStorageCacheInstance(path) {
        const { key } = this;
        if (!key) {
            throw new Error('A CryptoKey is not exists');
        }
        if (!(key instanceof CryptoKey)) {
            throw new Error('The key must be an instance of CryptoKey');
        }
        const cache = new SwarmStoreConnectorOrbitDBSubclassStorageCache({ dbName: path }, { key });
        return cache;
    }
    createSecretStorageForPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const cache = this.createSecretStorageCacheInstance(path);
            yield cache.open();
            return cache;
        });
    }
    createOptionsForOpenStorageCacheInstanceConstructor(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const dbName = yield swarmStoreConnectorOrbitDbUtilsAddresGetHashPathFull(path);
            return { dbName };
        });
    }
    createOpenStorageCacheInstance(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const cacheStoreConstructorOptions = yield this.createOptionsForOpenStorageCacheInstanceConstructor(path);
            const cacheStoreInstance = new SwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapter(cacheStoreConstructorOptions);
            return cacheStoreInstance;
        });
    }
    createOpenStorageForPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const cache = yield this.createOpenStorageCacheInstance(path);
            yield cache.open();
            return cache;
        });
    }
    createPathForDb(dbName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.rootPath) {
                throw new Error('A root path is not defined');
            }
            return swarmStoreConnectorOrbitDbUtilsAddressCreateOrbitDbAddressByDatabaseName(this.rootPath, dbName);
        });
    }
}
//# sourceMappingURL=swarm-store-connector-orbit-db-subclass-storage-fabric.js.map