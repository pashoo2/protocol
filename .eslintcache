[{"/home/paul/projects/decentrilized-protocol/src/App.tsx":"1","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/error-extended-class-base/error-extended-class-base.ts":"2","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/event-emitter-class-base/event-emitter-class-base.ts":"3","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/event-emitter-class-base/event-emitter-class-base.types.ts":"4","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-base-body-processor.ts":"5","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-base-response-error.ts":"6","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-response-processor.ts":"7","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-utils.ts":"8","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.const.ts":"9","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.ts":"10","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.types.ts":"11","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.utils.ts":"12","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/mime-types-class-base/mime-types-class-base.const.ts":"13","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/mime-types-class-base/mime-types-class-base.ts":"14","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.const.ts":"15","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.ts":"16","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.types.ts":"17","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/status-class-base/status-class-base.const.ts":"18","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/status-class-base/status-class-base.ts":"19","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/status-class-base/status-class-base.types.ts":"20","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const-auth-credentials.ts":"21","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const.ts":"22","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-common.ts":"23","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-credentials.ts":"24","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-keys.ts":"25","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types.ts":"26","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v1/central-authority-class-user-identity-formatters-formatter-v1.ts":"27","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.const.ts":"28","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.ts":"29","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.types.ts":"30","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.utils.ts":"31","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/central-authority-class-user-identity-parsers-parser-v1.const.ts":"32","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/central-authority-class-user-identity-parsers-parser-v1.ts":"33","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.const.ts":"34","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.ts":"35","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.types.ts":"36","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.utils.ts":"37","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v1/central-authority-class-user-identity-validator-v1.ts":"38","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.const.ts":"39","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.ts":"40","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.types.ts":"41","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.utils.ts":"42","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const.ts":"43","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.ts":"44","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types.ts":"45","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class.ts":"46","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.const.ts":"47","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.ts":"48","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.types.ts":"49","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database.const.ts":"50","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database.ts":"51","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.error-codes.ts":"52","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.restrictions.ts":"53","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.ts":"54","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.ts":"55","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.types.configuration.ts":"56","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-server-api/central-authority-connection-server-api.ts":"57","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const-error-codes.ts":"58","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const.ts":"59","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections.types.ts":"60","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-storage/central-authority-storage-credentials/central-authority-storage-credentials.const.ts":"61","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-storage/central-authority-storage-credentials/central-authority-storage-credentials.ts":"62","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-storage/central-authority-storage-identity-credentials/central-authority-identity-storage.types.ts":"63","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-storage/central-authority-storage-identity-credentials/central-authority-storage-identity-credentials.const.ts":"64","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-storage/central-authority-storage-identity-credentials/central-authority-storage-identity-credentials.ts":"65","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-common.ts":"66","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-export.ts":"67","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-generate.ts":"68","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-import.ts":"69","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys.const.ts":"70","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys.ts":"71","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials.ts":"72","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials.ts":"73","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys-schemas.ts":"74","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys.ts":"75","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user.schemes.ts":"76","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user.ts":"77","/home/paul/projects/decentrilized-protocol/src/classes/channel-authority-class/channel-authority-class.ts":"78","/home/paul/projects/decentrilized-protocol/src/classes/channel-authority-class/channel-authority-class.types.ts":"79","/home/paul/projects/decentrilized-protocol/src/classes/channel-authority-class/channel-authority-connections/channel-authority-connection-with-server-api/channel-authority-connection-with-server-api.ts":"80","/home/paul/projects/decentrilized-protocol/src/classes/channel-authority-class/channel-authority-connections/channel-authority-connection-with-server-api/channel-authority-connection-with-server-api.types.ts":"81","/home/paul/projects/decentrilized-protocol/src/classes/safe-storage-class/safe-storage-class.const.ts":"82","/home/paul/projects/decentrilized-protocol/src/classes/safe-storage-class/safe-storage-class.ts":"83","/home/paul/projects/decentrilized-protocol/src/classes/safe-storage-class/safe-storage-class.types.ts":"84","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret_storage_providers/secret-storage-level-js-provider/secret-storage-level-js-provider.const.ts":"85","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret_storage_providers/secret-storage-level-js-provider/secret-storage-level-js-provider.ts":"86","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret_storage_providers/secret-storage-local-forage-provider/secret-storage-local-forage-provider.const.ts":"87","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret_storage_providers/secret-storage-local-forage-provider/secret-storage-local-forage-provider.ts":"88","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret_storage_providers/secret-storage-local-storage-provider/secret-storage-local-storage-provider.ts":"89","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret_storage_providers/secret-storage-session-storage-provider/secret-storage-session-storage-provider.ts":"90","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret-storage-class.const.ts":"91","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret-storage-class.ts":"92","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret-storage-class.types.ts":"93","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.browser.conf.ts":"94","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.const.ts":"95","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.delegate.conf.ts":"96","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.libp2p.conf.ts":"97","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.signal-star.conf.ts":"98","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.ts":"99","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.types.ts":"100","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-bootstrap.d.ts":"101","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-delegated-content-routing.d.ts":"102","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-delegated-peer-routing.d.ts":"103","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-gossipsub.d.ts":"104","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-kad-dht.d.ts":"105","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-secio.d.ts":"106","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-spdy.d.ts":"107","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-webrtc-star.d.ts":"108","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-websocket-star.d.ts":"109","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p.d.ts":"110","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/multiaddr.d.ts":"111","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/pull-mplex.d.ts":"112","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class.ts":"113","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class.types.ts":"114","/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-raw-constructor/swarm-message-subclass-raw-constructor.const.ts":"115","/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-raw-constructor/swarm-message-subclass-raw-constructor.ts":"116","/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-raw-constructor/swarm-message-subclass-raw-constructor.types.ts":"117","/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validator/swarm-message-subclass-validator.const.ts":"118","/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validator/swarm-message-subclass-validator.ts":"119","/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validator/swarm-message-subclass-validator.types.ts":"120","/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message.const.ts":"121","/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message.ts":"122","/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message.types.ts":"123","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-class.ts":"124","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-class.types.ts":"125","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.const.ts":"126","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.ts":"127","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.types.ts":"128","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const.ts":"129","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.ts":"130","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types.ts":"131","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider.const.ts":"132","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider.ts":"133","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.const.ts":"134","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.ts":"135","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.utils.ts":"136","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-cache/swarm-store-connector-orbit-db-subclass-storage-cache.ts":"137","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.ts":"138","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.types.ts":"139","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.const.ts":"140","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.ts":"141","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.types.ts":"142","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.const.ts":"143","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.ts":"144","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types.ts":"145","/home/paul/projects/decentrilized-protocol/src/const/common-date-time/common-date-time-timezone.const.ts":"146","/home/paul/projects/decentrilized-protocol/src/const/common-values/common-values.ts":"147","/home/paul/projects/decentrilized-protocol/src/const/const-validation-schemes/const-validation-schemes-common.ts":"148","/home/paul/projects/decentrilized-protocol/src/const/const-validation-schemes/const-validation-schemes-credentials.ts":"149","/home/paul/projects/decentrilized-protocol/src/const/const-validation-schemes/const-validation-schemes.ts":"150","/home/paul/projects/decentrilized-protocol/src/const/const-validation-values/const-validation-values-messaging-common/const-validation-values-messaging-common.ts":"151","/home/paul/projects/decentrilized-protocol/src/const/const-validation-values/const-validation-values-messaging-common/const-validation-values-messaging-common.types.ts":"152","/home/paul/projects/decentrilized-protocol/src/const/const-validation-values/const-validation-values-messaging-date.ts":"153","/home/paul/projects/decentrilized-protocol/src/const/const-validation-values/const-validation-values-messaging-timestamp.ts":"154","/home/paul/projects/decentrilized-protocol/src/const/const-values-restrictions-common.ts":"155","/home/paul/projects/decentrilized-protocol/src/index.tsx":"156","/home/paul/projects/decentrilized-protocol/src/react-app-env.d.ts":"157","/home/paul/projects/decentrilized-protocol/src/test/data-sign-test.ts":"158","/home/paul/projects/decentrilized-protocol/src/test/encryption-test.ts":"159","/home/paul/projects/decentrilized-protocol/src/test/error-extended-class-test.ts":"160","/home/paul/projects/decentrilized-protocol/src/test/ipfs-swarm-connection.test/ipfs-swarm-connection.const.ts":"161","/home/paul/projects/decentrilized-protocol/src/test/mocha-chai-initialize.ts":"162","/home/paul/projects/decentrilized-protocol/src/test/validation-messaging.test/validate-messaging-timestamps-test.ts":"163","/home/paul/projects/decentrilized-protocol/src/types/channels.types.ts":"164","/home/paul/projects/decentrilized-protocol/src/types/encryption-keys.types.ts":"165","/home/paul/projects/decentrilized-protocol/src/types/helper.types.ts":"166","/home/paul/projects/decentrilized-protocol/src/types/ipfs.d.ts":"167","/home/paul/projects/decentrilized-protocol/src/types/ipfs.types.d.ts":"168","/home/paul/projects/decentrilized-protocol/src/types/main.types.ts":"169","/home/paul/projects/decentrilized-protocol/src/types/orbit-db-cache.d.ts":"170","/home/paul/projects/decentrilized-protocol/src/types/orbit-db-identity-provider-ext.d.ts":"171","/home/paul/projects/decentrilized-protocol/src/types/orbit-db-keystore.d.ts":"172","/home/paul/projects/decentrilized-protocol/src/types/users.types.ts":"173","/home/paul/projects/decentrilized-protocol/src/utils/common-utils/common-utils-array.ts":"174","/home/paul/projects/decentrilized-protocol/src/utils/common-utils/common-utils-date-time.ts":"175","/home/paul/projects/decentrilized-protocol/src/utils/common-utils/common-utils-objects.ts":"176","/home/paul/projects/decentrilized-protocol/src/utils/common-utils/common-utils-timer.ts":"177","/home/paul/projects/decentrilized-protocol/src/utils/common-utils/common-utils.ts":"178","/home/paul/projects/decentrilized-protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.const.ts":"179","/home/paul/projects/decentrilized-protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.ts":"180","/home/paul/projects/decentrilized-protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.types.ts":"181","/home/paul/projects/decentrilized-protocol/src/utils/data-cache-utils/data-cache-utils.ts":"182","/home/paul/projects/decentrilized-protocol/src/utils/data-compression-utils/data-compression-utils-strings.ts":"183","/home/paul/projects/decentrilized-protocol/src/utils/data-compression-utils/data-compression-utils.const.ts":"184","/home/paul/projects/decentrilized-protocol/src/utils/data-compression-utils/data-compression-utils.ts":"185","/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/data-sign-utils.const.ts":"186","/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/data-sign-utils.ts":"187","/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/data-sign-utils.types.ts":"188","/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/keys.data-sign-utils.ts":"189","/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/main.data-sign-utils.const.ts":"190","/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/sign-data.encryption-utils.ts":"191","/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/verify-data.encryption-utils.ts":"192","/home/paul/projects/decentrilized-protocol/src/utils/data-validators-utils/data-validators-utils-common.ts":"193","/home/paul/projects/decentrilized-protocol/src/utils/data-validators-utils/data-validators-utils.ts":"194","/home/paul/projects/decentrilized-protocol/src/utils/encryption-keys-utils/encryption-keys-utils.const.ts":"195","/home/paul/projects/decentrilized-protocol/src/utils/encryption-keys-utils/encryption-keys-utils.ts":"196","/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/crypto-utils.const.ts":"197","/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/crypto-utils.types.ts":"198","/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/decrypt-data.encryption-utils.ts":"199","/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/encrypt-data.encryption-utils.ts":"200","/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/encryption-utils.ts":"201","/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/keys.encryption-utils.ts":"202","/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/main.crypto-utils.const.ts":"203","/home/paul/projects/decentrilized-protocol/src/utils/firebase-utils/firebase-utils.ts":"204","/home/paul/projects/decentrilized-protocol/src/utils/hash-calculation-utils/hash-calculation-utils.const.ts":"205","/home/paul/projects/decentrilized-protocol/src/utils/hash-calculation-utils/hash-calculation-utils.ts":"206","/home/paul/projects/decentrilized-protocol/src/utils/identity-utils/identity-utils.ts":"207","/home/paul/projects/decentrilized-protocol/src/utils/lazy-loading-utils/lazy-loading-utils.ts":"208","/home/paul/projects/decentrilized-protocol/src/utils/main-utils.ts":"209","/home/paul/projects/decentrilized-protocol/src/utils/password-utils/decrypt.password-utils.ts":"210","/home/paul/projects/decentrilized-protocol/src/utils/password-utils/derive-key.password-utils.ts":"211","/home/paul/projects/decentrilized-protocol/src/utils/password-utils/encrypt.password-utils.ts":"212","/home/paul/projects/decentrilized-protocol/src/utils/password-utils/password-utils.const.ts":"213","/home/paul/projects/decentrilized-protocol/src/utils/password-utils/password-utils.types.ts":"214","/home/paul/projects/decentrilized-protocol/src/utils/string-encoding-utils.ts":"215","/home/paul/projects/decentrilized-protocol/src/utils/string-utilities.ts":"216","/home/paul/projects/decentrilized-protocol/src/utils/typed-array-utils.ts":"217","/home/paul/projects/decentrilized-protocol/src/utils/validation-utils/validation-utils-timestamp.ts":"218","/home/paul/projects/decentrilized-protocol/src/utils/validation-utils/validation-utils.ts":"219","/home/paul/projects/decentrilized-protocol/src/App.test.tsx":"220","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-aurhority.keys.common.test.ts":"221","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.const.ts":"222","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.credentials-storage.ts":"223","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.database.ts":"224","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.ts":"225","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.utils.ts":"226","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-connection.test/central-authority-connection.test.ts":"227","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-identity.test.ts":"228","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-storage-identity-credentials.test.ts":"229","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority.credentials-storage.test.ts":"230","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority.keys.test.ts":"231","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority.test.ts":"232","/home/paul/projects/decentrilized-protocol/src/test/common-utils.test/common-utils.caching-decorator.test.ts":"233","/home/paul/projects/decentrilized-protocol/src/test/common-utils.test/common-utils.test.ts":"234","/home/paul/projects/decentrilized-protocol/src/test/http-request-class-base.test/http-request-class-base.test.ts":"235","/home/paul/projects/decentrilized-protocol/src/test/ipfs-swarm-connection.test/ipfs-swarm-connection-ipfs.test.ts":"236","/home/paul/projects/decentrilized-protocol/src/test/ipfs-swarm-connection.test/ipfs-swarm-connection.test.ts":"237","/home/paul/projects/decentrilized-protocol/src/test/nodejs-helpers.test/nodejs-helpers.test.firebase/nodejs-helpers.test.firebase.js":"238","/home/paul/projects/decentrilized-protocol/src/test/password-key.test.ts":"239","/home/paul/projects/decentrilized-protocol/src/test/safe-storage.test.ts":"240","/home/paul/projects/decentrilized-protocol/src/test/secret-storage.test.ts":"241","/home/paul/projects/decentrilized-protocol/src/test/swarm-storage-orbit-db.test/swarm-storage-orbit-db.test.const.ts":"242","/home/paul/projects/decentrilized-protocol/src/test/swarm-storage-orbit-db.test/swarm-storage-orbit-db.test.ts":"243","/home/paul/projects/decentrilized-protocol/src/test/valiation-utils.test.ts":"244","/home/paul/projects/decentrilized-protocol/src/test/validation-messaging.test/validation-messaging.test.const.ts":"245","/home/paul/projects/decentrilized-protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.const.ts":"246","/home/paul/projects/decentrilized-protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.ts":"247","/home/paul/projects/decentrilized-protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.types.ts":"248","/home/paul/projects/decentrilized-protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.utils.ts":"249","/home/paul/projects/decentrilized-protocol/src/const/const-api-conf.ts":"250"},{"size":3663,"mtime":1574970452495,"results":"251","hashOfConfig":"252"},{"size":578,"mtime":1574620670429,"results":"253","hashOfConfig":"252"},{"size":235,"mtime":1574620670429,"results":"254","hashOfConfig":"252"},{"size":1329,"mtime":1574797996119,"results":"255","hashOfConfig":"252"},{"size":2819,"mtime":1574797996123,"results":"256","hashOfConfig":"252"},{"size":1636,"mtime":1574620670433,"results":"257","hashOfConfig":"252"},{"size":3466,"mtime":1574797996123,"results":"258","hashOfConfig":"252"},{"size":4421,"mtime":1574797996123,"results":"259","hashOfConfig":"252"},{"size":1311,"mtime":1574797996123,"results":"260","hashOfConfig":"252"},{"size":7950,"mtime":1574797996123,"results":"261","hashOfConfig":"252"},{"size":1874,"mtime":1574797996123,"results":"262","hashOfConfig":"252"},{"size":2547,"mtime":1574797996123,"results":"263","hashOfConfig":"252"},{"size":728,"mtime":1574620670433,"results":"264","hashOfConfig":"252"},{"size":1648,"mtime":1574620670433,"results":"265","hashOfConfig":"252"},{"size":191,"mtime":1574620670433,"results":"266","hashOfConfig":"252"},{"size":2582,"mtime":1574797996123,"results":"267","hashOfConfig":"252"},{"size":978,"mtime":1574620670433,"results":"268","hashOfConfig":"252"},{"size":58,"mtime":1574620670433,"results":"269","hashOfConfig":"252"},{"size":2147,"mtime":1574797996123,"results":"270","hashOfConfig":"252"},{"size":216,"mtime":1574620670433,"results":"271","hashOfConfig":"252"},{"size":1301,"mtime":1574620670433,"results":"272","hashOfConfig":"252"},{"size":66,"mtime":1574620670433,"results":"273","hashOfConfig":"252"},{"size":2176,"mtime":1574620670433,"results":"274","hashOfConfig":"252"},{"size":1053,"mtime":1574620670433,"results":"275","hashOfConfig":"252"},{"size":751,"mtime":1574620670433,"results":"276","hashOfConfig":"252"},{"size":187,"mtime":1574620670437,"results":"277","hashOfConfig":"252"},{"size":1299,"mtime":1574620670437,"results":"278","hashOfConfig":"252"},{"size":556,"mtime":1574797996123,"results":"279","hashOfConfig":"252"},{"size":224,"mtime":1574620670437,"results":"280","hashOfConfig":"252"},{"size":379,"mtime":1574620670437,"results":"281","hashOfConfig":"252"},{"size":2670,"mtime":1574620670437,"results":"282","hashOfConfig":"252"},{"size":384,"mtime":1574620670437,"results":"283","hashOfConfig":"252"},{"size":1406,"mtime":1574620670437,"results":"284","hashOfConfig":"252"},{"size":495,"mtime":1574797996123,"results":"285","hashOfConfig":"252"},{"size":215,"mtime":1574620670437,"results":"286","hashOfConfig":"252"},{"size":340,"mtime":1574620670437,"results":"287","hashOfConfig":"252"},{"size":3790,"mtime":1574620670437,"results":"288","hashOfConfig":"252"},{"size":1449,"mtime":1574620670437,"results":"289","hashOfConfig":"252"},{"size":567,"mtime":1574797996123,"results":"290","hashOfConfig":"252"},{"size":224,"mtime":1574620670437,"results":"291","hashOfConfig":"252"},{"size":76,"mtime":1574620670437,"results":"292","hashOfConfig":"252"},{"size":3882,"mtime":1574620670437,"results":"293","hashOfConfig":"252"},{"size":578,"mtime":1574620670437,"results":"294","hashOfConfig":"252"},{"size":5894,"mtime":1574797996123,"results":"295","hashOfConfig":"252"},{"size":1706,"mtime":1574620670441,"results":"296","hashOfConfig":"252"},{"size":33,"mtime":1574620670441,"results":"297","hashOfConfig":"252"},{"size":311,"mtime":1574620670441,"results":"298","hashOfConfig":"252"},{"size":14274,"mtime":1574797996123,"results":"299","hashOfConfig":"252"},{"size":870,"mtime":1574620670441,"results":"300","hashOfConfig":"252"},{"size":145,"mtime":1574620670441,"results":"301","hashOfConfig":"252"},{"size":3894,"mtime":1574620670441,"results":"302","hashOfConfig":"252"},{"size":110,"mtime":1574620670441,"results":"303","hashOfConfig":"252"},{"size":77,"mtime":1574620670441,"results":"304","hashOfConfig":"252"},{"size":75,"mtime":1574620670441,"results":"305","hashOfConfig":"252"},{"size":32290,"mtime":1574797996123,"results":"306","hashOfConfig":"252"},{"size":306,"mtime":1574620670441,"results":"307","hashOfConfig":"252"},{"size":894,"mtime":1574797996123,"results":"308","hashOfConfig":"252"},{"size":385,"mtime":1574620670441,"results":"309","hashOfConfig":"252"},{"size":67,"mtime":1574620670441,"results":"310","hashOfConfig":"252"},{"size":2627,"mtime":1574620670441,"results":"311","hashOfConfig":"252"},{"size":2157,"mtime":1574620670441,"results":"312","hashOfConfig":"252"},{"size":14554,"mtime":1574620670445,"results":"313","hashOfConfig":"252"},{"size":2915,"mtime":1574620670445,"results":"314","hashOfConfig":"252"},{"size":1395,"mtime":1574620670445,"results":"315","hashOfConfig":"252"},{"size":12329,"mtime":1574620670445,"results":"316","hashOfConfig":"252"},{"size":3891,"mtime":1574620670445,"results":"317","hashOfConfig":"252"},{"size":3547,"mtime":1574797996123,"results":"318","hashOfConfig":"252"},{"size":5462,"mtime":1574797996123,"results":"319","hashOfConfig":"252"},{"size":4913,"mtime":1574620670445,"results":"320","hashOfConfig":"252"},{"size":453,"mtime":1574620670445,"results":"321","hashOfConfig":"252"},{"size":310,"mtime":1574620670445,"results":"322","hashOfConfig":"252"},{"size":9735,"mtime":1574620670445,"results":"323","hashOfConfig":"252"},{"size":2213,"mtime":1574620670445,"results":"324","hashOfConfig":"252"},{"size":665,"mtime":1574620670445,"results":"325","hashOfConfig":"252"},{"size":4181,"mtime":1574620670445,"results":"326","hashOfConfig":"252"},{"size":1589,"mtime":1574620670445,"results":"327","hashOfConfig":"252"},{"size":504,"mtime":1574620670445,"results":"328","hashOfConfig":"252"},{"size":33,"mtime":1574620670449,"results":"329","hashOfConfig":"252"},{"size":602,"mtime":1574620670449,"results":"330","hashOfConfig":"252"},{"size":43,"mtime":1574620670449,"results":"331","hashOfConfig":"252"},{"size":163,"mtime":1574620670449,"results":"332","hashOfConfig":"252"},{"size":1510,"mtime":1574620670449,"results":"333","hashOfConfig":"252"},{"size":32718,"mtime":1574797996127,"results":"334","hashOfConfig":"252"},{"size":1498,"mtime":1574620670449,"results":"335","hashOfConfig":"252"},{"size":80,"mtime":1574797996127,"results":"336","hashOfConfig":"252"},{"size":5237,"mtime":1574797996127,"results":"337","hashOfConfig":"252"},{"size":216,"mtime":1574797996127,"results":"338","hashOfConfig":"252"},{"size":5726,"mtime":1574797996127,"results":"339","hashOfConfig":"252"},{"size":1378,"mtime":1574620670449,"results":"340","hashOfConfig":"252"},{"size":1423,"mtime":1574620670449,"results":"341","hashOfConfig":"252"},{"size":1435,"mtime":1574797996127,"results":"342","hashOfConfig":"252"},{"size":23205,"mtime":1574797996127,"results":"343","hashOfConfig":"252"},{"size":2106,"mtime":1574797996127,"results":"344","hashOfConfig":"252"},{"size":1467,"mtime":1574620670453,"results":"345","hashOfConfig":"252"},{"size":1403,"mtime":1574797996127,"results":"346","hashOfConfig":"252"},{"size":4370,"mtime":1574797996127,"results":"347","hashOfConfig":"252"},{"size":8907,"mtime":1574797996127,"results":"348","hashOfConfig":"252"},{"size":1851,"mtime":1574797996127,"results":"349","hashOfConfig":"252"},{"size":10977,"mtime":1574797996131,"results":"350","hashOfConfig":"252"},{"size":114,"mtime":1574797996131,"results":"351","hashOfConfig":"252"},{"size":35,"mtime":1574620670453,"results":"352","hashOfConfig":"252"},{"size":51,"mtime":1574620670453,"results":"353","hashOfConfig":"252"},{"size":48,"mtime":1574620670453,"results":"354","hashOfConfig":"252"},{"size":35,"mtime":1574620670453,"results":"355","hashOfConfig":"252"},{"size":33,"mtime":1574620670453,"results":"356","hashOfConfig":"252"},{"size":31,"mtime":1574620670453,"results":"357","hashOfConfig":"252"},{"size":30,"mtime":1574620670453,"results":"358","hashOfConfig":"252"},{"size":37,"mtime":1574620670453,"results":"359","hashOfConfig":"252"},{"size":40,"mtime":1574620670453,"results":"360","hashOfConfig":"252"},{"size":25,"mtime":1574620670453,"results":"361","hashOfConfig":"252"},{"size":28,"mtime":1574620670453,"results":"362","hashOfConfig":"252"},{"size":29,"mtime":1574620670453,"results":"363","hashOfConfig":"252"},{"size":5821,"mtime":1574797996131,"results":"364","hashOfConfig":"252"},{"size":2201,"mtime":1574797996131,"results":"365","hashOfConfig":"252"},{"size":76,"mtime":1574797996131,"results":"366","hashOfConfig":"252"},{"size":780,"mtime":1574797996131,"results":"367","hashOfConfig":"252"},{"size":1208,"mtime":1574797996131,"results":"368","hashOfConfig":"252"},{"size":465,"mtime":1574797996131,"results":"369","hashOfConfig":"252"},{"size":13877,"mtime":1574797996131,"results":"370","hashOfConfig":"252"},{"size":2028,"mtime":1574797996131,"results":"371","hashOfConfig":"252"},{"size":34,"mtime":1574797996131,"results":"372","hashOfConfig":"252"},{"size":29,"mtime":1574797996131,"results":"373","hashOfConfig":"252"},{"size":894,"mtime":1574797996131,"results":"374","hashOfConfig":"252"},{"size":20,"mtime":1574797996135,"results":"375","hashOfConfig":"252"},{"size":20,"mtime":1574797996135,"results":"376","hashOfConfig":"252"},{"size":270,"mtime":1574797996135,"results":"377","hashOfConfig":"252"},{"size":7019,"mtime":1574797996135,"results":"378","hashOfConfig":"252"},{"size":2052,"mtime":1574797996135,"results":"379","hashOfConfig":"252"},{"size":1153,"mtime":1574797996135,"results":"380","hashOfConfig":"252"},{"size":15837,"mtime":1574797996135,"results":"381","hashOfConfig":"252"},{"size":2293,"mtime":1574797996135,"results":"382","hashOfConfig":"252"},{"size":126,"mtime":1574797996135,"results":"383","hashOfConfig":"252"},{"size":2744,"mtime":1574797996135,"results":"384","hashOfConfig":"252"},{"size":157,"mtime":1574797996135,"results":"385","hashOfConfig":"252"},{"size":677,"mtime":1574797996135,"results":"386","hashOfConfig":"252"},{"size":1607,"mtime":1574797996135,"results":"387","hashOfConfig":"252"},{"size":763,"mtime":1574797996135,"results":"388","hashOfConfig":"252"},{"size":2655,"mtime":1574797996139,"results":"389","hashOfConfig":"252"},{"size":158,"mtime":1574797996139,"results":"390","hashOfConfig":"252"},{"size":562,"mtime":1574797996139,"results":"391","hashOfConfig":"252"},{"size":8360,"mtime":1574797996139,"results":"392","hashOfConfig":"252"},{"size":286,"mtime":1574797996139,"results":"393","hashOfConfig":"252"},{"size":2536,"mtime":1574797996139,"results":"394","hashOfConfig":"252"},{"size":36272,"mtime":1574797996139,"results":"395","hashOfConfig":"252"},{"size":1582,"mtime":1574797996139,"results":"396","hashOfConfig":"252"},{"size":54,"mtime":1574797996139,"results":"397","hashOfConfig":"252"},{"size":228,"mtime":1574797996139,"results":"398","hashOfConfig":"252"},{"size":2139,"mtime":1574620670465,"results":"399","hashOfConfig":"252"},{"size":480,"mtime":1574620670465,"results":"400","hashOfConfig":"252"},{"size":56,"mtime":1574620670465,"results":"401","hashOfConfig":"252"},{"size":771,"mtime":1574797996139,"results":"402","hashOfConfig":"252"},{"size":132,"mtime":1574797996139,"results":"403","hashOfConfig":"252"},{"size":1398,"mtime":1575051686631,"results":"404","hashOfConfig":"252"},{"size":1330,"mtime":1574797996143,"results":"405","hashOfConfig":"252"},{"size":290,"mtime":1574620670465,"results":"406","hashOfConfig":"252"},{"size":168,"mtime":1574797996143,"results":"407","hashOfConfig":"252"},{"size":40,"mtime":1574620670465,"results":"408","hashOfConfig":"252"},{"size":2348,"mtime":1574620670469,"results":"409","hashOfConfig":"252"},{"size":3237,"mtime":1574797996143,"results":"410","hashOfConfig":"252"},{"size":2982,"mtime":1574620670469,"results":"411","hashOfConfig":"252"},{"size":343,"mtime":1574797996143,"results":"412","hashOfConfig":"252"},{"size":1529,"mtime":1574797996143,"results":"413","hashOfConfig":"252"},{"size":1525,"mtime":1574797996147,"results":"414","hashOfConfig":"252"},{"size":534,"mtime":1574620670473,"results":"415","hashOfConfig":"252"},{"size":215,"mtime":1574620670473,"results":"416","hashOfConfig":"252"},{"size":325,"mtime":1574797996147,"results":"417","hashOfConfig":"252"},{"size":23,"mtime":1574797996147,"results":"418","hashOfConfig":"252"},{"size":10916,"mtime":1574797996147,"results":"419","hashOfConfig":"252"},{"size":306,"mtime":1574620670473,"results":"420","hashOfConfig":"252"},{"size":2965,"mtime":1574797996147,"results":"421","hashOfConfig":"252"},{"size":261,"mtime":1574797996147,"results":"422","hashOfConfig":"252"},{"size":937,"mtime":1574797996147,"results":"423","hashOfConfig":"252"},{"size":338,"mtime":1574620670473,"results":"424","hashOfConfig":"252"},{"size":2797,"mtime":1574797996147,"results":"425","hashOfConfig":"252"},{"size":832,"mtime":1574797996147,"results":"426","hashOfConfig":"252"},{"size":215,"mtime":1574620670473,"results":"427","hashOfConfig":"252"},{"size":314,"mtime":1574797996147,"results":"428","hashOfConfig":"252"},{"size":38,"mtime":1574620670473,"results":"429","hashOfConfig":"252"},{"size":66,"mtime":1574620670477,"results":"430","hashOfConfig":"252"},{"size":3866,"mtime":1574797996151,"results":"431","hashOfConfig":"252"},{"size":178,"mtime":1574620670477,"results":"432","hashOfConfig":"252"},{"size":89,"mtime":1574620670477,"results":"433","hashOfConfig":"252"},{"size":532,"mtime":1574620670477,"results":"434","hashOfConfig":"252"},{"size":63,"mtime":1574620670477,"results":"435","hashOfConfig":"252"},{"size":50,"mtime":1574620670477,"results":"436","hashOfConfig":"252"},{"size":1290,"mtime":1574620670477,"results":"437","hashOfConfig":"252"},{"size":136,"mtime":1574620670477,"results":"438","hashOfConfig":"252"},{"size":1614,"mtime":1574620670477,"results":"439","hashOfConfig":"252"},{"size":9208,"mtime":1574797996151,"results":"440","hashOfConfig":"252"},{"size":50,"mtime":1574620670477,"results":"441","hashOfConfig":"252"},{"size":1935,"mtime":1574797996151,"results":"442","hashOfConfig":"252"},{"size":2157,"mtime":1574797996151,"results":"443","hashOfConfig":"252"},{"size":821,"mtime":1574620670477,"results":"444","hashOfConfig":"252"},{"size":48,"mtime":1574620670477,"results":"445","hashOfConfig":"252"},{"size":281,"mtime":1574620670477,"results":"446","hashOfConfig":"252"},{"size":2120,"mtime":1574620670477,"results":"447","hashOfConfig":"252"},{"size":961,"mtime":1574620670477,"results":"448","hashOfConfig":"252"},{"size":1800,"mtime":1574620670477,"results":"449","hashOfConfig":"252"},{"size":2313,"mtime":1574620670477,"results":"450","hashOfConfig":"252"},{"size":4319,"mtime":1574797996151,"results":"451","hashOfConfig":"252"},{"size":141,"mtime":1574620670477,"results":"452","hashOfConfig":"252"},{"size":6608,"mtime":1574797996151,"results":"453","hashOfConfig":"252"},{"size":50,"mtime":1574620670481,"results":"454","hashOfConfig":"252"},{"size":554,"mtime":1574620670481,"results":"455","hashOfConfig":"252"},{"size":231,"mtime":1574620670481,"results":"456","hashOfConfig":"252"},{"size":1262,"mtime":1574620670481,"results":"457","hashOfConfig":"252"},{"size":75,"mtime":1574620670481,"results":"458","hashOfConfig":"252"},{"size":560,"mtime":1574620670481,"results":"459","hashOfConfig":"252"},{"size":718,"mtime":1574620670481,"results":"460","hashOfConfig":"252"},{"size":2978,"mtime":1574797996151,"results":"461","hashOfConfig":"252"},{"size":5442,"mtime":1574620670481,"results":"462","hashOfConfig":"252"},{"size":2382,"mtime":1574620670481,"results":"463","hashOfConfig":"252"},{"size":2434,"mtime":1574620670481,"results":"464","hashOfConfig":"252"},{"size":473,"mtime":1574620670481,"results":"465","hashOfConfig":"252"},{"size":575,"mtime":1574797996151,"results":"466","hashOfConfig":"252"},{"size":462,"mtime":1574620670481,"results":"467","hashOfConfig":"252"},{"size":2902,"mtime":1574620670481,"results":"468","hashOfConfig":"252"},{"size":1033,"mtime":1574797996151,"results":"469","hashOfConfig":"252"},{"size":394,"mtime":1574620670481,"results":"470","hashOfConfig":"252"},{"size":248,"mtime":1574620670429,"results":"471","hashOfConfig":"472"},{"size":10900,"mtime":1574620863005,"results":"473","hashOfConfig":"472"},{"size":730,"mtime":1574620670465,"results":"474","hashOfConfig":"472"},{"size":3946,"mtime":1574620670465,"results":"475","hashOfConfig":"472"},{"size":2920,"mtime":1574620670465,"results":"476","hashOfConfig":"472"},{"size":6824,"mtime":1574620863005,"results":"477","hashOfConfig":"472"},{"size":4035,"mtime":1574620670465,"results":"478","hashOfConfig":"472"},{"size":2098,"mtime":1574620670465,"results":"479","hashOfConfig":"472"},{"size":12018,"mtime":1574620863005,"results":"480","hashOfConfig":"472"},{"size":8252,"mtime":1574620863009,"results":"481","hashOfConfig":"472"},{"size":5943,"mtime":1574620670469,"results":"482","hashOfConfig":"472"},{"size":428,"mtime":1574620670469,"results":"483","hashOfConfig":"472"},{"size":162,"mtime":1574620670469,"results":"484","hashOfConfig":"472"},{"size":3057,"mtime":1574620670469,"results":"485","hashOfConfig":"472"},{"size":55,"mtime":1574620670469,"results":"486","hashOfConfig":"472"},{"size":474,"mtime":1574621187430,"results":"487","hashOfConfig":"472"},{"size":1618,"mtime":1574620863009,"results":"488","hashOfConfig":"472"},{"size":3186,"mtime":1574620863009,"results":"489","hashOfConfig":"472"},{"size":1228,"mtime":1574620863009,"results":"490","hashOfConfig":"472"},{"size":3100,"mtime":1574620670469,"results":"491","hashOfConfig":"472"},{"size":2100,"mtime":1574620670469,"results":"492","hashOfConfig":"472"},{"size":1477,"mtime":1574620670473,"results":"493","hashOfConfig":"472"},{"size":4769,"mtime":1574620863009,"results":"494","hashOfConfig":"472"},{"size":33866,"mtime":1574620863009,"results":"495","hashOfConfig":"472"},{"size":1642,"mtime":1574620670473,"results":"496","hashOfConfig":"472"},{"size":133,"mtime":1574620863009,"results":"497","hashOfConfig":"472"},{"size":839,"mtime":1574971490437,"results":"498","hashOfConfig":"252"},{"size":15343,"mtime":1575054110553,"results":"499","hashOfConfig":"252"},{"size":3120,"mtime":1574799545056,"results":"500","hashOfConfig":"252"},{"size":514,"mtime":1574797996147,"results":"501","hashOfConfig":"252"},{"size":78,"mtime":1574797996139,"results":"502","hashOfConfig":"252"},{"filePath":"503","messages":"504","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"505"},"u6995m",{"filePath":"506","messages":"507","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"508","messages":"509","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"510","messages":"511","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"512"},{"filePath":"513","messages":"514","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"515"},{"filePath":"516","messages":"517","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"518"},{"filePath":"519","messages":"520","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"521"},{"filePath":"522","messages":"523","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"524"},{"filePath":"525","messages":"526","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"527","messages":"528","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"529"},{"filePath":"530","messages":"531","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"532","messages":"533","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"534"},{"filePath":"535","messages":"536","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"537","messages":"538","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"539"},{"filePath":"540","messages":"541","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"542","messages":"543","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"544"},{"filePath":"545","messages":"546","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"547","messages":"548","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"549","messages":"550","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"551"},{"filePath":"552","messages":"553","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"554","messages":"555","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"556","messages":"557","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"558","messages":"559","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"560"},{"filePath":"561","messages":"562","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"563"},{"filePath":"564","messages":"565","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"566","messages":"567","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"568","messages":"569","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"570","messages":"571","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"572","messages":"573","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"574","messages":"575","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"576","messages":"577","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"578"},{"filePath":"579","messages":"580","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"581","messages":"582","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"583","messages":"584","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"585","messages":"586","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"587","messages":"588","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"589"},{"filePath":"590","messages":"591","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"592","messages":"593","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"594"},{"filePath":"595","messages":"596","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"597","messages":"598","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"599","messages":"600","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"601"},{"filePath":"602","messages":"603","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"604"},{"filePath":"605","messages":"606","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"607","messages":"608","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"609"},{"filePath":"610","messages":"611","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"612"},{"filePath":"613","messages":"614","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"615","messages":"616","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"617","messages":"618","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"619"},{"filePath":"620","messages":"621","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"622"},{"filePath":"623","messages":"624","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"625","messages":"626","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"627"},{"filePath":"628","messages":"629","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"630","messages":"631","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"632","messages":"633","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"634","messages":"635","errorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"636"},{"filePath":"637","messages":"638","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"639","messages":"640","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"641","messages":"642","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"643","messages":"644","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"645","messages":"646","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"647","messages":"648","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"649","messages":"650","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"651"},{"filePath":"652","messages":"653","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"654"},{"filePath":"655","messages":"656","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"657","messages":"658","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"659"},{"filePath":"660","messages":"661","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"662"},{"filePath":"663","messages":"664","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"665"},{"filePath":"666","messages":"667","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"668"},{"filePath":"669","messages":"670","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"671"},{"filePath":"672","messages":"673","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"674","messages":"675","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"676","messages":"677","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"678"},{"filePath":"679","messages":"680","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"681"},{"filePath":"682","messages":"683","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"684","messages":"685","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"686"},{"filePath":"687","messages":"688","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"689","messages":"690","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"691"},{"filePath":"692","messages":"693","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"694","messages":"695","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"696","messages":"697","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"698","messages":"699","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"700","messages":"701","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"702","messages":"703","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"704"},{"filePath":"705","messages":"706","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"707"},{"filePath":"708","messages":"709","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"710","messages":"711","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"712"},{"filePath":"713","messages":"714","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"715","messages":"716","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"717"},{"filePath":"718","messages":"719","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"720","messages":"721","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"722","messages":"723","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"724","messages":"725","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"726"},{"filePath":"727","messages":"728","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"729"},{"filePath":"730","messages":"731","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"732"},{"filePath":"733","messages":"734","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"735"},{"filePath":"736","messages":"737","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"738","messages":"739","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"740"},{"filePath":"741","messages":"742","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"743","messages":"744","errorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"745"},{"filePath":"746","messages":"747","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"748","messages":"749","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"750","messages":"751","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"752","messages":"753","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"754","messages":"755","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"756","messages":"757","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"758","messages":"759","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"760","messages":"761","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"762","messages":"763","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"764","messages":"765","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"766","messages":"767","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"768","messages":"769","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"770","messages":"771","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"772","messages":"773","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"774"},{"filePath":"775","messages":"776","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"777","messages":"778","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"779","messages":"780","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"781"},{"filePath":"782","messages":"783","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"784"},{"filePath":"785","messages":"786","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"787","messages":"788","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"789"},{"filePath":"790","messages":"791","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"792","messages":"793","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"794","messages":"795","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"796","messages":"797","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"798","messages":"799","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"800","messages":"801","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"802","messages":"803","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"804","messages":"805","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"806"},{"filePath":"807","messages":"808","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"809","messages":"810","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"811","messages":"812","errorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"813"},{"filePath":"814","messages":"815","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"816","messages":"817","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"818","messages":"819","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"820"},{"filePath":"821","messages":"822","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"823","messages":"824","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"825","messages":"826","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"827","messages":"828","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"829","messages":"830","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"831","messages":"832","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"833","messages":"834","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"835","messages":"836","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"837"},{"filePath":"838","messages":"839","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"840","messages":"841","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"842"},{"filePath":"843","messages":"844","errorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":1,"source":"845"},{"filePath":"846","messages":"847","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"848","messages":"849","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"850","messages":"851","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"852","messages":"853","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"854","messages":"855","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"856","messages":"857","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"858","messages":"859","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"860"},{"filePath":"861","messages":"862","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"863","messages":"864","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"865"},{"filePath":"866","messages":"867","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"868"},{"filePath":"869","messages":"870","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"871","messages":"872","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"873","messages":"874","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"875","messages":"876","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"877"},{"filePath":"878","messages":"879","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"880"},{"filePath":"881","messages":"882","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"883"},{"filePath":"884","messages":"885","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"886","messages":"887","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"888"},{"filePath":"889","messages":"890","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"891"},{"filePath":"892","messages":"893","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"894","messages":"895","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"896","messages":"897","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"898","messages":"899","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"900","messages":"901","errorCount":0,"warningCount":115,"fixableErrorCount":0,"fixableWarningCount":0,"source":"902"},{"filePath":"903","messages":"904","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"905","messages":"906","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"907","messages":"908","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"909","messages":"910","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"911"},{"filePath":"912","messages":"913","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"914","messages":"915","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"916"},{"filePath":"917","messages":"918","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"919","messages":"920","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"921"},{"filePath":"922","messages":"923","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"924"},{"filePath":"925","messages":"926","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"927","messages":"928","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"929","messages":"930","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"931"},{"filePath":"932","messages":"933","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"934","messages":"935","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"936","messages":"937","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"938","messages":"939","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"940","messages":"941","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"942","messages":"943","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"944","messages":"945","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"946","messages":"947","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"948","messages":"949","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"950"},{"filePath":"951","messages":"952","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"953","messages":"954","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"955"},{"filePath":"956","messages":"957","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"958"},{"filePath":"959","messages":"960","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"961"},{"filePath":"962","messages":"963","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"964","messages":"965","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"966","messages":"967","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"968"},{"filePath":"969","messages":"970","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"971","messages":"972","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"973","messages":"974","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"975","messages":"976","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"977"},{"filePath":"978","messages":"979","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"980","messages":"981","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"982"},{"filePath":"983","messages":"984","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"985","messages":"986","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"987","messages":"988","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"989","messages":"990","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"991","messages":"992","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"993"},{"filePath":"994","messages":"995","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"996"},{"filePath":"997","messages":"998","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"999","messages":"1000","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1001","messages":"1002","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1003","messages":"1004","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1005"},{"filePath":"1006","messages":"1007","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1008","messages":"1009","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1010","messages":"1011","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1012"},{"filePath":"1013","messages":"1014","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1015","messages":"1016","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1017"},{"filePath":"1018","messages":"1019","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1020","messages":"1021","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1022"},{"filePath":"1023","messages":"1024","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1o2e4c6",{"filePath":"1025","messages":"1026","errorCount":2,"warningCount":1,"fixableErrorCount":2,"fixableWarningCount":0,"source":"1027"},{"filePath":"1028","messages":"1029","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1030"},{"filePath":"1031","messages":"1032","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1033"},{"filePath":"1034","messages":"1035","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1036"},{"filePath":"1037","messages":"1038","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1039"},{"filePath":"1040","messages":"1041","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1042"},{"filePath":"1043","messages":"1044","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1045"},{"filePath":"1046","messages":"1047","errorCount":1,"warningCount":2,"fixableErrorCount":1,"fixableWarningCount":0,"source":"1048"},{"filePath":"1049","messages":"1050","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1051"},{"filePath":"1052","messages":"1053","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1054"},{"filePath":"1055","messages":"1056","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1057"},{"filePath":"1058","messages":"1059","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1060","messages":"1061","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1062"},{"filePath":"1063","messages":"1064","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1065","messages":"1066","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1067"},{"filePath":"1068","messages":"1069","errorCount":1,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1070"},{"filePath":"1071","messages":"1072","errorCount":2,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1073"},{"filePath":"1074","messages":"1075","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1076"},{"filePath":"1077","messages":"1078","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1079"},{"filePath":"1080","messages":"1081","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1082"},{"filePath":"1083","messages":"1084","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1085"},{"filePath":"1086","messages":"1087","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1088"},{"filePath":"1089","messages":"1090","errorCount":24,"warningCount":48,"fixableErrorCount":18,"fixableWarningCount":0,"source":"1091"},{"filePath":"1092","messages":"1093","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1094"},{"filePath":"1095","messages":"1096","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1097","messages":"1098","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1099","messages":"1100","errorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"1101","messages":"1102","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1103"},{"filePath":"1104","messages":"1105","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1106"},{"filePath":"1107","messages":"1108","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/paul/projects/decentrilized-protocol/src/App.tsx",["1109","1110","1111","1112","1113","1114","1115","1116","1117","1118","1119","1120","1121"],"import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nimport { runTestFirebaseConnectionDatabase } from 'test/central-authority.test/central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.database';\nimport { runTestFirebaseCredentialsStorage } from 'test/central-authority.test/central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.credentials-storage';\nimport { runTestCAIdentityWithAuthorityProviderGenerator } from 'test/central-authority.test/central-authority.test';\nimport {\n  runTestCAConnectionFirebase,\n  runTestCAConnectionFirebaseCryptoCredentialsGenerateByFirebaseAuthProvider,\n} from 'test/central-authority.test/central-authority-connection.test/central-authority-connection.test';\nimport { runTestErrorExtended } from 'test/error-extended-class-test';\nimport { runTestSwarmConnection } from 'test/ipfs-swarm-connection.test/ipfs-swarm-connection.test';\nimport { runTestSwarmConnectionIPFS } from 'test/ipfs-swarm-connection.test/ipfs-swarm-connection-ipfs.test';\nimport { initializeMocha, runMocha } from 'test/mocha-chai-initialize';\nimport { runTestSwarmStoreOrbitDBConnection } from 'test/swarm-storage-orbit-db.test/swarm-storage-orbit-db.test';\nimport { runTestValidateMessagingTimestampsTest } from 'test/validation-messaging.test/validate-messaging-timestamps-test';\nimport { runTestHttpRequest } from 'test/http-request-class-base.test/http-request-class-base.test';\nimport { runTestPseudoNtpClass } from 'test/pseudo-ntp-class.test/pseudo-ntp-class.test';\n\n// import { runCACredentialsIdentityStorageTest } from 'test/central-authority.test/central-authority-storage-identity-credentials.test';\n// import { runTestCachingDecorator } from 'test/common-utils.test/common-utils.test';\n// import { runTestCAIdentity } from 'test/central-authority.test/central-authority.test';\n// import {\n//   runTestKeys,\n//   runTestsCredentialsStorage,\n// } from 'test/central-authority.test/central-authority.test';\n// import 'test/data-sign-test';\n// import 'test/password-key.test';\n// import { runTest } from 'test/safe-storage.test';\n//import { runTest } from 'test/valiation-utils.test';\n// import { runTest } from 'test/secret-storage.test';\n\n// runTest();\n// runTestsCredentialsStorage();\n// runTestCAIdentity();\n// runTestCachingDecorator();\n// runCACredentialsIdentityStorageTest();\n\n// runTestProfileValidation();\n// runTestFirebaseCredentialsStorage();\n\n// runTestErrorExtended();\n// runTestCAConnectionFirebase();\n// runTestCAConnectionFirebaseCryptoCredentialsGenerateByFirebaseAuthProvider();\n// runTestFirebaseConnectionDatabase();\n// runTestCAIdentityWithAuthorityProviderGenerator();\n// runTestFirebaseCredentialsStorage();\n\n// runTestSwarmConnectionIPFS();\n\nconst runTest = async () => {\n  await initializeMocha();\n\n  // runTestSwarmConnection();\n  // runTestSwarmStoreOrbitDBConnection();\n  // runTestValidateMessagingTimestampsTest();\n  // runTestHttpRequest();\n  runTestPseudoNtpClass();\n  runMocha();\n};\n\nrunTest();\n\nconst App: React.FC = () => {\n  return null;\n  // return (\n  //   <div className=\"App\">\n  //     <header className=\"App-header\">\n  //       <img src={logo} className=\"App-logo\" alt=\"logo\" />\n  //       <p>\n  //         Edit <code>src/App.tsx</code> and save to reload.\n  //       </p>\n  //       <a\n  //         className=\"App-link\"\n  //         href=\"https://reactjs.org\"\n  //         target=\"_blank\"\n  //         rel=\"noopener noreferrer\"\n  //       >\n  //         Learn React\n  //       </a>\n  //     </header>\n  //   </div>\n  // );\n};\n\nexport default App;\n","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/error-extended-class-base/error-extended-class-base.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/event-emitter-class-base/event-emitter-class-base.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/event-emitter-class-base/event-emitter-class-base.types.ts",["1122","1123","1124"],"import { ownKeyOf } from 'types/helper.types';\nimport { any } from 'prop-types';\n\n/**\n * the source code is based on\n * https://github.com/andywer/typed-emitter\n */\n\ntype Arguments<T> = [T] extends [(...args: infer U) => any]\n  ? U\n  : [T] extends [void]\n  ? []\n  : [T];\n\nexport type TEventsList = { [key in string | symbol]: any };\n\ntype keyOf<T extends TEventsList> = ownKeyOf<T> extends string | symbol\n  ? keyof T\n  : never;\n\ntype TEvent = keyOf<TEventsList>;\n\nexport interface TypedEventEmitter<Events extends TEventsList> {\n  addListener<E extends TEvent>(event: E, listener: Events[E]): this;\n  on<E extends TEvent>(event: E, listener: Events[E]): this;\n  once<E extends TEvent>(event: E, listener: Events[E]): this;\n  prependListener<E extends TEvent>(event: E, listener: Events[E]): this;\n  prependOnceListener<E extends TEvent>(event: E, listener: Events[E]): this;\n\n  removeAllListeners<E extends TEvent>(event: E): this;\n  removeListener<E extends TEvent>(event: E, listener: Events[E]): this;\n\n  emit<E extends TEvent>(event: E, ...args: Arguments<Events[E]>): boolean;\n  eventNames(): TEvent[];\n  listeners<E extends TEvent>(event: E): Function[];\n  listenerCount<E extends TEvent>(event: E): number;\n\n  getMaxListeners(): number;\n  setMaxListeners(maxListeners: number): this;\n}\n\nexport default TypedEventEmitter;\n","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-base-body-processor.ts",["1125","1126","1127","1128","1129","1130"],"import { IHttpRequestOptions } from '../http-request-class-base.types';\nimport {\n  HTTP_REQUEST_METHOD,\n  HTTP_REQUEST_CONTENT_TYPE,\n} from '../http-request-class-base.const';\nimport {\n  objectToUrlEncodedString,\n  IParamsObject,\n  objectToFormData,\n  IParamsObjectFormData,\n} from '../http-request-class-base.utils';\n\nexport class HttpRequestBodyProcessor {\n  protected static logError(methodName: string, err: string | Error) {\n    console.error(`HttpRequestBodyProcessor::${methodName}`, err);\n  }\n\n  constructor(protected options: IHttpRequestOptions) {}\n\n  private get bodyRAW() {\n    const { options } = this;\n    const { body } = options;\n\n    return body;\n  }\n\n  private get bodyType() {\n    const { bodyRAW: body } = this;\n\n    return typeof body;\n  }\n\n  protected processBodyAsMultipart() {\n    const { bodyRAW: body, bodyType } = this;\n\n    if (body instanceof FormData) {\n      return body;\n    }\n    if (bodyType === 'object') {\n      return objectToFormData(body as IParamsObjectFormData);\n    }\n    HttpRequestBodyProcessor.logError(\n      'checkBodyIsMultipart',\n      'a wrong type of the body'\n    );\n    return undefined;\n  }\n\n  protected processBodyAsUrlEncoded() {\n    const { bodyRAW: body, bodyType } = this;\n\n    switch (bodyType) {\n      case 'string':\n        return encodeURI(String(body));\n      case 'object':\n        return objectToUrlEncodedString(body as IParamsObject);\n      default: {\n        HttpRequestBodyProcessor.logError(\n          'processBodyAsUrlEncoded',\n          'a wrong type of the body'\n        );\n        return undefined;\n      }\n    }\n  }\n\n  protected processBodyAsJSON(): string | FormData | undefined {\n    const { bodyRAW: body, bodyType } = this;\n\n    switch (bodyType) {\n      case 'string':\n        return body as string;\n      case 'number':\n      case 'object':\n        return JSON.stringify(body);\n      default:\n        return undefined;\n    }\n  }\n\n  protected preProcessBody(): string | FormData | undefined {\n    const { options } = this;\n    const { contentType } = options;\n\n    if (typeof contentType === 'string') {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      switch (contentType!) {\n        case HTTP_REQUEST_CONTENT_TYPE.JSON:\n          return this.processBodyAsJSON();\n        case HTTP_REQUEST_CONTENT_TYPE.URL_ENCODED:\n          return this.processBodyAsUrlEncoded();\n        case HTTP_REQUEST_CONTENT_TYPE.MULTIPART:\n          return this.processBodyAsMultipart();\n      }\n    }\n    return undefined;\n  }\n\n  protected getBody(): string | FormData | undefined {\n    const { options } = this;\n    const { method } = options;\n\n    if (\n      method === HTTP_REQUEST_METHOD.GET ||\n      method === HTTP_REQUEST_METHOD.DELETE\n    ) {\n      return undefined;\n    }\n    return this.preProcessBody();\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-base-response-error.ts",["1131","1132","1133","1134"],"import {\n  isClientSideError,\n  getNetworkError,\n} from '../http-request-class-base-utils';\n\nexport class HttpResponseError extends Error {\n  public code?: number;\n  public error?: Error;\n  // is error code is between the 400..500\n  public isClientError: boolean = false;\n\n  protected response: Response;\n\n  constructor(response: Response) {\n    super();\n    this.response = response;\n    this.processResponse();\n  }\n\n  setResponseCode() {\n    const { response } = this;\n    const { status } = response;\n\n    this.code = status ? Number(status) : undefined;\n  }\n\n  setIsClientSideError() {\n    const { response } = this;\n\n    this.isClientError = isClientSideError(response);\n  }\n\n  async errorMessage() {\n    const { message, response } = this;\n\n    if (message && typeof message === 'string') {\n      return message;\n    }\n    try {\n      const { statusText } = response;\n      const message = await response.text();\n\n      this.message = statusText;\n      if (message) {\n        // cached error message\n        this.message = String(message);\n        return message;\n      }\n      return statusText;\n    } catch (err) {\n      console.error(`HttpResponseError::setErrorMessage::fail`, err);\n      return err;\n    }\n  }\n\n  mergeWithNetworkError(): boolean {\n    const { response } = this;\n    const networkError = getNetworkError(response);\n\n    if (networkError instanceof Error) {\n      Object.assign(this, networkError);\n      return true;\n    }\n    return false;\n  }\n\n  processResponse() {\n    this.setResponseCode();\n    this.setIsClientSideError();\n    if (!this.mergeWithNetworkError()) {\n      this.errorMessage();\n    }\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-response-processor.ts",["1135"],"import { HttpResponseError } from './http-request-class-base-response-error';\nimport { THttpResponseResult } from '../http-request-class-base.types';\nimport {\n  isSucceedResponse,\n  getContentTypeRAW,\n} from '../http-request-class-base-utils';\nimport { HTTP_RESPONSE_TYPES } from '../http-request-class-base.const';\nimport { MimeTypeClass } from 'classes/basic-classes/mime-types-class-base/mime-types-class-base';\n\nexport class HttpRequestResponseProcessor {\n  constructor(protected response: Response) {}\n\n  protected logError(error: Error): Error {\n    console.error(error);\n    return error;\n  }\n\n  protected async processAsText(): Promise<string | Error> {\n    const { response } = this;\n\n    try {\n      const result = await response.text();\n\n      return result;\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processAsFormData(): Promise<Error | FormData> {\n    const { response } = this;\n    let result;\n\n    try {\n      if (typeof response.formData === 'function') {\n        result = await response.formData();\n      } else {\n      }\n\n      return new Error(\"Can't process the response as FormData\");\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processAsBlob(): Promise<Error | object> {\n    const { response } = this;\n\n    try {\n      const result = await response.blob();\n\n      return result;\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processAsFile(\n    mimeType?: string | null,\n    extension?: string | null\n  ): Promise<Error | object> {\n    const { response } = this;\n\n    try {\n      const result = await response.blob();\n\n      if (result instanceof Blob) {\n        return new File([result], extension || 'unknown', {\n          type: mimeType || undefined,\n        });\n      }\n      return new Error(\"Can't process the response as a file\");\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processAsJSON(): Promise<Error | object> {\n    const { response } = this;\n\n    try {\n      const result = await response.json();\n\n      if (result && typeof result === 'object') {\n        return result;\n      }\n      return new Error(\"Can't process the response as json\");\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processResponse(): Promise<Error | THttpResponseResult> {\n    const { response } = this;\n    const contentType = getContentTypeRAW(response);\n\n    if (contentType) {\n      const mimeType = new MimeTypeClass(contentType);\n\n      if (mimeType.isBlob) {\n        return this.processAsBlob();\n      }\n      if (mimeType.isJSON) {\n        return this.processAsJSON();\n      }\n      if (mimeType.isText) {\n        return this.processAsText();\n      }\n      if (mimeType.isFile) {\n        return this.processAsFile(contentType, mimeType.extension);\n      }\n      return new Error('There is unknown mime-type of the response content');\n    }\n\n    return new Error('There is no \"Content-Type\" in the response headers');\n  }\n\n  public async getResult(): Promise<\n    Error | HttpResponseError | THttpResponseResult\n  > {\n    const { response } = this;\n\n    if (response.type === HTTP_RESPONSE_TYPES.OPAQUE) {\n      return undefined;\n    }\n    if (response.type === HTTP_RESPONSE_TYPES.OPAQUE_REDIRECT) {\n      return undefined;\n    }\n    if (!isSucceedResponse(response)) {\n      return new HttpResponseError(response);\n    }\n    return this.processResponse();\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-utils.ts",["1136","1137","1138"],"import {\n  HTTP_REQUEST_ERROR_CODES_RANGE,\n  HTTP_REQUEST_CONTENT_TYPE,\n  HTTP_REQUEST_HEADERS_NAMES,\n  HTTP_REQUEST_CONTENT_TYPES_KNOWN,\n  HTTP_RESPONSE_TYPES,\n} from './http-request-class-base.const';\nimport { ownValueOf } from 'types/helper.types';\nimport {\n  TQueryStringParamsObject,\n  TQueryStringAllowedParamValue,\n  TQueryStringParams,\n} from './http-request-class-base.types';\nimport { concatStrings } from 'utils/string-utilities';\n\nconst { NO_ERROR, CLIENT_ERROR } = HTTP_REQUEST_ERROR_CODES_RANGE;\nconst [MIN_CODE_SUCCESS, MAX_CODE_SUCCESS] = NO_ERROR;\nconst [MIN_CODE_ERROR_CLIENT, MAX_CODE_ERROR_CLIENT] = CLIENT_ERROR;\n\nexport const isSucceedResponse = (response: Response): boolean => {\n  const { status, type } = response;\n\n  if (type === HTTP_RESPONSE_TYPES.ERROR) {\n    return false;\n  }\n\n  if (!status) {\n    return false;\n  }\n  if (status >= MIN_CODE_SUCCESS && status <= MAX_CODE_SUCCESS) {\n    return true;\n  }\n  return false;\n};\n\nexport const isClientSideError = (response: Response): boolean => {\n  const { status } = response;\n\n  if (!status) {\n    return false;\n  }\n  if (status >= MIN_CODE_ERROR_CLIENT && status <= MAX_CODE_ERROR_CLIENT) {\n    return true;\n  }\n  return false;\n};\n\nexport const getContentType = (response: Response): void | string => {\n  const { headers } = response;\n\n  if (headers) {\n    const contentType = headers.get(\n      HTTP_REQUEST_HEADERS_NAMES.CONTENT_TYPE\n    ) as HTTP_REQUEST_CONTENT_TYPE;\n\n    if (contentType && HTTP_REQUEST_CONTENT_TYPES_KNOWN.includes(contentType)) {\n      return contentType;\n    }\n  }\n  return undefined;\n};\n\nexport const getContentTypeRAW = (response: Response): void | string => {\n  const { headers } = response;\n\n  if (headers) {\n    const contentType = headers.get(HTTP_REQUEST_HEADERS_NAMES.CONTENT_TYPE);\n\n    if (typeof contentType === 'string') {\n      return contentType;\n    }\n  }\n  return undefined;\n};\n\nexport const getNetworkError = (response: Response): Error | void => {\n  if (typeof (response as any).error === 'function') {\n    const networkError = (response as any).error();\n\n    return networkError;\n  }\n  return undefined;\n};\n\n/**\n * resolve a param as a string can be used as\n * a query string param\n * @param {object | string | number | Array<object | string | number> } paramValue\n * @returns string\n */\nexport const resolveQueryStringParam = (\n  paramValue: TQueryStringAllowedParamValue\n): string => {\n  if (paramValue instanceof Array) {\n    return `[${paramValue.map(resolveQueryStringParam)}]`;\n  }\n\n  const paramValueType = typeof paramValue;\n  let resolvedValue;\n\n  try {\n    switch (paramValueType) {\n      case 'string':\n        resolvedValue = paramValue as string;\n        break;\n      case 'number':\n        resolvedValue = String(paramValue);\n        break;\n      default:\n        resolvedValue = JSON.stringify(paramValue);\n        break;\n    }\n    if (resolvedValue) {\n      return encodeURIComponent(resolvedValue);\n    }\n  } catch (err) {\n    console.error(err);\n  }\n  return '';\n};\n\n/**\n *\n * @param {object} obj\n * @returns {string} - string in the format of\n * param1=value1....&paramN=valueN\n */\nexport const queryStringFromObject = (\n  obj: TQueryStringParamsObject\n): string => {\n  if (obj && typeof obj === 'object') {\n    const paramNames = Object.keys(obj);\n    const paramsCount = paramNames.length;\n    const paramsLastIdx = paramsCount - 1;\n    let idx = 0;\n    let result = '';\n    let paramName;\n    let paramValue;\n    let paramValueString;\n\n    for (; idx < paramsCount; idx += 1) {\n      paramName = paramNames[idx];\n      paramValue = obj[paramName];\n      paramValueString = resolveQueryStringParam(paramValue);\n      result = `${encodeURIComponent(paramName)}=${paramValueString}${\n        idx !== paramsLastIdx ? '&' : ''\n      }`;\n    }\n    return result;\n  }\n  return '';\n};\n\nexport const resolveQueryStringParams = (\n  ...params: TQueryStringParams[]\n): string => {\n  const paramsCount = params.length;\n  let idx = 0;\n  let result = '';\n  let paramValue;\n  let paramStringValue;\n\n  for (; idx < paramsCount; idx += 1) {\n    paramValue = params[idx];\n    if (paramValue && typeof paramValue === 'object') {\n      paramStringValue = queryStringFromObject(\n        paramValue as TQueryStringParamsObject\n      );\n    } else {\n      paramStringValue = resolveQueryStringParam(paramValue);\n    }\n    result = concatStrings('&', result, paramStringValue);\n  }\n  return result;\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.ts",["1139","1140","1141","1142"],"import { isURL } from 'validator';\nimport { HttpRequestBodyProcessor } from './http-request-class-base-subclasses/http-request-class-base-body-processor';\nimport {\n  IHttpRequestOptions,\n  IHttpRequestHeaders,\n  THttpResponseResult,\n  THttpRequestToken,\n  TQueryStringParams,\n} from './http-request-class-base.types';\nimport {\n  HTTP_REQUEST_HEADERS_NAMES,\n  HTTP_REQUEST_METHOD,\n  HTTP_REQUEST_MODE,\n  HTTP_REQUEST_CONTENT_TYPE,\n  HTTP_REQUEST_MODES_SUPPORTED,\n} from './http-request-class-base.const';\nimport { HttpRequestResponseProcessor } from './http-request-class-base-subclasses/http-request-class-response-processor';\nimport { HttpResponseError } from './http-request-class-base-subclasses/http-request-class-base-response-error';\nimport { ownValueOf } from 'types/helper.types';\nimport { resolveQueryStringParams } from './http-request-class-base-utils';\nimport { prefixUrlWithHTTPProtocol } from './http-request-class-base.utils';\n\nexport class HttpRequest extends HttpRequestBodyProcessor {\n  public static ContentType = HTTP_REQUEST_CONTENT_TYPE;\n\n  public static HeaderName = HTTP_REQUEST_HEADERS_NAMES;\n\n  public static RequestMode = HTTP_REQUEST_MODE;\n\n  public static RequestMethod = HTTP_REQUEST_METHOD;\n\n  protected static baseUrl?: string;\n\n  private static token?: THttpRequestToken;\n\n  public static setBaseUrl(baseUrl: string): void | Error {\n    if (!isURL(baseUrl)) {\n      return new Error('This is not a valid url');\n    }\n    HttpRequest.baseUrl = baseUrl;\n  }\n\n  public static setToken(token: THttpRequestToken): void | Error {\n    HttpRequest.token = token;\n  }\n\n  protected baseUrl?: string = HttpRequest.baseUrl;\n\n  protected url?: string;\n\n  protected method?: string;\n\n  protected mode?: RequestMode;\n\n  protected token?: THttpRequestToken = HttpRequest.token;\n\n  protected contentType?: string;\n\n  protected queryStringParams?: string;\n\n  protected credentials?: RequestCredentials;\n\n  /**\n   * Creates an instance of HttpRequest.\n   * @param {IHttpRequestOptions} options\n   * @memberof HttpRequest\n   * @throws\n   */\n  constructor(options: IHttpRequestOptions) {\n    super(options);\n\n    const resultSetOptions = this.setOptions(options);\n\n    if (resultSetOptions instanceof Error) {\n      console.error(\n        'HttpRequest::setOptions::failed',\n        resultSetOptions,\n        options\n      );\n      throw resultSetOptions;\n    }\n  }\n\n  /**\n   * send the request to the server\n   * on the url defined in the\n   * options\n   *\n   * @memberof HttpRequest\n   */\n  public send = async () => {\n    const { url, method, credentials, mode } = this;\n    const body = this.getBody();\n    const headers = this.getRequestHeaders();\n    const cache = this.getCacheMode();\n\n    try {\n      const response = await fetch(url!, {\n        mode,\n        body,\n        headers,\n        cache,\n        method,\n        credentials,\n      });\n\n      return this.preProcessResponse(response);\n    } catch (err) {\n      console.error(`HttpRequest::${url}::send::failed`, err);\n      return err;\n    }\n  };\n\n  protected getRequestMethod(\n    method: string | undefined,\n    options: IHttpRequestOptions\n  ): Error | HTTP_REQUEST_METHOD {\n    if (!method) {\n      const { body } = options;\n\n      if (body) {\n        return HTTP_REQUEST_METHOD.POST;\n      }\n      return HTTP_REQUEST_METHOD.GET;\n    }\n\n    const methodRes = method.trim().toUpperCase();\n\n    if (HTTP_REQUEST_METHOD.hasOwnProperty(methodRes)) {\n      return (HTTP_REQUEST_METHOD as any)[methodRes] as ownValueOf<\n        typeof HTTP_REQUEST_METHOD\n      >;\n    }\n    return new Error(`An unknown request method \"${method}\"`);\n  }\n\n  protected getCredentials(\n    options: IHttpRequestOptions\n  ): RequestCredentials | undefined {\n    const { withCookie, credentials } = options;\n\n    if (credentials) {\n      return credentials;\n    }\n    if (withCookie) {\n      return 'same-origin';\n    }\n  }\n\n  protected getRequestMode(\n    method: HTTP_REQUEST_METHOD,\n    options: IHttpRequestOptions\n  ): RequestMode | Error | undefined {\n    const { mode, contentType, body, token } = options;\n\n    if (!mode) {\n      if (token) {\n        return 'cors';\n      }\n      if (\n        method === HTTP_REQUEST_METHOD.DELETE ||\n        method === HTTP_REQUEST_METHOD.PUT\n      ) {\n        return 'cors';\n      }\n      if (\n        contentType !== HTTP_REQUEST_CONTENT_TYPE.URL_ENCODED &&\n        contentType !== HTTP_REQUEST_CONTENT_TYPE.MULTIPART &&\n        contentType !== HTTP_REQUEST_CONTENT_TYPE.PLAIN\n      ) {\n        return 'cors';\n      }\n      if (body instanceof ReadableStream) {\n        return 'cors';\n      }\n      return undefined;\n    }\n\n    if (typeof mode === 'string') {\n      const methodRes = mode.trim().toLowerCase();\n\n      if ((HTTP_REQUEST_MODES_SUPPORTED as string[]).includes(methodRes)) {\n        return methodRes as RequestMode;\n      }\n      return new Error(`An unknown request mode \"${mode}\"`);\n    }\n  }\n\n  /**\n   * resolve the url where to send the request\n   * depending on the options url\n   * base url and a query string\n   */\n  protected resolveTargetUrl(url: string): string {\n    const { baseUrl, queryStringParams } = this;\n    const urlInstance = new URL(\n      baseUrl ? url : prefixUrlWithHTTPProtocol(url),\n      baseUrl ? prefixUrlWithHTTPProtocol(baseUrl) : undefined\n    );\n\n    if (queryStringParams) {\n      urlInstance.search = queryStringParams;\n    }\n    return String(urlInstance);\n  }\n\n  protected getQueryStringParams(params: TQueryStringParams): string {\n    const { queryStringParams } = this;\n    const resolvedParams = resolveQueryStringParams(\n      queryStringParams || '',\n      params\n    );\n\n    return resolvedParams;\n  }\n\n  /**\n   * @protected\n   * @param {IHttpRequestOptions} options\n   * @memberof HttpRequest\n   * @throws\n   */\n  protected setOptions(options: IHttpRequestOptions) {\n    if (!options) {\n      throw new Error('The options must be defined for the request');\n    }\n    if (typeof options !== 'object') {\n      return new Error('The options must be an object');\n    }\n    if (typeof options.url !== 'string') {\n      return new Error('The url must be defined in options');\n    }\n\n    const { url, baseUrl, method, token, queryStringParams } = options;\n\n    if (typeof url !== 'string') {\n      return new Error('The url must be defined in options');\n    }\n    if (typeof baseUrl === 'string') {\n      if (!isURL(baseUrl)) {\n        return new Error('The baseUrl is not valid');\n      }\n      this.baseUrl = baseUrl;\n    } else if (!isURL(url)) {\n      return new Error('The url is not valid');\n    }\n    if (token) {\n      this.token = token;\n    }\n\n    const methodRes = this.getRequestMethod(method, options);\n\n    if (methodRes instanceof Error) {\n      return methodRes;\n    }\n    this.method = methodRes;\n\n    const modeRes = this.getRequestMode(methodRes, options);\n\n    if (modeRes instanceof Error) {\n      return modeRes;\n    }\n    this.mode = modeRes;\n    this.credentials = this.getCredentials(options);\n    if (queryStringParams) {\n      this.queryStringParams = this.getQueryStringParams(queryStringParams);\n    }\n    this.url = this.resolveTargetUrl(url);\n  }\n\n  protected getRequestHeaders(): HeadersInit {\n    const { options, token } = this;\n    const { contentType } = options;\n    const headers: IHttpRequestHeaders = {};\n\n    if (contentType) {\n      headers[HTTP_REQUEST_HEADERS_NAMES.CONTENT_TYPE] = contentType;\n    }\n    if (token) {\n      headers[HTTP_REQUEST_HEADERS_NAMES.AUTHORIZATION] = `Bearer ${token}`;\n    }\n    return headers as HeadersInit;\n  }\n\n  protected getCacheMode(): RequestCache {\n    const { options } = this;\n    const { cache } = options;\n\n    return cache as RequestCache;\n  }\n\n  protected preProcessResponse(\n    response: Response\n  ): Promise<Error | HttpResponseError | THttpResponseResult> {\n    const responseProcessor = new HttpRequestResponseProcessor(response);\n\n    return responseProcessor.getResult();\n  }\n}\n\nexport default HttpRequest;\n","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.utils.ts",["1143"],"import { CONST_API_CONF_CURRENT_PROTOCOL_USED } from 'const/const-api-conf';\nimport { HTTP_REQUEST_URL_PROTOCOL_DELIIMETR_REGEXP } from './http-request-class-base.const';\n\nexport interface IParamsObject {\n  [paramName: string]: string | number | object;\n}\n/**\n * transforms object to a stirng url encoded\n * where a param names will be the object's\n * keys and it's values will be the object's\n * values\n * @param obj\n * @param {string} obj[name]\n */\nexport const objectToUrlEncodedString = (obj: IParamsObject): string => {\n  return Object.keys(obj).reduce((querystring, paramName) => {\n    const paramValue = obj[paramName] || '';\n    const paramValueType = typeof paramValue;\n    let paramValueCasted;\n\n    if (paramValueType === 'object') {\n      paramValueCasted = JSON.stringify(paramValue);\n    } else {\n      paramValueCasted = String(paramValue);\n    }\n    return `${querystring}${querystring.length ? '&' : ''}${encodeURIComponent(\n      paramName\n    )}=${encodeURIComponent(paramValueCasted)}`;\n  }, '');\n};\n\nexport interface IParamsObjectFormData {\n  [paramName: string]: string | File | Blob | object;\n}\n\nexport const objectToFormData = (obj: IParamsObjectFormData): FormData => {\n  let paramValueCasted;\n  let thirdParam;\n\n  return Object.keys(obj).reduce((formData: FormData, paramName) => {\n    const paramValue = obj[paramName] || '';\n    const paramValueType = typeof paramValue;\n\n    paramValueCasted = undefined;\n    thirdParam = undefined;\n    if (paramValue instanceof File) {\n      paramValueCasted = paramValue;\n      thirdParam = paramValueCasted.name;\n    } else if (paramValue instanceof Blob) {\n      paramValueCasted = paramValue;\n      thirdParam = 'file';\n    } else if (paramValueType === 'object') {\n      paramValueCasted = JSON.stringify(paramValue);\n    } else if (paramValueType === 'string' || paramValueType === 'number') {\n      paramValueCasted = String(paramValue);\n    }\n    if (paramValueCasted) {\n      formData.append(paramName, paramValueCasted, paramValueType);\n    } else {\n      console.error(\n        `Can't append the ${paramName} field as the form data value`\n      );\n    }\n    return formData;\n  }, new FormData());\n};\n\nexport const prefixUrlWithHTTPProtocol = (urlString: string): string => {\n  const urlTrimmed = urlString.trim().toLowerCase();\n\n  return urlTrimmed.startsWith('http://') || urlTrimmed.startsWith('https://')\n    ? urlTrimmed\n    : `${CONST_API_CONF_CURRENT_PROTOCOL_USED}//${urlTrimmed.replace(\n        HTTP_REQUEST_URL_PROTOCOL_DELIIMETR_REGEXP,\n        ''\n      )}`;\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/mime-types-class-base/mime-types-class-base.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/mime-types-class-base/mime-types-class-base.ts",["1144","1145"],"import mime from 'mime';\nimport {\n  MIME_TYPES_CLASS_TEXT_EXTENSIONS,\n  MIME_TYPES_CLASS_TEXT_TYPES,\n  MIME_TYPES_CLASS_BLOB_TYPES,\n  MIME_TYPES_CLASS_JSON_EXTENSIONS,\n} from './mime-types-class-base.const';\n\nexport class MimeTypeClass {\n  public extension: string | null = null;\n\n  public isText: boolean = false;\n\n  public isBlob: boolean = false;\n\n  public isFile: boolean = false;\n\n  public isJSON: boolean = false;\n\n  public isUnknown: boolean = false;\n\n  constructor(protected mimeType: string) {\n    this.processMimeType();\n  }\n\n  checkIsFile(): boolean {\n    const { extension } = this;\n\n    return !!extension;\n  }\n\n  checkIsBlob(): boolean {\n    const { mimeType } = this;\n\n    return MIME_TYPES_CLASS_BLOB_TYPES.includes(mimeType);\n  }\n\n  checkIsJSON(): boolean {\n    const { extension } = this;\n\n    return !!extension && MIME_TYPES_CLASS_JSON_EXTENSIONS.includes(extension);\n  }\n\n  checkIsText(): boolean {\n    const { mimeType } = this;\n\n    if (MIME_TYPES_CLASS_TEXT_TYPES.includes(mimeType)) {\n      return true;\n    }\n\n    const { extension } = this;\n\n    if (extension) {\n      return MIME_TYPES_CLASS_TEXT_EXTENSIONS.includes(extension);\n    }\n    return false;\n  }\n\n  checkFileExtension() {\n    const { mimeType } = this;\n\n    this.extension = mime.getExtension(mimeType);\n  }\n\n  processMimeType() {\n    this.checkFileExtension();\n    if ((this.isText = this.checkIsText())) {\n      return;\n    }\n    if ((this.isBlob = this.checkIsBlob())) {\n      return;\n    }\n    if ((this.isJSON = this.checkIsJSON())) {\n      return;\n    }\n    if ((this.isFile = this.checkIsFile())) {\n      return;\n    }\n    this.isUnknown = true;\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.ts",["1146","1147","1148","1149","1150","1151","1152","1153","1154"],"import { EventEmitter } from '../event-emitter-class-base';\nimport {\n  TQueue,\n  TIntervalEmitReadyMs,\n  TLastEmitReadyTimestamp,\n  TQueueManagerEvents,\n  IQueueOptions,\n  TMaxItemsInBatch,\n} from './queue-manager-class-base.types';\nimport {\n  QUEUE_MANAGER_EVENT_START,\n  DEFAULT_INTERVAL_MS,\n  QUEUE_MANAGER_EVENT_READY,\n  QUEUE_MANAGER_EVENT_STOP,\n} from './queue-manager-class-base.const';\n\nexport class QueueManagerClassBase<T> extends EventEmitter<\n  TQueueManagerEvents<T>\n> {\n  public static logError = (methodName: string, error: Error) => {\n    console.error(`QueueManagerClassBase::${methodName}`, error);\n  };\n\n  protected queue: TQueue<T> = [];\n  protected itemsInBatch?: TMaxItemsInBatch;\n  protected intervalMs: TIntervalEmitReadyMs = DEFAULT_INTERVAL_MS;\n  protected lastEmitMs: TLastEmitReadyTimestamp = 0;\n  protected interval?: NodeJS.Timer;\n\n  constructor(options: IQueueOptions) {\n    super();\n    this.setOptions(options);\n  }\n\n  setOptions(options: IQueueOptions) {\n    const { intervalMs, itemsInBatch } = options;\n\n    this.intervalMs = intervalMs;\n    this.itemsInBatch = itemsInBatch;\n  }\n\n  getTimestamp() {\n    return Date.now();\n  }\n\n  getBatchOfItems(): T[] {\n    const { queue, itemsInBatch } = this;\n\n    return queue.slice(0, itemsInBatch || undefined);\n  }\n\n  /**\n   * @memberof QueueManagerClassBase\n   * @param items - items to remove from queue\n   */\n  deleteItemsFromQueue(items: T[]): void {\n    this.queue = this.queue.filter((itemQueued) => items.includes(itemQueued));\n  }\n\n  emitEvent(\n    event: typeof QUEUE_MANAGER_EVENT_READY | typeof QUEUE_MANAGER_EVENT_STOP\n  ) {\n    const itemsInBatch = this.getBatchOfItems();\n\n    this.lastEmitMs = this.getTimestamp();\n    try {\n      this.emit(event, itemsInBatch);\n    } catch (err) {\n      QueueManagerClassBase.logError('emitReadyEvent', err);\n    }\n    this.deleteItemsFromQueue(itemsInBatch);\n  }\n\n  /**\n   * emit 'ready' event with a next batched\n   * items, wich are will be removed from the\n   * queue if there will no errors while\n   * handling the event\n   * @memberof QueueManagerClassBase\n   */\n  emitReadyEvent = () => {\n    this.emit(QUEUE_MANAGER_EVENT_READY);\n  };\n\n  startInterval() {\n    this.interval = setInterval(this.emitReadyEvent, this.intervalMs);\n  }\n\n  clearInterval() {\n    if (this.interval) {\n      clearInterval(this.interval);\n      this.interval = undefined;\n    }\n  }\n\n  start() {\n    this.startInterval();\n    this.emit(QUEUE_MANAGER_EVENT_START);\n  }\n\n  stop() {\n    this.clearInterval();\n    this.emit(QUEUE_MANAGER_EVENT_STOP);\n    this.queue = [];\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/status-class-base/status-class-base.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/status-class-base/status-class-base.ts",["1155","1156","1157","1158","1159"],"import { ownValueOf } from 'types/helper.types';\nimport { TStatusClassBaseOptions } from './status-class-base.types';\nimport { EventEmitter } from '../event-emitter-class-base/event-emitter-class-base';\nimport { STATUS_CLASS_STATUS_CHANGE_EVENT } from './status-class-base.const';\n\nexport const STATUS_EVENT = STATUS_CLASS_STATUS_CHANGE_EVENT;\n\nexport const getStatusClass = <TStatus extends object>({\n  errorStatus,\n  instanceName,\n  initialStatus,\n}: TStatusClassBaseOptions<TStatus>) =>\n  class StatusClassBase {\n    protected static error(err: string | Error): Error {\n      let errorInstance: Error;\n\n      if (err instanceof Error) {\n        errorInstance = err;\n      } else {\n        errorInstance = new Error(String(err));\n      }\n      console.error(instanceName, errorInstance);\n      return errorInstance;\n    }\n    public status?: ownValueOf<TStatus> = initialStatus\n      ? initialStatus\n      : undefined;\n\n    public errorOccurred?: Error;\n\n    /**\n     * emit an events described in\n     * TSafeStorageEvents\n     * @public\n     * @memberof StatusClassBase\n     */\n    public statusEmitter = new EventEmitter<{\n      [STATUS_CLASS_STATUS_CHANGE_EVENT]: TStatus;\n    }>();\n\n    protected clearError() {\n      this.errorOccurred = undefined;\n    }\n\n    protected clearStatus() {\n      this.status = undefined;\n    }\n\n    protected clearState() {\n      this.clearStatus();\n      this.clearError();\n    }\n\n    /**\n     *\n     * @param status\n     * @returns {Function} - function to set the previous status value\n     */\n    protected setStatus = (status: ownValueOf<TStatus>): (() => void) => {\n      const { statusEmitter, status: prevStatus } = this;\n\n      this.status = status;\n      statusEmitter.emit(STATUS_CLASS_STATUS_CHANGE_EVENT, status);\n      return () => {\n        this.status = prevStatus;\n      };\n    };\n\n    protected setErrorStatus = (err: Error | string): Error => {\n      if (err) {\n        const errorOccurred = StatusClassBase.error(err);\n\n        this.errorOccurred = errorOccurred;\n        return errorOccurred;\n      }\n      this.setStatus(errorStatus);\n      return new Error('Unknown error');\n    };\n  };\n","/home/paul/projects/decentrilized-protocol/src/classes/basic-classes/status-class-base/status-class-base.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const-auth-credentials.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-common.ts",["1160","1161"],"import { IUserDescription, TUesrIdentity } from 'types/users.types';\nimport { IHttpRequestOptions } from 'classes/basic-classes/http-request-class-base/http-request-class-base.types';\nimport {\n  CA_AUTH_CREDENTIALS_USER_PASSWORD_PROP_NAME,\n  CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME,\n} from '../central-authority-class-const/central-authority-class-const-auth-credentials';\nimport { TCACryptoKeyPairs } from './central-authority-class-types-crypto-keys';\nimport {\n  TCentralAuthorityUserCryptoCredentials,\n  TCentralAuthorityCredentialsStorageAuthCredentials,\n} from './central-authority-class-types-crypto-credentials';\n\nexport type TCentralAuthorityUserIdentity = string;\n\nexport interface ICentralAuthorityUserAuthCredentials {\n  login: string;\n  password: string;\n}\n\nexport type TCentralAuthorityAuthCredentials = {\n  [CA_AUTH_CREDENTIALS_USER_PASSWORD_PROP_NAME]: string;\n  [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: TCentralAuthorityUserIdentity;\n};\n\nexport interface ICentralAuthorityUserProfile {\n  name?: string | null;\n  email?: string | null;\n  phone?: string | null;\n  photoURL?: string | null;\n}\n\nexport interface ICentralAuthorityStorageCryptoCredentials {\n  connect(\n    credentials?: TCentralAuthorityCredentialsStorageAuthCredentials\n  ): Promise<boolean | Error>;\n  setCredentials(cryptoKeyPairs: TCACryptoKeyPairs): Promise<Error | boolean>;\n  getCredentials(): Promise<\n    TCentralAuthorityUserCryptoCredentials | Error | null\n  >;\n  disconnect(): Promise<boolean | Error>;\n}\n\nexport interface ICentralAuthorityConnectionOptions {\n  serverUrl: string;\n  getUsersDescriptionsRequestOptions: IHttpRequestOptions;\n}\n\nexport abstract class CentralAuthorityConnection {\n  constructor(options: ICentralAuthorityConnectionOptions) {}\n  /**\n   * request the users descriptions by the user identities\n   */\n  public abstract getUsersDescription(\n    users: TUesrIdentity[]\n  ): Promise<(IUserDescription | null)[] | Error>;\n}\n\nexport interface ICentralAuthorityConnection {\n  new (options: ICentralAuthorityConnectionOptions): CentralAuthorityConnection;\n}\n\nexport type TInstanceOfCentralAuthorityConnection = InstanceType<\n  ICentralAuthorityConnection\n>;\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-credentials.ts",["1162"],"import {\n  TCACryptoKeyPairsExported,\n  TCACryptoKeyPairs,\n} from './central-authority-class-types-crypto-keys';\nimport {\n  CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_USER_ID_KEY_NAME,\n  CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_CRYPTO_KEYS_KEY_NAME,\n} from '../central-authority-storage/central-authority-storage-credentials/central-authority-storage-credentials.const';\nimport {\n  TCentralAuthorityUserIdentity,\n  TCentralAuthorityAuthCredentials,\n} from './central-authority-class-types-common';\n\nexport type TCentralAuthorityUserCryptoCredentials = {\n  [CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_USER_ID_KEY_NAME]: TCentralAuthorityUserIdentity;\n  [CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: TCACryptoKeyPairs;\n};\n\nexport type TCentralAuthorityUserCryptoCredentialsExported = {\n  [CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_USER_ID_KEY_NAME]: TCentralAuthorityUserIdentity;\n  [CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: string;\n};\n\nexport type TCentralAuthorityCredentialsStorageAuthCredentials = TCentralAuthorityAuthCredentials;\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-keys.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v1/central-authority-class-user-identity-formatters-formatter-v1.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.utils.ts",["1163"],"import { IUserIdentityFormatter } from './central-authority-class-user-identity-formatters.types';\nimport {\n  validateUserIdentityDescriptionVersion,\n  validateUserIdentityDescription,\n} from '../central-authority-class-user-identity-validators/central-authority-class-user-identity-validators';\nimport {\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_PARSER_VERSIONS_SUPPORTED,\n} from '../central-authority-class-user-identity.const';\nimport { CA_USER_IDENTITY_FORMATTERS_BY_VERSION } from './central-authority-class-user-identity-formatters.const';\nimport { ICAUserUniqueIdentifierDescription } from '../central-authority-class-user-identity.types';\nimport { TCentralAuthorityUserIdentity } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { validateUserIdentity } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\n\nexport const getSerializerForIdentityVersion = (\n  userIdentityVersion: string\n): Error | IUserIdentityFormatter => {\n  const serializerFunction =\n    CA_USER_IDENTITY_FORMATTERS_BY_VERSION[userIdentityVersion];\n\n  if (typeof serializerFunction === 'function') {\n    return serializerFunction;\n  }\n  return new Error(\n    `There is no serializer was found for the identity version ${userIdentityVersion}`\n  );\n};\n\nexport const serializeIdentity = (\n  identity: ICAUserUniqueIdentifierDescription\n): TCentralAuthorityUserIdentity | Error => {\n  const validationResult = validateUserIdentityDescription(identity);\n\n  if (validationResult instanceof Error) {\n    return new Error('The user identity description have a wrong format');\n  }\n\n  const { [CA_USER_IDENTITY_VERSION_PROP_NAME]: version } = identity;\n\n  if (!CA_USER_IDENTITY_PARSER_VERSIONS_SUPPORTED.includes(version)) {\n    return new Error(`The version of the user identity given is not supported`);\n  }\n\n  const serializerFunction = getSerializerForIdentityVersion(version);\n\n  if (serializerFunction instanceof Error) {\n    console.error(serializerFunction);\n    return new Error(\n      `There is no serializer function for the user identity description version ${version}`\n    );\n  }\n\n  const serializeResult = serializerFunction(identity);\n\n  if (serializeResult instanceof Error) {\n    return new Error(\n      `Failed serialization for the user identity description version ${version}`\n    );\n  }\n  if (!validateUserIdentity(serializeResult)) {\n    return new Error(\n      `Failed serialization to the right format for the user identity description version ${version}`\n    );\n  }\n  return serializeResult;\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/central-authority-class-user-identity-parsers-parser-v1.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/central-authority-class-user-identity-parsers-parser-v1.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.types.ts",["1164"],"import { TCentralAuthorityUserIdentity } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { ICAUserIdentityDescription } from '../central-authority-class-user-identity.types';\n\nexport interface IParser {\n  (userIdentityWithoutVersion: string): ICAUserIdentityDescription | Error;\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v1/central-authority-class-user-identity-validator-v1.ts",["1165"],"import {\n  dataValidatorUtilURL,\n  dataValidatorUtilUUIDV4,\n} from 'utils/data-validators-utils/data-validators-utils';\nimport {\n  CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT,\n} from '../../central-authority-class-user-identity.const';\nimport { ICAUserUniqueIdentifierDescription } from '../../central-authority-class-user-identity.types';\n\nexport default (v: any): v is ICAUserUniqueIdentifierDescription => {\n  if (v && typeof v === 'object') {\n    const {\n      [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: userUniqueIdentifier,\n      [CA_USER_IDENTITY_VERSION_PROP_NAME]: version,\n      [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: authProviderURI,\n    } = v;\n\n    if (\n      typeof version !== 'string' ||\n      version.length !== CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT\n    ) {\n      return false;\n    }\n    if (!dataValidatorUtilURL(authProviderURI)) {\n      console.warn(\n        `The auth provider's uri ${authProviderURI} have a wrong format`\n      );\n      return false;\n    }\n    if (!dataValidatorUtilUUIDV4(userUniqueIdentifier)) {\n      console.warn(\n        `The user unique identifier ${userUniqueIdentifier} have a format different from the UUIDv4`\n      );\n      return false;\n    }\n    return true;\n  }\n  console.warn('The URI must be an object');\n  return false;\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.types.ts",["1166"],"export interface IUserIdentityDescriptionValidator {\n  (v: any): boolean;\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.utils.ts",["1167","1168","1169","1170"],"import { CA_USER_IDENTITY_VALIDATORS_BY_VERSION } from './central-authority-class-user-identity-validators.const';\nimport { IUserIdentityDescriptionValidator } from './central-authority-class-user-identity-validators.types';\nimport {\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT,\n  CA_USER_IDENTITY_PARSER_VERSIONS_SUPPORTED,\n} from '../central-authority-class-user-identity.const';\nimport { ICAUserUniqueIdentifierMetadata } from '../central-authority-class-user-identity.types';\nimport { CONST_VALIDATION_SCHEMES_URL } from 'const/const-validation-schemes/const-validation-schemes-common';\nimport { dataValidatorUtilURL } from 'utils/data-validators-utils/data-validators-utils';\n\nexport const validateIdentityDescriptionVersion = (\n  version: any\n): version is string => {\n  if (typeof version !== 'string') {\n    console.error('An identity description version must be a string');\n    return false;\n  }\n  if (version.length !== CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT) {\n    console.error(\n      `An identity description version length must be a ${CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT} characters`\n    );\n    return false;\n  }\n  if (!CA_USER_IDENTITY_PARSER_VERSIONS_SUPPORTED.includes(version)) {\n    console.error(`The version ${version} is not supported`);\n    return false;\n  }\n  return true;\n};\n\nexport const getValidatorByIdentityVersion = (\n  identityVersion: string\n): IUserIdentityDescriptionValidator | Error => {\n  const validator = CA_USER_IDENTITY_VALIDATORS_BY_VERSION[identityVersion];\n\n  if (typeof validator === 'function') {\n    return validator;\n  }\n  return new Error(\n    `There is no validator for the identity version ${identityVersion}`\n  );\n};\n\nexport const validateUserIdentityDescriptionVersion = (\n  identityVersion: string,\n  userIdentityDescription: any\n): boolean | Error => {\n  const validatorForVersion = getValidatorByIdentityVersion(identityVersion);\n\n  if (validatorForVersion instanceof Error) {\n    console.error(validatorForVersion);\n    return new Error(\n      `Can't define a validator for the user's identity version ${validatorForVersion}`\n    );\n  }\n\n  const validationResult = validatorForVersion(userIdentityDescription);\n\n  if (validationResult !== true) {\n    return new Error(\"There is a wrong format of user's identity\");\n  }\n  return true;\n};\n\nexport const validateUserIdentityDescription = (\n  userIdetnityDescription: any\n): boolean | Error => {\n  if (userIdetnityDescription && typeof userIdetnityDescription === 'object') {\n    const {\n      [CA_USER_IDENTITY_VERSION_PROP_NAME]: version,\n    } = userIdetnityDescription;\n\n    if (!version) {\n      return new Error(\n        'There is no version defined in the user identity description object'\n      );\n    }\n    if (validateIdentityDescriptionVersion(version)) {\n      return validateUserIdentityDescriptionVersion(\n        version,\n        userIdetnityDescription\n      );\n    }\n    return new Error(\n      'There is a wrong version in the user identity description object'\n    );\n  }\n  return new Error('There is a wrong format of the user identity description');\n};\n\nexport const checkIsValidUserIdentityMetadata = (\n  identityMetadata: ICAUserUniqueIdentifierMetadata\n): boolean | Error => {\n  if (typeof identityMetadata !== 'object') {\n    return new Error('Identity metadata must be an object');\n  }\n  if (identityMetadata instanceof Error) {\n    return identityMetadata;\n  }\n  if (!identityMetadata) {\n    return new Error('Identity metadata must not be empty');\n  }\n\n  const { version, authorityProviderURI } = identityMetadata;\n\n  if (version && !validateIdentityDescriptionVersion(version)) {\n    return new Error('Version in Identity metadata have a wrong format');\n  }\n  if (!dataValidatorUtilURL(authorityProviderURI)) {\n    return new Error('The URL of an authority provider is not valid');\n  }\n  return true;\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.ts",["1171","1172"],"import {\n  ICAUserUniqueIdentifierDescription,\n  ICAUserUniqueIdentifierDescriptionWithOptionalVersion,\n  ICAIdentityCommonInstance,\n} from './central-authority-class-user-identity.types';\nimport {\n  TCentralAuthorityUserIdentity,\n  TCentralAuthorityUserCryptoCredentials,\n} from '../central-authority-class-types/central-authority-class-types';\nimport { validateUserIdentitySilent } from '../central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { parseIdentity } from './central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers';\nimport { serializeIdentity } from './central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters';\nimport {\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_CURRENT,\n} from './central-authority-class-user-identity.const';\nimport { CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME } from '../central-authority-class-const/central-authority-class-const';\nexport class CentralAuthorityIdentity implements ICAIdentityCommonInstance {\n  protected _userIdentitySerialized?: Error | TCentralAuthorityUserIdentity;\n\n  protected _userIdentityParsed?: Error | ICAUserUniqueIdentifierDescription;\n\n  public isValid?: boolean;\n\n  constructor(\n    protected _userIdentity:\n      | TCentralAuthorityUserCryptoCredentials\n      | TCentralAuthorityUserIdentity\n      | ICAUserUniqueIdentifierDescriptionWithOptionalVersion\n  ) {\n    let identity = _userIdentity;\n\n    if (_userIdentity && typeof _userIdentity === 'object') {\n      //check may be it is a ctrypto credentials object\n      const identityVal = ((_userIdentity as unknown) as any)[\n        CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME\n      ];\n\n      if (typeof identityVal === 'string') {\n        identity = identityVal;\n      }\n    }\n    if (validateUserIdentitySilent(identity)) {\n      this.parseUserIdentity(identity);\n    } else {\n      const userIdentityDescription = this.extendDescriptionWithVersion(\n        identity as ICAUserUniqueIdentifierDescriptionWithOptionalVersion\n      );\n\n      this.serializeUserIdentityDescription(userIdentityDescription);\n    }\n  }\n\n  protected extendDescriptionWithVersion(\n    _userIdentityDescription: ICAUserUniqueIdentifierDescriptionWithOptionalVersion\n  ): ICAUserUniqueIdentifierDescription {\n    const {\n      [CA_USER_IDENTITY_VERSION_PROP_NAME]: version,\n    } = _userIdentityDescription;\n\n    if (!version) {\n      // extend the description with the\n      // current version\n      const result = {\n        ..._userIdentityDescription,\n        [CA_USER_IDENTITY_VERSION_PROP_NAME]: CA_USER_IDENTITY_VERSION_CURRENT,\n      };\n\n      this._userIdentity = result;\n      return result as ICAUserUniqueIdentifierDescription;\n    }\n    return _userIdentityDescription as ICAUserUniqueIdentifierDescription;\n  }\n\n  public get identityDescription(): ICAUserUniqueIdentifierDescription | Error {\n    const { _userIdentityParsed } = this;\n\n    if (!_userIdentityParsed) {\n      return new Error('Failed to parse the user identity');\n    }\n    return _userIdentityParsed;\n  }\n\n  public get identityDescritptionSerialized():\n    | TCentralAuthorityUserIdentity\n    | Error {\n    const { _userIdentitySerialized } = this;\n\n    if (!_userIdentitySerialized) {\n      return new Error('Failed to serialize the user identity');\n    }\n    return _userIdentitySerialized;\n  }\n\n  /**\n   * uniquely identifies the user\n   */\n  public get id(): string | Error {\n    const { identityDescription } = this;\n\n    if (identityDescription instanceof Error) {\n      return identityDescription;\n    }\n\n    const { authorityProviderURI, userUniqueIdentifier } = identityDescription;\n\n    return `${authorityProviderURI}${userUniqueIdentifier}`;\n  }\n\n  public toString(): TCentralAuthorityUserIdentity {\n    const { identityDescritptionSerialized } = this;\n\n    if (identityDescritptionSerialized instanceof Error) {\n      return '';\n    }\n    return identityDescritptionSerialized;\n  }\n\n  protected setIdentityIsValid(): void {\n    if (this.isValid !== false) {\n      this.isValid = true;\n    }\n  }\n\n  protected parseUserIdentity(\n    userIdentity: TCentralAuthorityUserIdentity\n  ): void {\n    if (userIdentity) {\n      const parsedUserIdentity = parseIdentity(userIdentity);\n      if (parsedUserIdentity instanceof Error) {\n        console.error(parsedUserIdentity);\n        this._userIdentityParsed = parsedUserIdentity;\n        this._userIdentitySerialized = new Error(\n          'Failed to parse the user identity'\n        );\n      } else {\n        this._userIdentityParsed = parsedUserIdentity;\n        this._userIdentitySerialized = userIdentity;\n        this.setIdentityIsValid();\n        return;\n      }\n    } else {\n      const err = new Error('The user identity serialized is not defined');\n\n      this._userIdentityParsed = err;\n      this._userIdentitySerialized = err;\n    }\n    this.isValid = false;\n  }\n\n  protected serializeUserIdentityDescription(\n    userIdentityDescription: ICAUserUniqueIdentifierDescription\n  ) {\n    if (userIdentityDescription) {\n      const serializedDescription = serializeIdentity(userIdentityDescription);\n\n      if (serializedDescription instanceof Error) {\n        this._userIdentityParsed = new Error(\n          'Failed to serialize the user identity description'\n        );\n        this._userIdentitySerialized = serializedDescription;\n      } else {\n        this._userIdentityParsed = userIdentityDescription;\n        this._userIdentitySerialized = serializedDescription;\n        this.setIdentityIsValid();\n        return;\n      }\n    } else {\n      const err = new Error('The user identifier description is not defined');\n\n      this._userIdentitySerialized = err;\n      this._userIdentityParsed = err;\n    }\n    this.isValid = false;\n  }\n}\n\nexport default CentralAuthorityIdentity;\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types.ts",["1173"],"import {\n  TCentralAuthorityUserIdentity,\n  TCentralAuthorityUserCryptoCredentials,\n} from '../central-authority-class-types/central-authority-class-types';\nimport {\n  CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME,\n  CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n} from './central-authority-class-user-identity.const';\n\n/**\n *\n * this is interface for description\n * of the user unique identity whithin\n * the server overall\n * @export\n * @interface ICAUserUniqueIdentifierDescription\n */\n\nexport type TCAuthProviderIdentifier = string;\n\nexport type TCAuthProviderUserIdentifier = string;\n\nexport interface ICAUserIdentityDescription {\n  [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: TCAuthProviderIdentifier;\n  [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: TCAuthProviderUserIdentifier;\n}\n\nexport interface ICAUserUniqueIdentifierDescription\n  extends ICAUserIdentityDescription {\n  [CA_USER_IDENTITY_VERSION_PROP_NAME]: string;\n}\n\nexport interface ICAUserUniqueIdentifierDescriptionWithOptionalVersion\n  extends ICAUserIdentityDescription {\n  [CA_USER_IDENTITY_VERSION_PROP_NAME]?: string;\n}\n\nexport interface ICAUserUniqueIdentifierMetadata {\n  [CA_USER_IDENTITY_VERSION_PROP_NAME]?: string;\n  [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: TCAuthProviderIdentifier;\n}\n\nexport interface ICAIdentityCommonInstance {\n  identityDescription: ICAUserUniqueIdentifierDescription | Error;\n  identityDescritptionSerialized: TCentralAuthorityUserIdentity | Error;\n  toString: () => TCentralAuthorityUserIdentity;\n  // returns a unique string, may be used as a unique identifier in overall system\n  id: string | Error;\n  isValid?: boolean;\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-class.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.ts",["1174","1175","1176","1177","1178","1179"],"import { CAConnectionWithFirebaseUtilDatabase } from '../central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database';\nimport { TCentralAuthorityUserCryptoCredentials } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { checkIsValidExportedCryptoCredentialsToString } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport {\n  getUserIdentityByCryptoCredentials,\n  exportCryptoCredentialsToString,\n  importCryptoCredentialsFromAString,\n} from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\nimport {\n  CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_KEY_PREFIX,\n  CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY,\n  CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_MAXIMUM_STORED_VALUES_CHECK,\n} from './central-authority-connection-firebase-utils.credentials-storage.const';\nimport { validateUserIdentity } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure } from './central-authority-connection-firebase-utils.credentials-storage.types';\nimport CAConnectionWithFirebase from '../../central-authority-connection-firebase';\nimport { encodeForFirebaseKey } from 'utils/firebase-utils/firebase-utils';\n\n/**\n * This class is used for storing\n * and reading the user's credentials.\n * It also used for reading\n * credentials of another user.\n * @export\n * @class CAConnectionFirestoreUtilsCredentialsStrorage\n * @extends {CAConnectionWithFirebaseUtilDatabase}\n */\nexport class CAConnectionFirestoreUtilsCredentialsStrorage extends CAConnectionWithFirebaseUtilDatabase {\n  protected connectionToFirebase?: CAConnectionWithFirebase;\n\n  protected app?: firebase.app.App;\n\n  /**\n   * returns a string will used to store/read value of\n   * the user credentials\n   * @protected\n   * @param {string} userId\n   * @returns {string}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  protected getCredentialsKeyByUserId(userId: string): string {\n    return `${CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_KEY_PREFIX}${encodeForFirebaseKey(\n      userId\n    )}`;\n  }\n\n  protected checkIsConnected(): boolean | Error {\n    const isConnectedToDatabase = super.checkIsConnected();\n\n    if (isConnectedToDatabase instanceof Error) {\n      return isConnectedToDatabase;\n    }\n\n    const { app, connectionToFirebase } = this;\n\n    if (!connectionToFirebase) {\n      return new Error(\n        'There is no instance implements a connection to the Firebase application'\n      );\n    }\n    if (!connectionToFirebase.isConnected) {\n      return new Error(\n        'There is no active connection to the firebase appliction'\n      );\n    }\n    if (!app) {\n      return new Error('There is no app connection');\n    }\n    return true;\n  }\n\n  protected get firebaseUserData(): firebase.User | null | Error {\n    const isConnected = this.checkIsConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { app } = this;\n\n    try {\n      return app!!.auth().currentUser;\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to get the user id for firebase');\n    }\n  }\n\n  protected get firebaseUserId(): string | Error {\n    const { firebaseUserData: userData } = this;\n\n    if (userData instanceof Error) {\n      console.error(userData);\n      return new Error('Failed to read the user data from a firebase');\n    }\n    if (userData == null) {\n      return new Error('There is no user data');\n    }\n    try {\n      return userData.uid;\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to get the user id for firebase');\n    }\n  }\n\n  protected checkIsAuthorized(): boolean | Error {\n    const isConnectedToDatabase = this.checkIsConnected();\n\n    if (isConnectedToDatabase instanceof Error) {\n      return isConnectedToDatabase;\n    }\n\n    const { firebaseUserId, connectionToFirebase } = this;\n\n    if (!connectionToFirebase || !connectionToFirebase.isUserSignedIn) {\n      return new Error(\n        'The user is not authorized in the Firebase application'\n      );\n    }\n    if (firebaseUserId instanceof Error) {\n      console.error(firebaseUserId);\n      return new Error('The user is not authorized');\n    }\n    return true;\n  }\n\n  constructor(connectionToFirebase: CAConnectionWithFirebase) {\n    super();\n\n    this.setUpConnection(connectionToFirebase);\n  }\n\n  protected setUpConnection(connectionToFirebase: CAConnectionWithFirebase) {\n    if (\n      typeof connectionToFirebase !== 'object' ||\n      !(connectionToFirebase instanceof CAConnectionWithFirebase)\n    ) {\n      throw new Error('There is no instance of CAConnectionWithFirebase');\n    }\n    if (!connectionToFirebase.isUserSignedIn) {\n      throw new Error('The user must be authorized in firebase');\n    }\n    this.connectionToFirebase = connectionToFirebase;\n\n    const app = connectionToFirebase.getApp();\n\n    if (!app) {\n      throw new Error(\n        'There is no insatnce which implements a connection to the Firebase app'\n      );\n    }\n    this.app = app;\n  }\n\n  /**\n   *\n   * check if a credentials set in the storage\n   * are in the valid format\n   * @protected\n   * @param {*} storedCredentialsValue\n   * @returns {storedCredentialsValue is ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  protected checkStoredCredentialsFormat(\n    storedCredentialsValue: any\n  ): storedCredentialsValue is ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure {\n    if (storedCredentialsValue instanceof Error) {\n      console.error(storedCredentialsValue);\n      return false;\n    }\n    if (storedCredentialsValue && typeof storedCredentialsValue === 'object') {\n      const {\n        credentials,\n        [CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY]: firebaseId,\n      } = storedCredentialsValue;\n\n      // an id set for the user by the Firebase\n      if (typeof firebaseId === 'string') {\n        if (checkIsValidExportedCryptoCredentialsToString(credentials)) {\n          return true;\n        }\n        console.error(\n          \"Credentials are't exists or invalid in the stored credentials\"\n        );\n      } else {\n        console.error(\n          'Firebase user id is not valid in the stored credentials'\n        );\n      }\n    }\n    return false;\n  }\n\n  protected async getCredentialsByValueStored(\n    storedCredentialsValue: any\n  ): Promise<TCentralAuthorityUserCryptoCredentials | null | Error> {\n    if (storedCredentialsValue == null) {\n      return null;\n    }\n    if (storedCredentialsValue instanceof Error) {\n      return storedCredentialsValue;\n    }\n    if (!this.checkStoredCredentialsFormat(storedCredentialsValue)) {\n      return new Error('the value stored have an unknown format');\n    }\n\n    const { credentials: exportedCredentials } = storedCredentialsValue;\n    const importedCredentials = await importCryptoCredentialsFromAString(\n      exportedCredentials\n    );\n\n    if (importedCredentials instanceof Error) {\n      console.error(importedCredentials);\n      return new Error('Failed to import credentials value stored');\n    }\n    return importedCredentials;\n  }\n\n  /**\n   *\n   * filter a value stored for the user key\n   * to get a value of the credentials\n   * for the user\n   * @protected\n   * @param {{\n   *     [key: string]: any;\n   *   }} [valueStored]\n   * @returns {(Promise<TCentralAuthorityUserCryptoCredentials | null | Error>)}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  protected async filterCredentialsValues(valueStored?: {\n    [key: string]: any;\n  }): Promise<TCentralAuthorityUserCryptoCredentials | null | Error> {\n    if (!valueStored) {\n      return null;\n    }\n    if (valueStored instanceof Error) {\n      return valueStored;\n    }\n\n    const keys = Object.keys(valueStored);\n\n    // if an empty object\n    if (keys.length === 0) {\n      return null;\n    }\n\n    const len = Math.min(\n      keys.length,\n      CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_MAXIMUM_STORED_VALUES_CHECK\n    );\n    let idx = 0;\n    let keyValueStored;\n    let valueValueStored;\n    let credentialsImported;\n\n    // for each property of the value stored\n    // check wherether it is a valid\n    // crypto credentials\n    for (; idx < len; idx++) {\n      keyValueStored = keys[idx];\n      valueValueStored = valueStored[keyValueStored];\n      credentialsImported = await this.getCredentialsByValueStored(\n        valueValueStored\n      );\n\n      if (!(credentialsImported instanceof Error)) {\n        return credentialsImported;\n      }\n    }\n    return null;\n  }\n\n  // check if there is a credentials for the current user is exists\n  // and return it if exists\n  public async getCredentialsForTheCurrentUser(): Promise<\n    Error | null | TCentralAuthorityUserCryptoCredentials\n  > {\n    const isAuthorizedResult = this.checkIsAuthorized();\n\n    if (isAuthorizedResult instanceof Error) {\n      console.error(isAuthorizedResult);\n      return new Error('The user is not authorized');\n    }\n\n    const { firebaseUserId } = this;\n\n    if (firebaseUserId instanceof Error) {\n      console.error(firebaseUserId);\n      return new Error('Failed to get user id of the firebase user');\n    }\n\n    const { database } = this;\n\n    if (!database) {\n      return new Error('There is no connection to the database server');\n    }\n    try {\n      // read a value storerd as user's\n      // credentials in the database\n      const snapshot = await database\n        .ref(CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_KEY_PREFIX)\n        .orderByChild(\n          CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY\n        )\n        .equalTo(firebaseUserId)\n        .once('value');\n\n      if (snapshot.exists()) {\n        const valueStored = snapshot.val();\n        return this.filterCredentialsValues(valueStored);\n      }\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to read the user data from the database');\n    }\n    return null;\n  }\n\n  // store the credentials value\n  // for the current user\n  public async setUserCredentials(\n    credentials: TCentralAuthorityUserCryptoCredentials\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials> {\n    const isAuthorizedResult = this.checkIsAuthorized();\n\n    if (isAuthorizedResult instanceof Error) {\n      console.error(isAuthorizedResult);\n      return new Error('The user is not authorized');\n    }\n\n    const { firebaseUserId } = this;\n\n    if (firebaseUserId instanceof Error) {\n      console.error(firebaseUserId);\n      return new Error('Failed to get user id of the firebase user');\n    }\n\n    // check if a credentials value is\n    // already exists for the user\n    const credentialsForTheCurrentUser = await this.getCredentialsForTheCurrentUser();\n\n    if (\n      credentialsForTheCurrentUser != null &&\n      !(credentialsForTheCurrentUser instanceof Error)\n    ) {\n      // if a credentials are already stored for the user\n      // return it\n      return credentialsForTheCurrentUser;\n    }\n\n    const userId = getUserIdentityByCryptoCredentials(credentials);\n\n    if (userId instanceof Error) {\n      console.error(userId);\n      return new Error(\"Failed to get a user's identity from the credentials\");\n    }\n\n    const exportedCryptoCredentials = await exportCryptoCredentialsToString(\n      credentials\n    );\n\n    if (exportedCryptoCredentials instanceof Error) {\n      console.error(exportedCryptoCredentials);\n      return new Error('Failed to export the crypto credentials value');\n    }\n\n    //check if the user id is not exists in the database\n    const credentialsForTheUserId = await this.getUserCredentials(userId);\n\n    if (\n      credentialsForTheUserId != null &&\n      !(credentialsForTheUserId instanceof Error)\n    ) {\n      return new Error(\n        'A crypto credentials is already exists for the user id'\n      );\n    }\n\n    // TODO - it's necessary to remove all credentials for the user\n    // before to set a new one\n\n    const keyForValue = this.getCredentialsKeyByUserId(userId);\n    const storeResult = await this.setValue<\n      ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure\n    >(keyForValue, {\n      credentials: exportedCryptoCredentials,\n      [CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY]: firebaseUserId,\n    });\n\n    if (storeResult instanceof Error) {\n      console.error(storeResult);\n      return new Error('Failed to store the credentials in the database');\n    }\n    return credentials;\n  }\n\n  /**\n   *\n   * return a credentials for the user\n   * with the id = userId\n   * @param {string} userId\n   * @returns {(Promise<Error | null | TCentralAuthorityUserCryptoCredentials>)}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  public async getUserCredentials(\n    userId: string\n  ): Promise<Error | null | TCentralAuthorityUserCryptoCredentials> {\n    if (!validateUserIdentity(userId)) {\n      return new Error('The user identity is not valid');\n    }\n\n    const keyForValue = this.getCredentialsKeyByUserId(userId);\n    const storedCredentialsValue = await this.getValue<\n      ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure\n    >(keyForValue);\n\n    return this.getCredentialsByValueStored(storedCredentialsValue);\n  }\n\n  // disconnect from the database\n  public async disconnect(): Promise<Error | boolean> {\n    const isConnected = this.checkIsConnected();\n\n    if (!isConnected) {\n      return true;\n    }\n    const { database } = this;\n\n    if (!database) {\n      return new Error('There is no active database connection');\n    }\n    try {\n      await database.goOffline();\n    } catch (err) {\n      console.error();\n      return new Error('Failed to disconnect from the databases');\n    }\n    return true;\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.types.ts",["1180"],"import {\n  TCentralAuthorityUserCryptoCredentials,\n  TCentralAuthorityUserIdentity,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY } from './central-authority-connection-firebase-utils.credentials-storage.const';\n\nexport interface ICAConnectionFirestoreUtilsCredentialsStrorage {\n  setUserCredentials(\n    userId: string,\n    cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): Promise<Error | boolean>;\n  getUserCredentials(\n    userId: string\n  ): Promise<Error | null | TCentralAuthorityUserCryptoCredentials>;\n}\n\nexport interface ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure {\n  [CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY]: string;\n  credentials: string;\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database.ts",["1181","1182","1183","1184","1185","1186","1187","1188","1189"],"import * as firebase from 'firebase';\nimport {\n  CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MAX_LENGTH,\n  CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MIN_LENGTH,\n} from './central-authority-connection-firebase-utils.database.const';\n\nexport class CAConnectionWithFirebaseUtilDatabase {\n  protected database?: firebase.database.Database;\n\n  protected wasConnected: boolean = false;\n\n  public get isConnected(): boolean {\n    const { wasConnected, database } = this;\n\n    return wasConnected && !!database;\n  }\n\n  protected setWasConnectedStatus(wasConnected = false) {\n    this.wasConnected = !!wasConnected;\n  }\n\n  protected setDatabaseInstance(db: firebase.database.Database) {\n    this.database = db;\n  }\n\n  protected checkIsConnected(): Error | boolean {\n    const { isConnected } = this;\n\n    if (!isConnected) {\n      return new Error('There is no connection with the remote database');\n    }\n    return true;\n  }\n\n  protected checkKeyValue(key: any): key is string {\n    if (typeof key !== 'string') {\n      console.error('Key must be a string');\n      return false;\n    }\n\n    const keyLen = key.length;\n\n    if (keyLen > CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MAX_LENGTH) {\n      console.error(\n        `Key must be less than ${CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MAX_LENGTH}, but the value is ${keyLen} characters len`\n      );\n      return false;\n    }\n    if (keyLen < CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MIN_LENGTH) {\n      console.error(\n        `Key must be greater than ${CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MAX_LENGTH}, but the value is ${keyLen} characters len`\n      );\n      return false;\n    }\n    return true;\n  }\n\n  public async connect(): Promise<boolean | Error> {\n    const { isConnected } = this;\n\n    if (isConnected) {\n      return true;\n    }\n\n    const database = firebase.database();\n\n    try {\n      await database.goOnline();\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to connect to the Database server');\n    }\n    this.setDatabaseInstance(database);\n    this.setWasConnectedStatus(true);\n    return true;\n  }\n\n  public async disconnect(): Promise<boolean | Error> {\n    const isConnected = this.checkIsConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { database } = this;\n\n    try {\n      await database!!.goOffline();\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to disconnect from the firebase server');\n    }\n    this.setWasConnectedStatus(false);\n    return true;\n  }\n\n  protected checkBeforeReadWrite(key: string): Error | boolean {\n    const isConnectedResult = this.checkIsConnected();\n\n    if (isConnectedResult instanceof Error) {\n      return isConnectedResult;\n    }\n    if (!this.checkKeyValue(key)) {\n      return new Error('The key value is not valid');\n    }\n    return true;\n  }\n\n  public async setValue<T>(key: string, value: T): Promise<Error | boolean> {\n    const canWrite = this.checkBeforeReadWrite(key);\n\n    if (canWrite instanceof Error) {\n      return canWrite;\n    }\n\n    const { database } = this;\n\n    try {\n      await database!!.ref(key).set(value);\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to store the value in the database');\n    }\n    return true;\n  }\n\n  public async getValue<T>(key: string): Promise<Error | null | T> {\n    const canRead = this.checkBeforeReadWrite(key);\n\n    if (canRead instanceof Error) {\n      return canRead;\n    }\n\n    const { database } = this;\n\n    try {\n      const snapshot = await database!!.ref(key).once('value');\n      const isExists = snapshot.exists();\n\n      if (!isExists) {\n        return null;\n      }\n      return snapshot.val() as T;\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to read the value from the storage');\n    }\n  }\n}\n\nexport default CAConnectionWithFirebaseUtilDatabase;\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.error-codes.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.restrictions.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.ts",["1190","1191","1192","1193","1194","1195","1196","1197","1198","1199","1200","1201","1202","1203","1204","1205"],"import * as firebase from 'firebase/app';\nimport 'firebase/auth';\nimport {\n  ICAConnection,\n  ICAConnectionSignUpCredentials,\n  ICAConnectionUserAuthorizedResult,\n} from '../central-authority-connections.types';\nimport {\n  ICAConnectionConfigurationFirebase,\n  ICAConnectionFirebaseUserProfile,\n} from './central-authority-connection-firebase.types.configuration';\nimport {\n  ICentralAuthorityUserAuthCredentials,\n  TCentralAuthorityUserCryptoCredentials,\n  ICentralAuthorityUserProfile,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { isEmptyObject } from 'utils/common-utils/common-utils-objects';\nimport { validateUserProfileData } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user';\nimport {\n  dataValidatorUtilEmail,\n  dataValidatorUtilURL,\n} from 'utils/data-validators-utils/data-validators-utils';\nimport { checkIsValidCryptoCredentials } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport { generateCryptoCredentialsWithUserIdentity } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport CentralAuthorityIdentity from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport { CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport { CAConnectionFirestoreUtilsCredentialsStrorage } from './central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage';\nimport { CA_CONNECTION_FIREBASE_CREDENTIALS_GENERATION_MAX_ATTEMPTS } from './central-authority-connection-firebase.const/central-authority-connection-firebase.const.restrictions';\nimport { validatePassword } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport ErrorExtendedBaseClass from 'classes/basic-classes/error-extended-class-base/error-extended-class-base';\nimport {\n  CA_CONNECTION_ERROR_ACCOUNT_NOT_VERIFIED_CODE,\n  CA_CONNECTION_ERROR_ACCOUNT_CAN_NOT_BE_USED_ANYMORE,\n} from '../central-authority-connections-const/central-authority-connections-const';\n\n// TODO export class CAConnectionWithFirebase implements ICAConnection {\n/**\n *\n * This is the class realized connection with the Firebase.\n * It allows to sign up and authorize on it, set a crypto credentials\n * for the user and read credentials for another users.\n * @export\n * @class CAConnectionWithFirebase\n * @implements {ICAConnection}\n */\nexport class CAConnectionWithFirebase implements ICAConnection {\n  protected app?: firebase.app.App;\n\n  protected configuration?: ICAConnectionConfigurationFirebase;\n\n  protected isAuthorizedWithCredentials: boolean = false;\n\n  protected valueofCredentialsSignUpOnAuthorizedSuccess?: ICAConnectionUserAuthorizedResult;\n\n  public getAuthResult(): ICAConnectionUserAuthorizedResult | void {\n    return this.valueofCredentialsSignUpOnAuthorizedSuccess;\n  }\n\n  protected connectionWithCredentialsStorage?: CAConnectionFirestoreUtilsCredentialsStrorage;\n\n  protected get currentUser(): firebase.User | null {\n    const { isConnected, app } = this;\n\n    return isConnected ? app!!.auth().currentUser : null;\n  }\n\n  protected get isVerifiedAccount(): boolean {\n    const { isConnected, currentUser: currentUserData } = this;\n\n    if (!isConnected) {\n      return false;\n    }\n    if (!currentUserData) {\n      return false;\n    }\n    return !!currentUserData.emailVerified;\n  }\n\n  public isConnected: boolean = false;\n\n  public get isUserSignedIn(): boolean {\n    const { isConnected, isVerifiedAccount } = this;\n\n    if (!isConnected) {\n      return false;\n    }\n    // according to the https://firebase.google.com/docs/auth/web/manage-users\n    return isVerifiedAccount;\n  }\n\n  public get isAuthorized(): boolean {\n    const {\n      isUserSignedIn,\n      valueofCredentialsSignUpOnAuthorizedSuccess: credentialsAuthorizedSuccess,\n    } = this;\n\n    if (!isUserSignedIn) {\n      return false;\n    }\n    // according to the https://firebase.google.com/docs/auth/web/manage-users\n    return !!credentialsAuthorizedSuccess;\n  }\n\n  protected get databaseURL(): Error | string {\n    const { configuration } = this;\n\n    if (!configuration) {\n      return new Error(\n        'There is no url specified for the Firebase authority provided'\n      );\n    }\n\n    const { databaseURL } = configuration;\n\n    if (dataValidatorUtilURL(databaseURL)) {\n      return databaseURL;\n    }\n    return new Error(\n      'An invalid URL provided for the Firebase authority provider'\n    );\n  }\n\n  public getApp(): void | firebase.app.App {\n    return this.app;\n  }\n\n  protected setConnectedStatus(isConnected: false | firebase.app.App) {\n    this.isConnected = !!isConnected;\n    if (isConnected) {\n      this.app = isConnected;\n    }\n  }\n\n  protected setAuthorizedStatus(isAuthorized: boolean) {\n    this.isAuthorizedWithCredentials = isAuthorized;\n  }\n\n  protected checkIfConnected(): boolean | Error {\n    const { isConnected, connectionWithCredentialsStorage } = this;\n\n    if (\n      !connectionWithCredentialsStorage ||\n      !connectionWithCredentialsStorage.isConnected\n    ) {\n      return false;\n    }\n    return !isConnected\n      ? new Error('There is no active connection with the Firebase')\n      : true;\n  }\n\n  protected checkSignUpCredentials(\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): boolean | Error {\n    if (!signUpCredentials) {\n      return new Error('Sign up credentials must be provided');\n    }\n    if (typeof signUpCredentials !== 'object') {\n      return new Error('Sign up credentials must be an object');\n    }\n\n    const {\n      cryptoCredentials: credentialsGiven,\n      login,\n      password,\n    } = signUpCredentials;\n\n    if (credentialsGiven) {\n      const resultCheckCredentialsGiven = this.checkUserIdentityIsValidForConfigurationProvided(\n        credentialsGiven\n      );\n\n      if (resultCheckCredentialsGiven instanceof Error) {\n        console.error(resultCheckCredentialsGiven);\n        return new Error(\n          'Credentials given is not valid for the Firebase auth provider'\n        );\n      }\n    }\n    if (!dataValidatorUtilEmail(login)) {\n      return new Error('The login must be an email valid');\n    }\n    if (!validatePassword(password)) {\n      return new Error('The password provided is not valid');\n    }\n    return true;\n  }\n\n  protected setConnectionWithCredentialsStorage(\n    connectionWithCredentialsStorage: CAConnectionFirestoreUtilsCredentialsStrorage\n  ) {\n    this.connectionWithCredentialsStorage = connectionWithCredentialsStorage;\n  }\n\n  protected async startConnectionWithCredentialsStorage(): Promise<\n    boolean | Error\n  > {\n    const connectionWithCredentialsStorage = new CAConnectionFirestoreUtilsCredentialsStrorage(\n      this\n    );\n    const storageConnectionResult = await connectionWithCredentialsStorage.connect();\n\n    if (storageConnectionResult instanceof Error) {\n      console.error(storageConnectionResult);\n      return new Error('Failed connect to the Firebase credentials storage');\n    }\n    if (!connectionWithCredentialsStorage.isConnected) {\n      return new Error(\n        'Connection to the Firebase credentials storage was not succeed'\n      );\n    }\n    this.setConnectionWithCredentialsStorage(connectionWithCredentialsStorage);\n    return true;\n  }\n\n  public async connect(\n    configuration: ICAConnectionConfigurationFirebase\n  ): Promise<boolean | Error> {\n    let app;\n    try {\n      app = firebase.initializeApp(configuration);\n      this.configuration = configuration;\n    } catch (err) {\n      console.error(err);\n      this.setConnectedStatus(false);\n      return new Error(\n        'Failed to initialize the application with the given configuration'\n      );\n    }\n    this.setConnectedStatus(app);\n    return true;\n  }\n\n  protected handleUnauthorized() {\n    this.setAuthorizedStatus(false);\n    this.valueofCredentialsSignUpOnAuthorizedSuccess = undefined;\n  }\n\n  // handle an authorization attemp failed\n  protected onAuthorizationFailed(error: Error | string): Error {\n    const err = error instanceof Error ? error : new Error(String(error));\n\n    console.error(err);\n    console.error('Authorization failed on remote Firebase server');\n    this.handleUnauthorized();\n    return err;\n  }\n\n  protected async singUpWithAuthCredentials(\n    authCredentials: ICentralAuthorityUserAuthCredentials\n  ): Promise<boolean | Error> {\n    const checkSignUpCredentialsResult = this.checkSignUpCredentials(\n      authCredentials\n    );\n\n    if (checkSignUpCredentialsResult instanceof Error) {\n      console.error(checkSignUpCredentialsResult);\n      return this.onAuthorizationFailed(checkSignUpCredentialsResult);\n    }\n\n    const { login, password } = authCredentials;\n\n    try {\n      await firebase.auth().createUserWithEmailAndPassword(login, password);\n    } catch (err) {\n      console.error(err);\n      return new Error(\n        'Failed to sign up to the Firebase with the given credentials'\n      );\n    }\n    return true;\n  }\n\n  /**\n   * sign in under the login\n   * provided by the user\n   * @param authCredentials\n   * @param {string} authCredentials.login\n   * @param {string} authCredentials.password\n   */\n  protected async singInWithAuthCredentials(\n    authCredentials: ICentralAuthorityUserAuthCredentials\n  ): Promise<boolean | Error> {\n    let signInResult;\n    const { login, password } = authCredentials;\n\n    try {\n      signInResult = await firebase\n        .auth()\n        .signInWithEmailAndPassword(login, password);\n    } catch (err) {\n      console.error(err);\n      return new Error(\n        'Failed to sign up to the Firebase with the given credentials'\n      );\n    }\n    return true;\n  }\n\n  protected async getUserProfileData(): Promise<\n    Error | ICentralAuthorityUserProfile\n  > {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { currentUser: currentUserData } = this;\n\n    // current user is instance\n    // of the firebase current user\n    if (!currentUserData) {\n      // if there is no profile data\n      return {};\n    }\n\n    const { displayName, photoURL, phoneNumber, email } = currentUserData;\n\n    return {\n      name: displayName || null,\n      email: email || null,\n      phone: phoneNumber || null,\n      photoURL: photoURL || null,\n    };\n  }\n\n  protected async returnOnAuthorizedResult(\n    cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): Promise<ICAConnectionUserAuthorizedResult | Error> {\n    const userProfile = await this.getUserProfileData();\n\n    if (userProfile instanceof Error) {\n      console.error(userProfile);\n      return new Error('Failed to get profile data');\n    }\n    return {\n      cryptoCredentials,\n      profile: userProfile,\n    };\n  }\n\n  protected mapAppProfileToFirebaseProfileWithoutEmail(\n    profile: Partial<ICentralAuthorityUserProfile>\n  ): ICAConnectionFirebaseUserProfile {\n    return {\n      displayName: (profile && profile.name) || null,\n      photoURL: (profile && profile.photoURL) || null,\n    };\n  }\n\n  protected async setProfileDataEmail(email: string): Promise<Error | boolean> {\n    const checkIsConnectedResult = this.checkIfConnected();\n\n    if (checkIsConnectedResult instanceof Error) {\n      return checkIsConnectedResult;\n    }\n    if (!dataValidatorUtilEmail(email)) {\n      return new Error('The email is not valid');\n    }\n\n    const { currentUser } = this;\n\n    if (!currentUser) {\n      return new Error('Failed to get the user profile data');\n    }\n    if (currentUser.email !== email) {\n      try {\n        await currentUser.updateEmail(email);\n      } catch (err) {\n        console.error(err);\n        return new Error('Failed to update the email address');\n      }\n\n      const sendEmailVerificationResult = await this.handleAuthEmailNotVerified();\n\n      if (sendEmailVerificationResult instanceof Error) {\n        console.error(sendEmailVerificationResult);\n        return new Error('Failed to update the email address');\n      }\n      // TODO - if the user was authentificated by OAuth\n      // it is necessary to invoke the reauthentificate method\n      // of the Firebase\n      const logOutResult = await this.signOut();\n\n      if (logOutResult instanceof Error) {\n        console.error(logOutResult);\n        return new Error('Failed to log out');\n      }\n      return true;\n    }\n    return true;\n  }\n\n  /**\n   * At no a phone number can't be updated\n   * @param profileDataPartialWithoutPhoneNumber\n   */\n  protected async setProfileDataWithFirebase(\n    profileDataPartialWithoutPhoneNumber: Partial<ICentralAuthorityUserProfile>\n  ): Promise<Error | boolean> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { currentUser } = this;\n\n    if (!currentUser) {\n      return new Error('There is no current user profile');\n    }\n\n    const profileMappedForFirebaseWithoutEmail = this.mapAppProfileToFirebaseProfileWithoutEmail(\n      profileDataPartialWithoutPhoneNumber\n    );\n\n    try {\n      await currentUser.updateProfile(profileMappedForFirebaseWithoutEmail);\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to set the Firebase profile data');\n    }\n    // TODO - what to do with a phone number\n    return true;\n  }\n\n  // TODO - test it and change to private method\n  public async setProfileData(\n    profile: Partial<ICentralAuthorityUserProfile>\n  ): Promise<Error | ICentralAuthorityUserProfile> {\n    if (isEmptyObject(profile)) {\n      return await this.getUserProfileData();\n    }\n    if (!validateUserProfileData(profile)) {\n      return new Error('The profile is not valid');\n    }\n\n    const resultUpdateProfile = await this.setProfileDataWithFirebase(profile);\n\n    if (resultUpdateProfile instanceof Error) {\n      return resultUpdateProfile;\n    }\n\n    const updatedProfile = await this.getUserProfileData();\n\n    if (updatedProfile instanceof Error) {\n      console.error(updatedProfile);\n      return new Error('Failed to read the updated profile data');\n    }\n\n    const { email } = profile;\n\n    if (email) {\n      // if it is necessary to update email value\n      // it will cause that user must authentificate\n      // once again\n      const updateEmailResult = await this.setProfileDataEmail(email);\n\n      if (updateEmailResult instanceof Error) {\n        return updateEmailResult;\n      }\n    }\n    return updatedProfile;\n  }\n\n  protected async handleAuthEmailNotVerified(): Promise<boolean | Error> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { currentUser } = this;\n\n    if (!currentUser) {\n      return new Error('There is no an active connection to the remote server');\n    }\n\n    try {\n      await currentUser.sendEmailVerification();\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to send the email verification link');\n    }\n    return true;\n  }\n\n  /**\n   * check if an account of the user\n   * was verified or not.\n   * If it wasn't, then send an email\n   * to verify it.\n   * @protected\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof CAConnectionWithFirebase\n   */\n  protected async chekIfVerifiedAccount(): Promise<boolean | Error> {\n    const { isVerifiedAccount } = this;\n\n    // if the account was validated by email\n    if (isVerifiedAccount) {\n      return true;\n    }\n\n    // if the account was not validated by email\n    // send the verification email\n    const sendVerificationEmailResult = await this.handleAuthEmailNotVerified();\n\n    if (sendVerificationEmailResult instanceof Error) {\n      console.error(sendVerificationEmailResult);\n      return new Error('Failed to send the email verification');\n    }\n    return new ErrorExtendedBaseClass(\n      'Please verify the email address',\n      CA_CONNECTION_ERROR_ACCOUNT_NOT_VERIFIED_CODE\n    );\n  }\n\n  protected async generateNewCryptoCredentialsForConfigurationProvided(): Promise<\n    Error | TCentralAuthorityUserCryptoCredentials\n  > {\n    const { databaseURL } = this;\n\n    if (databaseURL instanceof Error) {\n      return databaseURL;\n    }\n\n    const cryptoCredentials = await generateCryptoCredentialsWithUserIdentity({\n      authorityProviderURI: databaseURL,\n    });\n\n    if (cryptoCredentials instanceof Error) {\n      console.error(cryptoCredentials);\n      return new Error('Failed to generate a new crypto credentials');\n    }\n    return cryptoCredentials;\n  }\n\n  protected checkUserIdentityIsValidForConfigurationProvided(\n    cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): Error | TCentralAuthorityUserCryptoCredentials {\n    const { databaseURL } = this;\n\n    if (databaseURL instanceof Error) {\n      return databaseURL;\n    }\n    if (!checkIsValidCryptoCredentials(cryptoCredentials)) {\n      return new Error('The crypto credentials value is not valid');\n    }\n\n    const caUserIdentity = new CentralAuthorityIdentity(cryptoCredentials);\n\n    if (!caUserIdentity.isValid) {\n      return new Error('User identity is not valid');\n    }\n\n    const { identityDescription: identityDescriptionParsed } = caUserIdentity;\n\n    if (identityDescriptionParsed instanceof Error) {\n      console.error(identityDescriptionParsed);\n      return new Error('Failed to get description by identity string');\n    }\n    if (\n      identityDescriptionParsed[\n        CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME\n      ] !== databaseURL\n    ) {\n      return new Error(\n        'Wrong authority provider url got from the identity string'\n      );\n    }\n    return cryptoCredentials;\n  }\n\n  protected async readCryptoCredentialsForTheUserFromDatabase(): Promise<\n    Error | TCentralAuthorityUserCryptoCredentials | null\n  > {\n    const isConnected = this.checkIfConnected();\n\n    if (!isConnected) {\n      return new Error(\n        'There is no active connection to the Firebase auth provider'\n      );\n    }\n\n    const { connectionWithCredentialsStorage } = this;\n    const credentialsForTheCurrentUser = await connectionWithCredentialsStorage!!.getCredentialsForTheCurrentUser();\n\n    if (credentialsForTheCurrentUser instanceof Error) {\n      console.error(credentialsForTheCurrentUser);\n      return new Error('Failed to read credentials of the current user');\n    }\n    return credentialsForTheCurrentUser;\n  }\n\n  protected async setCryptoCredentialsForTheUserToDatabase(\n    cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials> {\n    const isConnected = this.checkIfConnected();\n    const { connectionWithCredentialsStorage } = this;\n\n    if (!isConnected) {\n      return new Error(\n        'There is no active connection to the Firebase auth provider'\n      );\n    }\n    // set the new generated credentials forcely\n    // and rewrite the existing\n    // cause it is not valid\n    const setCredentialsResult = await connectionWithCredentialsStorage!!.setUserCredentials(\n      cryptoCredentials\n    );\n\n    if (setCredentialsResult instanceof Error) {\n      return setCredentialsResult;\n    }\n    // if not an error then return\n    // a crypto credentials\n    return setCredentialsResult;\n  }\n\n  protected async generateAndSetCredentialsForTheCurrentUser(\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials> {\n    let attempt = 0;\n    let cryptoCredentials:\n      | TCentralAuthorityUserCryptoCredentials\n      | Error = new Error(\n      'Failed to generate and set a crypto credentials for the user because of unknown reason'\n    );\n    let isSuccess: boolean = false;\n\n    const credentialsProvidedCheckResult = this.checkSignUpCredentials(\n      signUpCredentials\n    );\n\n    if (credentialsProvidedCheckResult instanceof Error) {\n      console.error(credentialsProvidedCheckResult);\n      return credentialsProvidedCheckResult;\n    }\n\n    const { cryptoCredentials: credentialsGiven } = signUpCredentials;\n\n    // try a multiple times cause may be\n    // a network errors or user id\n    // is already exists in the database\n    while (\n      attempt < CA_CONNECTION_FIREBASE_CREDENTIALS_GENERATION_MAX_ATTEMPTS ||\n      isSuccess\n    ) {\n      cryptoCredentials = credentialsGiven\n        ? // if a credentials provided, then use it\n          credentialsGiven\n        : // if a credentials not provided, generate a new one\n          await this.generateNewCryptoCredentialsForConfigurationProvided();\n\n      if (cryptoCredentials instanceof Error) {\n        // fialed to generate a new crypto credentials\n        console.error(cryptoCredentials);\n      } else {\n        const setCredentialsResult = await this.setCryptoCredentialsForTheUserToDatabase(\n          cryptoCredentials\n        );\n\n        if (setCredentialsResult instanceof Error) {\n          console.error(setCredentialsResult);\n          cryptoCredentials = new Error(\n            'Failed to store credentials for the user in the database'\n          );\n        } else {\n          cryptoCredentials = setCredentialsResult;\n          isSuccess = true;\n          break;\n        }\n      }\n      attempt += 1;\n    }\n    return cryptoCredentials;\n  }\n\n  protected async createOrReturnExistingCredentialsForUser(\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials> {\n    const credentialsExistingForTheCurrentUser = await this.readCryptoCredentialsForTheUserFromDatabase();\n\n    if (credentialsExistingForTheCurrentUser instanceof Error) {\n      // if something was going wrong when reading\n      // a credentials for the current user\n      // return an Error, because if ignore\n      // and set a new credentials in storage\n      // the data may become inconsistent, cause\n      // credentials is already exists in the database\n      // but an error has occurred once for a some reason.\n      console.error(credentialsExistingForTheCurrentUser);\n      return new Error(\n        'Failed to read credentials for the user from the Firebase database'\n      );\n    }\n\n    if (credentialsExistingForTheCurrentUser) {\n      const credentialsValidationResult = this.checkUserIdentityIsValidForConfigurationProvided(\n        credentialsExistingForTheCurrentUser\n      );\n\n      if (credentialsValidationResult instanceof Error) {\n        console.error(credentialsValidationResult);\n        console.error('The credentials stored for the user is not valid');\n        // if credentials exists for the user but invalid at now\n        // return an error to inform that the user can't user\n        // this account for authorization.\n        // Credentials was already read by another users\n        // and if we set a new one in the storage it may\n        // cause inconsistency.\n        return new ErrorExtendedBaseClass(\n          \"Sorry, you can't use this account anymore, cause a credentials existing for the account exists and not valid\",\n          CA_CONNECTION_ERROR_ACCOUNT_CAN_NOT_BE_USED_ANYMORE\n        );\n      }\n\n      // if the credentials read from the\n      // Firebase storage is valid\n      // for the current configuration return it\n      return credentialsExistingForTheCurrentUser;\n    }\n\n    // generate a new credentials for the user and\n    // set it in the storage. If a credentials was\n    // provided into signUpCredentials and valid, it will be used\n    // instead of generating a new one.\n    const newCredentialsGenerated = await this.generateAndSetCredentialsForTheCurrentUser(\n      signUpCredentials\n    );\n\n    if (newCredentialsGenerated instanceof Error) {\n      console.error(newCredentialsGenerated);\n      return new Error(\n        'Failed to generate or set a crypto credentials for the user'\n      );\n    }\n    return newCredentialsGenerated;\n  }\n  async signIn(\n    firebaseCredentials: ICAConnectionSignUpCredentials\n  ): Promise<boolean | Error> {\n    const checkSignUpCredentialsResult = this.checkSignUpCredentials(\n      firebaseCredentials\n    );\n\n    if (checkSignUpCredentialsResult instanceof Error) {\n      console.error(checkSignUpCredentialsResult);\n      return this.onAuthorizationFailed(checkSignUpCredentialsResult);\n    }\n\n    // try to sign in with the credentials, then try to sign up\n    return this.singInWithAuthCredentials(firebaseCredentials);\n  }\n\n  protected async signUp(\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | boolean> {\n    // if failed to sign in with the\n    // credentials, then try to\n    // sign up\n    const signUpResult = await this.singUpWithAuthCredentials(\n      signUpCredentials\n    );\n\n    if (signUpResult instanceof Error) {\n      // if sign up failed then return\n      // error that the authorization\n      // failed\n      return this.onAuthorizationFailed(\n        'Failed to authorize on Firebase remote server with the credentials'\n      );\n    }\n    return true;\n  }\n\n  /**\n   * @param {ICAConnectionSignUpCredentials} firebaseCredentials\n   * @param firebaseCredentials.login - there must be an email to authorize with a Firebase account\n   * @param firebaseCredentials.password - password used for encrypt a sensitive data and authorize\n   * in the Firebase account\n   * @param profile - if provided then the user profile will be set in firebase\n   */\n  public async authorize(\n    firebaseCredentials: ICAConnectionSignUpCredentials,\n    profile?: Partial<ICentralAuthorityUserProfile>\n  ): Promise<ICAConnectionUserAuthorizedResult | Error> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return this.onAuthorizationFailed(isConnected);\n    }\n\n    let authHandleResult;\n    const { isAuthorized } = this;\n\n    if (isAuthorized) {\n      authHandleResult = this.valueofCredentialsSignUpOnAuthorizedSuccess!!;\n    } else {\n      // try to sign in with the credentials, then try to sign up\n      const signInResult = await this.signIn(firebaseCredentials);\n\n      if (signInResult instanceof Error) {\n        console.warn('Failed to sign in with the credentials given');\n\n        // if failed to sign in with the credentials\n        // try to sign up\n        const signUpResult = await this.signUp(firebaseCredentials);\n\n        if (signUpResult instanceof Error) {\n          console.error(signUpResult);\n          return this.onAuthorizationFailed('The user was failed to sign up');\n        }\n      }\n\n      // check if the account was verfied by the user\n      const isVerifiedResult = await this.chekIfVerifiedAccount();\n\n      if (isVerifiedResult instanceof Error) {\n        console.error('The account is not verified');\n        return this.onAuthorizationFailed(isVerifiedResult);\n      }\n\n      const connectWithStorageResult = await this.startConnectionWithCredentialsStorage();\n\n      if (connectWithStorageResult instanceof Error) {\n        console.error(connectWithStorageResult);\n        return new Error('Failed to connect to the credentials storage');\n      }\n\n      // create a new credentnials for the user or return\n      // an existing.\n      // if a crytpto credentials provided in signUpCredentials\n      // it will be used to set in the Firebase credentials\n      // storage\n      const cryptoCredentials = await this.createOrReturnExistingCredentialsForUser(\n        firebaseCredentials\n      );\n\n      if (cryptoCredentials instanceof Error) {\n        console.error('Failed to get a crypto credentials valid for the user');\n        return this.onAuthorizationFailed(cryptoCredentials);\n      }\n\n      // give user's profile\n      // with a credentials\n      authHandleResult = await this.returnOnAuthorizedResult(cryptoCredentials);\n    }\n\n    if (authHandleResult instanceof Error) {\n      return this.onAuthorizationFailed(authHandleResult);\n    }\n    // if a profile data is necessary to be set\n    // by a profile data from the arguments given\n    if (profile && !isEmptyObject(profile)) {\n      const setProfileResult = await this.setProfileData(profile);\n\n      if (setProfileResult instanceof Error) {\n        console.error(setProfileResult);\n        return this.onAuthorizationFailed('Failed to set the profile data');\n      }\n\n      // set porofile is the user's profile\n      // data stored in the firebase\n      authHandleResult = {\n        profile: setProfileResult,\n        // TODO it is necessry to set this credentials in the database\n        cryptoCredentials: authHandleResult.cryptoCredentials,\n      };\n    }\n    // set the authentification success\n    // result. To return it on the second authorization\n    // request\n    this.valueofCredentialsSignUpOnAuthorizedSuccess = authHandleResult;\n    return authHandleResult;\n  }\n\n  protected async disconnectCredentialsStorage(): Promise<Error | boolean> {\n    const { connectionWithCredentialsStorage } = this;\n\n    if (\n      connectionWithCredentialsStorage &&\n      connectionWithCredentialsStorage.isConnected\n    ) {\n      const res = await connectionWithCredentialsStorage.disconnect();\n\n      if (res instanceof Error) {\n        console.error(res);\n        return new Error(\n          'Failed to disconnect from the Firebase credentials storage'\n        );\n      }\n    }\n\n    this.connectionWithCredentialsStorage = undefined;\n    return true;\n  }\n\n  public async signOut(): Promise<boolean | Error> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    // disconnect the strage cause it's necessary\n    // that the user was authorized\n    const disconnectFromStorageResult = await this.disconnectCredentialsStorage();\n\n    if (disconnectFromStorageResult instanceof Error) {\n      return disconnectFromStorageResult;\n    }\n\n    const { app } = this;\n\n    try {\n      await app!!.auth().signOut();\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to sign out');\n    }\n    this.handleUnauthorized();\n\n    return true;\n  }\n\n  public async disconnect() {\n    const disconnectFromStorageResult = await this.disconnectCredentialsStorage();\n\n    if (disconnectFromStorageResult instanceof Error) {\n      return disconnectFromStorageResult;\n    }\n\n    const { app } = this;\n\n    if (app) {\n      try {\n        // disconect from the application\n        await app.delete();\n      } catch (err) {\n        console.error(err);\n        return new Error('Failed to disconnect from the Firebase app');\n      }\n    }\n    return new Error('There is no active Firebase App instance to close');\n  }\n\n  public async delete(\n    firebaseCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | boolean> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { currentUser } = this;\n\n    if (currentUser instanceof Error) {\n      console.error(currentUser);\n      return new Error('Failed to read the current user');\n    }\n    if (currentUser == null) {\n      return new Error('There is no current user');\n    }\n\n    // try to sign in with the credentials, then try to sign up\n    const signInResult = await this.signIn(firebaseCredentials);\n\n    if (signInResult instanceof Error) {\n      console.error('Failed to sign in before the user deletion');\n      return signInResult;\n    }\n\n    try {\n      const result = (await currentUser.delete()) as unknown; // or maybe deleteWithCompletion method\n\n      if (result instanceof Error) {\n        console.error(result);\n        return new Error('Failed to delete the user from the firebase');\n      }\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to delete the user from the authority');\n    }\n\n    // disconnection from the firebase\n    // is not necessry cause the firebase\n    // disconnects automatically if the user\n    // delete himself\n    return true;\n  }\n}\n\nexport default CAConnectionWithFirebase;\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.types.configuration.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-server-api/central-authority-connection-server-api.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const-error-codes.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-storage/central-authority-storage-credentials/central-authority-storage-credentials.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-storage/central-authority-storage-credentials/central-authority-storage-credentials.ts",["1206","1207","1208","1209"],"/**\n * This is storage of the current\n * user crypto keys for signing\n * and encryptopn a data\n */\n\nimport { SecretStorage } from 'classes/secret-storage-class';\nimport { getStatusClass } from 'classes/basic-classes/status-class-base/status-class-base';\nimport {\n  TCentralAuthorityCredentialsStorageAuthCredentials,\n  TCentralAuthorityUserCryptoCredentials,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-credentials';\nimport {\n  TCentralAuthorityUserIdentity,\n  TCACryptoKeyPairs,\n  ICentralAuthorityStorageCryptoCredentials,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport {\n  validateUserIdentity,\n  validateAuthCredentials,\n} from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport {\n  CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME,\n  CA_AUTH_CREDENTIALS_USER_PASSWORD_PROP_NAME,\n} from 'classes/central-authority-class/central-authority-class-const/central-authority-class-const';\nimport {\n  exportCryptoCredentialsToString,\n  getUserCredentialsByUserIdentityAndCryptoKeys,\n  importCryptoCredentialsFromAString,\n} from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials';\nimport {\n  CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_STATUS,\n  CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_KEY_CRYPTO_CREDENTIALS,\n  CENTRAL_AUTHORITY_STORAGE_PROVIDER_NAME,\n} from './central-authority-storage-credentials.const';\nimport { TSecretStoreConfiguration } from 'classes/secret-storage-class/secret-storage-class.types';\nimport { calculateHash } from 'utils/hash-calculation-utils/hash-calculation-utils';\nimport { checkIsValidCryptoCredentials } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\n\n/**\n *\n * this is storage which is necessary\n * to save all the user keys along with the user id which\n * are necessary to communicate with another users\n * in the network in encrypted form\n * @export\n * @class CentralAuthorityCredentialsStorage\n * @extends {StatusClassBase<typeof CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_STATUS>}\n */\nexport class CentralAuthorityCredentialsStorage\n  extends getStatusClass<typeof CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_STATUS>({\n    errorStatus: CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_STATUS.ERROR,\n    initialStatus: CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_STATUS.NEW,\n    instanceName: 'CentralAuthorityCredentialsStorage',\n  })\n  implements ICentralAuthorityStorageCryptoCredentials {\n  protected __userIdentity?: TCentralAuthorityUserIdentity;\n\n  protected __userIdentityHash?: string;\n\n  protected secretStorageConnection?: SecretStorage;\n\n  protected userCryptoCredentialsCached?: TCentralAuthorityUserCryptoCredentials;\n\n  protected get userIdentity(): undefined | string {\n    const { __userIdentity } = this;\n\n    if (validateUserIdentity(__userIdentity)) {\n      return __userIdentity;\n    }\n    return undefined;\n  }\n\n  protected get userIdentityHash(): undefined | string {\n    const { __userIdentityHash } = this;\n\n    return __userIdentityHash || undefined;\n  }\n\n  protected get secretStorageCredentialsValueKey(): string {\n    const { userIdentityHash } = this;\n\n    return `${CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_KEY_CRYPTO_CREDENTIALS}__${userIdentityHash}`;\n  }\n\n  protected get isConnectedToStorage(): boolean {\n    const { status } = this;\n\n    return status === CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_STATUS.CONNECTED;\n  }\n\n  protected get secretStorageOptions(): Partial<TSecretStoreConfiguration> {\n    return {\n      storageProviderName: CENTRAL_AUTHORITY_STORAGE_PROVIDER_NAME,\n    };\n  }\n\n  protected async setUserIdentity(userIdentity: any): Promise<Error | boolean> {\n    if (validateUserIdentity(userIdentity)) {\n      const userIdentityHash = await calculateHash(userIdentity);\n\n      if (userIdentityHash instanceof Error) {\n        console.error(userIdentityHash);\n        return new Error(\"Failed to calculate the user's identity hash\");\n      }\n\n      this.__userIdentity = userIdentity;\n      this.__userIdentityHash = userIdentityHash;\n      return true;\n    }\n    return new Error('The user identity is not valid');\n  }\n\n  protected createSecretStorageInstance() {\n    const { secretStorageOptions: configuration } = this;\n\n    this.secretStorageConnection = new SecretStorage(configuration);\n  }\n\n  /**\n   * authorize to the storage with a credentials given\n   * @param {object} credentials\n   */\n  protected authorizeWithCredentials(\n    credentials: TCentralAuthorityCredentialsStorageAuthCredentials\n  ): Promise<Error | boolean> | Error {\n    const { secretStorageConnection } = this;\n    const {\n      [CA_AUTH_CREDENTIALS_USER_PASSWORD_PROP_NAME]: password,\n    } = credentials;\n\n    if (secretStorageConnection) {\n      return secretStorageConnection.authorize({ password });\n    }\n    return new Error('There is no secretStorageConnection');\n  }\n\n  /**\n   * connect to the SecretStorage without credentials.\n   * the success will depending on the previous\n   * connection with credentials - if it was succed\n   * then the credentials may be stored in the session\n   * storage\n   */\n  protected connectToStorageWithoutCredentials():\n    | Promise<Error | boolean>\n    | Error {\n    const { secretStorageConnection } = this;\n\n    if (secretStorageConnection) {\n      return secretStorageConnection.connect();\n    }\n    return new Error('There is no secretStorageConnection');\n  }\n\n  protected async connectToTheStorage(\n    credentials?: TCentralAuthorityCredentialsStorageAuthCredentials\n  ): Promise<boolean | Error> {\n    if (validateAuthCredentials(credentials)) {\n      const {\n        [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n      } = credentials;\n      const resultSetUserIdentity = await this.setUserIdentity(userIdentity);\n\n      if (resultSetUserIdentity === true) {\n        return this.authorizeWithCredentials(credentials);\n      }\n      return new Error('A wrong user identity');\n    }\n    return this.connectToStorageWithoutCredentials();\n  }\n\n  public async connect(\n    credentials?: TCentralAuthorityCredentialsStorageAuthCredentials\n  ): Promise<boolean | Error> {\n    this.setStatus(CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_STATUS.CONNECTING);\n    this.createSecretStorageInstance();\n\n    const connectionResult = await this.connectToTheStorage(credentials);\n\n    if (connectionResult instanceof Error) {\n      this.setStatus(\n        CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_STATUS.CONNECTION_FAILED\n      );\n      CentralAuthorityCredentialsStorage.error(connectionResult);\n      return connectionResult;\n    }\n    this.setStatus(CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_STATUS.CONNECTED);\n    return true;\n  }\n\n  protected reset() {\n    this.__userIdentity = undefined;\n    this.__userIdentityHash = undefined;\n    this.secretStorageConnection = undefined;\n  }\n\n  public async disconnect(): Promise<boolean | Error> {\n    const { isConnectedToStorage, secretStorageConnection } = this;\n\n    if (isConnectedToStorage && secretStorageConnection) {\n      const disconnectFromStorageResult = await secretStorageConnection.disconnect();\n\n      if (disconnectFromStorageResult instanceof Error) {\n        console.error(disconnectFromStorageResult);\n        return new Error('Failed to disconnect from the storage');\n      }\n      this.reset();\n      this.setStatus(CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_STATUS.DISCONNECTED);\n      return true;\n    }\n    return new Error('Not connected to the storage');\n  }\n\n  protected setUserCredentialsToCache(\n    userCryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): undefined | Error {\n    if (!checkIsValidCryptoCredentials(userCryptoCredentials)) {\n      return new Error('The given value is not a valid crypto credentials');\n    }\n    this.userCryptoCredentialsCached = userCryptoCredentials;\n  }\n\n  protected unsetUserCredentialsInCache(): void {\n    this.userCryptoCredentialsCached = undefined;\n  }\n\n  protected async setToStorage(\n    key: string,\n    value: any\n  ): Promise<Error | boolean> {\n    const {\n      secretStorageConnection,\n      isConnectedToStorage: isConnectedToTheSecretStorage,\n    } = this;\n\n    if (isConnectedToTheSecretStorage && secretStorageConnection) {\n      return secretStorageConnection.set(key, value);\n    }\n    return new Error('There is no active connecion to the secret storage');\n  }\n\n  protected async readFromStorage(\n    key: string\n  ): Promise<Error | string | undefined> {\n    const {\n      secretStorageConnection,\n      isConnectedToStorage: isConnectedToTheSecretStorage,\n    } = this;\n\n    if (isConnectedToTheSecretStorage && secretStorageConnection) {\n      return secretStorageConnection.get(key);\n    }\n    return new Error('There is no active connecion to the secret storage');\n  }\n\n  protected async setCryptoCredentialsToStorage(\n    userCryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): Promise<Error | boolean> {\n    const {\n      isConnectedToStorage: isConnectedToTheSecretStorage,\n      secretStorageCredentialsValueKey,\n    } = this;\n\n    if (!isConnectedToTheSecretStorage) {\n      return new Error('There is no active connecion to the secret storage');\n    }\n\n    const exportedUserCryptoCredentials = await exportCryptoCredentialsToString(\n      userCryptoCredentials\n    );\n\n    if (exportedUserCryptoCredentials instanceof Error) {\n      return exportedUserCryptoCredentials;\n    }\n    return this.setToStorage(\n      secretStorageCredentialsValueKey,\n      exportedUserCryptoCredentials\n    );\n  }\n\n  protected unsetCryptoCredentialsToStorage(): Promise<Error | boolean> {\n    const { secretStorageCredentialsValueKey } = this;\n\n    return this.setToStorage(secretStorageCredentialsValueKey, null);\n  }\n\n  protected getCredentialsCached():\n    | TCentralAuthorityUserCryptoCredentials\n    | Error\n    | undefined {\n    const { userCryptoCredentialsCached } = this;\n\n    if (!userCryptoCredentialsCached) {\n      return undefined;\n    }\n    if (checkIsValidCryptoCredentials(userCryptoCredentialsCached)) {\n      return userCryptoCredentialsCached;\n    }\n    return new Error('There is no a crypto credetials cached');\n  }\n\n  protected async readCryptoCredentialsFromStorage(): Promise<\n    TCentralAuthorityUserCryptoCredentials | Error | null\n  > {\n    const { secretStorageCredentialsValueKey } = this;\n\n    const cryptoCredentials = await this.readFromStorage(\n      secretStorageCredentialsValueKey\n    );\n\n    if (cryptoCredentials instanceof Error) {\n      console.error(cryptoCredentials);\n      return new Error('Failed to read the credentials from the storage');\n    }\n    if (!cryptoCredentials) {\n      console.warn('There is no crypto credentials stored');\n      return null;\n    }\n\n    const importedCryptoKey = await importCryptoCredentialsFromAString(\n      cryptoCredentials\n    );\n\n    if (importedCryptoKey instanceof Error) {\n      console.error(importedCryptoKey);\n      return new Error(\n        'Failed to import a crypto credentials value from the string stored'\n      );\n    }\n\n    const resultSetInCache = this.setUserCredentialsToCache(importedCryptoKey);\n\n    if (resultSetInCache instanceof Error) {\n      console.error(resultSetInCache);\n      this.unsetUserCredentialsInCache();\n      return new Error(\n        'Failed to set the crypto credentials value in the cache'\n      );\n    }\n    return importedCryptoKey;\n  }\n\n  public async getCredentials(): Promise<\n    TCentralAuthorityUserCryptoCredentials | Error | null\n  > {\n    const { isConnectedToStorage } = this;\n\n    if (!isConnectedToStorage) {\n      return new Error('There is no an active connection to the storage');\n    }\n    const cachedCryptoCredentials = this.getCredentialsCached();\n\n    if (cachedCryptoCredentials instanceof Error) {\n      console.error(cachedCryptoCredentials);\n      console.error('Failed to read a cached value of a crypto credentials');\n    }\n    if (cachedCryptoCredentials) {\n      return cachedCryptoCredentials;\n    }\n\n    const storedCryptoCredentials = await this.readCryptoCredentialsFromStorage();\n\n    if (storedCryptoCredentials instanceof Error) {\n      console.error(storedCryptoCredentials);\n      return new Error(\n        'Failed to read a crypto credentials value from the storage'\n      );\n    }\n    if (!storedCryptoCredentials) {\n      console.warn('A crypto credentials value is absent');\n      return null;\n    }\n\n    const setToCacheResult = this.setUserCredentialsToCache(\n      storedCryptoCredentials\n    );\n\n    if (setToCacheResult instanceof Error) {\n      console.error(setToCacheResult);\n      this.unsetUserCredentialsInCache();\n      console.error(\n        'Failed to set the crypto credentials read from the storage in the cache'\n      );\n    }\n    return storedCryptoCredentials;\n  }\n\n  public async setCredentials(\n    cryptoKeyPairs: TCACryptoKeyPairs\n  ): Promise<Error | boolean> {\n    const { userIdentity, isConnectedToStorage } = this;\n\n    if (!isConnectedToStorage) {\n      return new Error('There is no an active connection to the storage');\n    }\n    if (!userIdentity) {\n      return new Error('A user identity value was not set');\n    }\n\n    const cryptoCredentials = getUserCredentialsByUserIdentityAndCryptoKeys(\n      userIdentity,\n      cryptoKeyPairs\n    );\n\n    if (cryptoCredentials instanceof Error) {\n      console.error(cryptoCredentials);\n      return new Error(\n        'Failed to create a valid crypro credentials from the given crypto keys and the user identity'\n      );\n    }\n\n    const setCredentialsInCacheResult = this.setUserCredentialsToCache(\n      cryptoCredentials\n    );\n\n    if (setCredentialsInCacheResult instanceof Error) {\n      this.unsetUserCredentialsInCache();\n      console.error(setCredentialsInCacheResult);\n      return new Error('Failed to set the crypto credentials in the cahce');\n    }\n\n    const resultSetCryptoCredentialsToStorage = await this.setCryptoCredentialsToStorage(\n      cryptoCredentials\n    );\n\n    if (resultSetCryptoCredentialsToStorage instanceof Error) {\n      this.unsetUserCredentialsInCache();\n      if ((await this.unsetCryptoCredentialsToStorage()) instanceof Error) {\n        console.error('Failed to unset a crypto credentials in the storage');\n      }\n      console.error(resultSetCryptoCredentialsToStorage);\n      return new Error('Failed to set the crypto credentials in the storage');\n    }\n    return true;\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-storage/central-authority-storage-identity-credentials/central-authority-identity-storage.types.ts",["1210","1211"],"import {\n  TCentralAuthorityUserIdentity,\n  TCACryptoKeyPairs,\n  TCentralAuthorityUserCryptoCredentials,\n  TCentralAuthorityUserCryptoCredentialsExported,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { ownValueOf } from 'types/helper.types';\nimport { ISecretStoreCredentials } from 'classes/secret-storage-class/secret-storage-class.types';\n\n/**\n * contains the user's identifier\n * and a keys for data sign and\n * data encryption. An identifier\n * is unique, but an identifier's\n * value must be different for\n * the same user. It is necessary\n * to parse it and get a unique\n * value, which is uniquely\n * identifies the user throughout\n * the app.\n * @export\n * @interface ICAIdentityCredentialsDescription\n */\nexport interface ICAIdentityCredentialsDescription {\n  // an identiy of the user\n  identity: TCentralAuthorityUserIdentity;\n  // a key pairs for data sign and data encryption for the user\n  credentials: TCACryptoKeyPairs;\n}\n\n/**\n * defines how does a user's\n * identity and credentials will be stored\n * @export\n * @interface ICAIdentityCredentialsDescriptionStored\n */\nexport interface ICAIdentityCredentialsDescriptionStored {\n  // the user's unique identifier\n  // throughout the app\n  id: string;\n  // an identiy of the user\n  identity: TCentralAuthorityUserIdentity;\n  // a key pairs for data sign and data encryption for the user\n  credentials: TCACryptoKeyPairs;\n}\n\n/**\n * the interface for the storage\n * implementation. There are\n * only two methods to realize\n * the main functionality of it.\n * The first method returns stored\n * credentials of the user. And the\n * second set the credentials\n * of the user in the storage.\n * @export\n * @interface ICAIdentityCredentialsStorage\n */\nexport interface ICAIdentityCredentialsStorage {\n  // is the instance is connected\n  // to the storage and active\n  isActive: boolean;\n  // connect to the storage with the credentials\n  // to decrypt a values stored\n  connect(credentials: ISecretStoreCredentials): Promise<boolean | Error>;\n  // disconnect from the storage\n  disconnect(): Promise<boolean | Error>;\n  // read credentials from the storage\n  getCredentials(\n    identity: TCentralAuthorityUserIdentity\n  ): Promise<TCentralAuthorityUserCryptoCredentials | Error | null>;\n  // store credentials for the identity\n  // in the storage\n  setCredentials(\n    identity: TCentralAuthorityUserIdentity,\n    cryptoCredentials: TCACryptoKeyPairs\n  ): Promise<boolean | Error>;\n  // Store the crypto credentials.\n  // It will be parsed to\n  // identity and key pairs\n  setCredentials(\n    cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): Promise<boolean | Error>;\n  // store the crypto credentials\n  // exported to a string.\n  // It will be parsed to\n  // identity and key pairs\n  setCredentials(\n    cryptoCredentialsExportedAsString: string\n  ): Promise<boolean | Error>;\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-storage/central-authority-storage-identity-credentials/central-authority-storage-identity-credentials.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-storage/central-authority-storage-identity-credentials/central-authority-storage-identity-credentials.ts",["1212","1213","1214","1215","1216","1217","1218"],"import { getStatusClass } from 'classes/basic-classes/status-class-base/status-class-base';\nimport {\n  CA_IDENTITY_CREDENTIALS_STORAGE_STATUS,\n  CA_IDENTITY_CREDENTIALS_STORAGE_CONFIGURATION,\n  CA_IDENTITY_CREDENTIALS_STORAGE_READ_CACHE_CAPACITY,\n  CA_IDENTITY_CREDENTIALS_STORAGE_READ_RAW_CACHE_CAPACITY,\n  CA_IDENTITY_CREDENTIALS_STORAGE_FULL_NAME,\n} from './central-authority-storage-identity-credentials.const';\nimport { ICAIdentityCredentialsStorage } from './central-authority-identity-storage.types';\nimport { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';\nimport {\n  ISecretStoreCredentials,\n  ISecretStorage,\n} from 'classes/secret-storage-class/secret-storage-class.types';\nimport {\n  TCentralAuthorityUserIdentity,\n  TCACryptoKeyPairs,\n  TCentralAuthorityUserCryptoCredentials,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport CentralAuthorityIdentity from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport {\n  getExportedCryptoCredentialsByCAIdentity,\n  importCryptoCredentialsFromExportedFromat,\n  replaceCryptoCredentialsIdentity,\n  importCryptoCredentialsFromAString,\n  getUserIdentityByCryptoCredentials,\n  getCryptoKeyPairsByCryptoCredentials,\n} from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\nimport { dataCachingUtilsCachingDecorator as caching } from 'utils/data-cache-utils/data-cache-utils';\nimport {\n  checkIsValidExportedCryptoCredentialsToString,\n  checkIsValidCryptoCredentials,\n} from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\n\n/**\n * this is the storage for the user\n * identifier and a public keys for\n * data sign and encryption\n */\nexport class CentralAuthorityIdentityCredentialsStorage\n  extends getStatusClass<typeof CA_IDENTITY_CREDENTIALS_STORAGE_STATUS>({\n    errorStatus: CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.ERROR,\n    initialStatus: CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.NEW,\n    instanceName: 'CentralAuthorityIdentityCredentialsStorage',\n  })\n  implements ICAIdentityCredentialsStorage {\n  protected secretStorageConnection?: ISecretStorage;\n\n  protected createConnectionToSecretStorage(): SecretStorage | Error {\n    try {\n      const connection = new SecretStorage(\n        CA_IDENTITY_CREDENTIALS_STORAGE_CONFIGURATION\n      );\n\n      return connection;\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  public get isActive(): boolean {\n    const { status, secretStorageConnection } = this;\n\n    return (\n      status === CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.CONNECTED &&\n      !!secretStorageConnection &&\n      secretStorageConnection.isActive\n    );\n  }\n\n  /**\n   * connect to the SecretStorage with\n   * the user's credentials\n   * @param storageCredentials\n   */\n  public async connect(\n    storageCredentials?: ISecretStoreCredentials\n  ): Promise<boolean | Error> {\n    const connection = this.createConnectionToSecretStorage();\n\n    if (connection instanceof Error) {\n      console.error(connection);\n      return this.setErrorStatus(\n        'Failed to create an instance of SecretStorage'\n      );\n    }\n    this.setStatus(CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.CONNECTING);\n\n    let connectionResult;\n\n    if (storageCredentials) {\n      connectionResult = await connection.authorize(storageCredentials);\n    } else {\n      connectionResult = await connection.connect();\n    }\n\n    if (connectionResult instanceof Error) {\n      console.error(connectionResult);\n      this.setStatus(CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.CONNECTION_FAILED);\n      return new Error('Failed to authorize');\n    }\n    this.setStatus(CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.CONNECTED);\n    this.secretStorageConnection = connection;\n    return true;\n  }\n\n  public async disconnect(): Promise<Error | boolean> {\n    const { status, secretStorageConnection } = this;\n\n    if (status === CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.DISCONNECTED) {\n      console.error(\n        new Error('The instance is already disconnected from the storage')\n      );\n      // return false cause already disconnected\n      return false;\n    }\n    if (\n      status !== CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.CONNECTED ||\n      status === CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.ERROR\n    ) {\n      return this.setErrorStatus(\n        new Error(\n          \"Can't disconnect cause the instance is not in the Connected state\"\n        )\n      );\n    }\n    if (!(secretStorageConnection instanceof SecretStorage)) {\n      return this.setErrorStatus('There is no connection to the SecretStorage');\n    }\n\n    const disconnectionResult = await secretStorageConnection.disconnect();\n\n    if (disconnectionResult instanceof Error) {\n      console.error(disconnectionResult);\n      return this.setErrorStatus('SecretStorage failed to disconnect');\n    }\n    this.setStatus(CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.DISCONNECTED);\n    return true;\n  }\n\n  protected getKeyNameWithPrefix(key: string): string {\n    return `__CA_IDENTITY_CREDENTIALS_STORAGE_FULL_NAME___${key}`;\n  }\n\n  @caching(CA_IDENTITY_CREDENTIALS_STORAGE_READ_RAW_CACHE_CAPACITY)\n  protected async getCredentialsRaw(\n    id: string\n  ): Promise<string | Error | undefined> {\n    const { isActive } = this;\n\n    if (!isActive) {\n      return new Error('The storage is not active');\n    }\n    try {\n      const { secretStorageConnection } = this;\n      const caCryptoCredentials = await secretStorageConnection!!.get(\n        this.getKeyNameWithPrefix(id)\n      );\n\n      if (caCryptoCredentials instanceof Error) {\n        console.error(caCryptoCredentials);\n        return new Error('Failed to read credentials from the storage');\n      }\n      if (!caCryptoCredentials) {\n        return undefined;\n      }\n      return caCryptoCredentials;\n    } catch (err) {\n      console.error(err);\n      return new Error(\n        'Failed to read a credentials for identity from the storage'\n      );\n    }\n    return undefined;\n  }\n\n  protected setCredentialsByIdentity = async (\n    identity: TCentralAuthorityUserIdentity,\n    cryptoKeyPairs: TCACryptoKeyPairs\n  ): Promise<boolean | Error> => {\n    const { isActive } = this;\n\n    if (!isActive) {\n      return new Error('The storage is not active');\n    }\n    try {\n      // parse the identity\n      const caIdentity = new CentralAuthorityIdentity(identity);\n      const cryptoCredentialsExported = await getExportedCryptoCredentialsByCAIdentity(\n        caIdentity,\n        cryptoKeyPairs\n      );\n\n      if (cryptoCredentialsExported instanceof Error) {\n        console.error(cryptoCredentialsExported);\n        return new Error('Failed to export the credentials to a string');\n      }\n\n      const { id } = caIdentity;\n      /**\n       * id - is the unique identity\n       * for the user throughout\n       * the application.\n       * Wich is uniquely identifies\n       * the user with the\n       * identity. Use it as a key\n       * to store the credentials\n       * */\n      if (id instanceof Error) {\n        return new Error(\n          'The identity value is wrong or have an unknown format'\n        );\n      }\n\n      const credentialsStoredForIdentity = await this.getCredentialsRaw(id);\n\n      // if a credentials was already\n      // stored for the identity\n      // do not modify it.\n      // Cause it's value\n      // must be immutable\n      if (\n        credentialsStoredForIdentity &&\n        !(credentialsStoredForIdentity instanceof Error)\n      ) {\n        return false;\n      }\n\n      // if the given values are valid\n      // then can put it to the storage\n      // connected to\n      const { secretStorageConnection } = this;\n\n      return secretStorageConnection!!.set(\n        this.getKeyNameWithPrefix(id),\n        cryptoCredentialsExported\n      );\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to store the credentials');\n    }\n    return true;\n  };\n\n  protected async setCredentialsByCACryptoCredentials(\n    caCryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): Promise<boolean | Error> {\n    const identity = getUserIdentityByCryptoCredentials(caCryptoCredentials);\n\n    if (identity instanceof Error) {\n      console.error(identity);\n      return new Error(\n        'The user identity is not valid or have an unknown format'\n      );\n    }\n\n    const cryptoKeyPairs = getCryptoKeyPairsByCryptoCredentials(\n      caCryptoCredentials\n    );\n\n    if (cryptoKeyPairs instanceof Error) {\n      console.error(cryptoKeyPairs);\n      return new Error(\n        'The crypto key pairs are not valid or have an unknown format'\n      );\n    }\n\n    return this.setCredentialsByIdentity(identity, cryptoKeyPairs);\n  }\n\n  protected async setCredentialsByCACryptoCredentialsExportedToString(\n    caCryptoCredentialsExportedToString: string\n  ): Promise<boolean | Error> {\n    const cryptoCredentials = await importCryptoCredentialsFromAString(\n      caCryptoCredentialsExportedToString\n    );\n\n    if (cryptoCredentials instanceof Error) {\n      console.error(cryptoCredentials);\n      return new Error('Failed to import crypto credentials from the string');\n    }\n    return this.setCredentialsByCACryptoCredentials(cryptoCredentials);\n  }\n\n  public async setCredentials(...args: any[]): Promise<boolean | Error> {\n    const argsLenght = args.length;\n\n    if (argsLenght === 2) {\n      return this.setCredentialsByIdentity(args[0], args[1]);\n    } else if (argsLenght === 1) {\n      const caCryptoCredentials = args[0];\n\n      if (checkIsValidExportedCryptoCredentialsToString(caCryptoCredentials)) {\n        return this.setCredentialsByCACryptoCredentialsExportedToString(\n          caCryptoCredentials\n        );\n      } else if (checkIsValidCryptoCredentials(caCryptoCredentials)) {\n        return this.setCredentialsByCACryptoCredentials(caCryptoCredentials);\n      }\n    }\n    return new Error('An unknown arguments');\n  }\n\n  @caching(CA_IDENTITY_CREDENTIALS_STORAGE_READ_CACHE_CAPACITY)\n  protected async getCredentialsCached(\n    identity: TCentralAuthorityUserIdentity\n  ): Promise<TCentralAuthorityUserCryptoCredentials | Error | null> {\n    try {\n      // parse the identity\n      const caIdentity = new CentralAuthorityIdentity(identity);\n      const { isValid, id } = caIdentity;\n\n      if (!isValid) {\n        return new Error('The identity is not valid');\n      }\n      if (id instanceof Error) {\n        return new Error('Failed to parse the identity and get id');\n      }\n\n      const caCryptoCredentials = await this.getCredentialsRaw(id);\n\n      if (caCryptoCredentials instanceof Error) {\n        console.error(caCryptoCredentials);\n        return new Error('Failed to read credentials from the storage');\n      }\n      if (!caCryptoCredentials) {\n        return null;\n      }\n\n      const importedCryptoCredentials = await importCryptoCredentialsFromAString(\n        caCryptoCredentials\n      );\n\n      if (importedCryptoCredentials instanceof Error) {\n        console.error(importedCryptoCredentials);\n        return new Error('Failed to import the value read');\n      }\n\n      // replace the existing value\n      // of the user identity\n      // by a requested value.\n      // Because the stored identity\n      // version may be different\n      // from the requested. It may\n      // cause an unexpected issues\n      const resultedValue = replaceCryptoCredentialsIdentity(\n        importedCryptoCredentials,\n        identity\n      );\n\n      if (resultedValue instanceof Error) {\n        console.error(resultedValue);\n        return new Error(\n          'Failed to replace the identity in the credentials read from the storage'\n        );\n      }\n      return resultedValue;\n    } catch (err) {\n      console.error(err);\n      return new Error(\n        'Failed to read a credentials for identity from the storage'\n      );\n    }\n  }\n\n  public async getCredentials(\n    identity: TCentralAuthorityUserIdentity\n  ): Promise<TCentralAuthorityUserCryptoCredentials | Error | null> {\n    const { isActive } = this;\n\n    if (!isActive) {\n      return new Error('The storage is not active');\n    }\n    return this.getCredentialsCached(identity);\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-common.ts",["1219","1220","1221","1222"],"import {\n  isCryptoKeyPair,\n  isCryptoKey,\n  isCryptoKeyPairExportedAsString,\n} from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport {\n  TCACryptoKeyPairs,\n  TCACryptoPubilicKeys,\n  TCACryptoKeyPairsExported,\n} from '../../central-authority-class-types/central-authority-class-types';\nimport {\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_STRINGIFIED_MIN_LENGTH,\n} from './central-authority-util-crypto-keys.const';\n\nexport const checkIsCryptoKeyPairsExportedAsString = (v: any): boolean => {\n  return (\n    typeof v === 'string' &&\n    v.length >= CA_CRYPTO_KEY_PAIRS_STRINGIFIED_MIN_LENGTH\n  );\n};\n\n/**\n * check is a given value\n * have a key pairs in a\n * raw format\n * @param keyPairs\n * @returns {boolean}\n */\nexport const checkIsCryptoKeyPairs = (\n  keyPairs: any\n): keyPairs is TCACryptoKeyPairs => {\n  if (keyPairs && typeof keyPairs === 'object') {\n    const {\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signKeyPair,\n    } = keyPairs;\n\n    if (!isCryptoKeyPair(encryptionKeyPair)) {\n      console.error('Encryption key pair is not valid');\n      return false;\n    }\n    if (!isCryptoKeyPair(signKeyPair)) {\n      console.error('Data sign key pair is not valid');\n      return false;\n    }\n    return true;\n  }\n  console.error('A wrong format of the keyPairs');\n  return false;\n};\n\n/**\n * check is a given value\n * have a key pairs in an\n * exported format\n * @param keyPairs\n * @returns {boolean}\n */\nexport const checkIsCryptoKeyPairsExported = (\n  keyPairs: any\n): keyPairs is TCACryptoKeyPairsExported => {\n  if (keyPairs && typeof keyPairs === 'object') {\n    const {\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPairExported,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signKeyPairExported,\n    } = keyPairs;\n\n    if (!isCryptoKeyPairExportedAsString(encryptionKeyPairExported)) {\n      console.error('Encryption key pair exported is not valid');\n      return false;\n    }\n    if (!isCryptoKeyPairExportedAsString(signKeyPairExported)) {\n      console.error('Data sign key pair exported is not valid');\n      return false;\n    }\n    return true;\n  }\n  console.error('A wrong format of the keyPairs exported');\n  return false;\n};\n\nexport const checkIsPublicKeys = (\n  keysPublic: any\n): keysPublic is TCACryptoPubilicKeys => {\n  if (keysPublic && typeof keysPublic === 'object') {\n    if (\n      !isCryptoKey(keysPublic[CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME])\n    ) {\n      console.error('Encryption public key is not valid');\n      return false;\n    }\n    if (!isCryptoKey(keysPublic[CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME])) {\n      console.error('Sign data public key is not valid');\n      return false;\n    }\n    return true;\n  }\n  console.error('A wrong format for the keysPublic');\n  return false;\n};\n\n/**\n * returns only a public keys\n * from a key pairs object\n * @param keyPairs\n * @returns {Error | object}\n */\nexport const getPublicKeysFromCryptoKeyPairs = (\n  keyPairs: TCACryptoKeyPairs\n): TCACryptoPubilicKeys | Error => {\n  if (!checkIsCryptoKeyPairs(keyPairs)) {\n    return new Error('There is a wrong format of the key pairs');\n  }\n\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: dataSignKeyPair,\n  }: TCACryptoKeyPairs = keyPairs;\n  const publicKeys = {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]:\n      encryptionKeyPair.publicKey,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: dataSignKeyPair.publicKey,\n  };\n\n  if (checkIsPublicKeys(publicKeys)) {\n    return publicKeys;\n  }\n  return new Error(\n    'Failed to receive a valid public keys from the encryption key pairs'\n  );\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-export.ts",["1223"],"import {\n  exportKeyPairAsString as exportKeyPairDataEncryptAsString,\n  exportKeyAsString as exportPublicKeyDataEncryptAsString,\n} from 'utils/encryption-utils';\nimport {\n  exportKeyPairAsString as exportKeyPairDataSignAsString,\n  exportKeyAsString as exportPublicKeyDataSignAsString,\n} from 'utils/data-sign-utils';\nimport {\n  TCACryptoKeyPairs,\n  TCACryptoPubilicKeys,\n} from '../../central-authority-class-types/central-authority-class-types';\nimport {\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME,\n} from './central-authority-util-crypto-keys.const';\nimport {\n  checkIsCryptoKeyPairs,\n  getPublicKeysFromCryptoKeyPairs,\n} from './central-authority-util-crypto-keys-common';\nimport { compressString } from 'utils/data-compression-utils/data-compression-utils-strings';\nimport { stringify } from 'utils/main-utils';\n\n/**\n * export two key pairs\n * (data sign and data encryption)\n * as a one string\n * @param {object} cryptoKeyPairs\n * @returns {Promise<string | Error>}\n */\nexport const exportKeyPairsAsString = async (\n  cryptoKeyPairs: TCACryptoKeyPairs\n): Promise<string | Error> => {\n  if (!checkIsCryptoKeyPairs(cryptoKeyPairs)) {\n    return new Error('The keypair is not valid');\n  }\n\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signDataKeyPair,\n  } = cryptoKeyPairs;\n  const [encryptionKeyPairString, signDataKeyPairString] = await Promise.all([\n    exportKeyPairDataEncryptAsString(encryptionKeyPair),\n    exportKeyPairDataSignAsString(signDataKeyPair),\n  ]);\n\n  if (encryptionKeyPairString instanceof Error) {\n    return encryptionKeyPairString;\n  }\n  if (signDataKeyPairString instanceof Error) {\n    return signDataKeyPairString;\n  }\n  try {\n    const stringifyResult = stringify({\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPairString,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signDataKeyPairString,\n    });\n\n    if (stringifyResult instanceof Error) {\n      return stringifyResult;\n    }\n    return compressString(stringifyResult);\n  } catch (err) {\n    return err;\n  }\n};\n\n/**\n * export a public keys only\n * from a keyPairs as a string\n * @param {object} keyPairs\n * @returns {string | Error}\n */\nexport const exportPublicKeysAsString = async (\n  keyPairs: TCACryptoKeyPairs\n): Promise<string | Error> => {\n  const publicKeys = getPublicKeysFromCryptoKeyPairs(keyPairs);\n\n  if (publicKeys instanceof Error) {\n    return publicKeys;\n  }\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]: encryptionPublicKey,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: signPublicKey,\n  } = publicKeys;\n\n  const [\n    encryptionPublicKeyExported,\n    signPublicKeyExported,\n  ] = await Promise.all([\n    exportPublicKeyDataEncryptAsString(encryptionPublicKey),\n    exportPublicKeyDataSignAsString(signPublicKey),\n  ]);\n\n  if (encryptionPublicKeyExported instanceof Error) {\n    console.error('export of the encryptionPublicKey was failed');\n    return encryptionPublicKeyExported;\n  }\n  if (signPublicKeyExported instanceof Error) {\n    console.error('export of the signPublicKeyExported was failed');\n    return signPublicKeyExported;\n  }\n  try {\n    return stringify({\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]: encryptionPublicKeyExported,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: signPublicKeyExported,\n    });\n  } catch (err) {\n    return err;\n  }\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-generate.ts",["1224"],"import { generateKeyPair as generateKeyPairDataEncryption } from 'utils/encryption-utils';\nimport { generateKeyPair as generateKeyPairSignData } from 'utils/data-sign-utils';\nimport { isCryptoKeyPair } from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport {\n  TCACryptoKeyPairs,\n  TCentralAuthorityUserCryptoCredentials,\n} from '../../central-authority-class-types/central-authority-class-types';\nimport {\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME,\n} from './central-authority-util-crypto-keys.const';\nimport { checkIsCryptoKeyPairs } from './central-authority-util-crypto-keys-common';\nimport {\n  CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_USER_ID_KEY_NAME,\n  CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_CRYPTO_KEYS_KEY_NAME,\n} from 'classes/central-authority-class/central-authority-storage/central-authority-storage-credentials/central-authority-storage-credentials.const';\nimport { generateUUID } from 'utils/identity-utils/identity-utils';\nimport {\n  ICAUserUniqueIdentifierMetadata,\n  ICAUserUniqueIdentifierDescriptionWithOptionalVersion,\n} from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { checkIsValidUserIdentityMetadata } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators';\nimport { dataValidatorUtilUUIDV4 } from 'utils/data-validators-utils/data-validators-utils';\nimport { CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport CentralAuthorityIdentity from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\n\n/**\n * generate a key pair, used for data encryption\n */\nexport const generateEncryptKeyPair = async (): Promise<\n  CryptoKeyPair | Error\n> => {\n  const keyPair = await generateKeyPairDataEncryption();\n  const isKeyPair = isCryptoKeyPair(keyPair);\n\n  if (!isKeyPair) {\n    return new Error('Failed to generate a key pair');\n  }\n  return keyPair;\n};\n\n/**\n * generate a key pair, used for data signing\n */\nexport const generateSignKeyPair = async (): Promise<CryptoKeyPair | Error> => {\n  const keyPair = await generateKeyPairSignData();\n  const isKeyPair = isCryptoKeyPair(keyPair);\n\n  if (!isKeyPair) {\n    return new Error('Failed to generate a key pair');\n  }\n  return keyPair;\n};\n\n/**\n * generate a two key pairs\n * one is used to sign a data\n * second is used to encrypt a data\n */\nexport const generateKeyPairs = async (): Promise<\n  TCACryptoKeyPairs | Error\n> => {\n  const [encryptionKeyPair, signDataKeyPair] = await Promise.all([\n    generateEncryptKeyPair(),\n    generateSignKeyPair(),\n  ]);\n\n  if (encryptionKeyPair instanceof Error) {\n    return encryptionKeyPair;\n  }\n  if (signDataKeyPair instanceof Error) {\n    return signDataKeyPair;\n  }\n\n  const keyPairs = {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signDataKeyPair,\n  };\n\n  if (checkIsCryptoKeyPairs(keyPairs)) {\n    return keyPairs;\n  }\n  return new Error('Failed to generate a valid key pairs');\n};\n\n/**\n * generates a random crypto credentials\n * or return an Error if failed\n */\nexport const generateCryptoCredentials = async (): Promise<\n  TCentralAuthorityUserCryptoCredentials | Error\n> => {\n  const cryptoKeyPair = await generateKeyPairs();\n\n  if (cryptoKeyPair instanceof Error) {\n    console.error(cryptoKeyPair);\n    return new Error('Failed to generate a valid crypto credentials');\n  }\n  return {\n    [CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_USER_ID_KEY_NAME]: generateUUID(),\n    [CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPair,\n  };\n};\n\n/**\n * generates a random crypto credentials\n * or return an Error if failed\n */\nexport const generateCryptoCredentialsWithUserIdentity = async (\n  identityMetadata: ICAUserUniqueIdentifierMetadata\n): Promise<TCentralAuthorityUserCryptoCredentials | Error> => {\n  const validationIdentityMetadataResult = checkIsValidUserIdentityMetadata(\n    identityMetadata\n  );\n\n  if (validationIdentityMetadataResult instanceof Error) {\n    console.error(validationIdentityMetadataResult);\n    return new Error('The identity metadata is not valid');\n  }\n\n  const userUUID = generateUUID();\n  const userUniqueIdentityDescription: ICAUserUniqueIdentifierDescriptionWithOptionalVersion = {\n    ...identityMetadata,\n    [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: userUUID,\n  };\n  const userUniqueIdentityInstance = new CentralAuthorityIdentity(\n    userUniqueIdentityDescription\n  );\n\n  if (!userUniqueIdentityInstance.isValid) {\n    return new Error('Failed to generate a valid user unique identity');\n  }\n\n  const userUniqueId = userUniqueIdentityInstance.toString();\n\n  if (!userUniqueId) {\n    return new Error(\n      'Failed to get stringified version of the user unique identity generated'\n    );\n  }\n\n  const cryptoKeyPair = await generateKeyPairs();\n\n  if (cryptoKeyPair instanceof Error) {\n    console.error(cryptoKeyPair);\n    return new Error('Failed to generate a valid crypto credentials');\n  }\n\n  return {\n    [CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_USER_ID_KEY_NAME]: userUniqueId,\n    [CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPair,\n  };\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-import.ts",["1225"],"import {\n  importKeyPairFromString as importKeyPairDataEncryptionFromString,\n  importKeyFromString as importKeyEncryptionFromString,\n} from 'utils/encryption-utils';\nimport {\n  importKeyPairFromString as importKeyPairDataSignFromString,\n  importKeyFromString as importKeySignFromString,\n} from 'utils/data-sign-utils';\nimport {\n  TCACryptoKeyPairs,\n  TCACryptoPubilicKeys,\n} from '../../central-authority-class-types/central-authority-class-types';\nimport {\n  CA_CRYPTO_KEY_PAIRS_STRINGIFIED_MIN_LENGTH,\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_PUBLIC_KEYS_STRINGIFIED_MIN_LENGTH,\n} from './central-authority-util-crypto-keys.const';\nimport { caValidateCryptoKeyPairExportedObject } from '../../central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport {\n  checkIsPublicKeys,\n  checkIsCryptoKeyPairs,\n  checkIsCryptoKeyPairsExportedAsString,\n} from './central-authority-util-crypto-keys-common';\nimport { decompressString } from 'utils/data-compression-utils/data-compression-utils-strings';\n\n/**\n * import an exported key pair\n * and returs it a crypto key pair\n * @param {string} keyPairsString\n * @returns {Promise<Error | object>}\n */\nexport const importKeyPairsFromString = async (\n  keyPairsString: string\n): Promise<TCACryptoKeyPairs | Error> => {\n  if (!checkIsCryptoKeyPairsExportedAsString(keyPairsString)) {\n    return new Error('This is a wrong type of exported crypto keys');\n  }\n\n  let parsedKeyPairsObject;\n\n  const decompressedValue = decompressString(keyPairsString);\n\n  if (decompressedValue instanceof Error) {\n    console.error(decompressedValue);\n    return new Error('Failed to decompress key pairs');\n  }\n\n  try {\n    parsedKeyPairsObject = JSON.parse(decompressedValue);\n  } catch (err) {\n    return err;\n  }\n  if (!caValidateCryptoKeyPairExportedObject(parsedKeyPairsObject)) {\n    return new Error('There is a wrong format of a key pairs exported');\n  }\n\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPairString,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signDataKeyPairString,\n  } = parsedKeyPairsObject;\n  const [encryptionKeyPair, dataSignKeyPair] = await Promise.all([\n    importKeyPairDataEncryptionFromString(encryptionKeyPairString),\n    importKeyPairDataSignFromString(signDataKeyPairString),\n  ]);\n\n  if (encryptionKeyPair instanceof Error) {\n    return encryptionKeyPair;\n  }\n  if (dataSignKeyPair instanceof Error) {\n    return dataSignKeyPair;\n  }\n\n  const encryptionKeyPairs = {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: dataSignKeyPair,\n  };\n\n  if (checkIsCryptoKeyPairs(encryptionKeyPairs)) {\n    return encryptionKeyPairs;\n  }\n  return new Error('Failed to import key pairs');\n};\n\nexport const importPublicKeyPairsFromString = async (\n  publicKeyPairsString: string\n): Promise<Error | TCACryptoPubilicKeys> => {\n  let publicKeyPairsImport;\n  try {\n    publicKeyPairsImport = JSON.parse(publicKeyPairsString);\n  } catch (err) {\n    return err;\n  }\n\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]: importedStringEncryptionPublicKey,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: importedStringSignPublicKey,\n  } = publicKeyPairsImport;\n\n  if (\n    typeof importedStringEncryptionPublicKey !== 'string' ||\n    importedStringEncryptionPublicKey.length <\n      CA_CRYPTO_KEY_PAIRS_PUBLIC_KEYS_STRINGIFIED_MIN_LENGTH\n  ) {\n    const err = new Error(\n      'Encryption public key import as a string was failed'\n    );\n\n    console.error(err);\n    return err;\n  }\n  if (\n    typeof importedStringSignPublicKey !== 'string' ||\n    importedStringSignPublicKey.length <\n      CA_CRYPTO_KEY_PAIRS_PUBLIC_KEYS_STRINGIFIED_MIN_LENGTH\n  ) {\n    const err = new Error('Sign public key import as a string was failed');\n\n    console.error(err);\n    return err;\n  }\n\n  const [\n    importedEncryptionPublicKey,\n    importedSignPublicKey,\n  ] = await Promise.all([\n    importKeyEncryptionFromString(importedStringEncryptionPublicKey),\n    importKeySignFromString(importedStringSignPublicKey),\n  ]);\n\n  if (importedEncryptionPublicKey instanceof Error) {\n    console.error('Failed to import encryption public key from the string');\n    return importedEncryptionPublicKey;\n  }\n  if (importedSignPublicKey instanceof Error) {\n    console.error('Failed to import sign public key from the string');\n    return importedSignPublicKey;\n  }\n\n  const publicKeys = {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]: importedEncryptionPublicKey,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: importedSignPublicKey,\n  };\n\n  if (checkIsPublicKeys(publicKeys)) {\n    return publicKeys;\n  }\n  return new Error('Failed to import a public keys');\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials.ts",["1226","1227"],"import { TCentralAuthorityUserCryptoCredentials } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-credentials';\nimport {\n  checkIsCryptoKeyPairs,\n  exportKeyPairsAsString,\n  importKeyPairsFromString,\n} from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport { validateUserIdentity } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport {\n  CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME,\n  CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME,\n} from 'classes/central-authority-class/central-authority-class-const/central-authority-class-const';\nimport {\n  TCentralAuthorityUserIdentity,\n  TCACryptoKeyPairs,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { CentralAuthorityIdentity } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport {\n  checkIsValidCryptoCredentials,\n  checkIsValidCryptoCredentialsExportedFormat,\n  checkIsValidExportedCryptoCredentialsToString,\n} from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport { stringify } from 'utils/main-utils';\n\nexport const exportCryptoCredentialsToString = async (\n  userCryptoCredentials: TCentralAuthorityUserCryptoCredentials\n): Promise<Error | string> => {\n  if (!checkIsValidCryptoCredentials(userCryptoCredentials)) {\n    return new Error('The given value is not a valid crypto credentials');\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeys,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  } = userCryptoCredentials;\n  const exportedCryptoKeys = await exportKeyPairsAsString(cryptoKeys);\n\n  if (exportedCryptoKeys instanceof Error) {\n    return exportedCryptoKeys;\n  }\n\n  const cryptoCredentialsExported = {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: exportedCryptoKeys,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  };\n\n  if (!checkIsValidCryptoCredentialsExportedFormat(cryptoCredentialsExported)) {\n    return new Error(\n      'Failed to create a crypto credentials in the exported format'\n    );\n  }\n  try {\n    const exportedCryptoCredentialsAsString = stringify(\n      cryptoCredentialsExported\n    );\n\n    if (\n      !checkIsValidExportedCryptoCredentialsToString(\n        exportedCryptoCredentialsAsString\n      )\n    ) {\n      return new Error(\n        'Failed cause the crypto credentials exported as a sting have a wrong format'\n      );\n    }\n    return exportedCryptoCredentialsAsString;\n  } catch (err) {\n    console.error(err);\n    return new Error('Failed to stringify the crypto credentials');\n  }\n};\n\nexport const compareCryptoCredentials = async (\n  ...credentials: TCentralAuthorityUserCryptoCredentials[]\n): Promise<boolean | Error> => {\n  if (!(credentials instanceof Array)) {\n    return new Error('Crdentails to compare must be an array');\n  }\n\n  const exportResult = await exportCryptoCredentialsToString(credentials[0]);\n\n  if (exportResult instanceof Error) {\n    return exportResult;\n  }\n  if (credentials.length === 1) {\n    return true;\n  }\n\n  let idx = 1;\n  const length = credentials.length;\n  let exportCredentialsResult = null;\n\n  for (; idx < length; idx += 1) {\n    exportCredentialsResult = await exportCryptoCredentialsToString(\n      credentials[idx]\n    );\n\n    if (exportCredentialsResult instanceof Error) {\n      console.error(\n        `Failed to export the credentials on index ${idx} === ${credentials[idx]}`\n      );\n      return exportCredentialsResult;\n    }\n    if (exportCredentialsResult !== exportResult) {\n      return new Error(\n        `The credentials on index ${idx} are not equals to the first credentials`\n      );\n    }\n  }\n  return true;\n};\n\nexport const importCryptoCredentialsFromExportedFromat = async (\n  cryptoCredentialsExported: any\n): Promise<Error | TCentralAuthorityUserCryptoCredentials> => {\n  if (!checkIsValidCryptoCredentialsExportedFormat(cryptoCredentialsExported)) {\n    return new Error('The crypto credentials exported have a wrong format');\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeysExported,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentityExported,\n  } = cryptoCredentialsExported;\n  const cryptoKeysImported = await importKeyPairsFromString(cryptoKeysExported);\n\n  if (cryptoKeysImported instanceof Error) {\n    console.error(cryptoKeysImported);\n    return new Error(\n      'Failed to import a crypto key pairs from the given string'\n    );\n  }\n\n  const cryptoCredentials = {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeysImported,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentityExported,\n  };\n\n  if (!checkIsValidCryptoCredentials(cryptoCredentials)) {\n    return new Error(\n      'Failed to return the crypto credentials imorted in the valid format'\n    );\n  }\n  return cryptoCredentials;\n};\n\nexport const importCryptoCredentialsFromAString = async (\n  cryptoCredentialsString: any\n): Promise<Error | TCentralAuthorityUserCryptoCredentials> => {\n  const typeCryptoCredentials = typeof cryptoCredentialsString;\n\n  if (typeCryptoCredentials !== 'string') {\n    return new Error(\n      `The cryptoCredentials value have the wrong type::${typeCryptoCredentials}::`\n    );\n  }\n  if (!checkIsValidExportedCryptoCredentialsToString(cryptoCredentialsString)) {\n    return new Error('The cryptoCredentials value have a wrong format');\n  }\n\n  let cryptoCredentialsExported;\n  try {\n    cryptoCredentialsExported = JSON.parse(cryptoCredentialsString);\n  } catch (err) {\n    console.error(err);\n    return new Error('Failed to parse the given crypto credentials string');\n  }\n  return importCryptoCredentialsFromExportedFromat(cryptoCredentialsExported);\n};\n\nexport const getUserCredentialsByUserIdentityAndCryptoKeys = (\n  userIdentity: TCentralAuthorityUserIdentity,\n  cryptoKeyPairs: TCACryptoKeyPairs\n): Error | TCentralAuthorityUserCryptoCredentials => {\n  if (!validateUserIdentity(userIdentity)) {\n    return new Error('The user identity has a wrong format');\n  }\n  if (!checkIsCryptoKeyPairs(cryptoKeyPairs)) {\n    return new Error('The crypto key pairs has a wrong format');\n  }\n\n  const cryptoCredentials = {\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPairs,\n  };\n\n  if (!checkIsValidCryptoCredentials(cryptoCredentials)) {\n    return new Error('Failed to create a valid crypto credentials');\n  }\n  return cryptoCredentials;\n};\n\nexport const getExportedAsStringCryptoCredentials = async (\n  identity: TCentralAuthorityUserIdentity,\n  cryptoCredentialsKeyPairs: TCACryptoKeyPairs\n): Promise<Error | string> => {\n  try {\n    // parse the identity\n    const caIdentity = new CentralAuthorityIdentity(identity);\n    const { isValid } = caIdentity;\n\n    if (!isValid) {\n      return new Error('The identity is not valid or have an unknown format');\n    }\n    if (!checkIsCryptoKeyPairs(cryptoCredentialsKeyPairs)) {\n      return new Error(\n        'The crypto keys are not valid or have an unknown format'\n      );\n    }\n\n    const caUserCryptoCredentials = getUserCredentialsByUserIdentityAndCryptoKeys(\n      identity,\n      cryptoCredentialsKeyPairs\n    );\n\n    if (caUserCryptoCredentials instanceof Error) {\n      console.error(caUserCryptoCredentials);\n      return new Error('Failed to get User crypto credentials');\n    }\n    return exportCryptoCredentialsToString(caUserCryptoCredentials);\n  } catch (err) {\n    console.error(err);\n    return new Error('Failed to process the credentials or identity');\n  }\n};\n\nexport const getExportedCryptoCredentialsByCAIdentity = async (\n  caIdentity: CentralAuthorityIdentity,\n  cryptoCredentialsKeyPairs: TCACryptoKeyPairs\n): Promise<Error | string> => {\n  if (typeof caIdentity === 'object') {\n    return getExportedAsStringCryptoCredentials(\n      String(caIdentity), // conver it to identity\n      cryptoCredentialsKeyPairs\n    );\n  }\n  return new Error('The identity has a wrong format');\n};\n\nexport const replaceCryptoCredentialsIdentity = (\n  cryptoCredentials: TCentralAuthorityUserCryptoCredentials,\n  identity: TCentralAuthorityUserIdentity\n): Error | TCentralAuthorityUserCryptoCredentials => {\n  if (checkIsValidCryptoCredentials(cryptoCredentials)) {\n    return {\n      ...cryptoCredentials,\n      [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: identity,\n    };\n  }\n  return new Error('The crypto credentials have a wrong format');\n};\n\nexport const getUserIdentityByCryptoCredentials = (\n  cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n): Error | TCentralAuthorityUserIdentity => {\n  if (typeof cryptoCredentials !== 'object') {\n    return new Error('The crypto credentials have an unknown format');\n  }\n\n  const {\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  } = cryptoCredentials;\n\n  if (validateUserIdentity(userIdentity)) {\n    return userIdentity;\n  }\n  return new Error('The user identity is not valid');\n};\n\nexport const getCryptoKeyPairsByCryptoCredentials = (\n  cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n): Error | TCACryptoKeyPairs => {\n  if (typeof cryptoCredentials !== 'object') {\n    return new Error('The crypto credentials have an unknown format');\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPairs,\n  } = cryptoCredentials;\n\n  if (checkIsCryptoKeyPairs(cryptoKeyPairs)) {\n    return cryptoKeyPairs;\n  }\n  return new Error('The crypto key pairs are not valid');\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials.ts",["1228","1229","1230","1231","1232"],"import {\n  CA_USER_IDENTITY_TYPE,\n  CA_USER_IDENTITY_MIN_LENGTH,\n  CA_USER_PASSWORD_MIN_LENGTH,\n  CA_USER_PASSWORD_TYPE,\n  CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME,\n  CA_AUTH_CREDENTIALS_USER_PASSWORD_PROP_NAME,\n  CA_USER_IDENTITY_MAX_LENGTH,\n} from 'classes/central-authority-class/central-authority-class-const/central-authority-class-const';\nimport {\n  TCentralAuthorityUserIdentity,\n  TCentralAuthorityAuthCredentials,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { UTILS_DATA_COMPRESSION_COMPRESSION_RATIO_MAX } from 'utils/data-compression-utils/data-compression-utils.const';\n\nexport const validateUserIdentityType = (v: any): boolean =>\n  typeof v === CA_USER_IDENTITY_TYPE;\n\nexport const validateUserIdentity = (\n  v: any,\n  isSilentMode: boolean = false\n): v is TCentralAuthorityUserIdentity => {\n  if (!validateUserIdentityType(v)) {\n    if (!isSilentMode) {\n      console.error('There is a wrong type of the user identity');\n    }\n    return false;\n  }\n  if (\n    v.length <\n    CA_USER_IDENTITY_MIN_LENGTH / UTILS_DATA_COMPRESSION_COMPRESSION_RATIO_MAX\n  ) {\n    if (!isSilentMode) {\n      console.error('There is a too small length of the user identity');\n    }\n    return false;\n  }\n  if (v.length > CA_USER_IDENTITY_MAX_LENGTH) {\n    if (!isSilentMode) {\n      console.error('There is a too big length of the user identity');\n    }\n    return false;\n  }\n  return true;\n};\n\nexport const validateUserIdentitySilent = (\n  v: any\n): v is TCentralAuthorityUserIdentity => validateUserIdentity(v, true);\n\nexport const validatePassword = (\n  v: any\n): v is TCentralAuthorityUserIdentity => {\n  return (\n    typeof v === CA_USER_PASSWORD_TYPE &&\n    v.length >=\n      CA_USER_PASSWORD_MIN_LENGTH / UTILS_DATA_COMPRESSION_COMPRESSION_RATIO_MAX\n  );\n};\n\nexport const validateAuthCredentials = (\n  v: any\n): v is TCentralAuthorityAuthCredentials => {\n  if (v && typeof v === 'object') {\n    const {\n      [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n      [CA_AUTH_CREDENTIALS_USER_PASSWORD_PROP_NAME]: password,\n    } = v;\n\n    return validatePassword(password) && validateUserIdentity(userIdentity);\n  }\n  return false;\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys-schemas.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys.ts",["1233","1234","1235","1236"],"import { validateBySchema } from 'utils/validation-utils/validation-utils';\nimport { caValidatorsCryptoKeysExportedObjectValidationSchema } from './central-authority-validators-crypto-keys-schemas';\nimport {\n  TCentralAuthorityUserCryptoCredentialsExported,\n  TCentralAuthorityUserCryptoCredentials,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport {\n  CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME,\n  CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME,\n  CA_CREDENTIALS_KEY_CRYPTO_CREDENTIALS_EXPORTED_AS_STRING_MIN_LENGTH,\n} from 'classes/central-authority-class/central-authority-class-const/central-authority-class-const';\nimport { validateUserIdentity } from '../central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport {\n  checkIsCryptoKeyPairs,\n  checkIsCryptoKeyPairsExportedAsString,\n} from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\n\nexport const caValidateCryptoKeyPairExportedObject = (value: any): boolean =>\n  validateBySchema(caValidatorsCryptoKeysExportedObjectValidationSchema, value);\n\n/**\n * validate is a given value has\n * a valid crypto key pair and\n * the user identity\n * in the raw format\n * @param {any} cryptoCredentials\n */\nexport const checkIsValidCryptoCredentials = (\n  cryptoCredentials: any\n): cryptoCredentials is TCentralAuthorityUserCryptoCredentials => {\n  if (!cryptoCredentials || typeof cryptoCredentials !== 'object') {\n    return false;\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeys,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  } = cryptoCredentials;\n\n  if (!cryptoKeys) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case a crypto keys was not found'\n    );\n    return false;\n  }\n  if (!userIdentity) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case a user identity value was not found'\n    );\n    return false;\n  }\n  if (!validateUserIdentity(userIdentity)) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case the user identity value have a wrong type'\n    );\n    return false;\n  }\n  if (!checkIsCryptoKeyPairs(cryptoKeys)) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case the crypto keys value have a wrong type'\n    );\n    return false;\n  }\n  return true;\n};\n\n/**\n * validate is a given value has\n * a valid crypto key pair and\n * the user identity\n * in the exported format\n * @param {any} cryptoCredentials\n */\nexport const checkIsValidCryptoCredentialsExportedFormat = (\n  cryptoCredentials: any\n): cryptoCredentials is TCentralAuthorityUserCryptoCredentialsExported => {\n  if (!cryptoCredentials || typeof cryptoCredentials !== 'object') {\n    return false;\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeys,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  } = cryptoCredentials;\n\n  if (!cryptoKeys) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case a crypto keys was not found'\n    );\n    return false;\n  }\n  if (!userIdentity) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case a user identity value was not found'\n    );\n    return false;\n  }\n  if (!validateUserIdentity(userIdentity)) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case the user identity value have a wrong type'\n    );\n    return false;\n  }\n  if (!checkIsCryptoKeyPairsExportedAsString(cryptoKeys)) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case the crypto keys exported as a string value have a wrong type'\n    );\n    return false;\n  }\n  return true;\n};\n\nexport const checkIsValidExportedCryptoCredentialsToString = (\n  cryptoCredentialsExportedAsString: any\n): boolean => {\n  return (\n    typeof cryptoCredentialsExportedAsString === 'string' &&\n    cryptoCredentialsExportedAsString.length >\n      CA_CREDENTIALS_KEY_CRYPTO_CREDENTIALS_EXPORTED_AS_STRING_MIN_LENGTH\n  );\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user.schemes.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user.ts",["1237"],"import { ICentralAuthorityUserProfile } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { validateBySchema } from 'utils/validation-utils/validation-utils';\nimport { CA_VALIDATORS_USER_PROFILE_SCHEME } from './central-authority-validators-user.schemes';\n\nexport const validateUserProfileData = (\n  profileData: any\n): profileData is ICentralAuthorityUserProfile => {\n  return validateBySchema(CA_VALIDATORS_USER_PROFILE_SCHEME, profileData);\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/channel-authority-class/channel-authority-class.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/channel-authority-class/channel-authority-class.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/channel-authority-class/channel-authority-connections/channel-authority-connection-with-server-api/channel-authority-connection-with-server-api.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/channel-authority-class/channel-authority-connections/channel-authority-connection-with-server-api/channel-authority-connection-with-server-api.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/safe-storage-class/safe-storage-class.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/safe-storage-class/safe-storage-class.ts",["1238","1239","1240","1241","1242","1243","1244","1245","1246"],"import {\n  ISafeStorageOptions,\n  TSafeStorageStoredDataType,\n  TSafeStorageStoredDataTypeKeyValue,\n  TSafeStorageStoredDataTypeAppendLog,\n  TSafeStorageDataTypesAvail,\n  TSafeStorageKeyType,\n  TSafeStorageDataType,\n  TSafeStorageStorageAppendLogDataType,\n} from './safe-storage-class.types';\nimport { DEFAULT_INTERVAL_MS } from 'classes/basic-classes/queue-manager-class-base/queue-manager-class-base.const';\nimport { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';\nimport {\n  SAFE_STORAGE_DUMP_PROVIDER_DEFAULT,\n  ESAFE_STORAGE_PROVIDER_STATUS,\n  SAFE_STORAGE_STORAGE_NAME_COMMON_PREFIX,\n  ESAFE_STORAGE_STORAGE_TYPE,\n  SAFE_STORAGE_MAX_ITEMS_APPEND_LOG,\n  SAFE_STORAGE_KEY_VALUE_INITIAL_VALUE,\n  SAFE_STORAGE_APPEND_LOG_INITIAL_VALUE,\n  SAFE_STORAGE_APPEND_LOG_APPEND_DATA_INITIAL_VALUE,\n  SAFE_STORAGE_KEY_VALUE_APPEND_DATA_INITIAL_VALUE,\n  SAFE_STORAGE_STORAGE_APPEND_LOG_COMMON_POSTFIX,\n  SAFE_STORAGE_ATTEMPTS_TO_SAVE_DATA_TO_STORAGE,\n  SAFE_STORAGE_DEFAULT_STORAGE_BUSY_TIMEOUT_MS,\n} from './safe-storage-class.const';\nimport {\n  getStatusClass,\n  STATUS_EVENT,\n} from 'classes/basic-classes/status-class-base/status-class-base';\n\nexport class SafeStorage<\n  TYPE extends ESAFE_STORAGE_STORAGE_TYPE\n> extends getStatusClass<typeof ESAFE_STORAGE_PROVIDER_STATUS>({\n  errorStatus: ESAFE_STORAGE_PROVIDER_STATUS.ERROR,\n  instanceName: 'SecretStorage',\n}) {\n  static storagesNames: string[] = []; // exists storages names, put it from constructor\n\n  static checkIfNameIsExists(storageName: string) {\n    const { storagesNames } = SafeStorage;\n\n    return storagesNames.includes(storageName);\n  }\n\n  static addStorageName(storageName: string) {\n    const { storagesNames } = SafeStorage;\n\n    storagesNames.push(storageName);\n  }\n\n  protected storageName: string = '';\n\n  protected storageNameAppendLog: string = '';\n\n  protected options?: ISafeStorageOptions;\n\n  protected dumpIntervalMs?: number;\n\n  protected dumpIntervalRunning?: NodeJS.Timeout | number;\n\n  protected secretStorageConnection?: InstanceType<typeof SecretStorage>;\n\n  protected tableData: TSafeStorageStoredDataType<\n    ESAFE_STORAGE_STORAGE_TYPE\n  > = [] as TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG>;\n\n  /**\n   *\n   * this is data which will be merged with the data from storage\n   * and then will be write to the storage\n   * @protected\n   * @type {TSafeStorageStoredDataType<\n   *     ESAFE_STORAGE_STORAGE_TYPE\n   *   >}\n   * @memberof SafeStorage\n   */\n  protected appendData: TSafeStorageStoredDataType<\n    ESAFE_STORAGE_STORAGE_TYPE\n  > = [] as TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG>;\n\n  /**\n   *\n   * here a data will be placed if any dumping of appendData is in progress,\n   * on a dumping will be ended up, data\n   * from this property will be merged with the appendData property\n   * @protected\n   * @type {TSafeStorageStoredDataType<\n   *     ESAFE_STORAGE_STORAGE_TYPE\n   *   >}\n   * @memberof SafeStorage\n   */\n  protected appendDataTemp: TSafeStorageStoredDataType<\n    ESAFE_STORAGE_STORAGE_TYPE\n  > = [] as TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG>;\n\n  protected storageType?: ESAFE_STORAGE_STORAGE_TYPE;\n\n  constructor(options: ISafeStorageOptions) {\n    super();\n\n    const setOptionsResult = this.setOptions(options);\n\n    if (setOptionsResult instanceof Error) {\n      throw setOptionsResult;\n    }\n    this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.NEW);\n    if (options.storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG) {\n      this.appendData = [] as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n      >;\n      this.appendDataTemp = [] as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n      >;\n    } else {\n      this.appendData = {} as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n      >;\n      this.appendDataTemp = {} as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n      >;\n    }\n  }\n\n  get secretStorageOptions() {\n    const { options } = this;\n    const { storageDumpProvider } = options as ISafeStorageOptions;\n\n    return {\n      storageProviderName:\n        storageDumpProvider || SAFE_STORAGE_DUMP_PROVIDER_DEFAULT,\n    };\n  }\n\n  get isStorageBusy(): boolean {\n    const { status } = this;\n\n    return status === ESAFE_STORAGE_PROVIDER_STATUS.WORKING_WITH_STORAGE;\n  }\n\n  /**\n   * connect to the secret storage\n   * and preload a data dumped\n   * from it\n   * @returns {boolean | Error} - true on success, false if connecting is\n   * already in progress, Error if an error has occurred\n   */\n  async connect(): Promise<boolean | Error> {\n    const { status, options } = this;\n\n    if (status !== ESAFE_STORAGE_PROVIDER_STATUS.CONNECTING_TO_STORAGE) {\n      const { credentials } = options as ISafeStorageOptions;\n      const connectionToTheSecretStorage = this.createSecretStorageInstance();\n\n      if (connectionToTheSecretStorage instanceof Error) {\n        return connectionToTheSecretStorage;\n      }\n      this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.CONNECTING_TO_STORAGE);\n\n      const connectionToSecretStorageResult = await connectionToTheSecretStorage.authorize(\n        credentials\n      );\n\n      if (connectionToSecretStorageResult instanceof Error) {\n        return this.setErrorStatus(connectionToSecretStorageResult);\n      }\n      this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.CONNECTED_TO_STORAGE);\n\n      const preloadDataResult = await this.reloadOverallTableData();\n\n      if (preloadDataResult instanceof Error) {\n        return preloadDataResult;\n      }\n\n      const startIntervalResult = this.startInterval();\n\n      if (startIntervalResult instanceof Error) {\n        return this.setErrorStatus(startIntervalResult);\n      }\n      this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.READY);\n      return true;\n    }\n    return false;\n  }\n\n  checkOptionsAreValid(options: ISafeStorageOptions): Error | true {\n    const { name, credentials } = options;\n    const { checkIfNameIsExists } = SafeStorage;\n\n    if (\n      typeof credentials !== 'object' ||\n      !credentials ||\n      !credentials.password\n    ) {\n      return this.setErrorStatus(\n        'SafeStorage: a storage with the name is already exists'\n      );\n    }\n    if (checkIfNameIsExists(name)) {\n      return this.setErrorStatus(\n        'SafeStorage: a storage with the name is already exists'\n      );\n    }\n    return true;\n  }\n\n  setOptions(options: ISafeStorageOptions): Error | true {\n    const { name, dumpIntervalMs, storageType } = options;\n    const checkOptionsResult = this.checkOptionsAreValid(options);\n    const { addStorageName } = SafeStorage;\n    const dumpInterval =\n      typeof dumpIntervalMs === 'number' ? dumpIntervalMs : DEFAULT_INTERVAL_MS;\n    const storageTypeResolved =\n      storageType &&\n      Object.values(ESAFE_STORAGE_STORAGE_TYPE).includes(storageType)\n        ? storageType\n        : ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG;\n\n    if (checkOptionsResult instanceof Error) {\n      return checkOptionsResult;\n    }\n    addStorageName(name);\n    this.options = {\n      ...options,\n      dumpIntervalMs: dumpInterval,\n      storageType: storageTypeResolved,\n    };\n    this.storageType = storageTypeResolved;\n\n    const storageName = `${SAFE_STORAGE_STORAGE_NAME_COMMON_PREFIX}${name}`;\n\n    this.storageName = storageName;\n    this.storageNameAppendLog = `${storageName}${SAFE_STORAGE_STORAGE_APPEND_LOG_COMMON_POSTFIX}`;\n    this.dumpIntervalMs = dumpInterval;\n    return true;\n  }\n\n  /**\n   * load all the data from the secret storage\n   * and put all the data to the memory table\n   */\n  async reloadOverallTableData(): Promise<boolean | Error> {\n    // load data from the storage\n    // and it's append log\n    const tableData = await this.loadOverallTable();\n\n    if (tableData instanceof Error) {\n      return this.setErrorStatus(tableData);\n    }\n    // set all data to the memory table\n    this.setTableData(tableData);\n    return true;\n  }\n\n  /**\n   * disconnect from the secret storage\n   * and dump the data before it\n   */\n  async disconnect(): Promise<Error | true> {\n    const { dumpIntervalRunning } = this;\n\n    if (typeof dumpIntervalRunning === 'number') {\n      clearInterval(dumpIntervalRunning);\n    }\n\n    // dump the data before disconnection\n    const resultDumping = await this.dumpData();\n\n    if (resultDumping === true) {\n      this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.DISCONNECTED);\n      return true;\n    }\n    return this.setErrorStatus(\n      \"Can't dump the table's data before disconnected\"\n    );\n  }\n\n  /**\n   * @returns {boolean} - returns true if the storage is freed\n   * false - on timeout\n   */\n  waitingStorageFreed(): Promise<boolean | undefined> | true {\n    if (!this.isStorageBusy) {\n      return true;\n    }\n\n    return new Promise((res) => {\n      const timeout = setTimeout(\n        res,\n        SAFE_STORAGE_DEFAULT_STORAGE_BUSY_TIMEOUT_MS\n      );\n      const { statusEmitter } = this;\n\n      statusEmitter.once(STATUS_EVENT, () => {\n        if (!this.isStorageBusy) {\n          clearTimeout(timeout);\n          res(true);\n        }\n      });\n    });\n  }\n\n  castDataToAppendLogType(\n    data?: null | TSafeStorageStoredDataType<TYPE>\n  ): TSafeStorageStoredDataTypeAppendLog | Error {\n    if (data == null) {\n      return [] as TSafeStorageStoredDataTypeAppendLog;\n    }\n    if (data instanceof Array) {\n      return data as TSafeStorageStoredDataTypeAppendLog;\n    }\n    return new Error(\n      `There is a wrong data type ${typeof data} for the append log storage`\n    );\n  }\n\n  castDataToKeyValueType(\n    data?: null | TSafeStorageStoredDataType<TYPE>\n  ): TSafeStorageStoredDataTypeKeyValue | Error {\n    if (data == null) {\n      return {} as TSafeStorageStoredDataTypeKeyValue;\n    }\n    if (!(data instanceof Array) && typeof data === 'object') {\n      return data as TSafeStorageStoredDataTypeKeyValue;\n    }\n    return new Error(\n      `There is a wrong data type ${typeof data} for a key value storage`\n    );\n  }\n\n  /**\n   * check if the data given\n   * is conformed to the\n   * storage type and\n   * return an Error if it's\n   * not conformed or data in\n   * storage type\n   * @param data\n   */\n  castDataToStorageType(\n    data?: Error | null | TSafeStorageStoredDataType<TYPE>\n  ): TSafeStorageStoredDataType<TYPE> | Error {\n    if (data instanceof Error) {\n      return data;\n    }\n\n    const { storageType } = this;\n\n    switch (storageType) {\n      case ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG:\n        return this.castDataToAppendLogType(data) as TSafeStorageStoredDataType<\n          TYPE\n        >;\n      default:\n        return this.castDataToKeyValueType(data) as TSafeStorageStoredDataType<\n          TYPE\n        >;\n    }\n  }\n\n  /**\n   * parse a data stringified\n   * before save it to the storage\n   * and read from the secret storage\n   * as a string.\n   * @param {string | Error | undefined} data\n   */\n  parseDataFromStorage<D>(\n    data: string | undefined | Error\n  ): Error | D | undefined {\n    if (data instanceof Error) {\n      return this.setErrorStatus(data);\n    }\n    if (data == null) {\n      return undefined;\n    }\n    try {\n      return JSON.parse(data) as D | undefined;\n    } catch (err) {\n      return err as Error;\n    }\n  }\n\n  /**\n   * merge the data and cast it to the\n   * storage type\n   * returns the merged data\n   * casted to the storage type\n   * @memberof SafeStorage\n   * @param { object | array } result\n   * @param { string | object | array }\n   * @returns { object | array | Error }\n   */\n  mergeData = (\n    result: TSafeStorageStoredDataType<TYPE> | Error,\n    dataToAppend: string | TSafeStorageStoredDataType<TYPE>\n  ): TSafeStorageStoredDataType<TYPE> | Error => {\n    const { storageType } = this;\n    const isAppendLogStorage =\n      storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG;\n\n    if (result instanceof Error) {\n      return result;\n    }\n\n    const dataObj =\n      typeof dataToAppend === 'string'\n        ? this.parseDataFromStorage(dataToAppend)\n        : dataToAppend;\n    const dataCastedToStorageType = this.castDataToStorageType(\n      dataObj as Error | TSafeStorageStoredDataType<TYPE>\n    );\n    if (dataCastedToStorageType instanceof Error) {\n      return this.setErrorStatus(dataCastedToStorageType);\n    }\n    return (isAppendLogStorage\n      ? [\n          ...(result as TSafeStorageStoredDataTypeAppendLog),\n          ...(dataCastedToStorageType as TSafeStorageStoredDataTypeAppendLog),\n        ]\n      : {\n          ...(result as TSafeStorageStoredDataTypeKeyValue),\n          ...(dataCastedToStorageType as TSafeStorageStoredDataTypeKeyValue),\n        }) as TSafeStorageStoredDataType<TYPE>;\n  };\n\n  /**\n   * load a data from the key\n   * named as storage name param\n   * of the secret storage connected\n   * to and return this data\n   * @param {string} storageName\n   */\n  async loadDataFromTable<D>(\n    storageName: string\n  ): Promise<D | undefined | Error> {\n    const { secretStorageConnection } = this;\n\n    if (await this.waitingStorageFreed()) {\n      const setPreviousStatus = this.setStatus(\n        ESAFE_STORAGE_PROVIDER_STATUS.WORKING_WITH_STORAGE\n      );\n      const data = await (secretStorageConnection as SecretStorage).get(\n        storageName\n      );\n\n      setPreviousStatus();\n\n      const parsedDate = this.parseDataFromStorage(data);\n\n      if (parsedDate instanceof Error) {\n        return this.setErrorStatus(parsedDate);\n      }\n      return parsedDate as D | undefined;\n    }\n    return new Error(`The storage is too busy`);\n  }\n\n  /**\n   * load data from append log key\n   * of the secret storage connected to\n   */\n  loadDataFromStorageAppendLog(): Promise<\n    TSafeStorageStorageAppendLogDataType | undefined | Error\n  > {\n    const { storageNameAppendLog } = this;\n\n    return this.loadDataFromTable<TSafeStorageStorageAppendLogDataType>(\n      storageNameAppendLog\n    );\n  }\n\n  /**\n   * load data from the append log key\n   * of the secret storage connected to\n   * parse it as an array of data append\n   * and return in a type of the storage:\n   * 1) array for an APPEND LOG type storage\n   * 2) object for an KEY VALUE type storage\n   */\n  async loadAndParseDataFromAppendLogStorage(): Promise<\n    TSafeStorageStoredDataType<TYPE> | undefined | Error\n  > {\n    const tableAppendlogsArray = await this.loadDataFromStorageAppendLog();\n    if (tableAppendlogsArray instanceof Error) {\n      return tableAppendlogsArray;\n    }\n    if (tableAppendlogsArray == null) {\n      return undefined;\n    }\n    if (tableAppendlogsArray instanceof Array) {\n      return tableAppendlogsArray\n        .map((str) => (typeof str === 'string' ? decodeURIComponent(str) : str))\n        .reduce(\n          this.mergeData,\n          this.castDataToStorageType(undefined) as TSafeStorageStoredDataType<\n            TYPE\n          >\n        );\n    }\n  }\n\n  loadDataFromMainStorage(): Promise<\n    TSafeStorageStoredDataType<TYPE> | undefined | Error\n  > {\n    const { storageName } = this;\n\n    return this.loadDataFromTable<TSafeStorageStoredDataType<TYPE>>(\n      storageName\n    );\n  }\n\n  /**\n   * loads a data from the main storage\n   * and the append log\n   * and merge it\n   */\n  async loadOverallData(): Promise<TSafeStorageStoredDataType<TYPE> | Error> {\n    const storageMainTableData = this.castDataToStorageType(\n      await this.loadDataFromMainStorage()\n    );\n    if (storageMainTableData instanceof Error) {\n      return this.setErrorStatus(storageMainTableData);\n    }\n\n    const storageDataFromAppendLogTable = this.castDataToStorageType(\n      await this.loadAndParseDataFromAppendLogStorage()\n    );\n    if (storageDataFromAppendLogTable instanceof Error) {\n      return this.setErrorStatus(storageDataFromAppendLogTable);\n    }\n    return this.mergeData(storageMainTableData, storageDataFromAppendLogTable);\n  }\n\n  /**\n   * save a data to the secret storage\n   * to the key with name\n   * storageName\n   * @param {string} storageName\n   * @param {string | null | undefined} dataStringified\n   */\n  async saveDataToStorage(\n    storageName: string,\n    dataStringified?: string | null\n  ): Promise<boolean | Error> {\n    const { secretStorageConnection, status } = this;\n\n    if (dataStringified !== null && typeof dataStringified !== 'string') {\n      const err = new Error(\n        `The table overall data must be null or string, but ${typeof dataStringified} was given`\n      );\n\n      console.error(err);\n      return err;\n    }\n\n    let attempt = 0;\n\n    if (await this.waitingStorageFreed()) {\n      const setPrevStatus = this.setStatus(\n        ESAFE_STORAGE_PROVIDER_STATUS.WORKING_WITH_STORAGE\n      );\n\n      while ((attempt += 1) < SAFE_STORAGE_ATTEMPTS_TO_SAVE_DATA_TO_STORAGE) {\n        if (\n          !(\n            (secretStorageConnection as InstanceType<typeof SecretStorage>).set(\n              storageName,\n              dataStringified || ''\n            ) instanceof Error\n          )\n        ) {\n          setPrevStatus();\n          return true;\n        }\n      }\n      setPrevStatus();\n      return new Error(`Can't save the data to the storage ${storageName}`);\n    }\n    return new Error(`The storage is too busy`);\n  }\n\n  /**\n   * stringify data for the\n   * storage\n   * @param dataAppendLog\n   * @returns {Error | string | false} - sating -stringified data, falser - no data, Error - an error has occurred\n   */\n  async stringifyDataForStorage(\n    dataAppendLog: TSafeStorageDataType[] | TSafeStorageStoredDataTypeKeyValue\n  ): Promise<string | null | Error> {\n    if (this.checkIfEmptyData(dataAppendLog)) {\n      return null;\n    }\n\n    try {\n      return JSON.stringify(dataAppendLog);\n    } catch (err) {\n      return this.setErrorStatus(err);\n    }\n  }\n\n  async writeOverallDataToMainTable(\n    data?:\n      | string\n      | null\n      | TSafeStorageDataType[]\n      | TSafeStorageStoredDataTypeKeyValue\n  ): Promise<boolean | Error> {\n    const { storageName } = this;\n    let dataStringified;\n    if (data && typeof data === 'object') {\n      dataStringified = await this.stringifyDataForStorage(data);\n    } else if (data && typeof data === 'string') {\n      dataStringified = data;\n    } else if (data) {\n      return new Error(\n        'Only an object data can be write to the main table key of the secret storage'\n      );\n    }\n    if (dataStringified instanceof Error) {\n      return dataStringified;\n    }\n    return this.saveDataToStorage(storageName, dataStringified);\n  }\n\n  /**\n   * write the data to the secret storage's\n   * key used as append log data for the\n   * main storage key\n   * @param [string[]] [undefined] data\n   */\n  async writeDataToStorageAppengLog(\n    data?: string | null | TSafeStorageStorageAppendLogDataType\n  ): Promise<Error | boolean> {\n    const { storageNameAppendLog } = this;\n    let dataStringified;\n    if (data && data instanceof Array) {\n      dataStringified = await this.stringifyDataForStorage(data);\n    } else if (data && typeof data === 'string') {\n      dataStringified = data;\n    } else if (data) {\n      return new Error(\n        'Only an array data can be write to the append log key of the secret storage'\n      );\n    }\n    if (dataStringified instanceof Error) {\n      return dataStringified;\n    }\n    return this.saveDataToStorage(storageNameAppendLog, dataStringified);\n  }\n\n  async clearAppendLogData(): Promise<boolean | Error> {\n    const { storageNameAppendLog } = this;\n\n    return this.saveDataToStorage(storageNameAppendLog, null);\n  }\n\n  async loadOverallTable(): Promise<TSafeStorageStoredDataType<TYPE> | Error> {\n    /**\n     * read data from the main storage table\n     * and storage append log table\n     * merge it\n     */\n    const overallData = await this.loadOverallData();\n    if (overallData instanceof Error) {\n      return this.setErrorStatus(overallData);\n    }\n\n    /*\n      save data from the main storage and \n      append log storage to the main storage\n      table\n    */\n    const resultSaveDataToMainStorage = await this.writeOverallDataToMainTable(\n      overallData\n    );\n    if (resultSaveDataToMainStorage instanceof Error) {\n      this.setErrorStatus(resultSaveDataToMainStorage);\n      // if an error is occurred while writing\n      // an overall data on the main storage\n      // set an error and return overall data\n      // without clearing the storage append\n      // log table\n      return overallData;\n    }\n\n    const resultClearStorageAppendLogData = await this.clearAppendLogData();\n    if (resultClearStorageAppendLogData instanceof Error) {\n      // if an error occurred while clearing the\n      // storage append log table\n      // return an error occurred as the\n      // result\n      return this.setErrorStatus(resultClearStorageAppendLogData);\n    }\n    return overallData;\n  }\n\n  setTableData(tableData?: TSafeStorageStoredDataType<TYPE>) {\n    const { storageType } = this;\n\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG) {\n      this.tableData = (tableData ||\n        SAFE_STORAGE_APPEND_LOG_INITIAL_VALUE) as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n      >;\n      this.appendData = SAFE_STORAGE_APPEND_LOG_APPEND_DATA_INITIAL_VALUE as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n      >;\n    } else {\n      this.tableData = (tableData ||\n        SAFE_STORAGE_KEY_VALUE_INITIAL_VALUE) as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n      >;\n      this.appendData = SAFE_STORAGE_KEY_VALUE_APPEND_DATA_INITIAL_VALUE as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n      >;\n    }\n  }\n\n  createSecretStorageInstance(): Error | SecretStorage {\n    const { secretStorageOptions } = this;\n    try {\n      const connectionToTheSecretStorage = new SecretStorage(\n        secretStorageOptions\n      );\n\n      this.secretStorageConnection = connectionToTheSecretStorage;\n      return connectionToTheSecretStorage;\n    } catch (err) {\n      return this.setErrorStatus(err);\n    }\n  }\n\n  startInterval(): boolean | Error {\n    const { dumpIntervalMs } = this;\n\n    try {\n      this.dumpIntervalRunning = setInterval(this.dumpData, dumpIntervalMs);\n      return true;\n    } catch (err) {\n      return this.setErrorStatus(err);\n    }\n  }\n\n  checkIfEmptyData(\n    data: TSafeStorageStoredDataType<\n      | ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n      | ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n    >\n  ): boolean {\n    if (data instanceof Array && !data.length) {\n      return true;\n    }\n    if (typeof data === 'object' && !Object.keys(data).length) {\n      return true;\n    }\n    return false;\n  }\n\n  async writeDump(\n    data:\n      | TSafeStorageStoredDataTypeAppendLog\n      | TSafeStorageStoredDataTypeKeyValue\n  ): Promise<Error | boolean> {\n    if (this.checkIfEmptyData(data)) {\n      return true;\n    }\n    let dataStringified: string;\n\n    try {\n      dataStringified = JSON.stringify(data);\n    } catch (err) {\n      return this.setErrorStatus(err);\n    }\n    return this.writeDataToStorageAppengLog(dataStringified);\n  }\n\n  async dumpAllStorageTypes(): Promise<Error | boolean> {\n    const tableOverallDataDump = await this.loadDataFromStorageAppendLog();\n    if (tableOverallDataDump instanceof Error) {\n      return this.setErrorStatus(tableOverallDataDump);\n    }\n\n    const { appendData } = this;\n    const appendDataString = await this.stringifyDataForStorage(appendData);\n    if (appendDataString instanceof Error) {\n      return this.setErrorStatus(appendDataString);\n    }\n    if (\n      tableOverallDataDump != null &&\n      !(tableOverallDataDump instanceof Array)\n    ) {\n      return this.setErrorStatus('A wrong data type was read from storage');\n    }\n\n    const tableOverallData = [\n      ...(tableOverallDataDump || []),\n      appendDataString,\n    ] as TSafeStorageStoredDataTypeAppendLog;\n    return this.writeDump(tableOverallData);\n  }\n\n  async dumpDataAppendLog(): Promise<Error | true> {\n    const writeDumpResult = await this.dumpAllStorageTypes();\n\n    if (writeDumpResult instanceof Error) {\n      const { appendData } = this;\n\n      this.appendData = [\n        ...(appendData as TSafeStorageStoredDataTypeAppendLog),\n        ...(this.appendDataTemp as TSafeStorageStoredDataTypeAppendLog),\n      ];\n      this.appendDataTemp = [];\n      return writeDumpResult;\n    }\n    this.appendData = this.appendDataTemp;\n    this.appendDataTemp = [];\n    return true;\n  }\n\n  async dumpDataKeyValueStorage(): Promise<Error | boolean> {\n    const writeDumpResult = await this.dumpAllStorageTypes();\n\n    if (writeDumpResult instanceof Error) {\n      const { appendData } = this;\n\n      this.appendData = {\n        ...(appendData as TSafeStorageStoredDataType<\n          ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n        >),\n        ...(this.appendDataTemp as TSafeStorageStoredDataType<\n          ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n        >),\n      };\n      this.appendDataTemp = {};\n      return writeDumpResult;\n    }\n    this.appendData = this.appendDataTemp;\n    this.appendDataTemp = {};\n    return true;\n  }\n\n  /**\n   * write the data from the append log\n   * in-memory table to the secret storage\n   * append log table. On error merge data\n   * from in-memory append log and\n   * in-memory temporary append log data,\n   * then clear the in-memory append log data.\n   * On success clear the in-memory\n   * append log data table and copy data\n   * from the temporary append log\n   * to the in-memory append log. And\n   * clear in-memory temporary append log\n   */\n  dumpData = async (): Promise<Error | boolean> => {\n    const { storageType, appendData, status } = this;\n\n    if (this.isStorageBusy) {\n      // if already writing a dump\n      return true;\n    }\n    if (this.checkIfEmptyData(appendData)) {\n      return true;\n    }\n\n    let resultWritingDump;\n\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE) {\n      resultWritingDump = await this.dumpDataKeyValueStorage();\n    } else {\n      resultWritingDump = await this.dumpDataAppendLog();\n    }\n    if (resultWritingDump === true) {\n      // TODO - ??reload all the data from storage\n      // to guarantee the data persistance\n      return true;\n    }\n    return this.setErrorStatus(\n      'An unknown error has occurred while writing the dump of the data to the SecretStorage'\n    );\n  };\n\n  /**\n   * check if too much data in the in-memory\n   * append log storage\n   * If it is, write a data from it\n   * to the secret storage\n   */\n  checkIfMemoryAppendLogOverflow() {\n    const { appendData } = this;\n\n    if (\n      appendData instanceof Array &&\n      appendData.length > SAFE_STORAGE_MAX_ITEMS_APPEND_LOG\n    ) {\n      this.dumpData();\n    }\n  }\n\n  getDataFromAppendLogStorage<D extends TSafeStorageDataTypesAvail>(\n    key: TSafeStorageKeyType\n  ): Error | null | undefined | D {\n    const { tableData } = this;\n    const keyType = typeof key;\n\n    if (keyType !== 'number') {\n      const err = new Error(\n        `For append log storage only a numeric keys are available but ${keyType} type key was given`\n      );\n\n      console.error(err);\n      return err;\n    }\n    return (tableData as TSafeStorageStoredDataTypeAppendLog)[key as number] as\n      | Error\n      | null\n      | undefined\n      | D;\n  }\n\n  getDataFromKeyValueStorage<D extends TSafeStorageDataTypesAvail>(\n    key: TSafeStorageKeyType\n  ): Error | null | undefined | D {\n    const { tableData } = this;\n    const keyType = typeof key;\n\n    if (keyType !== 'string') {\n      const err = new Error(\n        `For append log storage only a string keys are available but ${keyType} type key was given`\n      );\n\n      console.error(err);\n      return err;\n    }\n    return (tableData as TSafeStorageStoredDataTypeKeyValue)[key as string] as\n      | Error\n      | null\n      | undefined\n      | D;\n  }\n\n  /**\n   * get data for the key specified\n   * from the in-memory table\n   * @param key\n   */\n  get<D extends TSafeStorageDataTypesAvail>(\n    key: TSafeStorageKeyType\n  ): Error | undefined | null | D {\n    const { storageType } = this;\n\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG) {\n      return this.getDataFromAppendLogStorage<D>(key);\n    }\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE) {\n      return this.getDataFromKeyValueStorage<D>(key);\n    }\n    const err = new Error('An unknown storage type');\n\n    console.error(err);\n    return err;\n  }\n\n  /**\n   * try to stringify the data\n   * and return true if all is\n   * ok or an Error otherwise\n   * @param data\n   */\n  checkDataIsSafetyForSave(data: any): boolean | Error {\n    try {\n      JSON.stringify(data);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * encode the data to the JSON\n   * format, e.g. Date type\n   * will be normalized to\n   * a stringified date in ISO\n   * @param data\n   */\n  normilizeData(\n    data: TSafeStorageDataTypesAvail | undefined | null\n  ): string | null | undefined {\n    return data != null ? JSON.parse(JSON.stringify(data)) : undefined;\n  }\n\n  async setDataInAppendLogStorage(\n    data: TSafeStorageDataTypesAvail | undefined | null,\n    key?: TSafeStorageKeyType\n  ): Promise<Error | boolean> {\n    if (key && typeof key !== 'number') {\n      const err = new Error(\n        `For append log storage only a numeric keys are available but ${typeof key} type key was given`\n      );\n\n      console.error(err);\n      return err;\n    }\n\n    const { appendData, appendDataTemp, tableData } = this;\n    const tempStorage = this.isStorageBusy ? appendDataTemp : appendData;\n    const stringifiedData = this.normilizeData(data);\n\n    if (!key) {\n      (tempStorage as TSafeStorageStoredDataTypeAppendLog).push(\n        stringifiedData || null\n      );\n      (tableData as TSafeStorageStoredDataTypeAppendLog).push(\n        stringifiedData || null\n      );\n    } else {\n      (tempStorage as TSafeStorageStoredDataTypeAppendLog)[key as number] =\n        stringifiedData || null;\n      (tableData as TSafeStorageStoredDataTypeAppendLog)[key as number] =\n        stringifiedData || null;\n    }\n    return true;\n  }\n\n  /**\n   *\n   * @param data\n   * @param [numbder] key [undefined] - index where\n   * put the data given.\n   * If it's not specified\n   * then set the data given\n   * by the last index\n   */\n  async setDataInKeyValueStorage(\n    data: TSafeStorageDataTypesAvail | undefined | null,\n    key?: TSafeStorageKeyType\n  ): Promise<Error | boolean> {\n    if (typeof key !== 'string') {\n      const err = new Error(\n        `For key value storage only a string keys are available but ${typeof key} type key was given`\n      );\n\n      console.error(err);\n      return err;\n    }\n\n    const { appendData, appendDataTemp, tableData } = this;\n    const tempStorage = this.isStorageBusy ? appendDataTemp : appendData;\n    const stringifiedData = this.normilizeData(data);\n\n    (tableData as TSafeStorageStoredDataTypeKeyValue)[key] =\n      stringifiedData || null;\n    (tempStorage as TSafeStorageStoredDataTypeKeyValue)[key] =\n      stringifiedData || null;\n    return true;\n  }\n\n  /**\n   * set data in the in-memory\n   * table and in-memory append log\n   * table or in-memory temporary\n   * append-log table\n   * if any operations on append log\n   * in-memory table is active.\n   * Also the data set into\n   * the in-memory overall data\n   * table for the key specified\n   * @param data\n   * @param key\n   */\n  async set(\n    data: TSafeStorageDataTypesAvail | undefined | null,\n    key?: TSafeStorageKeyType\n  ): Promise<Error | boolean> {\n    const { storageType } = this;\n\n    const dataSafeResult = this.checkDataIsSafetyForSave(data);\n    if (dataSafeResult instanceof Error) {\n      return dataSafeResult;\n    }\n    this.checkIfMemoryAppendLogOverflow();\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG) {\n      return this.setDataInAppendLogStorage(data, key);\n    }\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE) {\n      return this.setDataInKeyValueStorage(data, key);\n    }\n\n    const err = new Error('An unknown storage type');\n\n    console.error(err);\n    return err;\n  }\n\n  /**\n   * remove a data by fot a key specified\n   */\n  async remove(key: TSafeStorageKeyType) {\n    if (!key) {\n      return new Error('A key must be specified to remove a data from it');\n    }\n    return this.set(null, key);\n  }\n\n  /**\n   * clear the data in the storage\n   */\n  async clear(): Promise<Error | boolean> {\n    this.appendData = this.castDataToStorageType() as TSafeStorageStoredDataType<\n      TYPE\n    >;\n    this.appendDataTemp = this.castDataToStorageType() as TSafeStorageStoredDataType<\n      TYPE\n    >;\n    this.tableData = this.castDataToStorageType() as TSafeStorageStoredDataType<\n      TYPE\n    >;\n    return this.writeDataToStorageAppengLog(null);\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/safe-storage-class/safe-storage-class.types.ts",["1247"],"import {\n  ISecretStoreCredentials,\n  TSecretStoreConfiguration,\n  TSecretStorageProviderName,\n} from 'classes/secret-storage-class/secret-storage-class.types';\nimport {\n  ESAFE_STORAGE_STORAGE_TYPE,\n  ESAFE_STORAGE_PROVIDER_STATUS,\n} from './safe-storage-class.const';\n\nexport type TSafeStorageProviderName = TSecretStorageProviderName;\n\nexport type TSafeStorageStorageAppendLogDataType = string[];\n\nexport type TSafeStorageKeyType = string | number;\n\nexport type TSafeStorageDataType = string | object | number | null;\n\nexport type TSafeStorageStoredDataTypeKeyValue = {\n  [keyName: string]: TSafeStorageDataType;\n};\n\nexport type TSafeStorageStoredDataTypeAppendLog = Array<TSafeStorageDataType>;\n\nexport type TSafeStorageStoredDataType<\n  T extends ESAFE_STORAGE_STORAGE_TYPE\n> = T extends ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n  ? TSafeStorageStoredDataTypeAppendLog\n  : TSafeStorageStoredDataTypeKeyValue;\n\nexport interface ISafeStorageOptions {\n  name: string; // a unique name for the storage\n  credentials: ISecretStoreCredentials; // credentials for access to the secret storage\n  dumpIntervalMs?: number; // how often a dump of a data must be saved in secret storage\n  storageDumpProvider?: TSafeStorageProviderName; // name for the provider where the dumps will be stored\n  storageType?: ESAFE_STORAGE_STORAGE_TYPE; // storage data type\n}\n\nexport type TSafeStorageDataTypesAvail = string | number | object;\n\nexport type TSafeStorageEvents = {\n  status: ESAFE_STORAGE_PROVIDER_STATUS;\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret_storage_providers/secret-storage-level-js-provider/secret-storage-level-js-provider.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret_storage_providers/secret-storage-level-js-provider/secret-storage-level-js-provider.ts",["1248","1249","1250","1251"],"import levelup, { LevelUp } from 'levelup';\nimport leveljs from 'level-js';\nimport encodingDown from 'encoding-down';\nimport {\n  StorageProvider,\n  IStorageProviderOptions,\n} from '../../secret-storage-class.types';\nimport { SECRET_STORAGE_LEVELJS_PROVIDER_DEFAULTS_DB_NAME } from './secret-storage-level-js-provider.const';\n\nexport class SecretStorageProviderLevelJS implements StorageProvider {\n  public static isBufferSupported = true;\n\n  private levelStorage?: LevelUp;\n\n  private dbName: string = SECRET_STORAGE_LEVELJS_PROVIDER_DEFAULTS_DB_NAME;\n\n  private options?: IStorageProviderOptions;\n\n  private isDisconnected: boolean = false;\n\n  public async connect(\n    options?: IStorageProviderOptions\n  ): Promise<true | Error> {\n    try {\n      const { isDisconnected } = this;\n\n      if (isDisconnected) {\n        return new Error(\n          'The instance of the SecretStorageProvider was closed before'\n        );\n      }\n\n      this.setOptions(options);\n\n      const res = await this.createInstanceOfLevelDB();\n\n      if (res instanceof Error) {\n        console.error('SecretStorageProviderLevelJS', res);\n        return res;\n      }\n      return true;\n    } catch (err) {\n      console.error('SecretStorageProviderLevelJS', err);\n      return err;\n    }\n  }\n\n  public async disconnect(): Promise<true | Error> {\n    try {\n      const { levelStorage, isDisconnected } = this;\n\n      if (isDisconnected) {\n        return true;\n      }\n      this.setIsDisconnected();\n      if (levelStorage) {\n        await levelStorage.close();\n\n        return true;\n      }\n    } catch (err) {\n      console.error(err);\n    }\n    return true;\n  }\n\n  /**\n   * WARNING! If the value is empty\n   * it will be removed with the leveljs.del\n   *\n   * @param {string} key\n   * @param {string} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public async set(key: string, value?: string): Promise<Error | true> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n\n      if (!levelStorage) {\n        return new Error('There is no storage connected');\n      }\n      if (!value) {\n        await levelStorage.del(key);\n      } else {\n        await levelStorage.put(key, value);\n      }\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * WARNING! If the value is empty\n   * it will be removed with the leveljs.del\n   *\n   * @param {string} key\n   * @param {string} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public async setUInt8Array(\n    key: string,\n    value?: Uint8Array\n  ): Promise<Error | true> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n\n      if (!levelStorage) {\n        return new Error('There is no storage connected');\n      }\n      if (!value) {\n        await levelStorage.del(key);\n      } else {\n        await levelStorage.put(key, value);\n      }\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async get(key: string): Promise<Error | string | undefined> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n      const item = await levelStorage!.get(key, { asBuffer: false });\n\n      if (typeof item !== 'string') {\n        return undefined;\n      }\n      return item;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async getUInt8Array(\n    key: string\n  ): Promise<Error | Uint8Array | undefined> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n      // TODO - the custom patch used to return\n      // Uint8Array instead of Buffer\n      const item = await levelStorage!.get(key, { asBuffer: true });\n\n      return new Uint8Array(item);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected setOptions(options?: IStorageProviderOptions): void {\n    if (options && typeof options === 'object') {\n      this.options = options;\n\n      const { dbName } = options;\n\n      if (dbName && typeof dbName === 'string') {\n        this.dbName = dbName;\n      }\n    }\n  }\n\n  protected setIsDisconnected() {\n    this.isDisconnected = true;\n  }\n\n  protected checkIsReady(): void | Error {\n    const { isDisconnected, levelStorage } = this;\n\n    if (isDisconnected) {\n      return new Error('The StorageProvider instance is disconnected');\n    }\n    if (!levelStorage) {\n      return new Error('There is no storage connected');\n    }\n  }\n\n  protected async createInstanceOfLevelDB(): Promise<void | Error> {\n    const { dbName } = this;\n    const dbNameRes =\n      dbName || SECRET_STORAGE_LEVELJS_PROVIDER_DEFAULTS_DB_NAME;\n\n    const levelStorage = levelup(leveljs(dbNameRes));\n\n    try {\n      await levelStorage.open();\n    } catch (err) {\n      return err;\n    }\n    this.levelStorage = levelup(leveljs(dbNameRes));\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret_storage_providers/secret-storage-local-forage-provider/secret-storage-local-forage-provider.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret_storage_providers/secret-storage-local-forage-provider/secret-storage-local-forage-provider.ts",["1252","1253","1254","1255"],"import localforage from 'localforage';\nimport {\n  StorageProvider,\n  IStorageProviderOptions,\n} from '../../secret-storage-class.types';\nimport {\n  SECRET_STORAGE_LOCAL_FORAGE_PROVIDER_DEFAULTS_DB_NAME,\n  SECRET_STORAGE_LOCAL_FORAGE_PROVIDER_DRIVER,\n} from './secret-storage-local-forage-provider.const';\n\n/**\n * The main advantage of using the LocalForage provider because\n * it can store a large binary data(such as UInt8Array) as is\n * without an issues caused unsupported encoding\n *\n * @export\n * @class SecretStorageProviderLocalForage\n * @implements {StorageProvider}\n */\nexport class SecretStorageProviderLocalForage implements StorageProvider {\n  public static isBufferSupported = true;\n\n  private localForage?: LocalForage;\n\n  private dbName: string = SECRET_STORAGE_LOCAL_FORAGE_PROVIDER_DEFAULTS_DB_NAME;\n\n  private options?: IStorageProviderOptions;\n\n  private isDisconnected: boolean = false;\n\n  public async connect(\n    options?: IStorageProviderOptions\n  ): Promise<true | Error> {\n    try {\n      const { isDisconnected } = this;\n\n      if (isDisconnected) {\n        return new Error(\n          'The instance of the SecretStorageProvider was closed before'\n        );\n      }\n\n      this.setOptions(options);\n\n      const res = await this.createInstanceOfLocalforage();\n\n      if (res instanceof Error) {\n        console.error('SecretStorageProviderLevelJS', res);\n        return res;\n      }\n      return true;\n    } catch (err) {\n      console.error('SecretStorageProviderLevelJS', err);\n      return err;\n    }\n  }\n\n  public async disconnect(): Promise<true | Error> {\n    try {\n      const { localForage, isDisconnected } = this;\n\n      if (isDisconnected) {\n        return true;\n      }\n      this.setIsDisconnected();\n      if (localForage) {\n        await localForage.ready();\n\n        return true;\n      }\n    } catch (err) {\n      console.error(err);\n    }\n    return true;\n  }\n\n  /**\n   * WARNING! If the value is empty\n   * it will be removed with the leveljs.del\n   *\n   * @param {string} key\n   * @param {string} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public async set(key: string, value?: string): Promise<Error | true> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { localForage: levelStorage } = this;\n\n      if (!levelStorage) {\n        return new Error('There is no storage connected');\n      }\n      if (!value) {\n        await levelStorage.removeItem(key);\n      } else {\n        await levelStorage.setItem(key, value);\n      }\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * WARNING! If the value is empty\n   * it will be removed with the leveljs.del\n   *\n   * @param {string} key\n   * @param {string} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public async setUInt8Array(\n    key: string,\n    value?: Uint8Array\n  ): Promise<Error | true> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { localForage: levelStorage } = this;\n\n      if (!levelStorage) {\n        return new Error('There is no storage connected');\n      }\n      if (!value) {\n        await levelStorage.removeItem(key);\n      } else {\n        await levelStorage.setItem(key, value);\n      }\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async get(key: string): Promise<Error | string | undefined> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { localForage: levelStorage } = this;\n      const item = await levelStorage!.getItem(key);\n\n      if (typeof item !== 'string') {\n        return undefined;\n      }\n      return item;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async getUInt8Array(\n    key: string\n  ): Promise<Error | Uint8Array | undefined> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { localForage: levelStorage } = this;\n      // TODO - the custom patch used to return\n      // Uint8Array instead of Buffer\n      const item = await levelStorage!.getItem(key);\n\n      if (!item) {\n        return undefined;\n      }\n      return new Uint8Array(item as any);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected setOptions(options?: IStorageProviderOptions): void {\n    if (options && typeof options === 'object') {\n      this.options = options;\n\n      const { dbName } = options;\n\n      if (dbName && typeof dbName === 'string') {\n        this.dbName = dbName;\n      }\n    }\n  }\n\n  protected setIsDisconnected() {\n    this.isDisconnected = true;\n  }\n\n  protected checkIsReady(): void | Error {\n    const { isDisconnected, localForage: levelStorage } = this;\n\n    if (isDisconnected) {\n      return new Error('The StorageProvider instance is disconnected');\n    }\n    if (!levelStorage) {\n      return new Error('There is no storage connected');\n    }\n  }\n\n  protected async createInstanceOfLocalforage(): Promise<void | Error> {\n    const { dbName } = this;\n    const dbNameRes =\n      dbName || SECRET_STORAGE_LOCAL_FORAGE_PROVIDER_DEFAULTS_DB_NAME;\n\n    const localForage = localforage.createInstance({\n      name: dbNameRes,\n      storeName: dbNameRes,\n      driver: SECRET_STORAGE_LOCAL_FORAGE_PROVIDER_DRIVER,\n    });\n\n    try {\n      await localForage.ready();\n    } catch (err) {\n      return err;\n    }\n    this.localForage = localForage;\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret_storage_providers/secret-storage-local-storage-provider/secret-storage-local-storage-provider.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret_storage_providers/secret-storage-session-storage-provider/secret-storage-session-storage-provider.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret-storage-class.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret-storage-class.ts",["1256","1257","1258","1259","1260"],"import {\n  TInstanceofStorageProvider,\n  TSecretStoreConfiguration,\n  IStorageProvider,\n  ISecretStoreCredentials,\n  ISecretStorage,\n  ISecretStorageOptions,\n  ISecretStoreCredentialsCryptoKey,\n} from './secret-storage-class.types';\nimport {\n  SECRET_STORAGE_PROVIDERS,\n  SECRET_STORAGE_PROVIDERS_NAME,\n  SECRET_STORAGE_PROVIDERS_NAMES,\n  SECRET_STORAGE_STATUS,\n  SECRET_STORAGE_PASSWORD_MIN_LENGTH,\n} from './secret-storage-class.const';\nimport { ownValueOf, ownKeyOf } from 'types/helper.types';\nimport {\n  importPasswordKey,\n  exportPasswordKeyAsString,\n  importPasswordKeyFromString,\n  generatePasswordKeyByPasswordString,\n} from 'utils/password-utils/derive-key.password-utils';\nimport { TPASSWORD_ENCRYPTION_KEY_IMPORT_NATIVE_SUPPORTED_TYPES } from 'utils/password-utils/password-utils.types';\nimport {\n  decryptDataWithKey,\n  decryptDataWithKeyFromUint8Array,\n} from 'utils/password-utils/decrypt.password-utils';\nimport {\n  encryptDataToString,\n  encryptDataToUInt8Array,\n} from 'utils/password-utils/encrypt.password-utils';\nimport { getStatusClass } from 'classes/basic-classes/status-class-base/status-class-base';\n\nexport class SecretStorage\n  extends getStatusClass<typeof SECRET_STORAGE_STATUS>({\n    errorStatus: SECRET_STORAGE_STATUS.ERROR,\n    instanceName: 'SecretStorage',\n  })\n  implements ISecretStorage {\n  public static validateCredentials(\n    credentials?: ISecretStoreCredentials\n  ): void | Error {\n    if (!credentials) {\n      return new Error('validateCredentials::Credentials must not be empty');\n    }\n    if (typeof credentials !== 'object') {\n      return new Error('validateCredentials::Credentials must be an object');\n    }\n\n    const { password } = credentials;\n\n    if (typeof password !== 'string') {\n      return new Error(\n        'validateCredentials::A password string must be provided to authorize'\n      );\n    }\n    if (!password) {\n      return new Error(\n        'validateCredentials::A password non-empty string must be provided to authorize'\n      );\n    }\n    if (password.length < SECRET_STORAGE_PASSWORD_MIN_LENGTH) {\n      return new Error(\n        `validateCredentials::The password string must be a ${SECRET_STORAGE_PASSWORD_MIN_LENGTH} characters ar least`\n      );\n    }\n  }\n\n  public static validateCryptoKeyCredentials(\n    credentials?: ISecretStoreCredentialsCryptoKey\n  ): void | Error {\n    if (!credentials) {\n      return new Error(\n        'validateCryptoKeyCredentials::Credentials must not be empty'\n      );\n    }\n    if (typeof credentials !== 'object') {\n      return new Error(\n        'validateCryptoKeyCredentials::Credentials must be an object'\n      );\n    }\n\n    const { key } = credentials;\n\n    if (!key) {\n      return new Error(\n        'validateCryptoKeyCredentials::A Key must be provided to authorize'\n      );\n    }\n    if (key instanceof CryptoKey) {\n      return;\n    }\n    return new Error(\n      'validateCryptoKeyCredentials::A Key must be ab instance of CryptoKey'\n    );\n  }\n\n  public static async generatePasswordKeyByPasswordString(\n    password: string\n  ): Promise<CryptoKey | Error> {\n    if (!password) {\n      return new Error();\n    }\n\n    return generatePasswordKeyByPasswordString(password);\n  }\n\n  private static checkIsStorageProviderInstance(\n    storageProviderInstance: any\n  ): Error | boolean {\n    if (\n      !storageProviderInstance ||\n      typeof storageProviderInstance !== 'object'\n    ) {\n      return new Error('Storage provider must be an object');\n    }\n\n    const { connect, get, set, disconnect } = storageProviderInstance;\n\n    if (\n      typeof connect !== 'function' ||\n      typeof get !== 'function' ||\n      typeof set !== 'function' ||\n      typeof disconnect !== 'function'\n    ) {\n      return new Error(\n        'The instance has a wrong implemntation of a StorageProvider interface'\n      );\n    }\n    return true;\n  }\n\n  private static AuthStorageProvider: IStorageProvider =\n    SECRET_STORAGE_PROVIDERS[SECRET_STORAGE_PROVIDERS_NAME.SESSION_STORAGE];\n\n  private static KEY_IN_AUTH_STORAGE = '__SecretStorage__uk';\n\n  private k?: CryptoKey;\n\n  private storageProvider?: TInstanceofStorageProvider;\n\n  /**\n   * check whether the storage provider\n   * is support operations on\n   * UInt8Array values\n   *\n   * @private\n   * @type {boolean}\n   * @memberof SecretStorage\n   */\n  private isStorageProviderSupportUInt8Array: boolean = false;\n\n  private authStorageProvider?: TInstanceofStorageProvider;\n\n  private storageProviderName?: ownValueOf<\n    typeof SECRET_STORAGE_PROVIDERS_NAME\n  >;\n\n  /**\n   * options for the instance\n   *\n   * @private\n   * @type {ISecretStorageOptions}\n   * @memberof SecretStorage\n   */\n  private options?: ISecretStorageOptions;\n\n  /**\n   * name of the database\n   *\n   * @private\n   * @type {string}\n   * @memberof SecretStorage\n   */\n  private dbName?: string;\n\n  /**\n   * returns true if connected succesfully to\n   * a storage and have a vaild crypto key\n   */\n  protected isRunning() {\n    const { status } = this;\n\n    return status === SECRET_STORAGE_STATUS.RUNNING;\n  }\n\n  public get isActive() {\n    return !!this.isRunning();\n  }\n\n  /**\n   * @param {object} configuration\n   * @param {strig} [SECRET_STORAGE_PROVIDERS_NAME.LOCAL_STORAGE] configuration.storageProviderName\n   * - provider name use to store a secret data\n   */\n  constructor(\n    protected configuration: Partial<TSecretStoreConfiguration> = {}\n  ) {\n    super();\n  }\n\n  private setStorageProviderName(\n    storageProviderName: string = SECRET_STORAGE_PROVIDERS_NAME.LOCAL_STORAGE\n  ): boolean {\n    if (SECRET_STORAGE_PROVIDERS_NAMES.includes(storageProviderName)) {\n      this.storageProviderName = storageProviderName;\n      return true;\n    }\n    return false;\n  }\n\n  private createInstanceOfStorageProvider(\n    StorageProviderConstructor: IStorageProvider\n  ): TInstanceofStorageProvider | Error {\n    try {\n      const storageProvider = new StorageProviderConstructor();\n      const checkResult = SecretStorage.checkIsStorageProviderInstance(\n        storageProvider\n      );\n\n      if (checkResult instanceof Error) {\n        return checkResult;\n      }\n      return storageProvider;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  private setSupportForUInt8Array(\n    StorageProviderConstructor: IStorageProvider\n  ): void {\n    this.isStorageProviderSupportUInt8Array = !!StorageProviderConstructor.isBufferSupported;\n  }\n\n  private async runAuthStorageProvider(): Promise<boolean | Error> {\n    const { authStorageProvider: runningAuthStorageProvider } = this;\n    const checkIsRunning = SecretStorage.checkIsStorageProviderInstance(\n      runningAuthStorageProvider\n    );\n\n    /**\n     * if running already\n     */\n    if (checkIsRunning === true) {\n      return true;\n    }\n\n    const { AuthStorageProvider } = SecretStorage;\n\n    if (!AuthStorageProvider) {\n      return new Error('There is no provider for the auth storage is defined');\n    }\n\n    const authStorageProvider = this.createInstanceOfStorageProvider(\n      AuthStorageProvider\n    );\n\n    if (authStorageProvider instanceof Error) {\n      return authStorageProvider;\n    }\n\n    const { dbName } = this;\n    const connectResult = await authStorageProvider.connect({\n      dbName,\n    });\n\n    if (connectResult instanceof Error) {\n      return connectResult;\n    }\n    if (connectResult !== true) {\n      return new Error(\n        'There is a wrong result was returned by auth storage provider'\n      );\n    }\n    this.authStorageProvider = authStorageProvider;\n    return true;\n  }\n\n  protected async runStorageProvider(): Promise<Error | boolean> {\n    const { configuration } = this;\n\n    if (configuration) {\n      const { storageProviderName } = configuration;\n\n      if (this.setStorageProviderName(storageProviderName)) {\n        const { storageProviderName: storageProviderChosenName } = this;\n\n        if (!storageProviderChosenName) {\n          return new Error('There is no storage provider was choosed');\n        }\n\n        const storageProviderConstructor =\n          SECRET_STORAGE_PROVIDERS[storageProviderChosenName];\n\n        this.setSupportForUInt8Array(storageProviderConstructor);\n        if (storageProviderConstructor) {\n          const storageProvider = this.createInstanceOfStorageProvider(\n            storageProviderConstructor\n          );\n\n          if (storageProvider instanceof Error) {\n            return storageProvider;\n          }\n\n          const { dbName } = this;\n          const storageProviderIsRunning = await storageProvider.connect({\n            dbName,\n          });\n\n          if (storageProviderIsRunning instanceof Error) {\n            return storageProviderIsRunning;\n          }\n          this.storageProvider = storageProvider;\n          return true;\n        }\n      }\n      throw new Error('Failed to set the name of the storage provider');\n    }\n    throw new Error('There is no storage provider configuration was defined');\n  }\n\n  protected async setEncryptonKeyAuthInStorage(\n    key: string\n  ): Promise<boolean | Error> {\n    try {\n      const { KEY_IN_AUTH_STORAGE: KEY_IN_SESSION_STORAGE } = SecretStorage;\n      const { authStorageProvider } = this;\n\n      if (!authStorageProvider) {\n        return new Error('There is no an auth storage running');\n      }\n      return authStorageProvider.set(KEY_IN_SESSION_STORAGE, key);\n    } catch (err) {\n      this.setErrorStatus(err);\n      return err;\n    }\n  }\n\n  protected async readEncryptionKeyFomAuthStorage(): Promise<\n    CryptoKey | Error\n  > {\n    try {\n      const { KEY_IN_AUTH_STORAGE: KEY_IN_SESSION_STORAGE } = SecretStorage;\n      const { authStorageProvider } = this;\n\n      if (!authStorageProvider) {\n        return new Error('There is no an auth storage running');\n      }\n\n      const kFromStorage = await authStorageProvider.get(\n        KEY_IN_SESSION_STORAGE\n      );\n\n      if (typeof kFromStorage !== 'string') {\n        return new Error('There is no a valid user secret key was stored');\n      }\n\n      const cryptoKeyImported = await importPasswordKeyFromString(kFromStorage);\n\n      if (!(cryptoKeyImported instanceof CryptoKey)) {\n        return new Error(\"Can't import the key from the storage format\");\n      }\n      return cryptoKeyImported;\n    } catch (err) {\n      this.setErrorStatus(err);\n      return err;\n    }\n  }\n\n  protected async setEncryptionKey(\n    key: TPASSWORD_ENCRYPTION_KEY_IMPORT_NATIVE_SUPPORTED_TYPES | CryptoKey\n  ): Promise<boolean | Error> {\n    let k;\n\n    if (key instanceof CryptoKey) {\n      k = key;\n    } else {\n      const importedKey = await importPasswordKey(key);\n\n      if (importedKey instanceof Error) {\n        return importedKey;\n      }\n    }\n    if (!(k instanceof CryptoKey)) {\n      return new Error('Unknown type of the key');\n    }\n\n    const keyString = await exportPasswordKeyAsString(k);\n\n    if (keyString instanceof Error) {\n      return new Error(\"Can't convert the key to exported format\");\n    }\n\n    const result = await this.setEncryptonKeyAuthInStorage(keyString);\n\n    if (result instanceof Error) {\n      return new Error(\"Can't save the key in storage\");\n    }\n    this.k = k;\n    return true;\n  }\n\n  protected async importCryptoKey(): Promise<boolean | Error> {\n    const { k: cryptoKey } = this;\n\n    // check if already imported\n    if (cryptoKey instanceof CryptoKey) {\n      return true;\n    }\n\n    const importedCryptoKey = await this.readEncryptionKeyFomAuthStorage();\n\n    if (importedCryptoKey instanceof Error) {\n      this.setErrorStatus(importedCryptoKey);\n      return importedCryptoKey;\n    }\n\n    const resultSetImportKey = await this.setEncryptionKey(importedCryptoKey);\n\n    if (resultSetImportKey instanceof Error) {\n      this.setErrorStatus(resultSetImportKey);\n      return resultSetImportKey;\n    }\n    return true;\n  }\n\n  /**\n   * check if a crypto key is already exists\n   * in session storage or a cached in memory\n   */\n  protected async checkIsAuthorized(): Promise<boolean> {\n    const result = await this.importCryptoKey();\n\n    return result === true;\n  }\n\n  protected setOptions(options?: ISecretStorageOptions): void {\n    if (options && typeof options === 'object') {\n      this.options = options;\n\n      const { dbName } = options;\n\n      if (dbName && typeof dbName === 'string') {\n        this.dbName = dbName;\n      }\n    }\n  }\n\n  public async connect(\n    options?: ISecretStorageOptions\n  ): Promise<boolean | Error> {\n    this.clearState();\n    this.setStatus(SECRET_STORAGE_STATUS.CONNECTING);\n    this.setOptions(options);\n\n    const resultRunAuthProvider = await this.runAuthStorageProvider();\n\n    if (resultRunAuthProvider instanceof Error) {\n      this.setErrorStatus(resultRunAuthProvider);\n      return resultRunAuthProvider;\n    }\n\n    const isKeyExists = await this.importCryptoKey();\n\n    if (isKeyExists instanceof Error) {\n      this.setErrorStatus(isKeyExists);\n      return isKeyExists;\n    }\n\n    const isStorageProviderStarted = await this.runStorageProvider();\n\n    if (isStorageProviderStarted instanceof Error) {\n      this.setErrorStatus(isStorageProviderStarted);\n      return isStorageProviderStarted;\n    }\n    this.setStatus(SECRET_STORAGE_STATUS.RUNNING);\n    return true;\n  }\n\n  protected reset() {\n    this.clearError();\n    this.clearStatus();\n    this.clearState();\n    this.k = undefined;\n    this.authStorageProvider = undefined;\n  }\n\n  protected async storageProviderDisconnect(): Promise<boolean | Error> {\n    const { authStorageProvider } = this;\n\n    if (authStorageProvider) {\n      return authStorageProvider.disconnect();\n    }\n    return new Error('There is no Auth storage provider defined');\n  }\n\n  public async disconnect(): Promise<boolean | Error> {\n    const resultDisconnectFromStorageProvider = await this.storageProviderDisconnect();\n\n    if (resultDisconnectFromStorageProvider instanceof Error) {\n      console.error(resultDisconnectFromStorageProvider);\n      return new Error('Failed to disconnect from the storage provider');\n    }\n    this.reset();\n    this.setStatus(SECRET_STORAGE_STATUS.STOPPED);\n    return true;\n  }\n\n  public async authorize(\n    credentials: ISecretStoreCredentials,\n    options?: ISecretStorageOptions\n  ): Promise<boolean | Error> {\n    const credentialsValidationResult = SecretStorage.validateCredentials(\n      credentials\n    );\n\n    if (credentialsValidationResult instanceof Error) {\n      this.setErrorStatus(credentialsValidationResult);\n      return credentialsValidationResult;\n    }\n\n    const cryptoKey = await SecretStorage.generatePasswordKeyByPasswordString(\n      credentials.password\n    );\n\n    if (cryptoKey instanceof Error) {\n      this.setErrorStatus(cryptoKey);\n      return cryptoKey;\n    }\n\n    const resultRunAuthProvider = await this.runAuthStorageProvider();\n\n    if (resultRunAuthProvider instanceof Error) {\n      this.setErrorStatus(resultRunAuthProvider);\n      return resultRunAuthProvider;\n    }\n\n    const setKeyResult = await this.setEncryptionKey(cryptoKey);\n\n    if (setKeyResult instanceof Error) {\n      this.setErrorStatus(setKeyResult);\n      return setKeyResult;\n    }\n    return this.connect(options);\n  }\n\n  public async authorizeByKey(\n    credentials: ISecretStoreCredentialsCryptoKey,\n    options?: ISecretStorageOptions\n  ): Promise<boolean | Error> {\n    const credentialsValidationResult = SecretStorage.validateCryptoKeyCredentials(\n      credentials\n    );\n\n    if (credentialsValidationResult instanceof Error) {\n      this.setErrorStatus(credentialsValidationResult);\n      return credentialsValidationResult;\n    }\n\n    const { key: cryptoKey } = credentials;\n    const resultRunAuthProvider = await this.runAuthStorageProvider();\n\n    if (resultRunAuthProvider instanceof Error) {\n      this.setErrorStatus(resultRunAuthProvider);\n      return resultRunAuthProvider;\n    }\n\n    const setKeyResult = await this.setEncryptionKey(cryptoKey);\n\n    if (setKeyResult instanceof Error) {\n      this.setErrorStatus(setKeyResult);\n      return setKeyResult;\n    }\n    return this.connect(options);\n  }\n\n  protected async getWithStorageProvider(\n    key: string\n  ): Promise<string | Error | undefined> {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error('There is no connection with a storage provider');\n    }\n\n    const value = await storageProvider.get(key);\n\n    if (value instanceof Error) {\n      return SecretStorage.error(value);\n    }\n    if (value === undefined) {\n      return value;\n    }\n    if (typeof value !== 'string' || !value.length) {\n      return SecretStorage.error(\n        'There is a wrong value type returned by the storage provider. A string must be returned'\n      );\n    }\n    return value;\n  }\n\n  protected async getWithStorageProviderUint8Array(\n    key: string\n  ): Promise<Uint8Array | Error | undefined> {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error('There is no connection with a storage provider');\n    }\n\n    if (typeof storageProvider.getUInt8Array !== 'function') {\n      return new Error(\n        'The storage provider which support Uint8Array must provide the method called getUInt8Array'\n      );\n    }\n\n    const value = await storageProvider.getUInt8Array(key);\n\n    if (!value) {\n      return undefined;\n    }\n    if (value instanceof Error) {\n      return SecretStorage.error(value);\n    }\n    if (!(value instanceof Uint8Array) || !value.length) {\n      return SecretStorage.error(\n        'There is a wrong value type returned by the storage provider. An instance of Uint8Array must be returned'\n      );\n    }\n    return value;\n  }\n\n  protected async decryptValue(value: string): Promise<string | Error> {\n    const { k } = this;\n\n    if (!(k instanceof CryptoKey)) {\n      return SecretStorage.error(\n        'There is no a valid key to decrypt the value'\n      );\n    }\n\n    const decryptedValue = await decryptDataWithKey(k, value);\n\n    if (decryptedValue instanceof Error) {\n      return SecretStorage.error(decryptedValue);\n    }\n    if (typeof decryptedValue !== 'string') {\n      return SecretStorage.error('A wrong value decrypted');\n    }\n    return decryptedValue;\n  }\n\n  protected async decryptValueFromUInt8Array(\n    value: Uint8Array\n  ): Promise<string | Error> {\n    const { k } = this;\n\n    if (!(k instanceof CryptoKey)) {\n      return SecretStorage.error(\n        'There is no a valid key to decrypt the value'\n      );\n    }\n    if (!value.length) {\n      return SecretStorage.error('The value must not be empty');\n    }\n\n    const decryptedValue = await decryptDataWithKeyFromUint8Array(k, value);\n\n    if (decryptedValue instanceof Error) {\n      return SecretStorage.error(decryptedValue);\n    }\n    if (typeof decryptedValue !== 'string') {\n      return SecretStorage.error('A wrong value decrypted');\n    }\n    return decryptedValue;\n  }\n\n  public get = async (key: string): Promise<string | Error | undefined> => {\n    const { isRunning } = this;\n\n    if (!isRunning) {\n      return new Error('There is no connection with storage or not authorized');\n    }\n\n    const { isStorageProviderSupportUInt8Array } = this;\n\n    const valueEncrypted = await (isStorageProviderSupportUInt8Array\n      ? this.getWithStorageProviderUint8Array(key)\n      : this.getWithStorageProvider(key));\n\n    if (valueEncrypted === undefined) {\n      return valueEncrypted;\n    }\n    if (valueEncrypted instanceof Error) {\n      return SecretStorage.error(valueEncrypted);\n    }\n\n    const decryptResult = await (valueEncrypted instanceof Uint8Array\n      ? this.decryptValueFromUInt8Array(valueEncrypted)\n      : this.decryptValue(valueEncrypted));\n\n    if (decryptResult instanceof Error) {\n      return decryptResult;\n    }\n    return decryptResult || undefined;\n  };\n\n  protected async setWithStorageProvider(\n    key: string,\n    value: string\n  ): Promise<boolean | Error> {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error(\n        'There is no an active connection with storage provider'\n      );\n    }\n\n    const result = await storageProvider.set(key, value);\n\n    if (result instanceof Error) {\n      return result;\n    }\n    if (result !== true) {\n      return new Error(\n        'A wrong result on set the value into the storage provider'\n      );\n    }\n    return true;\n  }\n\n  protected async setWithStorageProviderUInt8Array(\n    key: string,\n    value: Uint8Array\n  ): Promise<boolean | Error> {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error(\n        'There is no an active connection with storage provider'\n      );\n    }\n    if (typeof storageProvider.setUInt8Array !== 'function') {\n      return new Error(\n        \"The storage provider doesn't have the method setUInt8Array\"\n      );\n    }\n\n    const result = await storageProvider.setUInt8Array(key, value);\n\n    if (result instanceof Error) {\n      return result;\n    }\n    if (result !== true) {\n      return new Error(\n        'A wrong result on set the value into the storage provider'\n      );\n    }\n    return true;\n  }\n\n  protected async encryptValue(value: string): Promise<string | Error> {\n    const { k } = this;\n\n    if (!(k instanceof CryptoKey)) {\n      return new Error('There is no key to encrypt the value');\n    }\n\n    const encryptedValue = await encryptDataToString(k, value);\n\n    if (encryptedValue instanceof Error) {\n      return encryptedValue;\n    }\n    if (typeof encryptedValue !== 'string' || !encryptedValue.length) {\n      return new Error('A wrong encryption result for the value');\n    }\n    return encryptedValue;\n  }\n\n  /**\n   * encrypts string to the UInt8Array\n   *\n   * @protected\n   * @param {string} value\n   * @returns {(Promise<Uint8Array | Error>)}\n   * @memberof SecretStorage\n   */\n  protected async encryptValueAsInt8Array(\n    value: string | Uint8Array\n  ): Promise<Uint8Array | Error> {\n    const { k } = this;\n\n    if (!(k instanceof CryptoKey)) {\n      return new Error('There is no key to encrypt the value');\n    }\n\n    const encryptedValue = await encryptDataToUInt8Array(k, value);\n\n    if (encryptedValue instanceof Error) {\n      return encryptedValue;\n    }\n    if (!(encryptedValue instanceof Uint8Array) || !encryptedValue.length) {\n      return new Error('A wrong encryption result for the value');\n    }\n    return encryptedValue;\n  }\n\n  public async set(key: string, value: string): Promise<boolean | Error> {\n    const { isRunning } = this;\n\n    if (!isRunning) {\n      return SecretStorage.error(\n        'The instance of SecretStorage is not connected to the storage provider or there is no an encryption key'\n      );\n    }\n\n    //value - must be an escaped sctring\n    const encryptedValue = this.isStorageProviderSupportUInt8Array\n      ? await this.encryptValueAsInt8Array(value)\n      : await this.encryptValue(value);\n\n    if (encryptedValue instanceof Error) {\n      return SecretStorage.error(encryptedValue);\n    }\n\n    const storeValueResult = await (encryptedValue instanceof Uint8Array\n      ? this.setWithStorageProviderUInt8Array(key, encryptedValue)\n      : this.setWithStorageProvider(key, encryptedValue));\n\n    if (storeValueResult instanceof Error) {\n      return SecretStorage.error(storeValueResult);\n    }\n    return storeValueResult;\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/secret-storage-class/secret-storage-class.types.ts",["1261"],"import { TPASSWORD_ENCRYPTION_KEY_IMPORT_NATIVE_SUPPORTED_TYPES } from 'utils/password-utils/password-utils.types';\n\nexport interface ISecretStorageOptions {\n  dbName?: string;\n}\n\nexport interface ISecretStorage {\n  // returns true if connected succesfully to\n  // a storage and have a vaild crypto key\n  isActive: boolean;\n  connect(options?: ISecretStorageOptions): Promise<boolean | Error>;\n  // authorize and connect to the storage\n  authorize(\n    credentials: ISecretStoreCredentials,\n    options?: ISecretStorageOptions\n  ): Promise<boolean | Error>;\n  // disconnect from the storage\n  disconnect(): Promise<boolean | Error>;\n  set(key: string, value: string): Promise<boolean | Error>;\n  get(key: string): Promise<string | undefined | Error>;\n}\n\nexport interface IStorageProviderOptions {\n  dbName?: string;\n}\n\nexport abstract class StorageProvider {\n  public abstract connect(\n    options?: IStorageProviderOptions\n  ): Promise<boolean | Error>;\n  public abstract disconnect(): Promise<boolean | Error>;\n  public abstract set(key: string, value: string): Promise<boolean | Error>;\n\n  public abstract setUInt8Array?(\n    key: string,\n    value: Uint8Array\n  ): Promise<boolean | Error>;\n  public abstract get(key: string): Promise<string | undefined | Error>;\n\n  public abstract getUInt8Array?(\n    key: string\n  ): Promise<Uint8Array | undefined | Error>;\n}\n\nexport type TStorageProvider = typeof StorageProvider;\n/**\n * static isBufferSupported {boolean} - whether the class\n * supports operations with the Int8Array\n *\n * @export\n * @interface IStorageProvider\n */\nexport interface IStorageProvider {\n  isBufferSupported?: boolean;\n  new (): StorageProvider;\n}\n\nexport type TInstanceofStorageProvider = InstanceType<IStorageProvider>;\n\nexport type TSecretStorageProviderName = string;\n\nexport interface ILocalStorageProviderTable {\n  [providerName: string]: IStorageProvider;\n}\n\nexport type TSecretStoreConfiguration = {\n  storageProviderName?: string;\n};\n\nexport interface ISecretStoreCredentials {\n  password: string;\n}\n\nexport interface ISecretStoreCredentialsCryptoKey {\n  key: CryptoKey;\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.browser.conf.ts",["1262"],"import Multiaddr from 'multiaddr';\nimport {\n  SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_BOOTSTRAP_MULTIADDRS,\n  SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_API_MULTIADDRS,\n} from './swarm-connection-class-subclass-ipfs.delegate.conf';\nimport { SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_SIGNAL_STAR_MULTIADDRESSES } from './swarm-connection-class-subclass-ipfs.signal-star.conf';\n\nexport enum SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_ROUTERS {\n  FLOODSUB = 'floodsub',\n  GOSSIPPSUB = 'gossipsub',\n}\n\n//https://github.com/ipfs/js-ipfs/blob/master/doc/config.md#api\nexport const SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_FOR_BROWSER_DEFAULT = {\n  Addresses: {\n    // if a dommain used then '/dns4/wrtc-star.discovery.libp2p.io/tcp/443/wss/p2p-webrtc-star'\n    Swarm: [\n      ...SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_SIGNAL_STAR_MULTIADDRESSES,\n      ...SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_BOOTSTRAP_MULTIADDRS,\n    ],\n    API: '',\n    Gateway: '',\n    Delegates: [\n      ...SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_API_MULTIADDRS,\n    ],\n  },\n  Discovery: {\n    MDNS: {\n      Enabled: false,\n      Interval: 10,\n    },\n    webRTCStar: {\n      Enabled: true,\n    },\n  },\n  Bootstrap: [\n    ...SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_BOOTSTRAP_MULTIADDRS,\n  ],\n  Pubsub: {\n    Enabled: true,\n    Router: SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_ROUTERS.GOSSIPPSUB,\n  },\n  Swarm: {\n    ConnMgr: {\n      LowWater: 200,\n      HighWater: 500,\n    },\n  },\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.const.ts",["1263"],"import { SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_FOR_BROWSER_DEFAULT } from './swarm-connection-class-subclass-ipfs.browser.conf';\nimport { getLibPeerToPeer } from './swarm-connection-class-subclass-ipfs.libp2p.conf';\nimport {\n  SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_API_MULTIADDRS,\n  SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_BOOTSTRAP_MULTIADDRS,\n} from './swarm-connection-class-subclass-ipfs.delegate.conf';\n\nexport const SWARM_CONNECTION_SUBCLASS_IPFS_CDN_SCRIPT_URL =\n  'https://cdn.jsdelivr.net/npm/ipfs/dist/index.js';\n\nexport const SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DEFALT = {\n  init: {\n    emptyRepo: true, // TODO - set to false\n    //privateKey TODO - create PeerId instance by the user's public and private keys\n  },\n  start: true,\n  pass: '', // TODO - use the password for it,\n  silent: false, // TODO - set true on production\n  relay: {\n    enabled: true,\n    hop: {\n      enabled: true,\n      active: true,\n    },\n  },\n  preload: {\n    enabled: true,\n    addresses: [\n      ...SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_API_MULTIADDRS,\n    ],\n  },\n  EXPERIMENTAL: {\n    ipnsPubsub: true,\n    sharding: true,\n  },\n  config: SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_FOR_BROWSER_DEFAULT,\n  libp2p: getLibPeerToPeer,\n};\n\nexport const SWARM_CONNECTION_SUBCLASS_IPFS_NODE_START_TIMEOUT = 2000;\n\nexport const SWARM_CONNECTION_SUBCLASS_IPFS_NODE_RECONNECTION_MAX_ATTEMPTS = 3;\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.delegate.conf.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.libp2p.conf.ts",["1264","1265"],"// example https://github.com/ipfs/js-ipfs/blob/master/examples/custom-libp2p/index.js\n// TODO use https://github.com/libp2p/js-libp2p-webrtc-star as transport\n// https://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf\n// TODO - use https://github.com/daviddias/webrtc-explorer\n// about libp2p-secio https://github.com/auditdrivencrypto/secure-channel/blob/master/prior-art.md#ipfss-secure-channel\nimport * as Libp2p from 'libp2p';\nimport * as KadDHT from 'libp2p-kad-dht';\nimport * as WebSocketStar from 'libp2p-websocket-star';\nimport * as SPDY from 'libp2p-spdy';\nimport * as MPLEX from 'pull-mplex';\nimport * as Bootstrap from 'libp2p-bootstrap';\nimport * as SECIO from 'libp2p-secio';\nimport * as WStar from 'libp2p-webrtc-star';\nimport * as PubSubGossip from 'libp2p-gossipsub';\nimport DelegatedPeerRouter from 'libp2p-delegated-peer-routing';\nimport DelegatedContentRouter from 'libp2p-delegated-content-routing';\nimport {\n  SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_API_OPTIONS_HTTP,\n  SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_API_OPTIONS_WS,\n} from './swarm-connection-class-subclass-ipfs.delegate.conf';\n\n// libp2p configuration for browsers\n// https://github.com/ipfs/js-ipfs/blob/master/src/core/runtime/libp2p-browser.js\nexport const getLibPeerToPeer = (opts: any) => {\n  // Set convenience variables to clearly showcase some of the useful things that are available\n  const peerInfo = opts.peerInfo;\n  const peerBook = opts.peerBook;\n  // bootstrap peers in the main configuration\n  const bootstrapList = opts.config.Bootstrap;\n\n  // Create our WebSocketStar transport and give it our PeerId, straight from the ipfs node\n  const wstar = new WStar({\n    id: peerInfo.id,\n  });\n  const wsstar = new WebSocketStar({\n    id: peerInfo.id,\n  });\n  // Content and peer routing\n  // https://github.com/libp2p/js-libp2p/tree/master/examples/peer-and-content-routing\n  // https://github.com/libp2p/js-libp2p/tree/master/examples/delegated-routing\n  const delegatePeerRouter = new DelegatedPeerRouter(\n    SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_API_OPTIONS_HTTP\n  );\n  const delegateContentRouter = new DelegatedContentRouter(\n    peerInfo.id,\n    SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_API_OPTIONS_HTTP\n  );\n  // Websocket connections failed cause CORS policy\n  // const delegatePeerRouterWS = new DelegatedPeerRouter(\n  //   SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_API_OPTIONS_WS\n  // );\n  // const delegateContentRouterWS = new DelegatedContentRouter(\n  //   peerInfo.id,\n  //   SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_API_OPTIONS_WS\n  // );\n\n  console.warn('IPFS delegate node config HTTP');\n  console.warn(SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_API_OPTIONS_HTTP);\n  console.warn('IPFS delegate node config HTTP-WS');\n  console.warn(SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_API_OPTIONS_WS);\n\n  // Build and return our libp2p node\n  return new Libp2p({\n    peerInfo,\n    peerBook,\n    /**\n     *  https://github.com/libp2p/js-libp2p/tree/master/src/switch\n     * bp2p-switch is a dialer machine, it leverages the multiple libp2p transports, stream muxers, crypto channels and other connection upgrades to dial to peers in the libp2p network. It also supports Protocol Multiplexing through a multicodec and multistream-select handshake.\n     * libp2p-switch supports private networking. In order to enabled private networks, the switch.protector must be set and must contain a protect method. \n     * denyTTL: - number of ms a peer should not be dialable to after it errors. Each successive deny will increase the TTL from the base value. Defaults to 5 minutes\n       denyAttempts: - number of times a peer can be denied before they are permanently denied. Defaults to 5.\n       maxParallelDials: - number of concurrent dials the switch should allow. Defaults to 100\n       maxColdCalls: - number of queued cold calls that are allowed. Defaults to 50\n       dialTimeout: - number of ms a dial to a peer should be allowed to run. Defaults to 30000 (30 seconds)\n     * \n     */\n    switch: {\n      denyTTL: 2 * 60 * 1e3, // 2 minute base\n      denyAttempts: 5, // back off 5 times\n      maxParallelDials: 100,\n      maxColdCalls: 25,\n      dialTimeout: 20e3,\n    },\n    // Lets limit the connection managers peers and have it check peer health less frequently\n    connectionManager: {\n      minPeers: 25,\n      maxPeers: 100,\n      pollInterval: 5000,\n    },\n    modules: {\n      transport: [wstar, wsstar],\n      streamMuxer: [MPLEX, SPDY],\n      connEncryption: [SECIO],\n      peerDiscovery: [Bootstrap, wstar.discovery, wsstar.discovery],\n      dht: KadDHT,\n      // https://github.com/libp2p/specs/tree/master/pubsub/gossipsub\n      pubsub: PubSubGossip,\n      contentRouting: [\n        delegateContentRouter,\n        // TODO - CORS failed for websocket // delegateContentRouterWS,\n      ],\n      peerRouting: [\n        delegatePeerRouter,\n        // TODO - CORS failed for websocket // delegatePeerRouterWS,\n      ],\n    },\n    config: {\n      peerDiscovery: {\n        // auto dial to peers we find when we have less peers than `connectionManager.minPeers`\n        autoDial: true,\n        mdns: {\n          interval: 10000,\n          enabled: true,\n        },\n        bootstrap: {\n          interval: 30e3,\n          enabled: true,\n          list: bootstrapList,\n        },\n        webrtcStar: {\n          // webrtc-star options\n          interval: 1000, // ms\n          enabled: true,\n        },\n        webSocketStar: {\n          // webrtc-star options\n          interval: 1000, // ms\n          enabled: true,\n        },\n      },\n      // Turn on relay with hop active so we can connect to more peers\n      // implements the circuit-relay mechanism that allows nodes that\n      // don't speak the same protocol to communicate using a third relay node.\n      // https://github.com/libp2p/js-libp2p-circuit - DEPRECATED, but docs\n      // can be forund on here\n      // https://github.com/libp2p/specs/tree/master/relay\n      /**\n       * The circuit relay is a means to establish connectivity between libp2p nodes (e.g. IPFS nodes) that wouldn't otherwise be able to establish a direct connection to each other.\n       *\n       * Relay is needed in situations where nodes are behind NAT, reverse proxies, firewalls and/or simply don't support the same transports (e.g. go-ipfs vs. browser-ipfs). Even though libp2p has modules for NAT traversal (go-libp2p-nat), piercing through NATs isn't always an option. The circuit relay protocol exists to overcome those scenarios.\n       * Unlike a transparent tunnel, where a libp2p peer would just proxy a communication stream to a destination (the destination being unaware of the original source), a circuit relay makes the destination aware of the original source and the circuit followed to establish communication between the two.\n       */\n      relay: {\n        enabled: true,\n        hop: {\n          enabled: true,\n          active: true,\n        },\n      },\n      /**\n       * Create a new KadDHT.\n       *\n       * @param {Switch} sw libp2p-switch instance\n       * @param {object} options DHT options\n       * @param {number} options.kBucketSize k-bucket size (default 20)\n       * @param {number} options.concurrency alpha concurrency of queries (default 3) limiting the scope of queries to k closest peers\n       * @param {Datastore} options.datastore datastore (default MemoryDatastore)\n       * @param {object} options.validators validators object with namespace as keys and function(key, record, callback)\n       * @param {object} options.selectors selectors object with namespace as keys and function(key, records)\n       * @param {randomWalkOptions} options.randomWalk randomWalk options\n       */\n      /**\n       * Random walk options\n       *\n       * @typedef {Object} randomWalkOptions\n       * @property {boolean} enabled discovery enabled (default: true)\n       * @property {number} queriesPerPeriod how many queries to run per period (default: 1)\n       * @property {number} interval how often to run the the random-walk process, in milliseconds (default: 300000)\n       * @property {number} timeout how long to wait for the the random-walk query to run, in milliseconds (default: 30000)\n       * @property {number} delay how long to wait before starting the first random walk, in milliseconds (default: 10000)\n       */\n      dht: {\n        enabled: true,\n        kBucketSize: 20,\n        concurrency: 5,\n        randomWalk: {\n          queriesPerPeriod: 2,\n          enabled: true,\n          interval: 10e3, // This is set low intentionally, so more peers are discovered quickly. Higher intervals are recommended\n          timeout: 2e3, // End the query quickly since we're running so frequently\n        },\n      },\n      pubsub: {\n        enabled: true,\n        emitSelf: true,\n        signMessages: true,\n        strictSigning: true,\n      },\n    },\n  });\n};\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.signal-star.conf.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.ts",["1266","1267","1268","1269","1270","1271","1272","1273","1274","1275","1276","1277","1278","1279","1280"],"import {\n  ISwarmConnectionSubclass,\n  ESwarmConnectionSubclassStatus,\n  IIPFSSpecificOptions,\n} from 'classes/swarm-connection-class/swarm-connection-class.types';\nimport {\n  SWARM_CONNECTION_SUBCLASS_IPFS_CDN_SCRIPT_URL,\n  SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DEFALT,\n  SWARM_CONNECTION_SUBCLASS_IPFS_NODE_START_TIMEOUT,\n  SWARM_CONNECTION_SUBCLASS_IPFS_NODE_RECONNECTION_MAX_ATTEMPTS,\n} from './swarm-connection-class-subclass-ipfs.const';\nimport { getStatusClass } from 'classes/basic-classes/status-class-base/status-class-base';\nimport { timeout } from 'utils/common-utils/common-utils-timer';\nimport * as Ipfs from 'types/ipfs.types';\n\nexport class SwarmConnectionSubclassIPFS\n  extends getStatusClass<typeof ESwarmConnectionSubclassStatus>({\n    errorStatus: ESwarmConnectionSubclassStatus.ERROR,\n    instanceName: 'SwarmConnectionSubclassIPFS',\n  })\n  implements ISwarmConnectionSubclass {\n  protected IPFS?: any;\n\n  protected options?: IIPFSSpecificOptions;\n\n  protected connection?: Ipfs.IPFS;\n\n  public isClosed: boolean = false;\n\n  protected reconnectionAttempt: number = 0;\n\n  public get isConnected(): boolean {\n    const { isClosed, connection } = this;\n\n    return !isClosed && !!connection && !!connection.isOnline();\n  }\n\n  public getNativeConnection(): Ipfs.IPFS | undefined {\n    return this.connection;\n  }\n\n  public async close(): Promise<boolean | Error> {\n    const { isClosed } = this;\n\n    console.warn('ipfs:close');\n    if (isClosed) {\n      return true;\n    }\n    this.setConnectionClosed();\n    await this.stopCurrentConnection();\n    return true;\n  }\n\n  public async connect(\n    options: IIPFSSpecificOptions\n  ): Promise<boolean | Error> {\n    const { isClosed } = this;\n\n    if (isClosed) {\n      return new Error('The connection was closed previousely');\n    }\n\n    const setOptionsResult = this.setOptions(options);\n\n    if (setOptionsResult instanceof Error) {\n      console.error(setOptionsResult);\n      return this.setErrorStatus('Failed to set the options');\n    }\n\n    const scriptLoadingResult = await this.preloadIpfsModule();\n\n    console.warn('ipfs:connect');\n    if (scriptLoadingResult instanceof Error) {\n      console.error(scriptLoadingResult);\n      return this.setErrorStatus('Failed to preload the IPFS library');\n    }\n\n    const startResult = await this.start();\n\n    if (startResult instanceof Error) {\n      // if failed to start, then try to reconnect\n      const connectionResult = await this.reconnect();\n\n      if (connectionResult instanceof Error) {\n        console.error(connectionResult);\n        return this.setErrorStatus('Failed to connect the first time');\n      }\n    }\n    return true;\n  }\n\n  protected setConnectionClosed() {\n    console.warn('Ipfs connection is closed');\n    this.isClosed = true;\n    this.setStatus(ESwarmConnectionSubclassStatus.CLOSE);\n  }\n\n  protected setOptions(options?: IIPFSSpecificOptions): Error | boolean {\n    if (!options || typeof options.password !== 'string') {\n      return new Error(\n        'An options and a password must be specified to encrypt the provate data'\n      );\n    }\n    this.options = options;\n    return true;\n  }\n\n  protected setIpfsConstructor(IPFS: any) {\n    this.IPFS = IPFS;\n  }\n\n  protected setIpfsConnection(ipfsNode: Ipfs.IPFS) {\n    this.connection = ipfsNode;\n    // unset the listeners for the node,\n    // cause it may be already set\n    this.unsetListeners(ipfsNode);\n    // set listeners for an events\n    // emitted by the IPFS node\n    this.setListeners(ipfsNode);\n  }\n\n  protected unsetCurrentConnection(ipfsNode?: Ipfs.IPFS) {\n    const { connection } = this;\n\n    if (ipfsNode) {\n      if (ipfsNode === connection) {\n        this.connection = undefined;\n      }\n      if (ipfsNode) {\n        this.unsetListeners(ipfsNode);\n      }\n    }\n  }\n\n  protected async preloadIpfsModule(): Promise<Error | boolean> {\n    let ipfsModule: unknown | Error;\n\n    try {\n      ipfsModule = await import('ipfs');\n    } catch (err) {\n      ipfsModule = err as Error;\n    }\n\n    if (ipfsModule instanceof Error) {\n      console.error(\n        `Failed to load the IPFS main script from the source ${SWARM_CONNECTION_SUBCLASS_IPFS_CDN_SCRIPT_URL}`\n      );\n      return ipfsModule;\n    }\n    if (!ipfsModule || typeof (ipfsModule as any).create !== 'function') {\n      return new Error('Failed to load an instance of IPFS');\n    }\n    this.setIpfsConstructor(ipfsModule);\n    return true;\n  }\n\n  protected handleStarted = () => {\n    console.warn('IPFS connection to the swarm was started');\n    this.setStatus(ESwarmConnectionSubclassStatus.STARTED);\n  };\n\n  protected handleError = async (error?: Error) => {\n    if (error) {\n      console.error(\n        'An error has occured with the IPFS swarm connection subclass'\n      );\n      console.error(error);\n    }\n  };\n\n  protected handleInitialized = () => {\n    console.warn('IPFS connection to the swarm was initialized');\n    this.setStatus(ESwarmConnectionSubclassStatus.INITIALIZED);\n  };\n\n  protected handleStop = () => {\n    console.warn('IPFS connection to the swarm was initialized');\n    const { isClosed } = this;\n\n    if (!isClosed) {\n      this.setStatus(ESwarmConnectionSubclassStatus.STOP);\n      this.reconnect();\n    }\n  };\n\n  protected setListeners(\n    connection: Ipfs.IPFS,\n    isSetListeners: boolean = true\n  ) {\n    const methodName = isSetListeners ? 'on' : 'off';\n\n    connection[methodName]('start', this.handleStarted);\n    connection[methodName]('init', this.handleInitialized);\n    connection[methodName]('error', this.handleError);\n    connection[methodName]('stop', this.handleStop);\n  }\n\n  protected unsetListeners = (connection: Ipfs.IPFS) => {\n    this.setListeners(connection, false);\n  };\n\n  protected async createConnection(): Promise<Error | boolean> {\n    console.warn('create a new IPFS connection to the swarm');\n    const { IPFS, options } = this;\n\n    if (IPFS) {\n      const connection: Ipfs.IPFS = await IPFS.create({\n        ...SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DEFALT,\n        pass: options ? options.password : null, // password from options\n      });\n\n      // this is working connection\n      // const connection: Ipfs.IPFS = await IPFS.create({\n      //   \"preload\":\n      //   {\"enabled\":false},\n      //   \"config\":{\"Addresses\":{\"Swarm\":[\"/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star\"]}},\n      //   \"repo\":\"orbit-chat-ipfs-dfffd\",\n      //   \"EXPERIMENTAL\": {\n      //     \"pubsub\":true,\n      //   }}\n      // );\n\n      if (connection instanceof Error) {\n        console.error('Failed to create a new IPFS node');\n        return connection;\n      }\n      this.setIpfsConnection(connection);\n      console.warn('IPFS node config');\n      console.warn(SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DEFALT);\n      return true;\n    }\n    return new Error('Ipfs was not loaded as a dynamic module previousely');\n  }\n\n  protected async startConnection(): Promise<Error | boolean> {\n    const { connection, isClosed } = this;\n\n    if (isClosed) {\n      return new Error('Unable to start connection closed previousely');\n    }\n    if (!connection) {\n      return new Error(\n        'There is no connection to the IPFS, it must be created before start'\n      );\n    }\n    try {\n      await Promise.race([\n        timeout(SWARM_CONNECTION_SUBCLASS_IPFS_NODE_START_TIMEOUT),\n        connection.ready,\n      ]);\n    } catch (err) {\n      console.error(err);\n\n      // if failed to start or a timeout has reached\n      // stop the connection\n      const stopConnectionResult = await this.stopConnection(connection);\n\n      if (stopConnectionResult instanceof Error) {\n        this.setErrorStatus(\n          'Failed to stop the connection during creating a new one'\n        );\n        return stopConnectionResult;\n      }\n      return err;\n    }\n\n    const nodeId = await connection.id();\n\n    if (!nodeId) {\n      return new Error('Failed to start node id connection');\n    }\n    console.warn(`Ipfs node was started as: /n ${nodeId}`);\n    return true;\n  }\n\n  protected async stopConnection(connection: Ipfs.IPFS): Promise<Error | void> {\n    console.warn('Stop the connection');\n    try {\n      connection.stop();\n    } catch (err) {\n      console.error(new Error('Failed to stop the ipfs node'));\n      return err;\n    }\n  }\n\n  async stopCurrentConnection(): Promise<Error | void> {\n    const { connection } = this;\n\n    if (connection) {\n      // if the current connection is exists, then stop it\n      // unset the connection and it's listeners\n      this.unsetCurrentConnection(connection);\n      const connectionStopResult = await this.stopConnection(connection);\n\n      if (connectionStopResult instanceof Error) {\n        console.error(connectionStopResult);\n        return connectionStopResult;\n      }\n    }\n  }\n\n  protected incReconnectionAttempt() {\n    this.reconnectionAttempt += 1;\n    console.warn('ipfs:incReconnectionAttempt');\n  }\n\n  protected resetReconnectionAttempt() {\n    this.reconnectionAttempt = 0;\n    console.warn('ipfs:resetReconnectionAttempt');\n  }\n\n  protected async reconnect(): Promise<Error | boolean> {\n    console.warn('ipfs:reconnect');\n    this.incReconnectionAttempt();\n    if (\n      this.reconnectionAttempt >\n      SWARM_CONNECTION_SUBCLASS_IPFS_NODE_RECONNECTION_MAX_ATTEMPTS\n    ) {\n      await this.close();\n      this.setStatus(ESwarmConnectionSubclassStatus.CONNECTION_FAILED);\n      return new Error('Failed to connect to the SWARM throught the IPFS');\n    }\n\n    const startResult = await this.start();\n\n    if (startResult instanceof Error) {\n      // if failed to start, then try to reconnect once again\n      console.error(startResult);\n      return this.reconnect();\n    }\n    this.resetReconnectionAttempt();\n    return true;\n  }\n\n  protected async start(): Promise<Error | boolean> {\n    const { isClosed } = this;\n\n    console.warn('ipfs:start');\n    if (isClosed) {\n      return new Error(\n        'Unable to connect to the swarm if the connection was closed before'\n      );\n    }\n    this.setStatus(ESwarmConnectionSubclassStatus.CONNECTING);\n\n    // stop the current connection if exists\n    const stopConnectionResult = await this.stopCurrentConnection();\n\n    if (stopConnectionResult instanceof Error) {\n      this.setErrorStatus('Failed to stop the previous connection');\n    }\n\n    // create a new connection to the ipfs\n    const createConnectionResult = await this.createConnection();\n\n    if (createConnectionResult instanceof Error) {\n      this.setErrorStatus(createConnectionResult);\n      return new Error('Failed to create a new connection');\n    }\n\n    const startConnectionResult = await this.startConnection();\n\n    if (startConnectionResult instanceof Error) {\n      this.setErrorStatus(startConnectionResult);\n      return new Error('Failed to start the connection');\n    }\n    // if started succesfully\n    // then set the status that the node\n    // was started succesfully\n    this.setStatus(ESwarmConnectionSubclassStatus.CONNECTED);\n    return true;\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-bootstrap.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-delegated-content-routing.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-delegated-peer-routing.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-gossipsub.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-kad-dht.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-secio.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-spdy.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-webrtc-star.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p-websocket-star.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/libp2p.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/multiaddr.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/types/pull-mplex.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class.ts",["1281","1282","1283","1284","1285","1286"],"import {\n  ISwarmConnection,\n  ISwarmConnectionSubclass,\n  ESwarmConnectionClassStatus,\n  ISwarmConnectionOptions,\n  ESwarmConnectionClassSubclassType,\n  TSwarmConnectionSubclassSpecificOptions,\n  ESwarmConnectionSubclassStatus,\n} from './swarm-connection-class.types';\nimport { SwarmConnectionSubclassIPFS } from './swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs';\nimport { getStatusClass } from 'classes/basic-classes/status-class-base/status-class-base';\nimport { STATUS_CLASS_STATUS_CHANGE_EVENT } from 'classes/basic-classes/status-class-base/status-class-base.const';\nimport * as Ipfs from 'types/ipfs.types';\n\nexport class SwarmConnection\n  extends getStatusClass<typeof ESwarmConnectionClassStatus>({\n    errorStatus: ESwarmConnectionClassStatus.ERROR,\n    instanceName: 'SwarmConnection',\n  })\n  implements ISwarmConnection {\n  public get isClosed(): boolean {\n    const { connection } = this;\n\n    if (connection) {\n      return !!connection.isClosed;\n    }\n    return this.status === ESwarmConnectionSubclassStatus.CLOSE;\n  }\n\n  public get isConnected() {\n    const { connection } = this;\n\n    if (connection) {\n      return !!connection.isConnected;\n    }\n    return false;\n  }\n\n  public get connectionType(): ESwarmConnectionClassSubclassType | void {\n    const { options } = this;\n\n    if (options) {\n      const { type } = options;\n\n      return type;\n    }\n  }\n\n  public getNativeConnection(): Ipfs.IPFS | undefined {\n    if (this.connection) {\n      return this.connection.getNativeConnection();\n    }\n    return undefined;\n  }\n\n  private connection?: ISwarmConnectionSubclass;\n\n  private options?: ISwarmConnectionOptions;\n\n  public async connect(\n    options: ISwarmConnectionOptions\n  ): Promise<boolean | Error> {\n    const { isClosed } = this;\n\n    if (isClosed) {\n      return new Error(\n        'Failed to start the connetion which was closed perviouselly'\n      );\n    }\n\n    this.setOptions(options);\n    this.setStatus(ESwarmConnectionClassStatus.CONNECTING);\n\n    const createConnectionInstanceResult = this.createConnectionInstance();\n\n    if (createConnectionInstanceResult instanceof Error) {\n      this.setErrorStatus(createConnectionInstanceResult);\n      return new Error(\n        'Failed to create the instance of the connection with swarm subclass'\n      );\n    }\n\n    const connectionResult = await this.startConnection();\n\n    if (connectionResult instanceof Error) {\n      this.setErrorStatus(connectionResult);\n      return connectionResult;\n    }\n    return true;\n  }\n\n  public async close(): Promise<Error | boolean> {\n    const { connection, isClosed } = this;\n\n    if (isClosed) {\n      return new Error('The connection was closed previousely');\n    }\n    this.setStatus(ESwarmConnectionClassStatus.CLOSE);\n    this.unsetConnectionSubClassInstance(connection);\n    if (connection) {\n      const subclassConnectionCloseResult = await connection.close();\n\n      if (subclassConnectionCloseResult instanceof Error) {\n        console.error(subclassConnectionCloseResult);\n        return this.setErrorStatus('Failed to close the sub connection');\n      }\n    }\n    return true;\n  }\n\n  /**\n   *\n   * returns options specific for the subclass connection\n   * @private\n   * @returns {(TSwarmConnectionSubclassSpecificOptions | void)}\n   * @memberof SwarmConnection\n   */\n  private getSubclassSpecificOptions(): TSwarmConnectionSubclassSpecificOptions | void {\n    const { options } = this;\n\n    if (options && typeof options === 'object') {\n      const { subclassOptions } = options;\n\n      return subclassOptions ? subclassOptions : undefined;\n    }\n  }\n\n  private setOptions(options: ISwarmConnectionOptions) {\n    this.options = options;\n  }\n\n  private setConnectionStatusListener(\n    connection: ISwarmConnectionSubclass,\n    isSet = true\n  ) {\n    const { statusEmitter } = connection;\n\n    statusEmitter[isSet ? 'addListener' : 'removeListener'](\n      STATUS_CLASS_STATUS_CHANGE_EVENT,\n      this.setStatus\n    );\n  }\n\n  private unsetConnectionStatusListener(connection: ISwarmConnectionSubclass) {\n    this.setConnectionStatusListener(connection, false);\n  }\n\n  private setConnectionSubClassInstance(connection: ISwarmConnectionSubclass) {\n    this.connection = connection;\n    this.setConnectionStatusListener(connection);\n  }\n\n  private unsetConnectionSubClassInstance(\n    connection?: ISwarmConnectionSubclass\n  ) {\n    if (connection === this.connection) {\n      this.connection = undefined;\n    }\n    if (connection) {\n      this.unsetConnectionStatusListener(connection);\n    }\n  }\n\n  private createConnectionToIPFS(): boolean | Error {\n    try {\n      const connectionToIPFS = new SwarmConnectionSubclassIPFS();\n\n      this.setConnectionSubClassInstance(connectionToIPFS);\n      return true;\n    } catch (err) {\n      console.error(err);\n      return new Error(\n        'Failed to create an instance of IPFS connection to swarm'\n      );\n    }\n  }\n\n  private createConnectionInstance(): boolean | Error {\n    const { connectionType: type } = this;\n\n    if (type === ESwarmConnectionClassSubclassType.IPFS) {\n      return this.createConnectionToIPFS();\n    }\n    return new Error('An unknown connection subclass type provided in options');\n  }\n\n  private async startConnection(): Promise<boolean | Error> {\n    const { connection, connectionType } = this;\n\n    if (!connection || typeof connection.connect !== 'function') {\n      return new Error('There is no connection');\n    }\n\n    const subclassSpecificOptions = this.getSubclassSpecificOptions();\n    const result = await connection.connect(subclassSpecificOptions);\n\n    if (result instanceof Error) {\n      console.error(\n        `Failed to start connection to the swarm ${connectionType}`\n      );\n      return result;\n    }\n    return result;\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-connection-class/swarm-connection-class.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-raw-constructor/swarm-message-subclass-raw-constructor.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-raw-constructor/swarm-message-subclass-raw-constructor.ts",["1287","1288"],"import { ISwarmMessageSubclassRawConstructorOptions } from './swarm-message-subclass-raw-constructor.types';\n\nexport class SwarmMessageSubclassRawConstructor {\n  constructor(options: ISwarmMessageSubclassRawConstructorOptions) {}\n\n  protected validateOptions(\n    options: ISwarmMessageSubclassRawConstructorOptions\n  ): Error | boolean {\n    if (!options) {\n      return new Error('An options must be provided');\n    }\n    if (typeof options !== 'object') {\n      return new Error('The options must be an object');\n    }\n\n    // const {\n    //     typ: string | number;\n    //     pld: string | Buffer;\n    //     uid: string;\n    //     iss: string;\n    //     k: CryptoKey;\n    // } = options;\n\n    // if (!typ) {\n    //     return new Error();\n    // }\n    return true;\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-raw-constructor/swarm-message-subclass-raw-constructor.types.ts",["1289"],"import CentralAuthorityIdentity from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport {\n  TCentralAuthorityUserCryptoCredentials,\n  TCentralAuthorityUserIdentity,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { ICAUserUniqueIdentifierDescriptionWithOptionalVersion } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types';\n\n/**\n * @property { string | number } typ - type of the message\n * @property { string | Buffer } pld - payload of the message\n * @property { string | CentralAuthorityIdentity } uid - the user identifier\n * @property { string } iss - the issuer service\n * @property { CryptoKey } k - the crypto key used to sign the data\n *\n * @export\n * @interface ISwarmMessageSubclassRawConstructorOptions\n */\nexport interface ISwarmMessageSubclassRawConstructorOptions {\n  typ: string | number;\n  pld: string | Buffer;\n  uid:\n    | TCentralAuthorityUserCryptoCredentials\n    | TCentralAuthorityUserIdentity\n    | ICAUserUniqueIdentifierDescriptionWithOptionalVersion;\n  iss: string;\n  k: CryptoKey;\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validator/swarm-message-subclass-validator.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validator/swarm-message-subclass-validator.ts",["1290"],"import CentralAuthorityIdentity from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport {\n  TCentralAuthorityUserCryptoCredentials,\n  TCentralAuthorityUserIdentity,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { ICAUserUniqueIdentifierDescriptionWithOptionalVersion } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport {\n  commonUtilsArrayDeleteFromArray,\n  commonUtilsArrayDoCallbackTillNoError,\n  commonUtilsArrayCalculateLengthOfIntegerArray,\n} from 'utils/common-utils/common-utils';\nimport {\n  TType,\n  IMessageValidatorOptions,\n  TPayload,\n} from './swarm-message-subclass-validator.types';\nimport {\n  SWARM_MESSAGE_SUBCLASS_VALIDATOR_PAYLOAD_MAX_LENGTH_BYTES,\n  SWARM_MESSAGE_SUBCLASS_VALIDATOR_PAYLOAD_MIN_LENGTH_BYTES,\n} from './swarm-message-subclass-validator.const';\n\nexport class SwarmMessageSubclassValidator {\n  /**\n   * list of a valid issuers.\n   * If it is empty then any issuer will\n   * be considered correct.\n   *\n   * @protected\n   * @static\n   * @type {string[]}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected issuersList: string[] = [];\n\n  /**\n   * list of a valid message types.\n   * If it is empty then any type will\n   * be considered correct.\n   *\n   * @protected\n   * @static\n   * @type {Array<string | number>}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected typesList: Array<string | number> = [];\n\n  /**\n   * the maximum lenght for a payload value\n   *\n   * @protected\n   * @type {number}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected payloadMaxLength: number = SWARM_MESSAGE_SUBCLASS_VALIDATOR_PAYLOAD_MAX_LENGTH_BYTES;\n\n  /**\n   * the minimum length for a payload values\n   *\n   * @protected\n   * @type {number}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected payloadMinLength: number = SWARM_MESSAGE_SUBCLASS_VALIDATOR_PAYLOAD_MIN_LENGTH_BYTES;\n\n  /**\n   * time to life of a message, the message will be invalidated if the\n   * message timestamp is not in the interval within the timestamp. If not defined or se to 0 means infinite\n   * time to live. Time to live in seconds\n   *\n   * @protected\n   * @type {number}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected ttlSeconds?: number;\n\n  /**\n   * Creates an instance of SwarmMessageSubclassValidator.\n   * @param {IMessageValidatorOptions} options\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  constructor(options: IMessageValidatorOptions) {\n    this.setOptions(options);\n  }\n\n  /**\n   * validates the Issuer type and length\n   *\n   * @param {string} issuer\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public validateIssuerFormat(issuer: string): boolean | Error {\n    if (!issuer) {\n      return new Error('The issuer must be defined');\n    }\n    if (typeof issuer !== 'string') {\n      return new Error('The issuer must be a string');\n    }\n    if (!issuer.length) {\n      return new Error('The issuer string must not be empty');\n    }\n    return true;\n  }\n\n  /**\n   * add an issuer string in the list\n   * as a valid issuer.\n   *\n   * @static\n   * @param {string} issuer\n   * @returns {(boolean | Error)}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public addIssuer = (issuer: string): boolean | Error => {\n    const issuerFormatValidationResult = this.validateIssuerFormat(issuer);\n\n    if (issuerFormatValidationResult instanceof Error) {\n      return issuerFormatValidationResult;\n    }\n\n    const { issuersList } = this;\n\n    if (typeof issuer !== 'string') {\n      return new Error('The issuer must be a string');\n    }\n    if (!issuersList.includes(issuer)) {\n      issuersList.push(issuer);\n    }\n    return true;\n  };\n\n  /**\n   * remove an issuer from the list of the\n   * valid issuers. If there is no\n   * issuer in the list returns true.\n   *\n   * @static\n   * @param {string} issuer\n   * @returns {(boolean | Error)}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public removeIssuer(issuer: string): boolean | Error {\n    const { issuersList } = this;\n\n    if (typeof issuer !== 'string') {\n      return new Error('The issuer must be a string');\n    }\n    commonUtilsArrayDeleteFromArray(issuersList, issuer);\n    return true;\n  }\n\n  /**\n   * checks whether the issuer is in the\n   * list of the valid issuers. If the\n   * list of the valid issuers is empty\n   * then returns true\n   *\n   * @param {string} issuer\n   * @returns {(Error | boolean)}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public checkIssuerInList(issuer: string): Error | boolean {\n    const { issuersList } = this;\n\n    if (issuersList && issuersList.length && !issuersList.includes(issuer)) {\n      return new Error('The issuer is not into the list of the valid issuers');\n    }\n    return true;\n  }\n\n  /**\n   * validate the Issuer format and\n   * if it is in the list of the valid\n   * issuers\n   *\n   * @param {string} issuer\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public validateIssuer(issuer: string): boolean | Error {\n    const issuerFormatValidationResult = this.validateIssuerFormat(issuer);\n\n    if (issuerFormatValidationResult instanceof Error) {\n      return issuerFormatValidationResult;\n    }\n\n    const issuerInListOfValidResult = this.checkIssuerInList(issuer);\n\n    if (issuerInListOfValidResult instanceof Error) {\n      return issuerInListOfValidResult;\n    }\n    return true;\n  }\n\n  /**\n   * validate the type of the Type value\n   * it's length or if it is positive or\n   * a negative number\n   *\n   * @param {string | number} [type]\n   * @returns {(boolean | Error)}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public validateTypeFormat(type?: TType): boolean | Error {\n    if (type == null) {\n      return new Error('A type must be specified');\n    }\n    if (typeof type === 'string') {\n      if (!type.length) {\n        return new Error('The type of the message must not be empty');\n      }\n      return true;\n    } else if (typeof type === 'number') {\n      if (type < 0) {\n        return new Error('The type must be a positive number');\n      }\n      return true;\n    }\n    return new Error('The type must be a number or a string');\n  }\n\n  /**\n   * add an type string in the list\n   * as a valid types.\n   *\n   * @static\n   * @param {string | number} type\n   * @returns {(boolean | Error)}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public addType = (type: TType): boolean | Error => {\n    const { typesList } = this;\n    const validationResult = this.validateTypeFormat(type);\n\n    if (validationResult instanceof Error) {\n      return validationResult;\n    }\n    if (!typesList.includes(type)) {\n      typesList.push(type);\n    }\n    return true;\n  };\n\n  /**\n   * remove an issuer from the list of the\n   * valid issuers. If there is no\n   * issuer in the list returns true.\n   *\n   * @static\n   * @param {string | number} type\n   * @returns {(boolean | Error)}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public removeType(type: TType): boolean | Error {\n    const { typesList } = this;\n\n    commonUtilsArrayDeleteFromArray(typesList, type);\n    return true;\n  }\n\n  /**\n   * Checks whether the list of valid types is defined and not empty.\n   * If it is then checks if the type is into the list.\n   *\n   * @static\n   * @param {string| number} type\n   * @returns\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public checkTypeInList(type: TType): boolean | Error {\n    const { typesList } = this;\n\n    if (typesList && typesList.length && !typesList.includes(type)) {\n      return new Error('The type is not into the list of the valid types');\n    }\n    return true;\n  }\n\n  /**\n   * check the Type value format and\n   * if the type is in the list of the\n   * valid types\n   *\n   * @param {string | number} type\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public validateType(type: TType): boolean | Error {\n    const formatValidationResult = this.validateTypeFormat(type);\n\n    if (formatValidationResult instanceof Error) {\n      return formatValidationResult;\n    }\n\n    const isTypeInTheList = this.checkTypeInList(type);\n\n    if (isTypeInTheList instanceof Error) {\n      return isTypeInTheList;\n    }\n    return true;\n  }\n\n  /**\n   * validates if the user identity is a valid\n   * central authority identity\n   *\n   * @param {((\n   *             TCentralAuthorityUserCryptoCredentials\n   *             | TCentralAuthorityUserIdentity\n   *             | ICAUserUniqueIdentifierDescriptionWithOptionalVersion\n   *         ))} userId\n   * @returns {(boolean | Error)}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public validateUserIdentifier(\n    userId:\n      | TCentralAuthorityUserCryptoCredentials\n      | TCentralAuthorityUserIdentity\n      | ICAUserUniqueIdentifierDescriptionWithOptionalVersion\n  ): boolean | Error {\n    if (!userId) {\n      return new Error('User id must be specified');\n    }\n    if (!(userId instanceof CentralAuthorityIdentity) && userId !== 'string') {\n      return new Error(\n        'User id must be a string or an instance of the CentralAuthorityIdentity'\n      );\n    }\n\n    const uid = new CentralAuthorityIdentity(userId);\n\n    if (!uid.isValid) {\n      return new Error('The user identity is not valid');\n    }\n    return true;\n  }\n\n  /**\n   * validates if the payload is an instance\n   * of the Buffer-compatible types or a string.\n   * And checks the length of the payload value\n   * to be less than the max and greater than the\n   * min\n   *\n   * @param {} pld\n   * @returns {string | number[] | Uint8Array | ArrayBuffer | SharedArrayBuffer}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public validatePayload(pld: TPayload): boolean | Error {\n    if (!pld) {\n      return new Error('A payload must be specified');\n    }\n\n    const { payloadMaxLength, payloadMinLength } = this;\n    let len;\n\n    if (pld instanceof Array) {\n      len = commonUtilsArrayCalculateLengthOfIntegerArray(pld, 255, 0);\n\n      if (len instanceof Error) {\n        console.error(len);\n        return new Error(\n          'The value of the payload is not a valid array with byte-length integers'\n        );\n      }\n    } else if (typeof pld === 'string') {\n      len = pld.length;\n    } else if (pld instanceof Uint8Array) {\n      len = pld.buffer.byteLength;\n    } else if (pld instanceof ArrayBuffer) {\n      len = pld.byteLength;\n    } else if (pld instanceof SharedArrayBuffer) {\n      len = pld.byteLength;\n    } else {\n      return new Error(\n        'The payload value must be a string, an instance of a byte-integers Array, Uint8Array, ArrayBuffer or SharedArrayBuffer'\n      );\n    }\n    if (typeof len !== 'number') {\n      return new Error(\n        'Unknown error has occurred while calculating the lenght of the payload'\n      );\n    }\n    if (Number.isFinite(len)) {\n      return new Error('The length of the payload is too big');\n    }\n    if (len > payloadMaxLength) {\n      return new Error('The payload value is too big');\n    }\n    if (len < payloadMinLength) {\n      return new Error('The payload value is too small');\n    }\n    return true;\n  }\n\n  /**\n   * validate the timestamp format and\n   * check whether it within the ttl defined\n   *\n   * @param {number} timestamp\n   * @returns {(Error | boolean)}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public validateTimestamp(timestamp: number): Error | boolean {\n    if (!timestamp) {\n      return new Error('Timestamp must be defined');\n    }\n    if (typeof timestamp !== 'number') {\n      return new Error('Timestamp must be a number');\n    }\n\n    return true;\n  }\n\n  /**\n   * set the options\n   *\n   * @protected\n   * @param {IMessageValidatorOptions} options\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected setOptions(options: IMessageValidatorOptions) {\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new Error('The options must be an object');\n      }\n\n      const {\n        payloadMaxLength,\n        payloadMinLength,\n        issuersList,\n        typesList,\n        ttlSeconds,\n      } = options;\n\n      if (ttlSeconds) {\n        if (typeof ttlSeconds !== 'number') {\n          throw new Error('The time to live must be a number');\n        }\n        this.ttlSeconds = ttlSeconds; // set time to live in milliseconds\n      }\n      if (payloadMaxLength) {\n        if (typeof payloadMaxLength === 'number') {\n          this.payloadMaxLength = payloadMaxLength;\n        } else {\n          throw new Error(\n            'The value of the \"payloadMaxLength\" option must be a number'\n          );\n        }\n      }\n      if (payloadMinLength) {\n        if (typeof payloadMinLength === 'number') {\n          this.payloadMinLength = payloadMinLength;\n        } else {\n          throw new Error(\n            'The value of the \"payloadMinLength\" option must be a number'\n          );\n        }\n      }\n      if (issuersList) {\n        if (issuersList instanceof Array) {\n          const setIssuersListResult = commonUtilsArrayDoCallbackTillNoError<\n            string\n          >(issuersList, this.addIssuer);\n\n          if (setIssuersListResult instanceof Error) {\n            throw setIssuersListResult;\n          }\n        } else {\n          throw new Error(\n            'The value of the \"issuersList\" option must be an Array'\n          );\n        }\n      }\n      if (typesList) {\n        if (typesList instanceof Array) {\n          const setTypesListResult = commonUtilsArrayDoCallbackTillNoError<\n            TType\n          >(typesList, this.addType);\n\n          if (setTypesListResult instanceof Error) {\n            throw setTypesListResult;\n          }\n        } else {\n          throw new Error(\n            'The value of the \"typesList\" option must be an Array'\n          );\n        }\n      }\n    }\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validator/swarm-message-subclass-validator.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-message/swarm-message.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-class.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-class.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.ts",["1291","1292"],"import OrbitDB from 'orbit-db';\nimport AccessController from 'orbit-db-access-controllers/src/access-controller-interface';\nimport {\n  SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_TYPE,\n  SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_LOG_PREFIX,\n} from './swarm-store-connector-orbit-db-subclass-access-controller.const';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions,\n  TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback,\n  ISwarmStoreConnectorOrbitDbDatabaseAccessControllerManifest,\n} from './swarm-store-connector-orbit-db-subclass-access-controller.types';\nimport { IdentityProvider } from 'orbit-db-identity-provider';\n\nexport class SwarmStoreConnectorOrbitDBSubclassAccessController<\n  T\n> extends AccessController {\n  // Returns the type of the access controller\n  public static get type(): string {\n    return SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_TYPE;\n  }\n  /**\n   * create and preload an instance\n   * of the SwarmStoreConnectorOrbitDBSubclassAccessController\n   *\n   * @static\n   * @template T\n   * @param {OrbitDB} orbitdb\n   * @param {ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T>} [options={}]\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  public static async create<T>(\n    orbitdb: OrbitDB,\n    options: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T> = {}\n  ): Promise<SwarmStoreConnectorOrbitDBSubclassAccessController<T>> {\n    return new SwarmStoreConnectorOrbitDBSubclassAccessController<T>(\n      orbitdb,\n      options\n    );\n  }\n\n  // if true then anyone have access\n  // to the database\n  protected _isPublic: boolean = false;\n\n  protected _grantAccessCallback?: TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback<\n    T\n  >;\n\n  protected _orbitdb?: OrbitDB;\n\n  protected _options?: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<\n    T\n  >;\n\n  constructor(\n    orbitdb: OrbitDB,\n    options: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T> = {}\n  ) {\n    super();\n    this._orbitdb = orbitdb;\n    this.setOptions(options);\n  }\n\n  /**\n   * Called by the databases (the log) to see if entry should\n   * be allowed in the database. Return true if the entry is allowed,\n   * false is not allowed.\n   *\n   * @param {LogEntry<T>} entry\n   * @param {IdentityProvider} identityProvider\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  public async canAppend(\n    entry: LogEntry<T>,\n    identityProvider: IdentityProvider\n  ): Promise<boolean> {\n    if (!this.verifyEntryFormat(entry)) {\n      console.warn(\n        `${SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_LOG_PREFIX}::entry have an unknown format`\n      );\n      return false;\n    }\n\n    // Write keys and admins keys are allowed\n    const { _options, _isPublic } = this;\n\n    if (_isPublic) {\n      return this.checkAccess(entry, identityProvider);\n    }\n\n    if (!_options) {\n      return false;\n    }\n\n    const { identity } = entry;\n    const { id: userPerformedActionOnEntryId } = identity;\n    const { write: accessListForUsers } = _options;\n\n    // If the ACL contains the writer's public key or it contains '*'\n    if (\n      accessListForUsers &&\n      accessListForUsers.includes(userPerformedActionOnEntryId)\n    ) {\n      return this.checkAccess(entry, identityProvider);\n    }\n    return false;\n  }\n\n  /**\n   *  return manifest params\n   *\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  public async save(): Promise<\n    ISwarmStoreConnectorOrbitDbDatabaseAccessControllerManifest\n  > {\n    return {};\n  }\n\n  /**\n   * check if the entry have the common fields\n   * used to verfy the access on it\n   *\n   * @protected\n   * @param {LogEntry<T>} entry\n   * @returns {entry is LogEntry<T>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  protected verifyEntryFormat(entry: LogEntry<T>): entry is LogEntry<T> {\n    if (!entry || typeof entry !== 'object') {\n      return false;\n    }\n\n    const { identity, payload } = entry;\n    const { id } = identity;\n\n    if (!id) {\n      return false;\n    }\n    if (payload === undefined) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * validate the identiry provided by the entity\n   *\n   * @protected\n   * @param {IdentityJson} identity\n   * @returns {Promise<boolean>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  protected verifyIdentity(\n    identity: IdentityJson,\n    identityProvider: IdentityProvider\n  ): Promise<boolean> {\n    return (identityProvider as any).verifyIdentity(identity);\n  }\n\n  /**\n   * validate the entity format and\n   * check the access on it for the\n   * identity provided\n   *\n   * @protected\n   * @param {LogEntry<T>} entry\n   * @returns {Promise<boolean>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  protected async verifyEntity(entry: LogEntry<T>): Promise<boolean> {\n    if (!this.verifyEntryFormat(entry)) {\n      return false;\n    }\n\n    const { identity, payload } = entry;\n    const { id } = identity;\n    const { _grantAccessCallback } = this;\n\n    if (typeof _grantAccessCallback === 'function') {\n      return _grantAccessCallback(payload, id);\n    }\n    return true;\n  }\n\n  /**\n   * validates the enetry and verify the user have\n   * the access on it\n   *\n   * @protected\n   * @param {LogEntry<T>} entry\n   * @param {IdentityProvider} identityProvider\n   * @returns {Promise<boolean>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  protected async checkAccess(\n    entry: LogEntry<T>,\n    identityProvider: IdentityProvider\n  ): Promise<boolean> {\n    try {\n      if (!this.verifyEntryFormat(entry)) {\n        return false;\n      }\n\n      const { identity } = entry;\n      const validateIdentityResult = await this.verifyIdentity(\n        identity,\n        identityProvider\n      );\n\n      if (validateIdentityResult !== true) {\n        return false;\n      }\n      return this.verifyEntity(entry);\n    } catch (err) {\n      console.error(err);\n      return false;\n    }\n  }\n\n  protected setOptions(\n    options: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T>\n  ) {\n    if (options) {\n      const { write, grantAcess } = options;\n\n      if (write instanceof Array) {\n        if (write.includes('*')) {\n          this._isPublic = true;\n        }\n      } else {\n        console.warn(\n          `${SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_LOG_PREFIX}::Noone have access on the database`\n        );\n      }\n      if (typeof grantAcess === 'function') {\n        if (grantAcess.length !== 2) {\n          console.warn(\n            `${SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_LOG_PREFIX}::A grant access callback must receives 2 arguments generally, but receives ${grantAcess.length}`\n          );\n        }\n        this._grantAccessCallback = grantAcess;\n      }\n      this._options = options;\n    }\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.ts",["1293","1294","1295","1296","1297","1298","1299","1300","1301","1302","1303","1304","1305","1306","1307","1308","1309","1310","1311"],"import * as orbitDbModule from 'orbit-db';\nimport OrbitDbFeedStore from 'orbit-db-feedstore';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseOptions,\n  ISwarmStoreConnectorOrbitDbDatabaseEvents,\n  ISwarmStoreConnectorOrbitDbDatabaseValue,\n  ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions,\n  TFeedStoreHash,\n} from './swarm-store-connector-orbit-db-subclass-database.types';\nimport { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport {\n  ESwarmConnectorOrbitDbDatabaseEventNames,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_LOG_PREFIX,\n  EOrbidDBFeedSoreEvents,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONFIGURATION,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_ENTITIES_LOAD_COUNT,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_ITERATOR_OPTIONS_DEFAULT,\n} from './swarm-store-connector-orbit-db-subclass-database.const';\nimport {\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON,\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_OFF,\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_UNSET_ALL_LISTENERS,\n} from 'const/common-values/common-values';\nimport { SwarmStoreConnectorOrbitDBSubclassAccessController } from '../swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller';\nimport { ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions } from '../swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.types';\n\nexport class SwarmStoreConnectorOrbitDBDatabase<\n  TFeedStoreType\n> extends EventEmitter<\n  ISwarmStoreConnectorOrbitDbDatabaseEvents<\n    SwarmStoreConnectorOrbitDBDatabase<TFeedStoreType>\n  >\n> {\n  // is loaded fully and ready to use\n  public isReady: boolean = false;\n\n  // whether is closed\n  public isClosed: boolean = false;\n\n  // a name of the database\n  public dbName: string = '';\n\n  private isFullyLoaded: boolean = false;\n\n  public constructor(\n    options: ISwarmStoreConnectorOrbitDbDatabaseOptions<TFeedStoreType>,\n    orbitDb: orbitDbModule.OrbitDB\n  ) {\n    super();\n    this.setOptions(options);\n    this.setOrbitDbInstance(orbitDb);\n  }\n\n  public async connect(): Promise<Error | void> {\n    this.unsetReadyState();\n\n    const dbStoreCreationResult = await this.createDbInstance();\n\n    if (dbStoreCreationResult instanceof Error) {\n      return dbStoreCreationResult;\n    }\n\n    const loadDbResult = await dbStoreCreationResult.load(\n      SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_ENTITIES_LOAD_COUNT\n    );\n\n    if ((loadDbResult as unknown) instanceof Error) {\n      console.error(loadDbResult);\n      return this.onFatalError(\n        'The fatal error has occurred on databse loading',\n        'connect'\n      );\n    }\n  }\n\n  public async close(): Promise<Error | void> {\n    const closeCurrentStoreResult = await this.closeCurrentStore();\n\n    this.unsetReadyState();\n    this.isClosed = true;\n    this.emitEvent(ESwarmConnectorOrbitDbDatabaseEventNames.CLOSE, this);\n    this.unsetAllListenersForEvents();\n    if (closeCurrentStoreResult instanceof Error) {\n      return closeCurrentStoreResult;\n    }\n  }\n\n  public async add(value: TFeedStoreType): Promise<string | Error> {\n    const database = this.getDbStoreInstance();\n\n    if (database instanceof Error) {\n      return database;\n    }\n    try {\n      const hash = await database.add(value);\n\n      if (typeof hash !== 'string') {\n        return new Error(\n          'An unknown type of hash was returned for the value stored'\n        );\n      }\n      return hash;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async get(\n    hash: TFeedStoreHash\n  ): Promise<\n    Error | ISwarmStoreConnectorOrbitDbDatabaseValue<TFeedStoreType> | void\n  > {\n    const database = this.getDbStoreInstance();\n\n    if (database instanceof Error) {\n      return database;\n    }\n\n    try {\n      const e = database.get(hash);\n\n      if (e instanceof Error) {\n        return new Error('An error has occurred on get the data from the key');\n      }\n      if (e) {\n        return this.parseValueStored(e);\n      }\n    } catch (err) {\n      return err;\n    }\n    return undefined;\n  }\n\n  public async remove(hash: TFeedStoreHash): Promise<Error | void> {\n    const database = this.getDbStoreInstance();\n\n    if (database instanceof Error) {\n      return database;\n    }\n    try {\n      const hashRemoved = await database.remove(hash);\n\n      if (typeof hashRemoved !== 'string') {\n        return new Error(\n          'An unknown type of hash was returned for the value removed'\n        );\n      }\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async iterator(\n    options?: ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions\n  ): Promise<\n    | Error\n    | Array<\n        ISwarmStoreConnectorOrbitDbDatabaseValue<TFeedStoreType> | Error | void\n      >\n  > {\n    const database = this.getDbStoreInstance();\n\n    if (database instanceof Error) {\n      return database;\n    }\n\n    const iteratorOptionsRes =\n      options ||\n      SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_ITERATOR_OPTIONS_DEFAULT;\n\n    return database\n      .iterator(iteratorOptionsRes)\n      .collect()\n      .map(this.parseValueStored);\n  }\n\n  protected parseValueStored = (\n    e: LogEntry<TFeedStoreType>\n  ):\n    | ISwarmStoreConnectorOrbitDbDatabaseValue<TFeedStoreType>\n    | Error\n    | void => {\n    const { payload, identity, hash } = e;\n\n    if (payload) {\n      return {\n        id: identity.id,\n        value: payload.value,\n        hash,\n      };\n    } else {\n      return new Error('An unknown fromat of the data stored');\n    }\n  };\n\n  private getDbStoreInstance(): Error | OrbitDbFeedStore<TFeedStoreType> {\n    const { isReady, database } = this;\n\n    if (!isReady) {\n      return new Error('The store is not ready to use');\n    }\n    if (!database) {\n      return this.emitError('The database store instance is empty');\n    }\n    return database;\n  }\n\n  private setReadyState(isReady: boolean = true) {\n    this.isReady = isReady;\n  }\n\n  private unsetReadyState() {\n    this.setReadyState(false);\n  }\n\n  private options?: ISwarmStoreConnectorOrbitDbDatabaseOptions<TFeedStoreType>;\n\n  protected orbitDb?: orbitDbModule.OrbitDB;\n\n  protected database?: OrbitDbFeedStore<TFeedStoreType>;\n\n  protected unsetAllListenersForEvents = () => {\n    Object.values(EOrbidDBFeedSoreEvents).forEach(\n      this[COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_UNSET_ALL_LISTENERS].bind(\n        this\n      )\n    );\n  };\n\n  protected emitError(\n    error: Error | string,\n    mehodName?: string,\n    isFatal: boolean = false\n  ): Error {\n    const err = typeof error === 'string' ? new Error() : error;\n    const eventName = isFatal\n      ? ESwarmConnectorOrbitDbDatabaseEventNames.FATAL\n      : ESwarmConnectorOrbitDbDatabaseEventNames.ERROR;\n\n    console.error(\n      `${SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_LOG_PREFIX}::error${\n        mehodName ? `::${mehodName}` : ''\n      }`,\n      err\n    );\n    this.emit(eventName, err);\n    return err;\n  }\n\n  protected onFatalError(error: Error | string, methodName: string) {\n    this.unsetReadyState();\n    this.emitError(error, methodName, true);\n\n    const { isClosed } = this;\n\n    if (!isClosed) {\n      this.close();\n    }\n    return this.emitError(\n      'The database closed cause a fatal error',\n      methodName,\n      true\n    );\n  }\n\n  protected emitEvent(\n    event: ESwarmConnectorOrbitDbDatabaseEventNames,\n    ...args: any[]\n  ) {\n    const { options } = this;\n    const { dbName } = options!;\n\n    this.emit(event, dbName, ...args);\n  }\n\n  private getFeedStoreOptions(): IStoreOptions | undefined | Error {\n    return SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONFIGURATION;\n  }\n\n  private emitFullyLoaded() {\n    if (!this.isFullyLoaded) {\n      this.isFullyLoaded = true;\n      this.emitEvent(ESwarmConnectorOrbitDbDatabaseEventNames.LOADING, 100);\n    }\n  }\n\n  protected logStore = () => {\n    const { database } = this;\n    const posts = database!.iterator({ limit: -1 }).collect();\n\n    console.log('STORE::READY--');\n    posts.forEach((post: any) => {\n      if (post && post.identity) {\n        console.log(post.identity.id);\n      }\n    });\n    console.log('--STORE::READY');\n  };\n\n  private handleFeedStoreReady = () => {\n    this.emitFullyLoaded();\n    this.setReadyState();\n    this.emitEvent(ESwarmConnectorOrbitDbDatabaseEventNames.READY);\n    this.logStore();\n  };\n\n  private handleFeedStoreLoaded = () => {\n    // emit event that the database local copy was fully loaded\n    this.emitFullyLoaded();\n  };\n\n  private handleFeedStoreLoadProgress = (\n    address: string,\n    hash: string,\n    entry: LogEntry<TFeedStoreType>,\n    progress: number,\n    total: number\n  ) => {\n    // emit event database local copy loading progress\n    this.emitEvent(ESwarmConnectorOrbitDbDatabaseEventNames.LOADING, progress);\n  };\n\n  private handleFeedStoreReplicated = () => {\n    // emit event that the db updated, cause it\n    // was replicated with another peer db copy\n    const { dbName } = this;\n\n    this.emitEvent(ESwarmConnectorOrbitDbDatabaseEventNames.UPDATE, dbName);\n    this.logStore();\n  };\n\n  private handleFeedStoreClosed = () => {\n    const { isClosed } = this;\n\n    if (!isClosed) {\n      this.unsetReadyState();\n      this.emitError(\n        'The instance was closed unexpected',\n        'handleFeedStoreClosed'\n      );\n      this.restartStore();\n    }\n  };\n\n  private async closeInstanceOfStore(\n    storeInstance: OrbitDbFeedStore<TFeedStoreType>\n  ): Promise<Error | void> {\n    if (!storeInstance) {\n      return new Error('An instance of the store must be specified');\n    }\n    this.unsetFeedStoreEventListeners(storeInstance);\n    try {\n      await storeInstance.close();\n    } catch (err) {\n      console.error(err);\n      return new Error(\n        'Fatal error has occurred on close the instance of the Feed store'\n      );\n    }\n  }\n\n  private async closeCurrentStore(): Promise<Error | void> {\n    const { database } = this;\n\n    if (database) {\n      const closeStoreResult = await this.closeInstanceOfStore(database);\n\n      if (closeStoreResult instanceof Error) {\n        console.error(closeStoreResult);\n        return new Error(\n          'Failed to close the current instance of the Database store'\n        );\n      }\n      this.database = undefined;\n    }\n  }\n\n  // restart the store\n  private async restartStore(): Promise<Error | void> {\n    const { isClosed } = this;\n\n    if (isClosed) {\n      return new Error('The store was closed previousely');\n    }\n\n    const currentStoreStopResult = await this.closeCurrentStore();\n\n    if (currentStoreStopResult instanceof Error) {\n      console.error(currentStoreStopResult);\n      return this.onFatalError(\n        'Failed to restart the Database cause failed to close the store instance',\n        'restartStore'\n      );\n    }\n    return this.connect();\n  }\n\n  private handleFeedStoreReplicateInProgress = (\n    address: string,\n    hash: string,\n    entry: LogEntry<TFeedStoreType>,\n    progress: number,\n    have: unknown\n  ) => {\n    console.warn(`handleFeedStoreReplicateInProgress::\n            addr: ${address}\n            hash: ${hash}\n            progress: ${progress}\n        `);\n    this.logStore();\n  };\n\n  private setFeedStoreEventListeners(\n    feedStore: OrbitDbFeedStore<TFeedStoreType>,\n    isSet = true\n  ): Error | void {\n    if (!feedStore) {\n      return new Error('An instance of the FeedStore must be specified');\n    }\n    if (!feedStore.events) {\n      return new Error('An unknown API of the FeedStore');\n    }\n    if (\n      typeof feedStore.events.addListener !== 'function' ||\n      typeof feedStore.events.removeListener !== 'function'\n    ) {\n      return new Error('An unknown API of the FeedStore events');\n    }\n\n    const methodName = isSet\n      ? COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON\n      : COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_OFF;\n\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.READY,\n      this.handleFeedStoreReady\n    );\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.LOAD,\n      this.handleFeedStoreLoaded\n    );\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.LOAD_PROGRESS,\n      this.handleFeedStoreLoadProgress\n    );\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.REPLICATED,\n      this.handleFeedStoreReplicated\n    );\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.CLOSE,\n      this.handleFeedStoreClosed\n    );\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.REPLICATE_PROGRESS,\n      this.handleFeedStoreReplicateInProgress\n    );\n  }\n\n  private unsetFeedStoreEventListeners(\n    feedStore: OrbitDbFeedStore<TFeedStoreType>\n  ) {\n    this.setFeedStoreEventListeners(feedStore, false);\n  }\n\n  private getAccessControllerOptions(): ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<\n    TFeedStoreType\n  > {\n    const { options } = this;\n    const resultedOptions: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<TFeedStoreType> = {\n      type: SwarmStoreConnectorOrbitDBSubclassAccessController.type,\n    };\n\n    if (!options) {\n      return resultedOptions;\n    }\n\n    const { isPublic, write, grantAcess } = options;\n\n    if (isPublic) {\n      resultedOptions.write = ['*'];\n    } else if (write instanceof Array) {\n      resultedOptions.write = write.filter(\n        (identity) => identity && typeof identity === 'string'\n      );\n    }\n    if (typeof grantAcess === 'function') {\n      if (grantAcess.length !== 2) {\n        console.warn(\n          'The grant access callback function must have 2 arguments'\n        );\n      }\n      resultedOptions.grantAcess = grantAcess;\n    }\n    return resultedOptions;\n  }\n\n  private async createDbInstance(): Promise<\n    Error | OrbitDbFeedStore<TFeedStoreType>\n  > {\n    try {\n      const { orbitDb, options } = this;\n\n      if (!orbitDb) {\n        return this.onFatalError(\n          'There is no intance of the OrbitDb is specified',\n          'createDbInstance'\n        );\n      }\n\n      const { dbName } = options!;\n\n      if (!dbName) {\n        return this.onFatalError(\n          'A name of the database must be specified',\n          'createDbInstance'\n        );\n      }\n\n      const dbFeedStoreOptions = this.getFeedStoreOptions();\n\n      if (dbFeedStoreOptions instanceof Error) {\n        return this.onFatalError(\n          dbFeedStoreOptions,\n          'createDbInstance::getFeedStoreOptions'\n        );\n      }\n\n      const db = await orbitDb.feed<TFeedStoreType>(dbName, {\n        ...SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONFIGURATION,\n        accessController: this.getAccessControllerOptions(),\n      });\n\n      if (db instanceof Error) {\n        return this.onFatalError(db, 'createDbInstance::feed store creation');\n      }\n\n      const setStoreListenersResult = this.setFeedStoreEventListeners(db);\n\n      if (setStoreListenersResult instanceof Error) {\n        return this.onFatalError(\n          setStoreListenersResult,\n          'createDbInstance::set feed store listeners'\n        );\n      }\n      this.database = db;\n      return db;\n    } catch (err) {\n      return this.onFatalError(err, 'createDbInstance');\n    }\n  }\n\n  private setOptions(\n    options: ISwarmStoreConnectorOrbitDbDatabaseOptions<TFeedStoreType>\n  ): void | Error {\n    if (!options) {\n      return this.onFatalError('Options must be specified', 'setOptions');\n    }\n\n    const { dbName } = options;\n\n    if (typeof dbName !== 'string') {\n      return this.onFatalError(\n        'A name of the database must be specified',\n        'setOptions'\n      );\n    }\n    this.options = options;\n    this.dbName = dbName;\n  }\n\n  private setOrbitDbInstance(orbitDb: orbitDbModule.OrbitDB): void | Error {\n    if (!orbitDb) {\n      return this.onFatalError(\n        'An instance of orbit db must be specified',\n        'setOrbitDbInstance'\n      );\n    }\n    this.orbitDb = orbitDb;\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider.ts",["1312","1313","1314","1315"],"import KeystoreClass, { Keystore } from 'orbit-db-keystore';\nimport {\n  IdentityProvider,\n  IdentityProviderOptions,\n  IdentityAsJson,\n} from 'orbit-db-identity-provider';\nimport { SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_IDENTITY_PROVIDER_TYPE } from './swarm-store-connector-orbit-db-subclass-identity-provider.const';\n\nexport class SwarmStoreConnectorOrbitDBSubclassIdentityProvider extends IdentityProvider {\n  /**\n   * return name of the identity provider\n   *\n   * @readonly\n   * @static\n   * @type {string}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n   */\n  public static get type(): string {\n    return SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_IDENTITY_PROVIDER_TYPE;\n  }\n\n  /**\n   * Verify that identity was signed by the ID\n   *\n   * @static\n   * @param {IdentityAsJson} identity\n   * @returns {Promise<boolean>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n   */\n  public static async verifyIdentity(\n    identity: IdentityAsJson\n  ): Promise<boolean> {\n    const verifyResult = await KeystoreClass.verify(\n      identity.signatures.publicKey,\n      identity.publicKey,\n      identity.publicKey + identity.signatures.id\n    );\n\n    return verifyResult;\n  }\n\n  protected _keystore?: Keystore;\n\n  constructor(options: IdentityProviderOptions = {}) {\n    super(options);\n    if (!options.keystore) {\n      throw new Error(\n        'IdentityProvider.createIdentity requires options.keystore'\n      );\n    }\n    if (!options.signingKeystore) {\n      options.signingKeystore = options.keystore;\n    }\n    this._keystore = options.signingKeystore;\n  }\n\n  /**\n   * return identifier of external id (eg. a public key)\n   *\n   * @param {IdentityProviderOptions} [options={}]\n   * @returns {Promise<string>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n   * @throws Error\n   */\n  async getId(options: IdentityProviderOptions = {}): Promise<string> {\n    const id = options.id;\n\n    if (!id) {\n      throw new Error('id is required');\n    }\n    return id;\n  }\n\n  /**\n   * return a signature of data (signature of the OrbtiDB public key)\n   *\n   * @param {*} data\n   * @param {IdentityProviderOptions} [options={}]\n   * @returns {Promise<any>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n   * @throws Error\n   */\n  async signIdentity(\n    data: any,\n    options: IdentityProviderOptions = {}\n  ): Promise<string> {\n    const id = options.id;\n\n    if (!id) {\n      throw new Error('id is required');\n    }\n\n    const { _keystore: keystore } = this;\n    const key = await keystore!.getKey(id);\n\n    if (!key) {\n      throw new Error(`Signing key for '${id}' not found`);\n    }\n\n    const result = await (keystore! as any).sign(key, data);\n\n    return result;\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-cache/swarm-store-connector-orbit-db-subclass-storage-cache.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.ts",["1316","1317","1318","1319","1320","1321","1322","1323","1324","1325","1326"],"import {\n  ISecretStorageOptions,\n  ISecretStoreCredentials,\n  ISecretStoreCredentialsCryptoKey,\n} from 'classes/secret-storage-class/secret-storage-class.types';\nimport { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';\nimport {\n  IOrbitDbCacheStore,\n  IOrbitDbKeystoreStore,\n} from './swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.types';\nimport {\n  SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_DEFAULT_OPTIONS_SECRET_STORAGE,\n  SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS,\n} from './swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.const';\nimport { TCallbackError, TCallbackErrorValue } from 'orbit-db-cache';\n\nexport class SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter\n  implements IOrbitDbKeystoreStore, IOrbitDbCacheStore {\n  public get status(): SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS {\n    const { isClose } = this;\n\n    if (isClose) {\n      return SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.CLOSE;\n    }\n    return SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.OPEN;\n  }\n\n  /**\n   * this is used in the Cache(orbit-db-cache) in status\n   * ` get status () { return this._store.db.status } `\n   *\n   * @readonly\n   * @type {{ status: SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS }}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter\n   */\n  public get db() {\n    return {\n      status: this.status,\n    };\n  }\n\n  protected options?: ISecretStorageOptions;\n\n  protected secretStorage?: InstanceType<typeof SecretStorage>;\n\n  private credentials?: ISecretStoreCredentials;\n\n  private credentialsCryptoKey?: ISecretStoreCredentialsCryptoKey;\n\n  protected isOpen: boolean = false;\n\n  protected isClose: boolean = false;\n\n  constructor(\n    credentials: ISecretStoreCredentials | ISecretStoreCredentialsCryptoKey,\n    options: Required<ISecretStorageOptions>\n  ) {\n    this.setOptions(options);\n    this.setCredentials(credentials);\n    this.createSecretStorage();\n  }\n\n  public async open(cb?: TCallbackError): Promise<void> {\n    const { isClose, isOpen } = this;\n\n    if (isClose) {\n      throw new Error('The instance was closed before');\n    }\n    if (isOpen) {\n      return;\n    }\n\n    const result = await this.startSecretStorage();\n\n    if (result instanceof Error) {\n      throw result;\n    }\n    this.setIsOpen();\n    if (typeof cb === 'function') {\n      cb(undefined);\n    }\n  }\n\n  public async close(cb?: TCallbackError): Promise<void> {\n    this.setIsClose();\n\n    const result = await this.disconnectSecretStorage();\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw result;\n    }\n    if (typeof cb === 'function') {\n      cb(undefined);\n    }\n  }\n\n  public async get(\n    k: string,\n    cb?: TCallbackErrorValue\n  ): Promise<string | undefined> {\n    // open connection to the secret storage\n    // before any operations\n    await this.openIfNecessary();\n\n    const secretStorage = this.getSecretStorage();\n\n    if (secretStorage instanceof Error) {\n      console.error(secretStorage);\n      throw secretStorage;\n    }\n\n    const result = await secretStorage.get(k);\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw result;\n    }\n    const resulted = result ? result : undefined;\n    if (typeof cb === 'function') {\n      cb(undefined, resulted);\n    }\n    return resulted;\n  }\n\n  public async put(\n    k: string,\n    v: string | Buffer,\n    cb?: TCallbackError\n  ): Promise<void> {\n    await this.openIfNecessary();\n\n    const secretStorage = this.getSecretStorage();\n\n    if (secretStorage instanceof Error) {\n      console.error(secretStorage);\n      throw secretStorage;\n    }\n\n    const value = v instanceof Buffer ? v.toString() : v;\n    const result = await secretStorage.set(k, value);\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw result;\n    }\n    if (typeof cb === 'function') {\n      cb(undefined);\n    }\n  }\n\n  public del(key: string, cb?: TCallbackError) {\n    return this.put(key, '', cb);\n  }\n\n  // TODO - not implemented in ocrbit-db-cache\n  public async load() {}\n\n  // TODO - not implemented in ocrbit-db-cache\n  public async destroy() {\n    const { secretStorage } = this;\n\n    if (secretStorage) {\n      await this.disconnectSecretStorage();\n    }\n  }\n\n  protected setIsOpen() {\n    this.isOpen = true;\n  }\n\n  protected setIsClose() {\n    this.isClose = true;\n  }\n\n  protected getSecretStorage(): Error | SecretStorage {\n    const { secretStorage } = this;\n\n    if (secretStorage) {\n      return secretStorage;\n    }\n    return new Error('There is no connection to the SecretStorage');\n  }\n\n  protected setOptions(options: Required<ISecretStorageOptions>): void {\n    if (!options) {\n      throw new Error('Options must be provided');\n    }\n    if (typeof options !== 'object') {\n      throw new Error('Options must be an object');\n    }\n\n    const { dbName } = options;\n\n    if (!dbName) {\n      throw new Error('A database name must be specified in the options');\n    }\n    if (typeof dbName !== 'string') {\n      throw new Error('A database name must be a string');\n    }\n    this.options = options;\n  }\n\n  /**\n   * validate and set credentials with password or crypto key\n   *\n   * @protected\n   * @param {(ISecretStoreCredentials | ISecretStoreCredentialsCryptoKey)} credentials\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter\n   * @throws\n   */\n  protected setCredentials(\n    credentials: ISecretStoreCredentials | ISecretStoreCredentialsCryptoKey\n  ) {\n    if (!credentials) {\n      throw new Error('Credentials must be specified');\n    }\n    if (typeof credentials !== 'object') {\n      throw new Error('Credentials must be an object');\n    }\n\n    if ((credentials as ISecretStoreCredentialsCryptoKey).key) {\n      const credentialsValidationResult = SecretStorage.validateCryptoKeyCredentials(\n        credentials as ISecretStoreCredentialsCryptoKey\n      );\n\n      if (credentialsValidationResult instanceof Error) {\n        console.error(credentialsValidationResult);\n        throw new Error('setCredentials::crypto credentials not valid');\n      }\n      this.credentialsCryptoKey = credentials as ISecretStoreCredentialsCryptoKey;\n    } else if ((credentials as ISecretStoreCredentials).password) {\n      const credentialsValidationResult = SecretStorage.validateCredentials(\n        credentials as ISecretStoreCredentials\n      );\n\n      if (credentialsValidationResult instanceof Error) {\n        console.error(credentialsValidationResult);\n        throw new Error('setCredentials::credentials not valid');\n      }\n      this.credentials = credentials as ISecretStoreCredentials;\n    }\n  }\n\n  protected unsetCredentials() {\n    this.credentials = undefined;\n  }\n\n  private createSecretStorage() {\n    const secretStorage = new SecretStorage(\n      SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_DEFAULT_OPTIONS_SECRET_STORAGE\n    );\n\n    this.secretStorage = secretStorage;\n  }\n\n  private unsetSecretStorage() {\n    this.secretStorage = undefined;\n  }\n\n  private startSecretStorage(): Promise<Error | boolean> | Error {\n    const { options, credentials, secretStorage, credentialsCryptoKey } = this;\n\n    if (secretStorage) {\n      if (credentialsCryptoKey) {\n        return secretStorage.authorizeByKey(credentialsCryptoKey, options);\n      } else if (credentials) {\n        return secretStorage.authorize(credentials, options);\n      }\n      return new Error('Credentials was not provided');\n    }\n    return new Error('Secret storage is not defined');\n  }\n\n  private async disconnectSecretStorage(): Promise<Error | void> {\n    const { secretStorage } = this;\n\n    if (!secretStorage) {\n      return new Error(\n        'There is no instance of the SecretStorage connected to'\n      );\n    }\n    try {\n      const result = await secretStorage.disconnect();\n\n      if (result instanceof Error) {\n        return result;\n      }\n    } catch (err) {\n      return err;\n    }\n    this.unsetSecretStorage();\n  }\n\n  protected async openIfNecessary(): Promise<void> {\n    const { isOpen } = this;\n\n    if (isOpen) {\n      return;\n    }\n    await this.open();\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.const.ts",["1327"],"import { SwarmStoreConnectorOrbitDBSubclassIdentityProvider } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider';\nimport { IdentityProvider } from 'orbit-db-identity-provider';\n\nexport enum ESwarmStoreConnectorOrbitDBEventNames {\n  /**\n   * fired before connecting to the swarm\n   */\n  CONNECTING = 'CONNECTING',\n  /**\n   * firing on the ready state change\n   * if the 'isReady' flag is true\n   * then the instance can be used to read\n   * a data from the database, if the flag\n   * is false, then the instance can be used\n   * to read/write a data.\n   * */\n  STATE_CHANGE = 'STATE_CHANGE',\n  /**\n   * a data was updated in the database and must\n   * be query to get a a new results.\n   * Arguments:\n   * 1) String - name of the database\n   */\n  UPDATE = 'UPDATE',\n  /**\n   * emit when connection to the\n   * database was opened\n   * arguments:\n   * 1) dbName = name of a database opened\n   */\n  READY = 'READY',\n  /**\n   * the instance closed and can't be used\n   * to read/write\n   */\n  CLOSE = 'CLOSE',\n  /**\n   * the instance closed and can't be used\n   * to read/write\n   * * Arguments:\n   * 1) string - name of the database closed\n   * 2) object - instance closed\n   */\n  CLOSE_DATABASE = 'CLOSE_DATABASE',\n  /**\n   * emitted when loading the database from the local data\n   * Arguments:\n   * 1) Number - percentage\n   */\n  LOADING = 'LOADING',\n  /**\n   * an error has occured on any operation\n   * emits with the argument equals to an error\n   */\n  ERROR = 'ERROR',\n}\n\n/**\n * time out before the connection to the swarm throught\n * an ipfs will be timed out\n */\nexport const SWARM_STORE_CONNECTOR_ORBITDB_CONNECTION_TIMEOUT_MS = 120000;\n\n/**\n * timeout for open a single database\n */\nexport const SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONNECTION_TIMEOUT_MS = 30000;\n\n/**\n * maximum attempts to open connection with the database\n */\nexport const SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_RECONNECTION_ATTEMPTS_MAX = 3;\n\nexport const SWARM_STORE_CONNECTOR_ORBITDB_IDENTITY_TYPE =\n  SwarmStoreConnectorOrbitDBSubclassIdentityProvider.type;\n\n// prefix used in logs\nexport const SWARM_STORE_CONNECTOR_ORBITDB_LOG_PREFIX =\n  'SwarmStoreConnctotOrbitDB';\n\nexport const SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DBNAME =\n  '___SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DBNAME';\n\nexport const SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DIRECTORY =\n  'SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DIRECTORY';\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.ts",["1328","1329","1330","1331","1332","1333","1334","1335","1336","1337","1338","1339","1340","1341","1342","1343","1344","1345","1346","1347","1348","1349","1350","1351","1352"],"import OrbitDB from 'orbit-db';\nimport Identities from 'orbit-db-identity-provider';\nimport AccessControllers from 'orbit-db-access-controllers';\nimport { Keystore } from 'orbit-db-keystore';\nimport { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport {\n  ESwarmStoreConnectorOrbitDBEventNames,\n  SWARM_STORE_CONNECTOR_ORBITDB_CONNECTION_TIMEOUT_MS,\n  SWARM_STORE_CONNECTOR_ORBITDB_LOG_PREFIX,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONNECTION_TIMEOUT_MS,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_RECONNECTION_ATTEMPTS_MAX,\n  SWARM_STORE_CONNECTOR_ORBITDB_IDENTITY_TYPE,\n  SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DBNAME,\n  SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DIRECTORY,\n} from './swarm-store-connector-orbit-db.const';\nimport { IPFS } from 'types/ipfs.types';\nimport { SwarmStoreConnectorOrbitDBSubclassIdentityProvider } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider';\nimport { SwarmStoreConnectorOrbitDBSubclassAccessController } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller';\nimport {\n  ISwarmStoreConnectorOrbitDBOptions,\n  ISwarmStoreConnectorOrbitDBConnectionOptions,\n  TESwarmStoreConnectorOrbitDBEvents,\n} from './swarm-store-connector-orbit-db.types';\nimport { timeout, delay } from 'utils/common-utils/common-utils-timer';\nimport { SwarmStoreConnectorOrbitDBDatabase } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseOptions,\n  TSwarmStoreConnectorOrbitDbDatabaseMathodNames,\n  TSwarmStoreConnectorOrbitDbDatabaseMathodArgument,\n} from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { ESwarmConnectorOrbitDbDatabaseEventNames } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { commonUtilsArrayDeleteFromArray } from 'utils/common-utils/common-utils';\nimport {\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON,\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_OFF,\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_UNSET_ALL_LISTENERS,\n} from 'const/common-values/common-values';\nimport { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';\nimport { SwarmStorageConnectorOrbitDBSublassKeyStore } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore';\nimport { ISwarmStoreConnectorOrbitDBSubclassStorageFabric } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.types';\nimport { SwarmStoreConnectorOrbitDBSubclassStorageFabric } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric';\n\nexport class SwarmStoreConnectorOrbitDB<\n  ISwarmDatabaseValueTypes\n> extends EventEmitter<TESwarmStoreConnectorOrbitDBEvents> {\n  private static isLoadedCustomIdentityProvider: boolean = false;\n\n  private static loadCustomIdentityProvider() {\n    if (!SwarmStoreConnectorOrbitDB.isLoadedCustomIdentityProvider) {\n      Identities.addIdentityProvider(\n        SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n      );\n      SwarmStoreConnectorOrbitDB.isLoadedCustomIdentityProvider = true;\n    }\n  }\n\n  private static isLoadedCustomAccessController: boolean = false;\n\n  private static loadCustomAccessController() {\n    if (!SwarmStoreConnectorOrbitDB.isLoadedCustomAccessController) {\n      AccessControllers.addAccessController({\n        AccessController: SwarmStoreConnectorOrbitDBSubclassAccessController,\n      });\n      SwarmStoreConnectorOrbitDB.isLoadedCustomAccessController = true;\n    }\n  }\n\n  public isReady: boolean = false;\n\n  public isClosed: boolean = false;\n\n  protected userId: string = '';\n\n  protected directory: string = SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DIRECTORY;\n\n  protected identity?: any;\n\n  protected connectionOptions?: ISwarmStoreConnectorOrbitDBConnectionOptions;\n\n  protected options?: ISwarmStoreConnectorOrbitDBOptions<\n    ISwarmDatabaseValueTypes\n  >;\n\n  protected ipfs?: IPFS; // instance of the IPFS connected through\n\n  protected orbitDb?: OrbitDB; // instance of the OrbitDB\n\n  protected databases: SwarmStoreConnectorOrbitDBDatabase<\n    ISwarmDatabaseValueTypes\n  >[] = [];\n\n  protected identityKeystore?: Keystore;\n\n  protected storage?: ISwarmStoreConnectorOrbitDBSubclassStorageFabric;\n\n  public constructor(\n    options: ISwarmStoreConnectorOrbitDBOptions<ISwarmDatabaseValueTypes>\n  ) {\n    super();\n    SwarmStoreConnectorOrbitDB.loadCustomIdentityProvider();\n    SwarmStoreConnectorOrbitDB.loadCustomAccessController();\n    this.applyOptions(options);\n  }\n\n  /**\n     * waiting for the connection to the swarm, load the database locally\n     * and ready to use it\n    /**\n     *\n     *\n     * @param {ISwarmStoreConnectorOrbitDBConnectionOptions} connectionOptions\n     * @returns {(Promise<void | Error>)}\n     * @memberof SwarmStoreConnectorOrbitDB\n     */\n  public async connect(\n    connectionOptions: ISwarmStoreConnectorOrbitDBConnectionOptions\n  ): Promise<void | Error> {\n    const resultCreateIdentity = await this.createIdentity();\n\n    if (resultCreateIdentity instanceof Error) {\n      console.error(resultCreateIdentity);\n      return this.emitError('Failed to create an identity');\n    }\n\n    const disconnectFromSwarmResult = await this.disconnectFromSwarm();\n\n    if (disconnectFromSwarmResult instanceof Error) {\n      return disconnectFromSwarmResult;\n    }\n\n    const setConnectionOptionsResult = this.setConnectionOptions(\n      connectionOptions\n    );\n\n    if (setConnectionOptionsResult instanceof Error) {\n      return setConnectionOptionsResult;\n    }\n\n    const connectToSwarmResult = await this.connectToSwarm();\n\n    if (connectToSwarmResult instanceof Error) {\n      return connectToSwarmResult;\n    }\n\n    // close the current connections to the databases if exists\n    const closeExistingDatabaseesOpened = await this.closeDatabases();\n\n    if (closeExistingDatabaseesOpened instanceof Error) {\n      return this.emitError(closeExistingDatabaseesOpened, 'openDatabases');\n    }\n\n    // stop the current instance of OrbitDB\n    // if it exists\n    const stopOrbitDBResult = await this.stopOrbitDBInsance();\n\n    if (stopOrbitDBResult instanceof Error) {\n      return stopOrbitDBResult;\n    }\n\n    // create a new OrbitDB instance\n    const createOrbitDbResult = await this.createOrbitDBInstance();\n\n    if (createOrbitDbResult instanceof Error) {\n      return createOrbitDbResult;\n    }\n\n    // create OrbitDB databases\n    const createDatabases = await this.openDatabases();\n\n    if (createDatabases instanceof Error) {\n      return createDatabases;\n    }\n    // set the database is ready to query\n    this.setIsReady(true);\n  }\n\n  public openDatabase = async (\n    dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<\n      ISwarmDatabaseValueTypes\n    >,\n    openAttempt: number = 0,\n    checkOptionsIsExists: boolean = true\n  ): Promise<void | Error> => {\n    const { orbitDb, isClosed } = this;\n\n    if (!orbitDb) {\n      return new Error('There is no instance of OrbitDB');\n    }\n    if (isClosed) {\n      return new Error(\"Can't open a database for the connection opened\");\n    }\n\n    // add options in the main setting only\n    // if options are not exists already\n    // in the list. If options are exists\n    // this may mean that the database was\n    // opened but still not ready to use and\n    // waiting when it will be ready to use.\n    const checkDbOptionsResult = checkOptionsIsExists\n      ? this.setDbOptionsIfNotExists(dbOptions)\n      : this.setDbOptions(dbOptions);\n\n    // options checked and set for valid\n    // calculation of the progress percent\n    if (checkDbOptionsResult instanceof Error) {\n      return checkDbOptionsResult;\n    }\n\n    const { dbName } = dbOptions;\n    const db = this.getDbConnectionExists(dbName);\n\n    if (db) {\n      this.unsetOptionsForDatabase(dbName);\n      return new Error(`A database named as ${dbName} is already exists`);\n    }\n\n    const database = new SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes\n    >(dbOptions, orbitDb);\n\n    this.setListenersDatabaseEvents(database);\n\n    const databaseOpenResult = await this.waitDatabaseOpened(database);\n\n    if (databaseOpenResult instanceof Error) {\n      await this.closeDatabase(database); // close the connection to the database\n      await delay(300);\n      if (\n        openAttempt >\n        SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_RECONNECTION_ATTEMPTS_MAX\n      ) {\n        return this.handleErrorOnDbOpen(\n          database,\n          'The max nunmber of connection attempts has reached'\n        );\n      }\n\n      const openDatabaseResult = await this.openDatabase(\n        dbOptions,\n        (openAttempt += 1)\n      );\n\n      if (openDatabaseResult instanceof Error) {\n        return this.handleErrorOnDbOpen(database, openDatabaseResult);\n      }\n    }\n    this.databases.push(database);\n    this.emit(ESwarmStoreConnectorOrbitDBEventNames.READY, dbOptions.dbName);\n  };\n\n  public async closeDb(dbName: string): Promise<Error | void> {\n    const db = this.getDbConnection(dbName);\n\n    if (db) {\n      return this.closeDatabase(db);\n    }\n    return new Error(`The database named ${dbName} was not found`);\n  }\n\n  /**\n   * make a request to a database by it's name\n   * and a method to execute\n   * @memberof SwarmStoreConnctotOrbitDB\n   */\n  public request = async (\n    dbName: string,\n    dbMethod: TSwarmStoreConnectorOrbitDbDatabaseMathodNames,\n    arg: TSwarmStoreConnectorOrbitDbDatabaseMathodArgument<\n      ISwarmDatabaseValueTypes\n    >\n  ): Promise<Error | any> => {\n    const { isClosed } = this;\n\n    if (isClosed) {\n      return new Error('The Swarm connection was closed');\n    }\n\n    const dbConnection = await this.waitingDbOpened(dbName);\n\n    if (dbConnection instanceof Error) {\n      console.error(dbConnection);\n      return this.emitError(\n        new Error('Failed to get an opened connection to the database')\n      );\n    }\n    return dbConnection[dbMethod](arg as any);\n  };\n\n  /**\n   * close all connections with databases\n   * and the Swarm store\n   * @memberof SwarmStoreConnctotOrbitDB\n   */\n  public close = async (): Promise<Error | void> => {\n    this.setIsClosed();\n\n    const closeAllDatabasesResult = await this.closeDatabases();\n    const stopOrbitDBResult = await this.stopOrbitDBInsance();\n    let err;\n\n    if (closeAllDatabasesResult instanceof Error) {\n      err = true;\n      console.error(closeAllDatabasesResult);\n      this.emitError('Failed to close all databases connections');\n    }\n    if (stopOrbitDBResult instanceof Error) {\n      err = true;\n      console.error(closeAllDatabasesResult);\n      this.emitError('Failed to close the current instanceof OrbitDB');\n    }\n    this.unsetAllListenersForEvents();\n    if (err) {\n      return this.emitError(\n        'Failed to close normally the connection to the swarm store'\n      );\n    }\n  };\n  protected setIsClosed = () => {\n    this.setNotReady();\n    this.isClosed = true;\n    this.emit(ESwarmStoreConnectorOrbitDBEventNames.CLOSE);\n  };\n\n  /**\n   * return an opened connection with the database by it's name\n   * if exists and undefined if it is not exists\n   * @readonly\n   * @protected\n   * @type {(SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes> | void)}\n   * @memberof SwarmStoreConnctotOrbitDB\n   */\n  protected getDbConnection = (\n    dbName: string,\n    checkIsOpen: boolean = true\n  ): SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes> | void => {\n    const { databases } = this;\n\n    return databases.find((db) => {\n      return (\n        db &&\n        db.dbName === dbName &&\n        (!checkIsOpen || (!db.isClosed && !!db.isReady))\n      );\n    });\n  };\n\n  /**\n   * returns a database if exists into the list\n   * of the databases which were opened.\n   * This method do not check whether db\n   * closed and ready.\n   * @protected\n   * @param {string} dbName\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected getDbConnectionExists(dbName: string) {\n    return this.getDbConnection(dbName, false);\n  }\n\n  protected handleDbClose(\n    database: SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>\n  ): void {\n    if (database) {\n      const { dbName } = database;\n\n      this.unsetListenersDatabaseEvents(database);\n      this.unsetOptionsForDatabase(dbName);\n      this.deleteDatabaseFromList(database);\n    }\n  }\n\n  protected handleErrorOnDbOpen(\n    database: SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>,\n    error: Error | string\n  ): Error {\n    if (database) {\n      const { dbName } = database;\n\n      this.handleDbClose(database);\n      console.error(\n        `An error has occurred while database named ${dbName} opening`\n      );\n      console.error(error);\n    }\n    return this.emitError(error);\n  }\n\n  /**\n   * waiting till connection to the database\n   * will be opened or failed. If a db will\n   * not be ready during a timeout return error.\n   * @protected\n   * @param {string} dbName\n   * @returns {(Promise<Error | SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>>)}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected async waitingDbOpened(\n    dbName: string\n  ): Promise<\n    Error | SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>\n  > {\n    const { getDbConnection } = this;\n    const db = getDbConnection(dbName);\n\n    if (db) {\n      return db;\n    } else {\n      const removeListener = this.removeListener.bind(this);\n\n      return new Promise((res) => {\n        let timeout: undefined | NodeJS.Timer;\n        function removeListners() {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = undefined;\n          }\n          removeListener(\n            ESwarmConnectorOrbitDbDatabaseEventNames.READY,\n            onReady\n          );\n          removeListener(\n            ESwarmConnectorOrbitDbDatabaseEventNames.CLOSE,\n            onClose\n          );\n        }\n        function onReady(dbNameReady: string) {\n          if (dbNameReady === dbName) {\n            const db = getDbConnection(dbName);\n\n            if (db) {\n              removeListners();\n              res(db);\n            }\n          }\n        }\n        function onClose() {\n          removeListners();\n          res(new Error('The Swarm store was closed'));\n        }\n\n        timeout = setTimeout(() => {\n          removeListners();\n          res(new Error());\n        }, SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONNECTION_TIMEOUT_MS);\n        this.once(ESwarmConnectorOrbitDbDatabaseEventNames.READY, onReady);\n        this.once(ESwarmConnectorOrbitDbDatabaseEventNames.CLOSE, onClose);\n      });\n    }\n  }\n\n  protected unsetAllListenersForEvents = () => {\n    Object.values(ESwarmStoreConnectorOrbitDBEventNames).forEach(\n      this[COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_UNSET_ALL_LISTENERS].bind(\n        this\n      )\n    );\n  };\n\n  protected emitDatabaseClose(\n    database: SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>\n  ) {\n    if (database) {\n      const { dbName } = database;\n\n      console.warn(`Database named ${dbName} was closed`);\n      this.emit(\n        ESwarmStoreConnectorOrbitDBEventNames.CLOSE_DATABASE,\n        dbName,\n        database\n      );\n    }\n  }\n\n  protected emitError(error: Error | string, mehodName?: string): Error {\n    const err = typeof error === 'string' ? new Error(error) : error;\n\n    console.error(\n      `${SWARM_STORE_CONNECTOR_ORBITDB_LOG_PREFIX}::error${\n        mehodName ? `::${mehodName}` : ''\n      }`,\n      err\n    );\n    this.emit(ESwarmStoreConnectorOrbitDBEventNames.ERROR, err);\n    return err;\n  }\n\n  private setIsReady(isReady: boolean = false) {\n    this.isReady = isReady;\n    this.emit(ESwarmStoreConnectorOrbitDBEventNames.STATE_CHANGE, isReady);\n  }\n\n  /**\n   * set the flag this instance\n   * is not ready to make a\n   * request to databases\n   * @protected\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected setReady() {\n    this.setIsReady(true);\n  }\n\n  protected setNotReady() {\n    this.setIsReady(false);\n  }\n\n  /**\n   * delete the database from the list\n   * of opened databases\n   * @protected\n   * @param {SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>} database\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected deleteDatabaseFromList(\n    database: SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>\n  ) {\n    const { databases } = this;\n\n    if (databases && databases instanceof Array) {\n      commonUtilsArrayDeleteFromArray<\n        SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>\n      >(databases, database);\n    }\n  }\n\n  protected checkDbOptions(\n    options: unknown\n  ): options is ISwarmStoreConnectorOrbitDbDatabaseOptions<\n    ISwarmDatabaseValueTypes\n  > {\n    if (options != null && typeof options === 'object') {\n      const { dbName } = options as { dbName: string };\n\n      return !!dbName && typeof dbName === 'string';\n    }\n    return false;\n  }\n\n  /**\n   * apply options provided for the\n   * instance\n   *\n   * @private\n   * @param {ISwarmStoreConnectorOrbitDBOptions} options\n   * @memberof SwarmStoreConnectorOrbitDB\n   * @throws Error - throw an error if the options are not valid\n   */\n  private applyOptions(\n    options: ISwarmStoreConnectorOrbitDBOptions<ISwarmDatabaseValueTypes>\n  ) {\n    if (!options || typeof options !== 'object') {\n      throw new Error('The options must be an object');\n    }\n\n    this.options = options;\n\n    const { id, credentials, directory } = options;\n\n    if (!id) {\n      console.warn(new Error('The user id is not provided'));\n    } else {\n      this.userId = id;\n    }\n    if (typeof directory === 'string') {\n      this.directory = directory;\n    }\n    if (credentials) {\n      // if credentials provided, then\n      // create the secret keystorage\n      this.createIdentityKeystores(credentials);\n      // create secret storage fabric\n      this.createStorage(credentials);\n    }\n  }\n\n  /**\n   * create keystores for identity provider\n   * throw an error if not valid\n   *\n   * @private\n   * @param {(ISwarmStoreConnectorOrbitDBOptions<ISwarmDatabaseValueTypes>)['credentials']} credentials\n   * @returns {void}\n   * @memberof SwarmStoreConnectorOrbitDB\n   * @throws Error\n   */\n  private createIdentityKeystores(\n    credentials: ISwarmStoreConnectorOrbitDBOptions<\n      ISwarmDatabaseValueTypes\n    >['credentials']\n  ): void {\n    const validateCredentialsResult = SecretStorage.validateCredentials(\n      credentials\n    );\n\n    if (validateCredentialsResult instanceof Error) {\n      console.error(validateCredentialsResult);\n      throw new Error(\n        'createIdentityKeystores::credentials provided are not valid'\n      );\n    }\n\n    const { directory, userId } = this;\n    const identityKeystorePrefix = `${directory}/${userId}`;\n    const identityKeystore = this.createKeystore(\n      credentials,\n      identityKeystorePrefix\n    );\n\n    if (identityKeystore instanceof Error) {\n      console.error(identityKeystore);\n      throw new Error('Failed on create identity keystore');\n    }\n    this.identityKeystore = identityKeystore;\n  }\n\n  /**\n   * create a Storage fabric which is\n   * used by the OrbitDB instance\n   * to generate Cache for a\n   * Keystore and various databases\n   * to read/write values from the\n   * local persistent Cache\n   *\n   * @private\n   * @param {(ISwarmStoreConnectorOrbitDBOptions<ISwarmDatabaseValueTypes>)['credentials']} credentials\n   * @memberof SwarmStoreConnectorOrbitDB\n   * @throws\n   */\n  private createStorage(\n    credentials: ISwarmStoreConnectorOrbitDBOptions<\n      ISwarmDatabaseValueTypes\n    >['credentials']\n  ): void {\n    const validateCredentialsResult = SecretStorage.validateCredentials(\n      credentials\n    );\n\n    if (validateCredentialsResult instanceof Error) {\n      console.error(validateCredentialsResult);\n      throw new Error(\n        'createIdentityKeystores::credentials provided are not valid'\n      );\n    }\n\n    this.storage = new SwarmStoreConnectorOrbitDBSubclassStorageFabric(\n      credentials!\n    );\n  }\n\n  protected createKeystore(\n    credentials: ISwarmStoreConnectorOrbitDBOptions<\n      ISwarmDatabaseValueTypes\n    >['credentials'],\n    keystoreNamePrefix?: string\n  ): Keystore | Error {\n    const keystoreName = `${keystoreNamePrefix ||\n      ''}${SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DBNAME}`;\n\n    if (!credentials) {\n      return this.emitError('createKeystore::A Credentials must be provided');\n    }\n    return new SwarmStorageConnectorOrbitDBSublassKeyStore({\n      credentials,\n      store: keystoreName,\n    });\n  }\n\n  /**\n   * create identity for the user. If the userid\n   * is provided then the identity will be created\n   * by the value of the user id.\n   *\n   * @private\n   * @returns {(Promise<Error | void>)}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  private async createIdentity(): Promise<Error | void> {\n    const { userId } = this;\n\n    try {\n      const identity = await Identities.createIdentity({\n        type: SWARM_STORE_CONNECTOR_ORBITDB_IDENTITY_TYPE,\n        id: userId ? userId : undefined,\n        keystore: this.identityKeystore,\n      });\n\n      if (!userId) {\n        this.userId = identity.id;\n        console.warn(`The user id created automatically is ${userId}`);\n      }\n      if (identity instanceof Error) {\n        return identity;\n      }\n      this.identity = identity;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * return index of the options\n   * for a database name is exists\n   * in the main databases options\n   * (in this.options.databases)\n   * @protected\n   * @param {string} dbName\n   * @returns {number | -1}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected getIdxDbOptions(dbName: string): number {\n    const { options } = this;\n\n    if (options) {\n      const { databases } = options;\n\n      if (databases instanceof Array) {\n        return databases.findIndex(\n          (db) => !!db && typeof db === 'object' && db.dbName === dbName\n        );\n      }\n    }\n    return -1;\n  }\n\n  protected unsetOptionsForDatabase(dbName: string) {\n    const { options } = this;\n\n    if (options) {\n      const { databases } = options;\n\n      if (databases instanceof Array) {\n        const idx = this.getIdxDbOptions(dbName);\n\n        databases.splice(idx, 1);\n      }\n    }\n  }\n\n  /**\n   * set the Database store options in\n   * the main options (this.options.databases)\n   * of all databases\n   * @protected\n   * @param {ISwarmStoreConnectorOrbitDbDatabaseOptions} dbOptions\n   * @param {boolean} [checkIfExists=false]\n   * @returns {(void | Error)}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected setDbOptions(\n    dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<\n      ISwarmDatabaseValueTypes\n    >,\n    checkIfExists: boolean = false\n  ): void | Error {\n    if (!this.checkDbOptions(dbOptions)) {\n      return new Error('The database options have a wrong format');\n    }\n\n    if (checkIfExists) {\n      const { dbName } = dbOptions;\n      const idxExisting = this.getIdxDbOptions(dbName);\n\n      if (idxExisting !== -1) {\n        return new Error(`\n                    Options for the database ${dbName} is already exists.\n                    May be the database was opened but still not be in ready state\n                `);\n      }\n    }\n\n    const { options } = this;\n\n    if (!options) {\n      this.applyOptions({\n        databases: [dbOptions],\n        id: '',\n      });\n      return;\n    }\n\n    const { databases } = options;\n\n    if (databases instanceof Array) {\n      const { dbName } = dbOptions;\n\n      this.unsetOptionsForDatabase(dbName);\n      databases.push(dbOptions);\n    } else {\n      options.databases = [dbOptions];\n    }\n  }\n\n  protected setDbOptionsIfNotExists(\n    dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<\n      ISwarmDatabaseValueTypes\n    >\n  ): void | Error {\n    return this.setDbOptions(dbOptions, true);\n  }\n\n  private async closeDatabase(\n    database: SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>\n  ): Promise<Error | void> {\n    this.unsetListenersDatabaseEvents(database);\n\n    const { dbName } = database;\n\n    this.unsetOptionsForDatabase(dbName);\n    this.deleteDatabaseFromList(database);\n\n    const closeDatabaseResult = await database.close();\n\n    if (closeDatabaseResult instanceof Error) {\n      return this.emitError(closeDatabaseResult);\n    }\n    this.emitDatabaseClose(database);\n  }\n\n  private setConnectionOptions(\n    connectionOptions: ISwarmStoreConnectorOrbitDBConnectionOptions\n  ): void | Error {\n    if (!connectionOptions) {\n      return this.emitError('Connection options must be specified');\n    }\n\n    const { ipfs } = connectionOptions;\n\n    if (!ipfs) {\n      return this.emitError(\n        'An instance of ipfs must be specified in the connection options'\n      );\n    }\n    this.ipfs = ipfs;\n  }\n\n  private unsetSwarmConnectionOptions() {\n    this.ipfs = undefined;\n    this.connectionOptions = undefined;\n  }\n\n  private async disconnectFromSwarm(): Promise<Error | void> {\n    console.warn(\n      `${SWARM_STORE_CONNECTOR_ORBITDB_LOG_PREFIX}::disconnectFromTheSwarm`\n    );\n    this.unsetSwarmConnectionOptions();\n    this.setNotReady();\n  }\n\n  private async connectToSwarm(): Promise<Error | void> {\n    const { ipfs } = this;\n\n    if (!ipfs) {\n      return this.emitError('An instance of the IPFS must be specified');\n    }\n    try {\n      // wait when the ipfs will be ready to use\n      await Promise.race([\n        ipfs.ready,\n        timeout(SWARM_STORE_CONNECTOR_ORBITDB_CONNECTION_TIMEOUT_MS),\n      ]);\n    } catch (err) {\n      return this.emitError(err);\n    }\n  }\n\n  private async stopOrbitDBInsance(): Promise<Error | void> {\n    const { orbitDb } = this;\n\n    if (orbitDb) {\n      try {\n        await orbitDb.stop();\n        this.setNotReady();\n        this.orbitDb = undefined;\n      } catch (err) {\n        return this.emitError(err, 'stopOrbitDBInsance');\n      }\n    }\n  }\n\n  private async createOrbitDBInstance(): Promise<Error | void> {\n    const { ipfs, identity, storage } = this;\n\n    if (!ipfs) {\n      return this.emitError(\n        'An instance of IPFS must exists',\n        'createOrbitDBInstance'\n      );\n    }\n    try {\n      if (!OrbitDB) {\n        return this.emitError('A constructor of the OrbitDb is not provided');\n      }\n      if (!identity) {\n        return this.emitError('An identity must be specified');\n      }\n\n      const instanceOfOrbitDB = await OrbitDB.createInstance(ipfs, {\n        identity,\n        storage,\n      });\n\n      if (instanceOfOrbitDB instanceof Error) {\n        return this.emitError(\n          instanceOfOrbitDB,\n          'createOrbitDBInstance::error has occurred in the \"createInstance\" method'\n        );\n      }\n      this.orbitDb = instanceOfOrbitDB;\n    } catch (err) {\n      return this.emitError(\n        err,\n        'createOrbitDBInstance::failed to create the instance of OrbitDB'\n      );\n    }\n  }\n\n  protected getDbOptions(\n    dbName: string\n  ):\n    | ISwarmStoreConnectorOrbitDbDatabaseOptions<ISwarmDatabaseValueTypes>\n    | void\n    | Error {\n    const { options } = this;\n\n    if (!options) {\n      return this.emitError(\n        'An options is not specified for the database',\n        `getDbOptions::${dbName}`\n      );\n    }\n\n    const { databases: databases } = options;\n\n    return databases.find((option) => option && option.dbName === dbName);\n  }\n\n  protected stop(): Promise<Error | void> {\n    this.setNotReady();\n    return this.closeDatabases();\n  }\n\n  /**\n   * open database and not check if an options are\n   * exists for the database (replace if exists)\n   * @private\n   * @param {ISwarmStoreConnectorOrbitDbDatabaseOptions} optionsForDb\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  private openDatabaseNotCheckOptionsExists(\n    optionsForDb: ISwarmStoreConnectorOrbitDbDatabaseOptions<\n      ISwarmDatabaseValueTypes\n    >\n  ): Promise<void | Error> {\n    return this.openDatabase(optionsForDb, 0, false);\n  }\n\n  private async restartDbConnection(\n    dbName: string,\n    database: SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>\n  ): Promise<void | Error> {\n    //try to restart the database\n    const optionsForDb = this.getDbOptions(dbName);\n\n    this.unsetListenersDatabaseEvents(database);\n    if (optionsForDb instanceof Error || !optionsForDb) {\n      this.emitError(\n        'Failed to get options to open a new db store',\n        `restartDbConnection::${dbName}`\n      );\n      return this.stop();\n    }\n\n    const startDbResult = await this.openDatabaseNotCheckOptionsExists(\n      optionsForDb\n    );\n\n    if (startDbResult instanceof Error) {\n      this.emitError(\n        'Failed to open a new db store',\n        `restartDbConnection::${dbName}`\n      );\n      return this.stop();\n    }\n  }\n\n  protected removeDbFromList(\n    database: SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>\n  ) {\n    if (this.databases instanceof Array) {\n      commonUtilsArrayDeleteFromArray<\n        SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>\n      >(this.databases, database);\n    }\n  }\n\n  private handleDatabaseStoreClosed = (\n    database: SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>\n  ) => {\n    if (database) {\n      const { dbName } = database;\n\n      this.emitError(\n        'Database closed unexpected',\n        `handleDatabaseStoreClosed::${dbName}`\n      );\n      this.handleDbClose(database);\n      this.restartDbConnection(dbName, database);\n    }\n  };\n\n  private handleLoadingProgress = (dbName: string, progress: number): void => {\n    /* \n            databases - is a list of the databases opened already\n            it means that the loading progress for this databases\n            is 100%\n        */\n    const { databases, options } = this;\n    let currentProgressInPercent = 0;\n\n    if (options) {\n      /* \n                overallDatabases - is a list of all databases\n                which are must be opened\n            */\n      const { databases: overallDatabases } = options;\n      // the progress which will be reached\n      // on all the databases will be opened\n      const overallProgressToReach = overallDatabases.length * 100;\n      // progress reached at this time\n      const currentProgress =\n        (databases ? databases.length : 0) * 100 + progress;\n      // the progress reached at this time in a percentage\n      currentProgressInPercent = currentProgress\n        ? (overallProgressToReach / currentProgress) * 100\n        : 0;\n    }\n    console.log(\n      `Swarm store connector::handleLoadingProgress::${dbName}::progress::${progress}`\n    );\n    this.emit(\n      ESwarmStoreConnectorOrbitDBEventNames.LOADING,\n      currentProgressInPercent\n    );\n  };\n\n  private handleDatabaseUpdated = (dbName: string) => {\n    this.emit(ESwarmConnectorOrbitDbDatabaseEventNames.UPDATE, dbName);\n  };\n\n  private async setListenersDatabaseEvents(\n    database: SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>,\n    isSet: boolean = true\n  ): Promise<Error | void> {\n    const methodName = isSet\n      ? COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON\n      : COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_OFF;\n\n    database[methodName](\n      ESwarmConnectorOrbitDbDatabaseEventNames.CLOSE,\n      this.handleDatabaseStoreClosed\n    );\n    database[methodName](\n      ESwarmConnectorOrbitDbDatabaseEventNames.LOADING,\n      this.handleLoadingProgress\n    );\n    database[methodName](\n      ESwarmConnectorOrbitDbDatabaseEventNames.UPDATE,\n      this.handleDatabaseUpdated\n    );\n    database[methodName](\n      ESwarmConnectorOrbitDbDatabaseEventNames.FATAL,\n      this.handleDatabaseStoreClosed\n    );\n  }\n\n  private async unsetListenersDatabaseEvents(\n    database: SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>\n  ): Promise<Error | void> {\n    this.setListenersDatabaseEvents(database, false);\n  }\n\n  private async closeDatabases(): Promise<Error | void> {\n    const { databases } = this;\n\n    // set that the orbit db is not ready to use\n    this.setNotReady();\n    if (!databases || !databases.length) {\n      return;\n    }\n\n    try {\n      let idx = 0;\n      const databasesToClose = [...databases];\n      const len = databasesToClose.length;\n\n      for (; idx < len; idx += 1) {\n        const db = databasesToClose[idx];\n        const dbCloseResult = await this.closeDatabase(db);\n\n        if (dbCloseResult instanceof Error) {\n          console.error(this.emitError(dbCloseResult));\n          this.emitError(\n            'An error has occurred on closing the database',\n            'closeDatabases'\n          );\n        }\n      }\n      this.databases = [];\n    } catch (err) {\n      return err;\n    }\n  }\n\n  private waitDatabaseOpened(\n    database: SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>\n  ): Promise<Error | boolean> {\n    return new Promise<Error | boolean>(async (res) => {\n      let timeout: NodeJS.Timer | undefined = undefined;\n\n      function usetListeners() {\n        database.removeListener(\n          ESwarmConnectorOrbitDbDatabaseEventNames.READY,\n          res\n        );\n        database.removeListener(\n          ESwarmConnectorOrbitDbDatabaseEventNames.CLOSE,\n          res\n        );\n        database.removeListener(\n          ESwarmConnectorOrbitDbDatabaseEventNames.FATAL,\n          res\n        );\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        timeout = undefined;\n      }\n\n      timeout = setTimeout(() => {\n        usetListeners();\n        res(\n          new Error('Failed to open the database cause the timeout has reached')\n        );\n      }, SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONNECTION_TIMEOUT_MS);\n      try {\n        database.once(ESwarmConnectorOrbitDbDatabaseEventNames.CLOSE, () => {\n          usetListeners();\n          res(new Error('Database was closed'));\n        });\n        database.once(ESwarmConnectorOrbitDbDatabaseEventNames.FATAL, () => {\n          usetListeners();\n          res(new Error('A fatal error has occurred while open the database'));\n        });\n        database.once(ESwarmConnectorOrbitDbDatabaseEventNames.READY, () => {\n          usetListeners();\n          res(true);\n        });\n\n        //connect to the database\n        // and wait for an events from it\n        const connectResult = await database.connect();\n\n        if (connectResult instanceof Error) {\n          usetListeners();\n          console.error(connectResult);\n          return this.emitError('The database.connect method was failed');\n        }\n      } catch (err) {\n        console.error(err);\n        usetListeners();\n        res(err);\n      }\n    });\n  }\n\n  private async openDatabases(): Promise<Error | void> {\n    const { options } = this;\n\n    if (!options) {\n      return this.emitError(\n        'The options must be specified to open the databases'\n      );\n    }\n\n    const { databases } = options;\n    const databasesOptions = [...databases];\n\n    if (!(databasesOptions instanceof Array) || !databasesOptions.length) {\n      return this.emitError('The options for databases must be specified');\n    }\n\n    try {\n      let idx = 0;\n      const len = databasesOptions.length;\n\n      for (; idx < len; idx += 1) {\n        const options = databasesOptions[idx];\n        const startResultStatus = await this.openDatabaseNotCheckOptionsExists(\n          options\n        );\n\n        if (startResultStatus instanceof Error) {\n          console.error(startResultStatus);\n          await this.closeDatabases();\n          return new Error('Failed to open the database');\n        }\n      }\n    } catch (err) {\n      await this.closeDatabases();\n      return this.emitError(err);\n    }\n  }\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/const/common-date-time/common-date-time-timezone.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/const/common-values/common-values.ts",[],"/home/paul/projects/decentrilized-protocol/src/const/const-validation-schemes/const-validation-schemes-common.ts",[],"/home/paul/projects/decentrilized-protocol/src/const/const-validation-schemes/const-validation-schemes-credentials.ts",[],"/home/paul/projects/decentrilized-protocol/src/const/const-validation-schemes/const-validation-schemes.ts",[],"/home/paul/projects/decentrilized-protocol/src/const/const-validation-values/const-validation-values-messaging-common/const-validation-values-messaging-common.ts",["1353"],"import { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport { IValidationValuesMessagingDateSyncIntervalEvents } from './const-validation-values-messaging-common.types';\n\nexport const CONST_VALIDATION_VALUES_MESSAGING_DATE_SYNC_INTERVAL_MS = 1000;\n\nexport const CONST_VALIDATION_VALUES_MESSAGING_DATE_SYNC_INTERVAL_EVENT =\n  'VALIDATION_VALUES_MESSAGING_DATE_SYNC_INTERVAL_EVENT';\n\nexport const timeIntervalSyncEvents = new EventEmitter<\n  IValidationValuesMessagingDateSyncIntervalEvents\n>();\n\nfunction dateTimeSyncTick() {\n  timeIntervalSyncEvents.emit(\n    CONST_VALIDATION_VALUES_MESSAGING_DATE_SYNC_INTERVAL_EVENT\n  );\n}\nsetInterval(\n  dateTimeSyncTick,\n  CONST_VALIDATION_VALUES_MESSAGING_DATE_SYNC_INTERVAL_MS\n);\n","/home/paul/projects/decentrilized-protocol/src/const/const-validation-values/const-validation-values-messaging-common/const-validation-values-messaging-common.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/const/const-validation-values/const-validation-values-messaging-date.ts",["1354"],"import {\n  getCurrentDate,\n  getDateWithTimeSyncOffset,\n} from 'utils/common-utils/common-utils-date-time';\nimport {\n  CONST_VALIDATION_VALUES_MESSAGING_DATE_SYNC_INTERVAL_EVENT,\n  timeIntervalSyncEvents,\n} from './const-validation-values-messaging-common/const-validation-values-messaging-common';\n\nexport const CONST_VALIDATION_VALUES_MESSAGING_MAX_ERROR_SECONDS = 70;\n\nexport const CONST_VALIDATION_VALUES_MESSAGING_DATE_MIN_YEAR = '2019';\n\nexport const CONST_VALIDATION_VALUES_MESSAGING_DATE_MIN_YEAR_MONTH = '01';\n\nexport const CONST_VALIDATION_VALUES_MESSAGING_DATE_MIN_YEAR_MONTH_DAY = '01';\n\nexport const CONST_VALIDATION_VALUES_MESSAGING_DATE_MIN_STRING_IN_UTC = `${CONST_VALIDATION_VALUES_MESSAGING_DATE_MIN_YEAR}-${CONST_VALIDATION_VALUES_MESSAGING_DATE_MIN_YEAR_MONTH}-${CONST_VALIDATION_VALUES_MESSAGING_DATE_MIN_YEAR_MONTH_DAY}T00:00:00.00Z`;\n\nexport const CONST_VALIDATION_VALUES_MESSAGING_DATE_MIN = getDateWithTimeSyncOffset(\n  new Date(CONST_VALIDATION_VALUES_MESSAGING_DATE_MIN_STRING_IN_UTC)\n);\n\nexport let CONST_VALIDATION_VALUES_MESSAGING_DATE_MAX = getCurrentDate();\n\nfunction setDateMax() {\n  const d = getCurrentDate();\n\n  d.setSeconds(\n    d.getSeconds() + CONST_VALIDATION_VALUES_MESSAGING_MAX_ERROR_SECONDS\n  );\n  CONST_VALIDATION_VALUES_MESSAGING_DATE_MAX = d;\n}\n\ntimeIntervalSyncEvents.on(\n  CONST_VALIDATION_VALUES_MESSAGING_DATE_SYNC_INTERVAL_EVENT,\n  setDateMax\n);\n","/home/paul/projects/decentrilized-protocol/src/const/const-validation-values/const-validation-values-messaging-timestamp.ts",["1355"],"import {\n  CONST_VALIDATION_VALUES_MESSAGING_DATE_MIN,\n  CONST_VALIDATION_VALUES_MESSAGING_DATE_MAX,\n} from './const-validation-values-messaging-date';\nimport { getSecondsByMilliseconds } from 'utils/common-utils/common-utils-date-time';\nimport {\n  CONST_VALIDATION_VALUES_MESSAGING_DATE_SYNC_INTERVAL_EVENT,\n  timeIntervalSyncEvents,\n} from './const-validation-values-messaging-common/const-validation-values-messaging-common';\n\nexport const CONST_VALIDATION_VALUES_TIMESTAMP_UNIX_MIN_MS = CONST_VALIDATION_VALUES_MESSAGING_DATE_MIN.getTime();\n\nexport const CONST_VALIDATION_VALUES_TIMESTAMP_UNIX_MIN_S = getSecondsByMilliseconds(\n  CONST_VALIDATION_VALUES_TIMESTAMP_UNIX_MIN_MS\n);\n\nexport let CONST_VALIDATION_VALUES_TIMESTAMP_UNIX_MAX_MS = CONST_VALIDATION_VALUES_MESSAGING_DATE_MAX.getTime();\n\nexport let CONST_VALIDATION_VALUES_TIMESTAMP_UNIX_MAX_S = getSecondsByMilliseconds(\n  CONST_VALIDATION_VALUES_TIMESTAMP_UNIX_MAX_MS\n);\n\nfunction setTimestampsMaxByDateMax() {\n  CONST_VALIDATION_VALUES_TIMESTAMP_UNIX_MAX_MS = CONST_VALIDATION_VALUES_MESSAGING_DATE_MAX.getTime();\n  CONST_VALIDATION_VALUES_TIMESTAMP_UNIX_MAX_S = getSecondsByMilliseconds(\n    CONST_VALIDATION_VALUES_TIMESTAMP_UNIX_MAX_MS\n  );\n}\n\ntimeIntervalSyncEvents.on(\n  CONST_VALIDATION_VALUES_MESSAGING_DATE_SYNC_INTERVAL_EVENT,\n  setTimestampsMaxByDateMax\n);\n","/home/paul/projects/decentrilized-protocol/src/const/const-values-restrictions-common.ts",[],"/home/paul/projects/decentrilized-protocol/src/index.tsx",[],"/home/paul/projects/decentrilized-protocol/src/react-app-env.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/test/data-sign-test.ts",["1356"],"import {\n  generateKeyPair,\n  exportKeyPairAsString,\n  importKeyPairFromString,\n  signToString,\n  verifyFromString,\n} from 'utils/data-sign-utils';\nimport { calculateHash } from 'utils/hash-calculation-utils';\n\nconst testDataSigning = async () => {\n  const keyPair = await generateKeyPair();\n\n  if (keyPair instanceof Error) {\n    console.error(keyPair);\n    return;\n  }\n  console.log('keyPair', keyPair);\n\n  const exportedKeyPair = await exportKeyPairAsString(keyPair);\n\n  if (exportedKeyPair instanceof Error) {\n    console.error(exportedKeyPair);\n    return;\n  }\n  console.log('exportedKeyPair', exportedKeyPair);\n\n  const keyPairImported = await importKeyPairFromString(exportedKeyPair);\n\n  if (keyPairImported instanceof Error) {\n    console.error(keyPairImported);\n    return keyPairImported;\n  }\n  console.log('keyPairImported', keyPairImported);\n\n  const exportedKeyPairByImported = await exportKeyPairAsString(\n    keyPairImported\n  );\n\n  if (exportedKeyPairByImported instanceof Error) {\n    console.error(exportedKeyPairByImported);\n    return;\n  }\n  console.log('exportedKeyPairByImported', exportedKeyPairByImported);\n  console.log(\n    'exportedKeyPairByImported === exportedKeyPair',\n    exportedKeyPairByImported === exportedKeyPair\n  );\n\n  const data = { d: 1 };\n  const signString = await signToString(keyPairImported.privateKey, data);\n\n  if (signString instanceof Error) {\n    console.error(signString);\n    return;\n  }\n\n  console.log('signString', signString);\n\n  const dataTwice = await calculateHash('2222');\n\n  if (dataTwice instanceof Error) {\n    console.error(dataTwice);\n    return dataTwice;\n  }\n\n  const signStringTwice = await signToString(\n    keyPairImported.privateKey,\n    dataTwice\n  );\n\n  if (signStringTwice instanceof Error) {\n    console.error(signStringTwice);\n    return;\n  }\n\n  console.log('signStringTwice', signStringTwice);\n\n  const isValid = await verifyFromString(keyPairImported, data, signString);\n\n  if (isValid instanceof Error) {\n    console.error(isValid);\n    return isValid;\n  }\n  console.log('isValid', isValid);\n\n  const isValidTwice = await verifyFromString(\n    keyPairImported,\n    dataTwice,\n    signStringTwice\n  );\n\n  if (isValidTwice instanceof Error) {\n    console.error(isValidTwice);\n    return isValidTwice;\n  }\n  console.log('isValidTwice', isValidTwice);\n};\ntestDataSigning();\n","/home/paul/projects/decentrilized-protocol/src/test/encryption-test.ts",["1357","1358","1359","1360","1361","1362","1363","1364","1365","1366","1367","1368"],"import {\n  generateKeyPair,\n  encryptNative,\n  decryptNative,\n  exportKeyPairAsString,\n  importKeyPairFromString,\n  encryptToString,\n  decryptFromString,\n  encryptToTypedArray,\n} from 'utils/encryption-utils';\nimport { calculateHash } from 'utils/hash-calculation-utils';\n\nfunction arrayBufferToBase64(buffer: ArrayBuffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  const len = bytes.byteLength;\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return window.btoa(binary);\n}\n\nconst testEncryption = async () => {\n  const kPair = await generateKeyPair();\n\n  if (kPair instanceof Error) {\n    console.error(kPair);\n  } else {\n    /** THE FIRST USE-CASE */\n    // console.log('export key pair', kPair);\n    // const dataToChiper = '245';\n    // const encryptedData = await encryptNative(\n    //   kPair.publicKey,\n    //   decode(btoa(dataToChiper))\n    // );\n    // if (encryptedData instanceof Error) {\n    //   console.error(encryptedData);\n    // } else {\n    //   const decryptedData = await decryptNative(\n    //     kPair.privateKey,\n    //     decode(encode(encryptedData))\n    //   );\n    //   if (decryptedData instanceof Error) {\n    //     console.error(decryptedData);\n    //   } else {\n    //     console.log('decrypted', atob(encode(decryptedData)));\n    //   }\n    //\n    /** THE SECOND USE-CASE */\n    // const exportedKeyPairString = await exportKeyPairAsString(kPair);\n    // console.log(exportedKeyPairString);\n    // const importedKeyPair = await importKeyPairFromString(\n    //   exportedKeyPairString\n    // );\n    // if (importedKeyPair instanceof Error) {\n    //   throw importedKeyPair;\n    // }\n    // const encryptedStringByExported = await encryptToString(\n    //   importedKeyPair,\n    //   'this is a long long text'\n    // );\n    // const encryptedStringByImported = await encryptToTypedArray(\n    //   exportedKeyPairString,\n    //   'this is a long long text'\n    // );\n    // console.log('encryptedStringByExported', encryptedStringByExported);\n    // console.log('encryptedStringByImported', encryptedStringByImported);\n    // if (!(encryptedStringByExported instanceof Error)) {\n    //   const decrypted = await decryptFromString(\n    //     importedKeyPair,\n    //     encryptedStringByExported\n    //   );\n    //   if (!(decrypted instanceof Error)) {\n    //     console.log('decrypted', decrypted);\n    //   }\n    // }\n    /** HASH CALCULATION */\n    // const hashStrOnce = await calculateHash({ d: 1 });\n    // const hashStrTwice = await calculateHash({ d: 1 });\n    // console.log(hashStrOnce);\n    // console.log(hashStrTwice);\n    // if (hashStrTwice !== hashStrOnce) {\n    //   console.error(new Error('Hash of the same data does not matching'));\n    // }\n    /** HASH CALCULATION STRING */\n    // const stringData =\n    //   '\"1233465)()09850MNLKADFNDSLKJGN%$%^$^#&#^@&*^)(&$#^&%*#%\"';\n    // const hashStrThird = await calculateHash(stringData);\n    // const hashStrFourth = await calculateHash(stringData);\n    // console.log(hashStrThird);\n    // console.log(hashStrFourth);\n    // if (hashStrThird !== hashStrFourth) {\n    //   console.error(new Error('Hash of the same data does not matching'));\n    // }\n  }\n};\n// testEncryption();\n","/home/paul/projects/decentrilized-protocol/src/test/error-extended-class-test.ts",["1369"],"import { ErrorExtendedBaseClass } from 'classes/basic-classes/error-extended-class-base/error-extended-class-base';\n\nexport const runTestErrorExtended = () => {\n  console.warn('test ErrorExtendedBaseClass was started');\n  const errExtendedEmpty = new ErrorExtendedBaseClass();\n\n  if (!(errExtendedEmpty instanceof Error)) {\n    console.error('ErrorExtended must be an instance of the Error');\n    return;\n  }\n\n  const errorMessageEmpty = errExtendedEmpty.toString();\n\n  if (typeof errorMessageEmpty !== 'string') {\n    console.error('Error message must be a string');\n    return;\n  }\n\n  const errorMessageTest = 'Test error message';\n  const errorStringNoCode = new ErrorExtendedBaseClass(errorMessageTest);\n\n  if (!(errorStringNoCode instanceof Error)) {\n    console.error('errorMessageStringNoCode must be an instance of Error');\n    return;\n  }\n\n  const errorMessageStringNoCode = errorStringNoCode.toString();\n\n  if (errorMessageStringNoCode !== errorMessageTest) {\n    console.error(\n      'The error stringified with no code must be equal to the string passed as argument'\n    );\n    return;\n  }\n\n  const errorWithMessageAndCodeMessage = 'Test error with code';\n  const errorWithMessageAndCodeCode = 100;\n  const errorWithMessageAndCode = new ErrorExtendedBaseClass(\n    errorWithMessageAndCodeMessage,\n    errorWithMessageAndCodeCode\n  );\n\n  if (!(errorWithMessageAndCode instanceof Error)) {\n    console.error('errorWithMessageAndCode must be an instance of Error');\n    return;\n  }\n\n  const { code: errorWithMessageAndCodeCodeResult } = errorWithMessageAndCode;\n\n  if (errorWithMessageAndCodeCodeResult !== errorWithMessageAndCodeCode) {\n    console.error('The error code must be equal to the passed');\n    return;\n  }\n\n  const {\n    message: errorWithMessageAndCodeMessageResult,\n  } = errorWithMessageAndCode;\n\n  if (\n    !errorWithMessageAndCodeMessageResult.includes(\n      errorWithMessageAndCodeMessage\n    )\n  ) {\n    console.error(\n      'The error message must includes the string passed as argument'\n    );\n    return;\n  }\n\n  const errorWithMessageAndCodeStringified = String(errorWithMessageAndCode);\n\n  if (\n    !errorWithMessageAndCodeStringified.includes(\n      `Error code: ${errorWithMessageAndCodeCode}`\n    )\n  ) {\n    console.error(\n      'The error stringified must includes the code passed as argument'\n    );\n    return;\n  }\n  if (\n    !errorWithMessageAndCodeStringified.includes(errorWithMessageAndCodeMessage)\n  ) {\n    console.error(\n      'The error stringified must includes the string message passed as argument'\n    );\n    return;\n  }\n\n  const errorMessageByErrorExtendedBaseClass = new ErrorExtendedBaseClass(\n    errorWithMessageAndCode\n  );\n\n  if (errorMessageByErrorExtendedBaseClass !== errorWithMessageAndCode) {\n    console.error(\n      'Error extended created depending on an instance of ErrorExtendedBaseClass must be equal to the argument passeds'\n    );\n    return;\n  }\n  console.warn('test ErrorExtendedBaseClass was succeed');\n};\n","/home/paul/projects/decentrilized-protocol/src/test/ipfs-swarm-connection.test/ipfs-swarm-connection.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/test/mocha-chai-initialize.ts",["1370","1371","1372"],"/* global mocha */\nimport { lazyLoadScript } from 'utils/lazy-loading-utils/lazy-loading-utils';\nimport Mocha from 'mocha';\nimport chai from 'chai';\nimport chaiAsPromised from 'chai-as-promised';\n\nconst MOCHA_CDN_URL =\n  'https://cdnjs.cloudflare.com/ajax/libs/mocha/6.2.1/mocha.min.js';\n\nexport async function initializeMocha() {\n  const mochaNode = document.createElement('div');\n\n  mochaNode.id = 'mocha';\n  document.body.prepend(mochaNode);\n  try {\n    await lazyLoadScript(MOCHA_CDN_URL);\n  } catch (err) {\n    console.error('Failed to load Mocha from cdn');\n    return err;\n  }\n\n  const mochaSetupScript = document.createElement('script');\n\n  mochaSetupScript.type = 'text/javascript';\n  mochaSetupScript.className = 'mocha-init';\n  mochaSetupScript.innerHTML = `\n        mocha.setup({\n            ui: 'bdd',\n            globals: ['globalThis']\n        });\n        mocha.checkLeaks();\n    `;\n  document.body.append(mochaSetupScript);\n  chai.use(chaiAsPromised);\n}\n\ntype TCallbackMochaRun = (failures: number) => void;\n\nexport function runMocha(\n  showErrorsOverlay: boolean = true,\n  cb?: TCallbackMochaRun\n) {\n  // it's necessary to disable\n  // error overlay to run test\n  // with mocha\n  if (!showErrorsOverlay) {\n    const hideErrorFrameStyle = document.createElement('style');\n\n    hideErrorFrameStyle.type = 'text/css';\n    hideErrorFrameStyle.innerHTML = `\n            body > iframe {\n                display: none;\n            }\n        `;\n    document.head.appendChild(hideErrorFrameStyle);\n  }\n  mocha.run(cb);\n}\n","/home/paul/projects/decentrilized-protocol/src/test/validation-messaging.test/validate-messaging-timestamps-test.ts",["1373"],"import { expect } from 'chai';\nimport {\n  DATE_MIN_NOT_VALID,\n  DATE_MIN_VALID,\n} from './validation-messaging.test.const';\nimport { validateUtilsTimestampNewMessage } from 'utils/validation-utils/validation-utils-timestamp';\nimport { getSecondsByMilliseconds } from 'utils/common-utils/common-utils-date-time';\n\nexport const runTestValidateMessagingTimestampsTest = () => {\n  describe('validation of messages timestamps test', () => {\n    it('validation of the minimum timestamp value - should return error', () => {\n      const timestampMinNotValid = getSecondsByMilliseconds(\n        DATE_MIN_NOT_VALID.getTime()\n      );\n      const result = validateUtilsTimestampNewMessage(timestampMinNotValid);\n\n      expect(result)\n        .to.be.an('error')\n        .which.haveOwnProperty(\n          'message',\n          'The timestamp is less than the minimal valid timestamp'\n        );\n    });\n\n    it('validation of the minimum timestamp value - should return true', () => {\n      const timestampMinValid = getSecondsByMilliseconds(\n        DATE_MIN_VALID.getTime()\n      );\n      const result = validateUtilsTimestampNewMessage(timestampMinValid);\n\n      expect(result).to.be.equal(true);\n    });\n\n    it('validation of the minimum timestamp value - should return error to zero', () => {\n      const result = validateUtilsTimestampNewMessage(0);\n\n      expect(result)\n        .to.be.an('error')\n        .which.haveOwnProperty(\n          'message',\n          'Timestamp of a message must be defined'\n        );\n    });\n  });\n};\n","/home/paul/projects/decentrilized-protocol/src/types/channels.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/types/encryption-keys.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/types/helper.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/types/ipfs.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/types/ipfs.types.d.ts",["1374","1375","1376","1377","1378","1379","1380","1381","1382","1383","1384","1385","1386","1387","1388","1389","1390","1391","1392","1393","1394","1395","1396","1397","1398","1399","1400","1401","1402","1403","1404","1405","1406","1407","1408","1409","1410","1411","1412","1413","1414","1415","1416","1417","1418","1419","1420","1421","1422","1423","1424","1425","1426","1427","1428","1429","1430","1431","1432","1433","1434","1435","1436","1437","1438","1439","1440","1441","1442","1443","1444","1445","1446","1447","1448","1449","1450","1451","1452","1453","1454","1455","1456","1457","1458","1459","1460","1461","1462","1463","1464","1465","1466","1467","1468","1469","1470","1471","1472","1473","1474","1475","1476","1477","1478","1479","1480","1481","1482","1483","1484","1485","1486","1487","1488"],"import { EventEmitter } from 'events';\n\ndeclare module 'ipfs' {}\n\ntype Callback<T> = (error: Error, result?: T) => void;\n\nexport class IPFS extends EventEmitter {\n  constructor(options?: Options);\n\n  types: Types;\n\n  init(options: InitOptions, callback: Callback<boolean>): void;\n  init(callback: Callback<boolean>): void;\n\n  preStart(callback: Callback<any>): void;\n  start(callback?: Callback<any>): void;\n  stop(callback?: (error?: Error) => void): void;\n  isOnline(): boolean;\n\n  version(\n    options: any,\n    callback: (error: Error, version: Version) => void\n  ): void;\n  version(options: any): Promise<Version>;\n  version(callback: (error: Error, version: Version) => void): void;\n  version(): Promise<Version>;\n\n  id(options: any, callback: (error: Error, version: Id) => void): void;\n  id(options: any): Promise<Id>;\n  id(callback: (error: Error, version: Id) => void): void;\n  id(): Promise<Id>;\n\n  ready: Promise<boolean>;\n  repo: RepoAPI;\n  bootstrap: any;\n  config: any;\n  block: any;\n  object: ObjectAPI;\n  dag: DagAPI;\n  libp2p: any;\n  swarm: SwarmAPI;\n  files: FilesAPI;\n  bitswap: Bitswap;\n\n  ping(callback: (error: Error) => void): void;\n  ping(): Promise<void>;\n\n  pubsub: Pubsub;\n\n  on(event: string, callback: () => void): this;\n  on(event: 'error', callback: (error: Error) => void): this;\n  once(event: string, callback: () => void): this;\n}\n\nexport interface Options {\n  init?: boolean;\n  start?: boolean;\n  EXPERIMENTAL?: any;\n  repo?: string;\n  config?: any;\n}\n\nexport interface InitOptions {\n  emptyRepo?: boolean;\n  bits?: number;\n  log?: Function;\n}\n\nexport interface Multiaddr {\n  buffer: Uint8Array;\n}\n\nexport type Multihash = any | string;\nexport type CID = any;\n\nexport interface Types {\n  Buffer: any;\n  PeerId: string | any;\n  PeerInfo: any;\n  multiaddr: Multiaddr;\n  multihash: Multihash;\n  CID: CID;\n}\n\nexport interface Version {\n  version: string;\n  repo: string;\n  commit: string;\n}\n\nexport interface Id {\n  id: string;\n  publicKey: string;\n  addresses: Multiaddr[];\n  agentVersion: string;\n  protocolVersion: string;\n}\n\nexport interface RepoAPI {\n  init(bits: number, empty: boolean, callback: Callback<any>): void;\n\n  version(options: any, callback: Callback<any>): void;\n  version(callback: Callback<any>): void;\n\n  gc(): void;\n  path(): string;\n}\n\nexport type FileContent = Record<string, any> | Blob | string;\n\n/** old version? */\nexport interface IPFSFile {\n  path: string;\n  hash: string;\n  size: number;\n  content?: FileContent;\n}\n\nexport interface IPFSGetResult {\n  depth: number;\n  name: string;\n  path: string;\n  size: number;\n  hash: Buffer;\n  content: Buffer;\n  type: 'file' | string;\n}\n\nexport interface FilesAPI {\n  createAddStream(options: any, callback: Callback<any>): void;\n  createAddStream(callback: Callback<any>): void;\n\n  createPullStream(options: any): any;\n\n  add(data: FileContent, options: any, callback: Callback<IPFSFile[]>): void;\n  add(data: FileContent, options: any): Promise<IPFSFile[]>;\n  add(data: FileContent, callback: Callback<IPFSFile[]>): void;\n  add(data: FileContent): Promise<IPFSFile[]>;\n\n  cat(hash: Multihash, callback: Callback<FileContent>): void;\n  cat(hash: Multihash): Promise<FileContent>;\n\n  get(hash: Multihash, callback: Callback<IPFSFile | IPFSGetResult[]>): void;\n  get(hash: Multihash): Promise<IPFSFile | IPFSGetResult[]>;\n\n  getPull(hash: Multihash, callback: Callback<any>): void;\n}\n\nexport interface PeersOptions {\n  v?: boolean;\n  verbose?: boolean;\n}\n\nexport type PeerId = any;\n\nexport interface PeerInfo {\n  id: PeerId;\n  multiaddr: Multiaddr;\n  multiaddrs: Multiaddr[];\n  distinctMultiaddr(): Multiaddr[];\n}\n\nexport interface Peer {\n  addr: Multiaddr;\n  peer: PeerInfo;\n}\n\nexport interface SwarmAPI {\n  peers(options: PeersOptions, callback: Callback<Peer[]>): void;\n  peers(options: PeersOptions): Promise<Peer[]>;\n  peers(callback: Callback<Peer[]>): void;\n  peers(): Promise<Peer[]>;\n\n  addrs(callback: Callback<PeerInfo[]>): void;\n  addrs(): Promise<PeerInfo[]>;\n\n  localAddrs(callback: Callback<Multiaddr[]>): void;\n  localAddrs(): Promise<Multiaddr[]>;\n\n  connect(maddr: Multiaddr | string, callback: Callback<any>): void;\n  connect(maddr: Multiaddr | string): Promise<any>;\n\n  disconnect(maddr: Multiaddr | string, callback: Callback<any>): void;\n  disconnect(maddr: Multiaddr | string): Promise<any>;\n\n  filters(callback: Callback<void>): never;\n}\n\nexport type DAGNode = any;\nexport type DAGLink = any;\nexport type DAGLinkRef = DAGLink | any;\nexport type Obj = BufferSource | Record<string, any>;\n\nexport interface ObjectStat {\n  Hash: Multihash;\n  NumLinks: number;\n  BlockSize: number;\n  LinksSize: number;\n  DataSize: number;\n  CumulativeSize: number;\n}\n\nexport interface PutObjectOptions {\n  enc?: any;\n}\n\nexport interface GetObjectOptions {\n  enc?: any;\n}\n\nexport interface ObjectPatchAPI {\n  addLink(\n    multihash: Multihash,\n    link: DAGLink,\n    options: GetObjectOptions,\n    callback: Callback<any>\n  ): void;\n  addLink(\n    multihash: Multihash,\n    link: DAGLink,\n    options: GetObjectOptions\n  ): Promise<any>;\n  addLink(multihash: Multihash, link: DAGLink, callback: Callback<any>): void;\n  addLink(multihash: Multihash, link: DAGLink): Promise<any>;\n\n  rmLink(\n    multihash: Multihash,\n    linkRef: DAGLinkRef,\n    options: GetObjectOptions,\n    callback: Callback<any>\n  ): void;\n  rmLink(\n    multihash: Multihash,\n    linkRef: DAGLinkRef,\n    options: GetObjectOptions\n  ): Promise<any>;\n  rmLink(\n    multihash: Multihash,\n    linkRef: DAGLinkRef,\n    callback: Callback<any>\n  ): void;\n  rmLink(multihash: Multihash, linkRef: DAGLinkRef): Promise<any>;\n\n  appendData(\n    multihash: Multihash,\n    data: any,\n    options: GetObjectOptions,\n    callback: Callback<any>\n  ): void;\n  appendData(\n    multihash: Multihash,\n    data: any,\n    options: GetObjectOptions\n  ): Promise<any>;\n  appendData(multihash: Multihash, data: any, callback: Callback<any>): void;\n  appendData(multihash: Multihash, data: any): Promise<any>;\n\n  setData(\n    multihash: Multihash,\n    data: any,\n    options: GetObjectOptions,\n    callback: Callback<any>\n  ): void;\n  setData(\n    multihash: Multihash,\n    data: any,\n    options: GetObjectOptions\n  ): Promise<any>;\n  setData(multihash: Multihash, data: any, callback: Callback<any>): void;\n  setData(multihash: Multihash, data: any): Promise<any>;\n}\n\nexport interface ObjectAPI {\n  'new'(template: 'unixfs-dir', callback: Callback<DAGNode>): void;\n  'new'(callback: Callback<DAGNode>): void;\n  'new'(): Promise<DAGNode>;\n\n  put(obj: Obj, options: PutObjectOptions, callback: Callback<any>): void;\n  put(obj: Obj, options: PutObjectOptions): Promise<any>;\n  put(obj: Obj, callback: Callback<any>): void;\n  put(obj: Obj): Promise<any>;\n\n  get(\n    multihash: Multihash,\n    options: GetObjectOptions,\n    callback: Callback<any>\n  ): void;\n  get(multihash: Multihash, options: GetObjectOptions): Promise<any>;\n  get(multihash: Multihash, callback: Callback<any>): void;\n  get(multihash: Multihash): Promise<any>;\n\n  data(\n    multihash: Multihash,\n    options: GetObjectOptions,\n    callback: Callback<any>\n  ): void;\n  data(multihash: Multihash, options: GetObjectOptions): Promise<any>;\n  data(multihash: Multihash, callback: Callback<any>): void;\n  data(multihash: Multihash): Promise<any>;\n\n  links(\n    multihash: Multihash,\n    options: GetObjectOptions,\n    callback: Callback<DAGLink[]>\n  ): void;\n  links(multihash: Multihash, options: GetObjectOptions): Promise<DAGLink[]>;\n  links(multihash: Multihash, callback: Callback<DAGLink[]>): void;\n  links(multihash: Multihash): Promise<DAGLink[]>;\n\n  stat(\n    multihash: Multihash,\n    options: GetObjectOptions,\n    callback: Callback<ObjectStat>\n  ): void;\n  stat(multihash: Multihash, options: GetObjectOptions): Promise<ObjectStat>;\n  stat(multihash: Multihash, callback: Callback<ObjectStat>): void;\n  stat(multihash: Multihash): Promise<ObjectStat>;\n\n  patch: ObjectPatchAPI;\n}\n\nexport interface DagAPI {\n  put(dagNode: any, options: any, callback: Callback<any>): void;\n  put(dagNode: any, options: any): Promise<any>;\n\n  get(\n    cid: string | CID,\n    path: string,\n    options: any,\n    callback: Callback<any>\n  ): void;\n  get(cid: string | CID, path: string, options: any): Promise<any>;\n  get(cid: string | CID, path: string, callback: Callback<any>): void;\n  get(cid: string | CID, path: string): Promise<any>;\n  get(cid: string | CID, callback: Callback<any>): void;\n  get(cid: string | CID): Promise<any>;\n\n  tree(\n    cid: string | CID,\n    path: string,\n    options: any,\n    callback: Callback<any>\n  ): void;\n  tree(cid: string | CID, path: string, options: any): Promise<any>;\n  tree(cid: string | CID, path: string, callback: Callback<any>): void;\n  tree(cid: string | CID, path: string): Promise<any>;\n  tree(cid: string | CID, options: any, callback: Callback<any>): void;\n  tree(cid: string | CID, options: any): Promise<any>;\n  tree(cid: string | CID, callback: Callback<any>): void;\n  tree(cid: string | CID): Promise<any>;\n}\n\ntype TPubSubTopic = string;\n\ntype TpubSubTopicHandler = (msg: any) => void;\n\ntype TPubSubTopicOptions = {\n  discover: boolean;\n};\n\ntype TPubSubData = string | Buffer;\n\nexport interface Pubsub {\n  subscribe(\n    topic: TPubSubTopic,\n    handler: TpubSubTopicHandler,\n    options: TPubSubTopicOptions,\n    callback: Callback<any>\n  ): void;\n  subscribe(\n    topic: TPubSubTopic,\n    handler: TpubSubTopicHandler,\n    options: TPubSubTopicOptions\n  ): Promise<void>;\n\n  unsubscribe(\n    topic: TPubSubTopic,\n    handler: TpubSubTopicHandler,\n    callback: Callback<void>\n  ): void;\n  unsubscribe(topic: TPubSubTopic, handler: TpubSubTopicHandler): Promise<void>;\n\n  publish(\n    topic: TPubSubTopic,\n    data: TPubSubData,\n    callback: Callback<any>\n  ): void;\n  publish(topic: TPubSubTopic, data: TPubSubData): Promise<any>;\n\n  ls(callback: Callback<any>): void;\n  ls(): Promise<any>;\n\n  peers(topic: TPubSubTopic, callback: Callback<any>): void;\n  peers(topic: TPubSubTopic): Promise<any>;\n\n  setMaxListeners(n: number): void;\n}\n\nexport interface WantListItem {\n  '/': string;\n}\nexport interface WantList {\n  Keys: WantListItem[];\n}\n\n/* class object */\nexport type Big = any;\nexport interface Stat {\n  provideBufLen: number;\n  blocksReceived: Big;\n  wantlist: WantListItem[];\n  peers: string[];\n  dupBlksReceived: Big;\n  dupDataReceived: Big;\n  dataReceived: Big;\n  blocksSent: Big;\n  dataSent: Big;\n}\n\nexport type KeyType = string | Buffer | CID | any;\nexport interface Bitswap {\n  wantlist(peerId: string, callback: Callback<WantList>): void;\n  wantlist(peerId: string): Promise<WantList>;\n  wantlist(callback: Callback<WantList>): void;\n  wantlist(): Promise<WantList>;\n\n  stat(callback: Callback<Stat>): void;\n  stat(): Promise<Stat>;\n\n  unwant(keys: KeyType | KeyType[], callback: Callback<any>): void;\n  unwant(keys: KeyType | KeyType[]): Promise<any>;\n}\n\nexport function create(options: Options): IPFS;\n\nexport as namespace Ipfs;\n","/home/paul/projects/decentrilized-protocol/src/types/main.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/types/orbit-db-cache.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/types/orbit-db-identity-provider-ext.d.ts",[],"/home/paul/projects/decentrilized-protocol/src/types/orbit-db-keystore.d.ts",["1489","1490","1491"],"import 'orbit-db-keystore';\n\ndeclare module 'orbit-db-keystore' {\n  export interface IOrbitDBKeystoreStore {\n    status: string;\n    open(): Promise<void>;\n    close(): Promise<void>;\n    put(k: string, v: any): Promise<void>;\n    get(k: string): string | Uint8Array;\n  }\n\n  export interface IOrbitDBKeystoreCache {\n    length: number;\n    keys: string[];\n    set(k: string, v: any): void;\n    get(k: string): any;\n    remove(k: string): void;\n    clear(): void;\n  }\n\n  /**\n   *\n   *\n   * @export\n   * @interface IOrbitDBKeystoreOptionsForSecretStorage\n   * @property {string} path - the custom name of the storage\n   */\n  export interface IOrbitDBKeystoreOptionsForSecretStorage {\n    store?: string | IOrbitDBKeystoreStore;\n    cache?: IOrbitDBKeystoreCache;\n    path?: string;\n    credentials: {\n      password: string;\n    };\n  }\n\n  export type TOrbitDBKeystoreOptions =\n    | IOrbitDBKeystoreOptionsForSecretStorage\n    | string;\n}\n","/home/paul/projects/decentrilized-protocol/src/types/users.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/common-utils/common-utils-array.ts",["1492","1493","1494"],"export const commonUtilsArrayOrderByDecComparationFunction = <T>(\n  a: T,\n  b: T\n): number => Number(b) - Number(a);\n\n/**\n * sort array by decreasing\n * value on increased index\n * @param {any[]} arr\n */\nexport const commonUtilsArrayOrderByDec = <T>(arr: T[]): T[] =>\n  arr.sort(commonUtilsArrayOrderByDecComparationFunction);\n\n/**\n * delete an item from the array\n * @param {Array} arr\n * @param {any} item\n */\n\nexport const commonUtilsArrayDeleteFromArray = <T>(arr: T[], item: T) => {\n  if (arr instanceof Array && arr.length) {\n    const idxOfItem = arr.findIndex((el: T) => el === item);\n\n    if (idxOfItem !== -1) {\n      arr.splice(idxOfItem, 1);\n    }\n  }\n};\n\n/**\n * call a callback function for an each item in the\n * array till the result is not an intstance of the\n * Error. If any callback resulted with an Error\n * then the execution will break.\n */\nexport const commonUtilsArrayDoCallbackTillNoError = <T>(\n  arr: T[],\n  cb: (v: T) => Error | any\n): Error | void => {\n  if (!(arr instanceof Array)) {\n    return new Error('The array value must be an instance of Array');\n  }\n\n  const len = arr.length;\n  let idx = 0;\n  let r: Error | any;\n\n  for (; idx < len; idx += 1) {\n    r = cb(arr[idx]);\n\n    if (r instanceof Error) {\n      return r;\n    }\n  }\n};\n\n/**\n * calculate the overall lenght\n * of the numeric array in bytes\n * @param {number[]} arr\n * @param {number} [maxNumber] - maximum value of the valid number\n * @param {number} [minNumber] - minimum value of the valid number\n * @returns {number | Error} - return a length of the array or an Error\n * if a non-finite or an unsafe number will be met\n */\nexport const commonUtilsArrayCalculateLengthOfIntegerArray = (\n  arr: number[],\n  maxNumber?: number,\n  minNumber?: number\n): number | Error => {\n  if (!(arr instanceof Array)) {\n    return new Error('The array value must be an instance of Array');\n  }\n\n  const maxNumberRes =\n    typeof maxNumber === 'number' ? maxNumber : Number.MAX_SAFE_INTEGER;\n  const minNumberRes = typeof minNumber === 'number' ? minNumber : 0;\n  const len = arr.length;\n  let idx = 0;\n  let item;\n  let result = 0;\n\n  for (; idx < len; idx += 1) {\n    item = arr[idx];\n\n    if (typeof item !== 'number') {\n      return new Error('The value is not a number');\n    }\n    if (item < 0) {\n      return new Error('The number must be greater than 0');\n    }\n    if (!Number.isFinite(item)) {\n      return new Error('The value is not a finite number');\n    }\n    if (item > maxNumberRes) {\n      return new Error('The number is too big');\n    }\n    if (item < minNumberRes) {\n      return new Error('The number is too small');\n    }\n    if (item < 255) {\n      result += 1;\n    } else if (item < 65537) {\n      result += 4;\n    } else if (item > 65537) {\n      result += 8;\n    }\n  }\n  return result;\n};\n","/home/paul/projects/decentrilized-protocol/src/utils/common-utils/common-utils-date-time.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/common-utils/common-utils-objects.ts",["1495","1496"],"export const isNotEmptyObject = (o: any): o is object => {\n  return !!o && typeof o === 'object' && !!Object.keys(o).length;\n};\n\nexport const isEmptyObject = (o: any): boolean => {\n  return !isNotEmptyObject(o);\n};\n","/home/paul/projects/decentrilized-protocol/src/utils/common-utils/common-utils-timer.ts",["1497","1498"],"export const timeout = (timeoutMs: number, error?: Error) =>\n  new Promise((res, rej) => {\n    setTimeout(() => {\n      rej(error || new Error('Time out'));\n    }, timeoutMs);\n  });\n\nexport const delay = (delayMs: number) =>\n  new Promise((res, rej) => {\n    setTimeout(() => {\n      res();\n    }, delayMs);\n  });\n","/home/paul/projects/decentrilized-protocol/src/utils/common-utils/common-utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.ts",["1499"],"import {\n  IDataCachingDecoratorDecoratedFunction,\n  IDataCachingDecoratorCachedValue,\n} from './data-cache-utils-caching-decorator.types';\nimport { commonUtilsArrayOrderByDec } from 'utils/common-utils/common-utils';\nimport { DATA_CACHING_DECORATOR_DEFAULT_CACHE_CAPACITY } from './data-cache-utils-caching-decorator.const';\n\n/**\n * decorator for a method, will be wrapped for\n * caching values of a mostly used keys.\n * Must be used only for immutable\n * key-value stores\n * @property {number} cachedValuesCount - number\n * of a cached values\n */\nexport const dataCachingUtilsCachingDecorator = <T, V, I extends object>(\n  cacheItemsCapacity: number = DATA_CACHING_DECORATOR_DEFAULT_CACHE_CAPACITY\n) => {\n  /**\n   *\n   *\n   * @param {object} target\n   * @param {string} propertyKey\n   * @param {PropertyDescriptor} descriptor\n   * @returns\n   */\n  return (\n    target: object,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) => {\n    let newDescriptor;\n    // the original method, will be wrapped\n    const methodOrigin: IDataCachingDecoratorDecoratedFunction<T, V> =\n      descriptor.value;\n    // key - rating\n    const keysRaiting = new Map<T, number>();\n    let keysHighestRatings: number[] = [];\n    const cache = new Map<T, IDataCachingDecoratorCachedValue<V>>();\n    const cachedValuesCountLastIndex = cacheItemsCapacity - 1;\n\n    if (typeof methodOrigin !== 'function') {\n      throw new Error(\n        'dataCachingUtilsCachingDecorator failed to decorate a non function property'\n      );\n    }\n\n    async function cachingWrapper(this: I, key: T): Promise<V> {\n      const cachedValueForKey = cache.get(key);\n\n      // check if the value of the\n      // key was cached\n      if (cachedValueForKey != null) {\n        return cachedValueForKey.value;\n      }\n\n      const resultedValue = await methodOrigin.call(this, key);\n\n      if (!(resultedValue instanceof Error) && resultedValue != null) {\n        const theMinimalRaitingValue =\n          keysHighestRatings[cachedValuesCountLastIndex];\n        // increase the key raiting on each read of the key\n        const keyRaiting = Number(keysRaiting.get(key) || 0) + 1;\n\n        keysRaiting.set(key, keyRaiting);\n        if (!theMinimalRaitingValue || theMinimalRaitingValue < keyRaiting) {\n          // put the key rating on the last index\n          keysHighestRatings[\n            Math.min(cachedValuesCountLastIndex, keysHighestRatings.length)\n          ] = keyRaiting;\n          // sort the resulted array an replace the highest rating\n          // array with the ordered copy of it\n          keysHighestRatings = commonUtilsArrayOrderByDec<number>(\n            keysHighestRatings\n          );\n\n          // if the minimal rating value is exists.\n          // Means that the cache is overflow\n          // and it's necessary to delete\n          // a value for the key with the minimal rating\n          // from the cache.\n          if (theMinimalRaitingValue) {\n            // find the key with the minimal value of the rating\n            // which value was stored in the cache\n            for (const entry of cache) {\n              if (entry[1].rating === theMinimalRaitingValue) {\n                // if found the key with the minimal\n                // rating delete it from the cache\n                cache.delete(entry[0]);\n                break;\n              }\n            }\n          }\n\n          // cache the key value\n          cache.set(key, {\n            rating: keyRaiting,\n            value: resultedValue,\n          });\n        }\n      }\n      return resultedValue;\n    }\n\n    if (descriptor.writable) {\n      descriptor.value = cachingWrapper;\n      newDescriptor = descriptor;\n    } else {\n      newDescriptor = {\n        writable: false,\n        enumerable: true,\n        configurable: false,\n        value: cachingWrapper,\n      };\n    }\n    return newDescriptor;\n  };\n};\n","/home/paul/projects/decentrilized-protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/data-cache-utils/data-cache-utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/data-compression-utils/data-compression-utils-strings.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/data-compression-utils/data-compression-utils.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/data-compression-utils/data-compression-utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/data-sign-utils.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/data-sign-utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/data-sign-utils.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/keys.data-sign-utils.ts",["1500","1501","1502"],"import {\n  DATA_SIGN_CRYPTO_UTIL_GENERATE_KEYPAIR_OPTIONS,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_USAGES,\n  DATA_SIGN_CRYPTO_UTIL_PUBLIC_KEY_USAGE,\n  DATA_SIGN_CRYPTO_UTIL_PRIVATE_KEY_USAGE,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n  DATA_SIGN_CRYPTO_UTIL_KEY_DESC,\n  DATA_SIGN_CRYPTO_UTIL_KEYS_EXTRACTABLE,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME,\n  KEY_NOT_FOUND_ERROR_MESSAGE,\n} from './data-sign-utils.const';\nimport { cryptoModule } from './main.data-sign-utils.const';\nimport {\n  TDATA_SIGN_UTIL_KEY_EXPORT_FORMAT_TYPE,\n  TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE,\n  TDATA_SIGN_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE,\n  TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n  TCRYPTO_UTIL_IMPORT_KEY_TYPES,\n} from './data-sign-utils.types';\nimport {\n  isCryptoKeyPair,\n  isJWK,\n  getJWK,\n  getJWKOrBool,\n} from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport { TEncryptionKeyStoreFormatType } from 'types/encryption-keys.types';\nimport { isTypedArray } from 'utils/typed-array-utils';\nimport { stringify } from 'utils/main-utils';\n\nexport const isCryptoKeyPairImported = (\n  key: any\n): key is TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE => {\n  return (\n    typeof key === 'object' &&\n    !!key[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME] &&\n    !!key[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]\n  );\n};\n\nexport const generateKeyPair = (): PromiseLike<CryptoKeyPair> =>\n  cryptoModule.generateKey(\n    DATA_SIGN_CRYPTO_UTIL_GENERATE_KEYPAIR_OPTIONS,\n    DATA_SIGN_CRYPTO_UTIL_KEYS_EXTRACTABLE,\n    DATA_SIGN_CRYPTO_UTIL_KEYPAIR_USAGES\n  );\n\nexport const exportKey = async (\n  key: CryptoKey\n): Promise<TDATA_SIGN_UTIL_KEY_EXPORT_FORMAT_TYPE | Error> => {\n  try {\n    return cryptoModule.exportKey(\n      DATA_SIGN_CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n      key\n    );\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const exportKeyAsString = async (\n  key: CryptoKey\n): Promise<string | Error> => {\n  const keyExported = await exportKey(key);\n\n  if (keyExported instanceof Error) {\n    return keyExported;\n  }\n  try {\n    return stringify(keyExported);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const exportPublicKey = async (\n  keyPair: CryptoKeyPair\n): Promise<TDATA_SIGN_UTIL_KEY_EXPORT_FORMAT_TYPE | Error> => {\n  if (isCryptoKeyPair(keyPair)) {\n    return exportKey(keyPair.publicKey);\n  }\n  return new Error('Argument must be a CryptoKeyPair');\n};\n\nexport const exportPublicKeyAsString = async (\n  keyPair: CryptoKeyPair\n): Promise<Error | string> => {\n  try {\n    const keyPublicExported = await exportPublicKey(keyPair);\n\n    if (keyPublicExported instanceof Error) {\n      return keyPublicExported;\n    }\n    return stringify(keyPublicExported);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const exportKeyPair = async (\n  keyPair: CryptoKeyPair\n): Promise<TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (isCryptoKeyPair(keyPair)) {\n      // do it in parallel\n      const [privateKey, publicKey] = await Promise.all([\n        exportKey(keyPair.privateKey),\n        exportKey(keyPair.publicKey),\n      ]).catch((err) => [err, err]);\n\n      if (privateKey instanceof Error) {\n        return privateKey;\n      }\n      if (publicKey instanceof Error) {\n        return publicKey;\n      }\n      return {\n        [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: publicKey,\n        [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: privateKey,\n      };\n    }\n    return new Error('Argument given must be a CryptoKeyPair');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const exportKeyPairAsString = async (\n  keyPair: CryptoKeyPair\n): Promise<string | Error> => {\n  try {\n    const res = await exportKeyPair(keyPair);\n\n    if (res instanceof Error) {\n      return res;\n    }\n    return stringify(res);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importKey = async (\n  key: TCRYPTO_UTIL_IMPORT_KEY_TYPES,\n  isPublic: boolean = true\n): Promise<CryptoKey | Error> => {\n  try {\n    if (typeof key !== 'object') {\n      return new Error('Unsupported argument type');\n    }\n    const res = await cryptoModule.importKey(\n      DATA_SIGN_CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n      key,\n      DATA_SIGN_CRYPTO_UTIL_KEY_DESC,\n      DATA_SIGN_CRYPTO_UTIL_KEYS_EXTRACTABLE,\n      [\n        isPublic\n          ? DATA_SIGN_CRYPTO_UTIL_PUBLIC_KEY_USAGE\n          : DATA_SIGN_CRYPTO_UTIL_PRIVATE_KEY_USAGE,\n      ]\n    );\n\n    if (!(res instanceof CryptoKey)) {\n      return new Error(\"Can't import the key\");\n    }\n    return res;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importPublicKey = (\n  key: TCRYPTO_UTIL_IMPORT_KEY_TYPES\n): PromiseLike<CryptoKey | Error> => importKey(key, true);\n\nexport const importPrivateKey = (\n  key: TCRYPTO_UTIL_IMPORT_KEY_TYPES\n): PromiseLike<CryptoKey | Error> => importKey(key, false);\n\nexport const importKeyPair = async (\n  keyPair: TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE\n): Promise<TDATA_SIGN_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (isCryptoKeyPairImported(keyPair)) {\n      const [publicKey, privateKey] = await Promise.all([\n        importPublicKey(keyPair[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]),\n        importPrivateKey(\n          keyPair[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]\n        ),\n      ]).catch((err) => [err, err]);\n\n      if (publicKey instanceof Error) {\n        return publicKey;\n      }\n      if (privateKey instanceof Error) {\n        return privateKey;\n      }\n      return {\n        [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: publicKey,\n        [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: privateKey,\n      };\n    }\n    return new Error('The argument must be an instance of CryptoKeyPair');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importKeyPairFromString = (\n  keyPairString: string\n): Promise<TDATA_SIGN_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE | Error> | Error => {\n  try {\n    if (typeof keyPairString === 'string') {\n      const keyPairObject = JSON.parse(keyPairString);\n\n      if (isCryptoKeyPairImported(keyPairObject)) {\n        return importKeyPair(keyPairObject);\n      }\n      return new Error('There is a wrong format for the imported key pair');\n    }\n    return new Error('The key must be a string');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importKeyFromString = (\n  keyString: string,\n  isPublic: boolean = true\n): PromiseLike<CryptoKey | Error> | Error => {\n  try {\n    if (typeof keyString !== 'string') {\n      return new Error('The key must be a string');\n    }\n\n    const parsedKey = JSON.parse(keyString);\n\n    return importKey(parsedKey, isPublic);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importPublicKeyFromString = (\n  key: string\n): PromiseLike<CryptoKey | Error> | Error => importKeyFromString(key, true);\n\nexport const importPrivateKeyFromString = (\n  key: string\n): PromiseLike<CryptoKey | Error> | Error => importKeyFromString(key, false);\n\nexport const checkIfStringIsKeyPair = (keyString: string): boolean => {\n  return (\n    keyString.includes(DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME) &&\n    keyString.includes(DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME)\n  );\n};\n\nexport const getKeyOfType = async (\n  key: TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n  type: KeyType\n): Promise<CryptoKey | Error> => {\n  if (typeof key === 'string') {\n    if (checkIfStringIsKeyPair(key)) {\n      const keyPair = await importKeyPairFromString(key);\n\n      if (keyPair instanceof Error) {\n        return keyPair;\n      }\n      return getKeyOfType(keyPair, type);\n    } else {\n      const keyFromString = await importKeyFromString(key, type === 'public');\n\n      if (keyFromString instanceof Error) {\n        return keyFromString;\n      }\n      return getKeyOfType(keyFromString, type);\n    }\n  }\n  if (key instanceof CryptoKey) {\n    return key.type === type ? key : new Error(KEY_NOT_FOUND_ERROR_MESSAGE);\n  }\n  if (typeof key === 'object') {\n    const keys = Object.values(key);\n    const keyResulted = keys.find(\n      (k: CryptoKey) => k && k.type && k.type === type\n    );\n\n    return keyResulted || new Error(KEY_NOT_FOUND_ERROR_MESSAGE);\n  }\n  return new Error('There is an unsupported type of the key given');\n};\n\n/**\n * import an encryption key from a\n * supported format of an exported key\n * and returns a crypto key in native\n * format\n * @param {} key\n */\nexport const importEncryptionKey = async (\n  key: TEncryptionKeyStoreFormatType\n): Promise<CryptoKey | Error> => {\n  if (isTypedArray(key)) {\n    return importKey(key);\n  } else {\n    const jwk = getJWKOrBool(key);\n\n    if (typeof jwk === 'object') {\n      return importKey(jwk);\n    } else if (typeof key === 'string') {\n      return importKeyFromString(key);\n    }\n  }\n  return new Error('There is an unknown key format');\n};\n\n/**\n * import an encryption key from a\n * supported format of an exported key\n * and returns a crypto key as a string\n * @param {} key\n */\nexport const convertAndExportKeyAsString = async (\n  key: TEncryptionKeyStoreFormatType\n): Promise<string | Error> => {\n  const cryptoKeyImported = await importEncryptionKey(key);\n\n  if (cryptoKeyImported instanceof Error) {\n    return cryptoKeyImported;\n  }\n  return exportKeyAsString(cryptoKeyImported);\n};\n","/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/main.data-sign-utils.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/sign-data.encryption-utils.ts",["1503"],"import { cryptoModule } from './main.data-sign-utils.const';\nimport {\n  DATA_SIGN_CRYPTO_UTIL_DATA_SIGN_AND_VERIFY_PARAMS,\n  DATA_SIGN_CRYPTO_UTIL_SIGN_KEY_TYPE,\n} from './data-sign-utils.const';\nimport {\n  TDATA_SIGN_UTIL_SIGN_DATA_TYPES,\n  TDATA_SIGN_UTIL_SIGN_DATA_TYPES_NATIVE,\n  TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n} from './data-sign-utils.types';\nimport { getKeyOfType, exportKey } from './keys.data-sign-utils';\nimport {\n  convertToTypedArray,\n  typedArrayToString,\n} from 'utils/typed-array-utils';\n\nexport const signNative = async (\n  key: CryptoKey,\n  data: TDATA_SIGN_UTIL_SIGN_DATA_TYPES_NATIVE\n): Promise<ArrayBuffer | Error> => {\n  if (key.type !== DATA_SIGN_CRYPTO_UTIL_SIGN_KEY_TYPE) {\n    return new Error(\n      `The type of the key ${key.type} may not be used for data signing`\n    );\n  }\n  try {\n    const res = await cryptoModule.sign(\n      { ...DATA_SIGN_CRYPTO_UTIL_DATA_SIGN_AND_VERIFY_PARAMS },\n      key,\n      data\n    );\n\n    return res;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const signToTypedArray = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n  data: TDATA_SIGN_UTIL_SIGN_DATA_TYPES\n): Promise<ArrayBuffer | Error> => {\n  const k = await getKeyOfType(key, DATA_SIGN_CRYPTO_UTIL_SIGN_KEY_TYPE);\n\n  if (k instanceof Error) {\n    return k;\n  }\n\n  const d = convertToTypedArray(data);\n\n  if (d instanceof Error) {\n    return d;\n  }\n\n  return signNative(k, d);\n};\n\nexport const signToString = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n  data: TDATA_SIGN_UTIL_SIGN_DATA_TYPES\n): Promise<string | Error> => {\n  const signedHashData = await signToTypedArray(key, data);\n\n  if (signedHashData instanceof Error) {\n    return signedHashData;\n  }\n\n  return typedArrayToString(signedHashData);\n};\n","/home/paul/projects/decentrilized-protocol/src/utils/data-sign-utils/verify-data.encryption-utils.ts",["1504"],"import {\n  isTypedArray,\n  stringToTypedArray,\n  typedArrayToString,\n} from 'utils/typed-array-utils';\nimport { stringify } from 'utils/main-utils';\nimport { cryptoModule } from './main.data-sign-utils.const';\nimport {\n  DATA_SIGN_CRYPTO_UTIL_VERIFY_KEY_TYPE,\n  DATA_SIGN_CRYPTO_UTIL_DATA_SIGN_AND_VERIFY_PARAMS,\n} from './data-sign-utils.const';\nimport {\n  TDATA_SIGN_UTIL_VERIFY_DATA_TYPES,\n  TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_NATIVE,\n  TDATA_SIGN_UTIL_VERIFY_KEY_TYPES,\n} from './data-sign-utils.types';\nimport { getKeyOfType } from './keys.data-sign-utils';\n\nexport const verifyNative = async (\n  key: CryptoKey,\n  data: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_NATIVE,\n  signature: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_NATIVE\n): Promise<boolean | Error> => {\n  if (key.type !== DATA_SIGN_CRYPTO_UTIL_VERIFY_KEY_TYPE) {\n    return new Error(\n      `The type of the key ${key.type} may not be used for data decryption`\n    );\n  }\n  if (!isTypedArray(data)) {\n    return new Error('The data type is not supported');\n  }\n  try {\n    const res = await cryptoModule.verify(\n      { ...DATA_SIGN_CRYPTO_UTIL_DATA_SIGN_AND_VERIFY_PARAMS },\n      key,\n      signature,\n      data\n    );\n\n    return res;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const verifyFromString = async (\n  key: TDATA_SIGN_UTIL_VERIFY_KEY_TYPES,\n  data: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES | object,\n  signature: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES\n): Promise<boolean | Error> => {\n  const k = await getKeyOfType(key, DATA_SIGN_CRYPTO_UTIL_VERIFY_KEY_TYPE);\n\n  if (k instanceof Error) {\n    return k;\n  }\n\n  let d;\n\n  if (isTypedArray(data)) {\n    d = data;\n  } else if (typeof data === 'object' && !(data instanceof Error)) {\n    d = stringify(data);\n\n    if (d instanceof Error) {\n      return d;\n    }\n    d = stringToTypedArray(d);\n  } else if (typeof data === 'string') {\n    d = stringToTypedArray(data);\n  } else {\n    return new Error('Unsupported data type');\n  }\n  if (d instanceof Error) {\n    return d;\n  }\n\n  const s =\n    typeof signature === 'string' ? stringToTypedArray(signature) : signature;\n\n  if (s instanceof Error) {\n    return s;\n  }\n\n  return verifyNative(k, d, s);\n};\n","/home/paul/projects/decentrilized-protocol/src/utils/data-validators-utils/data-validators-utils-common.ts",["1505","1506","1507","1508"],"import {\n  CONST_VALIDATION_SCHEMES_URI,\n  CONST_VALIDATION_SCHEMES_URL,\n  CONST_VALIDATION_SCHEMES_UUID_V4,\n  CONST_VALIDATION_SCHEMES_EMAIL,\n} from 'const/const-validation-schemes/const-validation-schemes-common';\nimport { validateBySchema } from 'utils/validation-utils/validation-utils';\n\nexport const dataValidatorUtilURI = (v: any): boolean => {\n  return validateBySchema(CONST_VALIDATION_SCHEMES_URI, v);\n};\n\nexport const dataValidatorUtilURL = (v: any): boolean => {\n  const result = validateBySchema(CONST_VALIDATION_SCHEMES_URL, v);\n\n  return result;\n};\n\nexport const dataValidatorUtilUUIDV4 = (v: any): boolean => {\n  return validateBySchema(CONST_VALIDATION_SCHEMES_UUID_V4, v);\n};\n\nexport const dataValidatorUtilEmail = (v: any): boolean => {\n  return validateBySchema(CONST_VALIDATION_SCHEMES_EMAIL, v);\n};\n","/home/paul/projects/decentrilized-protocol/src/utils/data-validators-utils/data-validators-utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/encryption-keys-utils/encryption-keys-utils.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/encryption-keys-utils/encryption-keys-utils.ts",["1509","1510","1511","1512","1513","1514"],"import {\n  MIN_JWK_PROPS_COUNT,\n  MIN_JWK_STRING_LENGTH,\n  ENCRYPTIONS_KEYS_UTILS_JWK_FORMAT_OBJECT_KEYS,\n} from './encryption-keys-utils.const';\n\nexport const isCryptoKey = (v: any): v is CryptoKey => v instanceof CryptoKey;\n\nexport const isCryptoKeyPair = (keyPair: any): keyPair is CryptoKeyPair => {\n  return (\n    typeof keyPair === 'object' &&\n    keyPair.publicKey instanceof CryptoKey &&\n    keyPair.privateKey instanceof CryptoKey\n  );\n};\n\nexport const isCryptoKeyPairExportedAsString = (keyPair: any): boolean => {\n  return typeof keyPair === 'string' && keyPair.length >= MIN_JWK_STRING_LENGTH;\n};\n\nexport const isJWK = (\n  keyObject: object,\n  isReturnError: boolean = false\n): Error | boolean => {\n  if (keyObject && typeof keyObject === 'object') {\n    const options = Object.keys(keyObject);\n    const optionsCount = options.length;\n\n    if (optionsCount > MIN_JWK_PROPS_COUNT) {\n      let idx = 0;\n      let optionName: string;\n\n      for (; idx < optionsCount; idx += 1) {\n        optionName = options[idx];\n        if (\n          !ENCRYPTIONS_KEYS_UTILS_JWK_FORMAT_OBJECT_KEYS.includes(optionName)\n        ) {\n          return isReturnError\n            ? new Error(`There is an unknown property ${optionName}`)\n            : false;\n        }\n      }\n      return true;\n    }\n  }\n  return isReturnError ? new Error('There is a wrong format of JWK') : false;\n};\n\nexport const getJWK = (\n  key: any,\n  isReturnError: boolean = false\n): JsonWebKey | boolean | Error => {\n  let keyObject = key;\n\n  if (typeof key === 'string' && key.length > MIN_JWK_STRING_LENGTH) {\n    try {\n      keyObject = JSON.parse(key);\n    } catch (e) {\n      return e;\n    }\n  }\n\n  const isJWKValid = isJWK(keyObject, isReturnError);\n\n  if (isJWKValid === true) {\n    return keyObject as JsonWebKey;\n  }\n  return isJWKValid instanceof Error\n    ? isJWKValid\n    : new Error('There is a wrong format of JWK');\n};\n\nexport const getJWKOrError = (key: any): JsonWebKey | Error =>\n  getJWK(key, true) as JsonWebKey | Error;\n\nexport const getJWKOrBool = (key: any): JsonWebKey | boolean =>\n  getJWK(key, false) as JsonWebKey | boolean;\n","/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/crypto-utils.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/crypto-utils.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/decrypt-data.encryption-utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/encrypt-data.encryption-utils.ts",["1515"],"import { cryptoModule } from './main.crypto-utils.const';\nimport {\n  CRYPTO_UTIL_KEY_DESC,\n  CRYPTO_UTIL_ENCRYPTION_KEY_TYPE,\n  INITIALIZATION_VECTOR_DEFAULT_LENGTH,\n} from './crypto-utils.const';\nimport {\n  TCRYPTO_UTIL_ENCRYPT_DATA_TYPES,\n  TCRYPTO_UTIL_ENCRYPT_DATA_TYPES_NATIVE,\n  TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n  TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG,\n  TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR,\n} from './crypto-utils.types';\nimport { getKeyOfType, exportKey } from './keys.encryption-utils';\nimport {\n  convertToTypedArray,\n  typedArrayToString,\n  arrayBufferFromTypedArray,\n  concatArrayBuffers,\n  getBytesFromArrayBuffer,\n} from 'utils/typed-array-utils';\nimport { decodeDOMStringToArrayBuffer } from 'utils/string-encoding-utils';\n\n/**\n * return a random vector, used e.g. for aes-gcm\n * encryption\n * @param vectorLength - lenght of the vector generated\n */\nexport const generateInitializationVectorNative = (\n  vectorLength: number = INITIALIZATION_VECTOR_DEFAULT_LENGTH\n): Uint8Array | Error => {\n  try {\n    return window.crypto.getRandomValues(new Uint8Array(vectorLength));\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const generateInitializationVectorNativeArrayBuffer = (\n  vectorLength?: number\n): ArrayBuffer | Error => {\n  const iv = generateInitializationVectorNative(vectorLength);\n\n  if (iv instanceof Error) {\n    return iv;\n  }\n  return arrayBufferFromTypedArray(iv);\n};\n\nexport const concatDataWithInitializationVector = (\n  options: TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR\n): ArrayBuffer | Error => {\n  try {\n    return concatArrayBuffers(options.iv, options.data);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const getInitializationVectorFromData = (\n  arrayBuffer: ArrayBuffer,\n  ivLengthBytes: number = INITIALIZATION_VECTOR_DEFAULT_LENGTH\n): TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR | Error => {\n  try {\n    const iv = getBytesFromArrayBuffer(arrayBuffer, 0, ivLengthBytes);\n\n    if (iv instanceof Error) {\n      return iv;\n    }\n\n    const data = getBytesFromArrayBuffer(arrayBuffer, ivLengthBytes);\n\n    if (data instanceof Error) {\n      return data;\n    }\n    return {\n      iv,\n      data,\n    };\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const getInitializationVectorFromDataString = (\n  data: string,\n  ivLengthBytes?: number\n): TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR | Error => {\n  const dataArrayBuffer = decodeDOMStringToArrayBuffer(data);\n\n  if (dataArrayBuffer instanceof Error) {\n    return dataArrayBuffer;\n  }\n  return getInitializationVectorFromData(dataArrayBuffer, ivLengthBytes);\n};\n\nexport const encryptNative = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: CryptoKey,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES_NATIVE,\n  //an optional params for the encryption method\n  cryptoKeyConfig: TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG = CRYPTO_UTIL_KEY_DESC\n): Promise<ArrayBuffer | Error> => {\n  try {\n    const res = await cryptoModule.encrypt(cryptoKeyConfig, key, data);\n\n    return res;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const encryptToTypedArray = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES,\n  //an optional params for the encryption method\n  cryptoKeyConfig?: TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG\n): Promise<ArrayBuffer | Error> => {\n  let k;\n\n  if (key instanceof CryptoKey) {\n    k = key;\n  } else {\n    k = await getKeyOfType(key, CRYPTO_UTIL_ENCRYPTION_KEY_TYPE);\n  }\n  if (k instanceof Error) {\n    return k;\n  }\n\n  const d = convertToTypedArray(data);\n\n  if (d instanceof Error) {\n    return d;\n  }\n\n  return encryptNative(k, d, cryptoKeyConfig);\n};\n\nexport const encryptToString = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES,\n  //an optional params for the encryption method\n  cryptoKeyConfig?: TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG\n): Promise<string | Error> => {\n  const encryptedData = await encryptToTypedArray(key, data);\n\n  if (encryptedData instanceof Error) {\n    return encryptedData;\n  }\n\n  return typedArrayToString(encryptedData);\n};\n","/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/encryption-utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/keys.encryption-utils.ts",["1516","1517","1518"],"import { isCryptoKeyPair } from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport {\n  CRYPTO_UTIL_GENERATE_KEYPAIR_OPTIONS,\n  CRYPTO_UTIL_KEYPAIR_USAGES,\n  CRYPTO_UTIL_PUBLIC_KEY_USAGE,\n  CRYPTO_UTIL_PRIVATE_KEY_USAGE,\n  CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n  CRYPTO_UTIL_KEY_DESC,\n  CRYPTO_UTIL_KEYS_EXTRACTABLE,\n  CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME,\n  CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME,\n} from './crypto-utils.const';\nimport { cryptoModule } from './main.crypto-utils.const';\nimport {\n  TCRYPTO_UTIL_KEY_EXPORT_FORMAT_TYPE,\n  TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE,\n  TCRYPTO_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE,\n  TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n} from './crypto-utils.types';\nimport { stringify } from 'utils/main-utils';\n\nexport const isCryptoKeyPairImported = (\n  key: any\n): key is TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE => {\n  return (\n    typeof key === 'object' &&\n    !!key[CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME] &&\n    !!key[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]\n  );\n};\n\nexport const generateKeyPair = (): PromiseLike<CryptoKeyPair> =>\n  cryptoModule.generateKey(\n    CRYPTO_UTIL_GENERATE_KEYPAIR_OPTIONS,\n    CRYPTO_UTIL_KEYS_EXTRACTABLE,\n    CRYPTO_UTIL_KEYPAIR_USAGES\n  );\n\nexport const exportKey = (\n  key: CryptoKey\n): PromiseLike<TCRYPTO_UTIL_KEY_EXPORT_FORMAT_TYPE | Error> => {\n  try {\n    return cryptoModule.exportKey(CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT, key);\n  } catch (err) {\n    console.error(err);\n    return err;\n  }\n};\n\nexport const exportKeyAsString = async (\n  key: CryptoKey\n): Promise<Error | string> => {\n  return stringify(await exportKey(key));\n};\n\nexport const exportPublicKey = async (keyPair: CryptoKeyPair) => {\n  return exportKey(keyPair.publicKey);\n};\n\nexport const exportPublicKeyAsString = async (keyPair: CryptoKeyPair) => {\n  const publicKey = await exportPublicKey(keyPair);\n\n  if (publicKey instanceof Error) {\n    return publicKey;\n  }\n  return stringify(publicKey);\n};\n\nexport const exportKeyPair = async (\n  keyPair: CryptoKeyPair\n): Promise<TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (isCryptoKeyPair(keyPair)) {\n      // do it in parallel\n      const [privateKey, publicKey] = await Promise.all([\n        exportKey(keyPair.privateKey),\n        exportKey(keyPair.publicKey),\n      ]).catch((err) => [err, err]);\n\n      if (privateKey instanceof Error) {\n        return privateKey;\n      }\n      if (publicKey instanceof Error) {\n        return publicKey;\n      }\n      return {\n        [CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: publicKey,\n        [CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: privateKey,\n      };\n    }\n    return new Error('Argument given must be a CryptoKeyPair');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const exportKeyPairAsString = async (\n  keyPair: CryptoKeyPair\n): Promise<string | Error> => {\n  const exportedKeyPair = await exportKeyPair(keyPair);\n\n  if (exportedKeyPair instanceof Error) {\n    return exportedKeyPair;\n  }\n  try {\n    return stringify(exportedKeyPair);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importKey = (\n  key: object,\n  isPublic: boolean = true\n): PromiseLike<CryptoKey> => {\n  return cryptoModule.importKey(\n    CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n    key,\n    CRYPTO_UTIL_KEY_DESC,\n    CRYPTO_UTIL_KEYS_EXTRACTABLE,\n    [isPublic ? CRYPTO_UTIL_PUBLIC_KEY_USAGE : CRYPTO_UTIL_PRIVATE_KEY_USAGE]\n  );\n};\n\nexport const importPublicKey = (key: object): PromiseLike<CryptoKey> =>\n  importKey(key, true);\n\nexport const importPrivateKey = (key: object): PromiseLike<CryptoKey> =>\n  importKey(key, false);\n\nexport const importKeyPair = async (\n  keyPair: TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE\n): Promise<TCRYPTO_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (isCryptoKeyPairImported(keyPair)) {\n      const [publicKey, privateKey] = await Promise.all([\n        importPublicKey(keyPair[CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]),\n        importPrivateKey(keyPair[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]),\n      ]).catch((err) => [err, err]);\n\n      if (publicKey instanceof Error) {\n        return publicKey;\n      }\n      if (privateKey instanceof Error) {\n        return privateKey;\n      }\n      return {\n        [CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: publicKey,\n        [CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: privateKey,\n      };\n    }\n    return new Error('The argument must be an instance of CryptoKeyPair');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importKeyPairFromString = (\n  keyPairString: string\n): Promise<TCRYPTO_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE | Error> | Error => {\n  try {\n    if (typeof keyPairString === 'string') {\n      const keyPairObject = JSON.parse(keyPairString);\n\n      return importKeyPair(keyPairObject);\n    }\n    return new Error('A key pair must be a string');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importKeyFromString = (\n  keyString: string,\n  isPublic: boolean = true\n): PromiseLike<CryptoKey> | Error => {\n  try {\n    return importKey(JSON.parse(keyString), isPublic);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importPublicKeyFromString = (\n  key: string\n): PromiseLike<CryptoKey> | Error => importKeyFromString(key, true);\n\nexport const importPrivateKeyFromString = (\n  key: string\n): PromiseLike<CryptoKey> | Error => importKeyFromString(key, false);\n\nexport const checkIfStringIsKeyPair = (keyString: string): boolean => {\n  return (\n    keyString.includes(CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME) &&\n    keyString.includes(CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME)\n  );\n};\n\nconst KEY_NOT_FOUND_ERROR_MESSAGE = 'A key of the required type was not found';\n\nexport const getKeyOfType = async (\n  key: TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n  type: KeyType\n): Promise<CryptoKey | Error> => {\n  if (typeof key === 'string') {\n    if (checkIfStringIsKeyPair(key)) {\n      const keyPair = await importKeyPairFromString(key);\n\n      if (keyPair instanceof Error) {\n        return keyPair;\n      }\n      return getKeyOfType(keyPair, type);\n    } else {\n      const keyFromString = await importKeyFromString(key, type === 'public');\n\n      if (keyFromString instanceof Error) {\n        return keyFromString;\n      }\n      return getKeyOfType(keyFromString, type);\n    }\n  }\n  if (key instanceof CryptoKey) {\n    return key.type === type ? key : new Error(KEY_NOT_FOUND_ERROR_MESSAGE);\n  }\n  if (typeof key === 'object') {\n    const keys = Object.values(key);\n    const keyResulted = keys.find(\n      (k: CryptoKey) => k && k.type && k.type === type\n    );\n\n    return keyResulted || new Error(KEY_NOT_FOUND_ERROR_MESSAGE);\n  }\n  return new Error('There is an unsupported type of the key given');\n};\n","/home/paul/projects/decentrilized-protocol/src/utils/encryption-utils/main.crypto-utils.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/firebase-utils/firebase-utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/hash-calculation-utils/hash-calculation-utils.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/hash-calculation-utils/hash-calculation-utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/identity-utils/identity-utils.ts",["1519"],"import uuidV4 from 'uuid/v4';\n\nexport const generateUUID = () => uuidV4();\n","/home/paul/projects/decentrilized-protocol/src/utils/lazy-loading-utils/lazy-loading-utils.ts",["1520"],"export const lazyLoadScript = (\n  url: string,\n  crossOrigin: string = 'anonymous'\n): Promise<Error | boolean> => {\n  try {\n    const script = window.document.createElement('script');\n\n    script.src = url;\n    script.async = true;\n    script.type = 'text/javascript';\n    script.crossOrigin = crossOrigin;\n    window.document.body.appendChild(script);\n    return new Promise<Error | boolean>((res, rej) => {\n      script.onload = () => {\n        res(true);\n      };\n      script.onerror = rej;\n    });\n  } catch (err) {\n    return Promise.reject(err);\n  }\n};\n","/home/paul/projects/decentrilized-protocol/src/utils/main-utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/password-utils/decrypt.password-utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/password-utils/derive-key.password-utils.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/password-utils/encrypt.password-utils.ts",["1521","1522"],"import {\n  PASSWORD_ENCRYPTION_UTILS_ENCRYPTION_INITIALIZATION_VECTOR_LENGTH,\n  PASSWORD_ENCRYPTION_UTILS_ENCRYPTION_PARAMS,\n} from './password-utils.const';\nimport {\n  generateInitializationVectorNativeArrayBuffer,\n  encryptToTypedArray,\n  concatDataWithInitializationVector,\n} from 'utils/encryption-utils/encryption-utils';\nimport {\n  TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n  TCRYPTO_UTIL_ENCRYPT_DATA_TYPES,\n} from 'utils/encryption-utils/crypto-utils.types';\nimport { encodeArrayBufferToDOMString } from 'utils/string-encoding-utils';\nimport {\n  importPasswordKeyFromString,\n  generatePasswordKeyByPasswordString,\n} from './derive-key.password-utils';\n\nexport const encryptDataToArrayBuffer = async (\n  key: string | CryptoKey,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES\n): Promise<Error | ArrayBuffer> => {\n  let cryptoKey;\n\n  if (key instanceof CryptoKey) {\n    cryptoKey = key;\n  } else {\n    cryptoKey = await importPasswordKeyFromString(key);\n  }\n  if (cryptoKey instanceof Error) {\n    return cryptoKey;\n  }\n\n  const iv = generateInitializationVectorNativeArrayBuffer();\n\n  if (iv instanceof Error) {\n    return iv;\n  }\n\n  const dataEncrypted = await encryptToTypedArray(cryptoKey, data, {\n    ...PASSWORD_ENCRYPTION_UTILS_ENCRYPTION_PARAMS,\n    iv,\n  });\n\n  if (dataEncrypted instanceof Error) {\n    return dataEncrypted;\n  }\n\n  return concatDataWithInitializationVector({\n    data: dataEncrypted,\n    iv,\n  });\n};\n\nexport const encryptDataToString = async (\n  key: string | CryptoKey,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES\n): Promise<Error | string> => {\n  const encrypted = await encryptDataToArrayBuffer(key, data);\n\n  if (encrypted instanceof Error) {\n    return encrypted;\n  }\n  return encodeArrayBufferToDOMString(encrypted);\n};\n\nexport const encryptDataToUInt8Array = async (\n  key: string | CryptoKey,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES\n): Promise<Error | Uint8Array> => {\n  const encrypted = await encryptDataToArrayBuffer(key, data);\n\n  if (encrypted instanceof Error) {\n    return encrypted;\n  }\n  return new Uint8Array(encrypted);\n};\n\nexport const encryptDataWithPassword = async (\n  password: string,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES\n): Promise<Error | string> => {\n  const key = await generatePasswordKeyByPasswordString(password);\n\n  if (key instanceof Error) {\n    console.error(key);\n    return key;\n  }\n\n  return encryptDataToString(key, data);\n};\n","/home/paul/projects/decentrilized-protocol/src/utils/password-utils/password-utils.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/password-utils/password-utils.types.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/string-encoding-utils.ts",["1523","1524","1525"],"/**\n * The sulutions is right from the article\n * https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String\n */\n\nexport function encodeArrayBufferToDOMString(buf: ArrayBuffer) {\n  return String.fromCharCode.apply(null, new Uint16Array(buf) as any);\n}\nexport function decodeDOMStringToArrayBuffer(str: string) {\n  const buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n  const bufView = new Uint16Array(buf);\n  for (let i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n","/home/paul/projects/decentrilized-protocol/src/utils/string-utilities.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/typed-array-utils.ts",["1526"],"import { TTypedArrays, TMainDataTypes } from 'types/main.types';\nimport { stringify, TStringifyData } from './main-utils';\nimport {\n  encodeArrayBufferToDOMString,\n  decodeDOMStringToArrayBuffer,\n} from 'utils/string-encoding-utils';\n\nexport const arrayBufferFromTypedArray = (\n  typedArray: TTypedArrays | ArrayBuffer\n): ArrayBuffer | Error => {\n  if (typedArray instanceof ArrayBuffer) {\n    return typedArray;\n  }\n  if (ArrayBuffer.isView(typedArray)) {\n    return typedArray.buffer;\n  }\n  return new Error('The data given is not a typed array');\n};\n\ntype isTypedArrayData = any;\n\nexport const isTypedArray = (data: isTypedArrayData): data is TTypedArrays =>\n  data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n\nexport const stringToTypedArray = (\n  data: TMainDataTypes\n): ArrayBuffer | Error => {\n  const strData = stringify(data);\n\n  if (strData instanceof Error) {\n    return strData;\n  }\n  return decodeDOMStringToArrayBuffer(strData);\n};\n\nexport const typedArrayToString = (\n  data: TTypedArrays | string\n): string | Error => {\n  if (typeof data === 'string') {\n    return data;\n  }\n  if (!isTypedArray(data)) {\n    return new Error('The data is not a typed array');\n  }\n\n  const dataAsArrayBuffer = arrayBufferFromTypedArray(data);\n\n  if (dataAsArrayBuffer instanceof Error) {\n    return dataAsArrayBuffer;\n  }\n\n  return encodeArrayBufferToDOMString(dataAsArrayBuffer);\n};\n\ntype TConvertedToTypedArrayData = TStringifyData | TTypedArrays;\n\nexport const convertToTypedArray = (\n  data: TConvertedToTypedArrayData\n): TTypedArrays | Error => {\n  if (isTypedArray(data)) {\n    return data;\n  }\n  return stringToTypedArray(data);\n};\n\nexport const getOverallLength = (\n  ...typedArrays: ArrayBuffer[]\n): number | Error => {\n  try {\n    return typedArrays.reduce(\n      (allLength, typedArray) => (allLength += typedArray.byteLength),\n      0\n    );\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const concatArrayBuffers = (\n  ...typedArrays: ArrayBuffer[]\n): ArrayBuffer | Error => {\n  const len = getOverallLength(...typedArrays);\n\n  if (len instanceof Error) {\n    return len;\n  }\n\n  const arrayResulted = new Uint8Array(len);\n  const count = typedArrays.length;\n  let idx = 0;\n  let arrayBuffer = null;\n  let currentLength = 0;\n  let newTypedArray;\n\n  try {\n    for (; idx < count; idx += 1) {\n      arrayBuffer = typedArrays[idx];\n      newTypedArray = new Uint8Array(arrayBuffer);\n      arrayResulted.set(newTypedArray, currentLength);\n      currentLength += newTypedArray.byteLength;\n    }\n  } catch (err) {\n    return err;\n  }\n  return arrayBufferFromTypedArray(arrayResulted);\n};\n\nexport const getBytesFromArrayBuffer = (\n  typedArray: ArrayBuffer,\n  from: number,\n  to?: number\n): ArrayBuffer | Error => {\n  try {\n    const arrayResulted = new Uint8Array(typedArray);\n\n    return arrayBufferFromTypedArray(arrayResulted.slice(from, to));\n  } catch (err) {\n    return err;\n  }\n};\n","/home/paul/projects/decentrilized-protocol/src/utils/validation-utils/validation-utils-timestamp.ts",[],"/home/paul/projects/decentrilized-protocol/src/utils/validation-utils/validation-utils.ts",["1527"],"import Ajv, { ValidateFunction } from 'ajv';\nimport memoize from 'lodash.memoize';\n\nconst ajv = new Ajv();\n\nexport const getValidatorForJSONSchema = memoize(\n  (schema: object): ValidateFunction => ajv.compile(schema)\n);\n\nexport const validateBySchema = (schema: object, value: any): boolean => {\n  const validator = getValidatorForJSONSchema(schema);\n\n  return validator(value) as boolean;\n};\n","/home/paul/projects/decentrilized-protocol/src/App.test.tsx",[],"/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-aurhority.keys.common.test.ts",["1528","1529","1530"],"import { signToString, verifyFromString } from 'utils/data-sign-utils';\nimport {\n  getPublicKeysFromCryptoKeyPairs,\n  checkIsCryptoKeyPairs,\n  exportKeyPairsAsString,\n  importKeyPairsFromString,\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME,\n} from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport {\n  encryptNative,\n  decryptNative,\n} from 'utils/encryption-utils/encryption-utils';\nimport {\n  TCACryptoKeyPairs,\n  TCACryptoPubilicKeys,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport {\n  stringToTypedArray,\n  typedArrayToString,\n} from 'utils/typed-array-utils';\n\nexport const runTestEncryptData = async (\n  keyPairs: TCACryptoKeyPairs\n): Promise<undefined | true> => {\n  const dataToEncode = 'data to encode';\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n  } = keyPairs;\n  const dataToEncodeTypeedArray = stringToTypedArray(dataToEncode);\n\n  if (dataToEncodeTypeedArray instanceof Error) {\n    console.error(dataToEncodeTypeedArray);\n    console.error('Failed to convert data to typed array');\n    return;\n  }\n\n  const encryptedData = await encryptNative(\n    encryptionKeyPair.publicKey,\n    dataToEncodeTypeedArray\n  );\n\n  if (encryptedData instanceof Error) {\n    console.error('Cant encrypt data with the key pair generated');\n    console.error(encryptedData);\n    return;\n  }\n\n  const decryptedData = await decryptNative(\n    encryptionKeyPair.privateKey,\n    encryptedData\n  );\n\n  if (decryptedData instanceof Error) {\n    console.error('Cant decrypt data encrypted with a generated key pairs');\n    console.error(decryptedData);\n    return;\n  }\n\n  const decryptedString = typedArrayToString(decryptedData);\n\n  if (decryptedString instanceof Error) {\n    console.error(decryptedString);\n    console.error(\n      'Failed to convert a string decrypted as array buffer to a DOMString'\n    );\n  }\n\n  if (decryptedString !== dataToEncode) {\n    console.error(\n      `Decrypted data is invalid. Expected: ${dataToEncode}, but ${decryptedString} was received`\n    );\n    return;\n  }\n  return true;\n};\n\nexport const runTestDataSign = async (\n  keyPairs: TCACryptoKeyPairs\n): Promise<undefined | boolean> => {\n  const dataToSign = {\n    hello: 'test hello',\n  };\n  const { [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signKeyPair } = keyPairs;\n  const signString = await signToString(signKeyPair, dataToSign);\n\n  if (signString instanceof Error) {\n    console.error('Failed to sign the string');\n    console.error(signString);\n    return;\n  }\n  if (typeof signString !== 'string') {\n    console.error('Failed to sign the data as a string');\n    return;\n  }\n\n  const verifyDataResult = await verifyFromString(\n    signKeyPair,\n    dataToSign,\n    signString\n  );\n\n  if (verifyDataResult instanceof Error) {\n    console.error('Failed to verify the data signed');\n    console.error(verifyDataResult);\n    return;\n  }\n  if (verifyDataResult !== true) {\n    console.error('The wrong result was given by the verifyFromString');\n    console.error(verifyDataResult);\n    return;\n  }\n\n  const wrongDataVerifyResult = await verifyFromString(\n    signKeyPair,\n    'Wrong data',\n    signString\n  );\n\n  if (wrongDataVerifyResult instanceof Error) {\n    console.error('Failed to verify a non original string data');\n    console.error(wrongDataVerifyResult);\n    return;\n  }\n  if (wrongDataVerifyResult !== false) {\n    console.error('The wrong result of non origin string verification');\n    return;\n  }\n  return true;\n};\n\nexport const runTestForKeyPairs = async (\n  keyPairs: any\n): Promise<undefined | boolean> => {\n  if (keyPairs instanceof Error) {\n    console.error('Cant generate a crypto key pair');\n    console.error(keyPairs);\n    return;\n  }\n\n  if ((await runTestEncryptData(keyPairs)) !== true) {\n    return;\n  }\n  if ((await runTestDataSign(keyPairs)) !== true) {\n    return;\n  }\n\n  const exportedKeyPairs = await exportKeyPairsAsString(keyPairs);\n\n  if (exportedKeyPairs instanceof Error) {\n    console.error('failed to export the key pair');\n    console.error(exportedKeyPairs);\n    return;\n  }\n  if (typeof exportedKeyPairs !== 'string') {\n    console.error('exportedKeyPairs does not exported in a string format');\n    return;\n  }\n\n  const importedKeyPairs = await importKeyPairsFromString(exportedKeyPairs);\n\n  if (!checkIsCryptoKeyPairs(importedKeyPairs)) {\n    console.error('A wrong format of the imported key pairs');\n    return;\n  }\n  if (importedKeyPairs instanceof Error) {\n    console.error('Failed to import key pairs from string');\n    return;\n  }\n  console.log('run tests for the imported from the exported string key pairs');\n  if ((await runTestEncryptData(importedKeyPairs)) !== true) {\n    console.error(\n      'failed tests for the imported from the exported string key pairs'\n    );\n    return;\n  }\n  console.log(\n    'run tests for the imported from the exported string key pairs fot data sign'\n  );\n  if ((await runTestDataSign(keyPairs)) !== true) {\n    console.error(\n      'failed tests for the imported from the exported string key pairs fot data sign'\n    );\n    return;\n  }\n  console.log(\n    'run tests for the imported from the exported string key pairs: use public key from the imported key pairs and the private key from the originally generated key pairs'\n  );\n  if (\n    (await runTestEncryptData({\n      ...importedKeyPairs,\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: {\n        ...importedKeyPairs[CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME],\n        privateKey:\n          keyPairs[CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME].privateKey,\n      },\n    })) !== true\n  ) {\n    console.error(\n      'failed tests for the imported from the exported string key pairs: use public key from the imported key pairs and the private key from the originally generated key pairs'\n    );\n    return;\n  }\n  console.log(\n    'run tests for the imported from the exported string key pairs: use private key from the imported key pairs and the public key from the originally generated key pairs'\n  );\n  /** data sign test-- */\n  console.log(\n    'run tests data sign for the imported from the exported string key pairs: use private key from the imported key pairs and the private key from the originally generated key pairs'\n  );\n  if (\n    (await runTestDataSign({\n      ...importedKeyPairs,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: {\n        ...importedKeyPairs[CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME],\n        privateKey: keyPairs[CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME].privateKey,\n      },\n    })) !== true\n  ) {\n    console.error(\n      'failed tests data sign for the imported from the exported string key pairs: use private key from the imported key pairs and the private key from the originally generated key pairs'\n    );\n    return;\n  }\n  /** --data sign test */\n  console.log(\n    'run tests encrypt for the imported from the exported string key pairs: use private key from the imported key pairs and the public key from the originally generated key pairs'\n  );\n  if (\n    (await runTestEncryptData({\n      ...importedKeyPairs,\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: {\n        ...importedKeyPairs[CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME],\n        publicKey:\n          keyPairs[CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME].publicKey,\n      },\n    })) !== true\n  ) {\n    console.log(\n      'failed tests for the imported from the exported string key pairs: use private key from the imported key pairs and the public key from the originally generated key pairs'\n    );\n    return;\n  }\n  /** data sign test-- */\n  console.log(\n    'run tests data sign for the imported from the exported string key pairs: use public key from the imported key pairs and the private key from the originally generated key pairs'\n  );\n  if (\n    (await runTestDataSign({\n      ...importedKeyPairs,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: {\n        ...importedKeyPairs[CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME],\n        publicKey: keyPairs[CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME].publicKey,\n      },\n    })) !== true\n  ) {\n    console.error(\n      'failed tests data sign for the imported from the exported string key pairs: use public key from the imported key pairs and the private key from the originally generated key pairs'\n    );\n    return;\n  }\n  console.log(\n    'run tests data sign for the imported from the exported string key pairs: use private key from the imported key pairs and the public key from the originally generated key pairs'\n  );\n  /** --data sign test */\n\n  const publicKeys = getPublicKeysFromCryptoKeyPairs(keyPairs);\n\n  if (publicKeys instanceof Error) {\n    console.error('Cant get public keys from crypto key pairs');\n    console.error(publicKeys);\n    return;\n  }\n\n  console.log(\n    'run tests public keys encrypt for the imported from the exported string key pairs: use private key from the imported key pairs and the public key from the originally generated key pairs'\n  );\n  if (\n    (await runTestEncryptData({\n      ...importedKeyPairs,\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: {\n        ...importedKeyPairs[CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME],\n        publicKey: (publicKeys as TCACryptoPubilicKeys)[\n          CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME\n        ],\n      },\n    })) !== true\n  ) {\n    console.log(\n      'failed tests public keys for the imported from the exported string key pairs: use private key from the imported key pairs and the public key from the originally generated key pairs'\n    );\n    return;\n  }\n  /** data sign test-- */\n  console.log(\n    'run tests public keys data sign for the imported from the exported string key pairs: use public key from the imported key pairs and the private key from the originally generated key pairs'\n  );\n  if (\n    (await runTestDataSign({\n      ...importedKeyPairs,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: {\n        ...importedKeyPairs[CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME],\n        publicKey: (publicKeys as TCACryptoPubilicKeys)[\n          CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME\n        ],\n      },\n    })) !== true\n  ) {\n    console.error(\n      'failed tests public keys data sign for the imported from the exported string key pairs: use public key from the imported key pairs and the private key from the originally generated key pairs'\n    );\n    return;\n  }\n  console.log(\n    'run tests public keys data sign for the imported from the exported string key pairs: use private key from the imported key pairs and the public key from the originally generated key pairs'\n  );\n  /** --data sign test */\n\n  console.warn('Central authority keys tests are succeed');\n  return true;\n};\n","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.const.ts",["1531"],"import { generateCryptoCredentials } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\n\nexport const CA_CONNECTION_FIREBASE_CONFIG = {\n  apiKey: 'AIzaSyCwmUlVklNmGZ0SD11NKT8gpvmZXbgbBRk',\n  authDomain: 'protocol-f251b.firebaseapp.com',\n  databaseURL: 'https://protocol-f251b.firebaseio.com',\n  projectId: 'protocol-f251b',\n  storageBucket: '',\n  messagingSenderId: '275196342406',\n  appId: '1:275196342406:web:40b79d671c50af57',\n};\n\nexport const CA_CONNECTION_FIREBASE_USER_CREDENTIALS = {\n  login: 'akulich.p@gmail.com',\n  password: '123456',\n};\n\nexport const CA_CONNECTION_FIREBASE_CREDENTIALS = CA_CONNECTION_FIREBASE_USER_CREDENTIALS;\n","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.credentials-storage.ts",["1532"],"import { CAConnectionFirestoreUtilsCredentialsStrorage } from 'classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage';\nimport { connectWithFirebase } from './central-authority-connection.test.firebase.utils';\nimport { generateCryptoCredentials } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport {\n  getUserIdentityByCryptoCredentials,\n  compareCryptoCredentials,\n} from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\n\nexport const runTestFirebaseCredentialsStorage = async () => {\n  console.warn('runTestFirebaseCredentialsStorage::start');\n  const firebaseConnection = await connectWithFirebase();\n\n  if (firebaseConnection instanceof Error) {\n    console.error(firebaseConnection);\n    return new Error('Failed to connect with firebase');\n  }\n\n  const credetntialsStoreConnectionToFirebase = new CAConnectionFirestoreUtilsCredentialsStrorage(\n    firebaseConnection\n  );\n\n  if (credetntialsStoreConnectionToFirebase.isConnected) {\n    console.error('Database connection flag must be false');\n    return;\n  }\n\n  const connectionResult = await credetntialsStoreConnectionToFirebase.connect();\n\n  if (connectionResult instanceof Error) {\n    console.error(connectionResult);\n    console.error('Failed to connect to the database server');\n    return;\n  }\n  if (!credetntialsStoreConnectionToFirebase.isConnected) {\n    console.error(\n      'Database connection flag must be true after connection method returns a success result'\n    );\n    return;\n  }\n\n  const credentialsForUser = await credetntialsStoreConnectionToFirebase.getCredentialsForTheCurrentUser();\n\n  if (credentialsForUser instanceof Error) {\n    console.error(credentialsForUser);\n    console.error('Failed to get credentials for the current user');\n    return;\n  }\n  if (!credentialsForUser) {\n    console.error('Credentials for the user must be auto generated on sign up');\n    return;\n  }\n\n  const credentials = await generateCryptoCredentials();\n\n  if (credentials instanceof Error) {\n    console.error('Failed to generate crypto credentials');\n    return;\n  }\n\n  const setCredentialsResult = await credetntialsStoreConnectionToFirebase.setUserCredentials(\n    credentials\n  );\n\n  if (setCredentialsResult instanceof Error) {\n    console.error(setCredentialsResult);\n    console.error('Failed to set credentials');\n    return;\n  }\n  if (\n    (await compareCryptoCredentials(\n      setCredentialsResult,\n      credentialsForUser\n    )) !== true\n  ) {\n    console.error(\n      'Credentials for the user created and stored once must be immputable anyway'\n    );\n    return;\n  }\n\n  const userId = getUserIdentityByCryptoCredentials(setCredentialsResult);\n\n  if (userId instanceof Error) {\n    console.error(userId);\n    console.error('Failed to get user id by crypto credentials');\n    return;\n  }\n\n  const getCredentialsResult = await credetntialsStoreConnectionToFirebase.getUserCredentials(\n    userId\n  );\n\n  if (!getCredentialsResult) {\n    console.error(\n      'There is no credentials stored before was found in the Firebsae database'\n    );\n    return;\n  }\n  if (getCredentialsResult instanceof Error) {\n    console.error('Failed to read credentials from the Firebase database');\n    return;\n  }\n  if (\n    (await compareCryptoCredentials(\n      setCredentialsResult,\n      credentialsForUser\n    )) !== true\n  ) {\n    console.error(\n      'Credentials for the user got by the user id must be immputable the same as the credentials set by the user on sign up flow'\n    );\n    return;\n  }\n  console.warn('runTestFirebaseCredentialsStorage::success');\n};\n","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.database.ts",["1533","1534"],"import CAConnectionWithFirebaseUtilDatabase from 'classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database';\nimport { connectWithFirebase } from './central-authority-connection.test.firebase.utils';\nimport { CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_KEY_PREFIX } from 'classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.const';\nimport { generateUUID } from 'utils/identity-utils/identity-utils';\n\nexport const runTestFirebaseConnectionDatabase = async () => {\n  console.warn('runTestFirebaseConnectionDatabase::start');\n\n  const login = 'i2ga8r+7mc075w0nc9ns@sharklasers.com';\n  const password = '123456';\n  const firebaseConnection = await connectWithFirebase({\n    login,\n    password,\n  });\n\n  if (firebaseConnection instanceof Error) {\n    console.error(firebaseConnection);\n    return new Error('Failed to connect with firebase');\n  }\n\n  const databaseConnectionToFirebase = new CAConnectionWithFirebaseUtilDatabase();\n\n  if (databaseConnectionToFirebase.isConnected) {\n    console.error('Database connection flag must be false');\n    return;\n  }\n\n  const connectionResult = await databaseConnectionToFirebase.connect();\n\n  if (connectionResult instanceof Error) {\n    console.error(connectionResult);\n    console.error('Failed to connect to the database server');\n    return;\n  }\n  if (!databaseConnectionToFirebase.isConnected) {\n    console.error(\n      'Database connection flag must be true after connection method returns a success result'\n    );\n    return;\n  }\n\n  const randomUUID = generateUUID();\n  const testKey = `${CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_KEY_PREFIX}${randomUUID}`;\n  const testData = {\n    testData: 'testData',\n  };\n  const setValueResult = await databaseConnectionToFirebase.setValue(\n    testKey,\n    testData\n  );\n\n  if (setValueResult instanceof Error) {\n    console.error(setValueResult);\n    return setValueResult;\n  }\n\n  const readValueResult = await databaseConnectionToFirebase.getValue(testKey);\n\n  if (readValueResult instanceof Error) {\n    console.error(readValueResult);\n    console.error('Failed to read a data from the database');\n    return;\n  }\n  if (!readValueResult || typeof readValueResult !== 'object') {\n    console.error('Value is empty or have a wrong format');\n    return;\n  }\n  if ((readValueResult as any).testData !== testData.testData) {\n    console.error(\n      'The data read from the Firebase Realtime Database have a wrong format'\n    );\n    return;\n  }\n  console.warn('runTestFirebaseConnectionDatabase::success');\n};\n","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.ts",["1535","1536","1537","1538","1539","1540"],"import { ICentralAuthorityUserProfile } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport {\n  connectToFirebase,\n  connectWithFirebase,\n  deleteTheUserFromCA,\n} from './central-authority-connection.test.firebase.utils';\nimport {\n  CA_CONNECTION_FIREBASE_USER_CREDENTIALS,\n  CA_CONNECTION_FIREBASE_CONFIG,\n} from './central-authority-connection.test.firebase.const';\nimport { checkIsValidCryptoCredentials } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport CentralAuthorityIdentity from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport { ICAConnectionUserAuthorizedResult } from 'classes/central-authority-class/central-authority-connections/central-authority-connections.types';\nimport { compareCryptoCredentials } from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\n\nexport const runTestCAConnectionFirebaseChangeEmail = async () => {\n  const connectionFirebase = await connectToFirebase();\n\n  if (connectionFirebase instanceof Error) {\n    console.error(connectionFirebase);\n    return;\n  }\n\n  const userProfileWithEmailTest = {\n    name: 'Test account',\n    email: 'gavidan@6mail.top',\n  };\n  const updateProfileWithEmailResult = await connectionFirebase.setProfileData(\n    userProfileWithEmailTest\n  );\n\n  if (updateProfileWithEmailResult instanceof Error) {\n    console.error('Failed to set the profile (with a email) data');\n    return;\n  }\n  if (updateProfileWithEmailResult.name !== updateProfileWithEmailResult.name) {\n    console.error('Name was not updated in the profile');\n    return;\n  }\n  if (\n    updateProfileWithEmailResult.email !== updateProfileWithEmailResult.email\n  ) {\n    console.error('The email was not updated in the profile');\n    return;\n  }\n  if (connectionFirebase.isAuthorized) {\n    console.error(\n      'isAuthorized connection flag must be false on email value changed'\n    );\n    return;\n  }\n};\n\nexport const runTestCAConnectionFirebase = async () => {\n  console.warn('CA connection firebase test started');\n  const credentials = {\n    login: 'lxnmgnyc@sharklasers.com',\n    password: '123456',\n  };\n  const connectionFirebase = await connectWithFirebase(credentials);\n  if (connectionFirebase instanceof Error) {\n    console.error(connectionFirebase);\n    return;\n  }\n\n  console.warn('CA connection firebase test succeed');\n\n  //check profile update result\n  const userProfileTestWOEmailAndPhoneNumber: Partial<\n    ICentralAuthorityUserProfile\n  > = {\n    name: 'Paul',\n    photoURL:\n      'https://cdn.dribbble.com/users/199982/screenshots/4044699/furkan-avatar-dribbble.png',\n  };\n  const updateProfileResult = await connectionFirebase.setProfileData(\n    userProfileTestWOEmailAndPhoneNumber\n  );\n\n  if (updateProfileResult instanceof Error) {\n    console.error('Failed tp set the profile (without a email) data');\n    return deleteTheUserFromCA(connectionFirebase, credentials);\n  }\n\n  if (\n    userProfileTestWOEmailAndPhoneNumber.photoURL !==\n    updateProfileResult.photoURL\n  ) {\n    console.error('The photo URL was not updated in the profile');\n    return deleteTheUserFromCA(connectionFirebase, credentials);\n  }\n  if (userProfileTestWOEmailAndPhoneNumber.name !== updateProfileResult.name) {\n    console.error('Name was not updated in the profile');\n    return deleteTheUserFromCA(connectionFirebase, credentials);\n  }\n  const deleteTheUserResult = await deleteTheUserFromCA(\n    connectionFirebase,\n    credentials\n  );\n  if (deleteTheUserResult instanceof Error) {\n    console.error(deleteTheUserResult);\n    return new Error('Failed to delete the user from the Firebase authority');\n  }\n  console.warn('CA connection firebase test success');\n};\n\nexport const runTestCAConnectionFirebaseCryptoCredentialsGenerateByFirebaseAuthProvider = async () => {\n  const credentials = {\n    login: 'lxnmgnyc@sharklasers.com',\n    password: '123456',\n  };\n  console.error('runTestCAConnectionFirebaseWithoutCryptoCredentials::start');\n  const connectionFirebase = await connectWithFirebase();\n\n  if (connectionFirebase instanceof Error) {\n    return new Error('Failed to sign up to the firebase app');\n  }\n  if (!connectionFirebase.isAuthorized) {\n    return new Error(\n      'isAuthorized connection flag must be truthly on authorization succeed'\n    );\n  }\n  const {\n    cryptoCredentials: cryptoCredentialsGenerated,\n  } = connectionFirebase.getAuthResult() as ICAConnectionUserAuthorizedResult;\n  if (!checkIsValidCryptoCredentials(cryptoCredentialsGenerated)) {\n    console.error(\n      'Invalida crypto credentials generated by Firebase CA connection'\n    );\n    return;\n  }\n\n  const userIdentityByCryptoCredentials = new CentralAuthorityIdentity(\n    cryptoCredentialsGenerated\n  );\n\n  if (!userIdentityByCryptoCredentials.isValid) {\n    console.error('The crypto credentials generated is not valid');\n    return;\n  }\n  const {\n    identityDescription: userIdentityDescription,\n  } = userIdentityByCryptoCredentials;\n\n  if (userIdentityDescription instanceof Error) {\n    console.error(userIdentityDescription);\n    console.error('Failed to parse the identity generated');\n    return;\n  }\n\n  const { authorityProviderURI } = userIdentityDescription;\n\n  if (authorityProviderURI !== CA_CONNECTION_FIREBASE_CONFIG.databaseURL) {\n    console.error(\n      'The url of the Firebase authority provider from generated identity is not valid'\n    );\n    return;\n  }\n  const signOutResult = await connectionFirebase.signOut();\n  if (signOutResult instanceof Error) {\n    console.error(signOutResult);\n    console.error('Failed to sign out');\n    return;\n  }\n\n  const authorizeResultWithCredentialsGenerated = await connectionFirebase.authorize(\n    {\n      ...CA_CONNECTION_FIREBASE_USER_CREDENTIALS,\n      cryptoCredentials: cryptoCredentialsGenerated,\n    }\n  );\n  if (authorizeResultWithCredentialsGenerated instanceof Error) {\n    return new Error('Failed to sign up to the firebase app');\n  }\n  if (!connectionFirebase.isAuthorized) {\n    return new Error(\n      'isAuthorized connection flag must be truthly on authorization succeed'\n    );\n  }\n\n  const {\n    cryptoCredentials: cryptoCredentialsFromAuthorization,\n  } = authorizeResultWithCredentialsGenerated;\n  if (\n    (await compareCryptoCredentials(\n      cryptoCredentialsFromAuthorization,\n      cryptoCredentialsGenerated\n    )) !== true\n  ) {\n    console.error(\n      'Crypto credentials returned after success authorization must be same as provided (if not stored before)'\n    );\n    return;\n  }\n  console.warn('runTestCAConnectionFirebaseWithoutCryptoCredentials::success');\n};\n","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.utils.ts",["1541","1542","1543"],"import { CAConnectionWithFirebase } from 'classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase';\nimport {\n  CA_CONNECTION_FIREBASE_CONFIG,\n  CA_CONNECTION_FIREBASE_CREDENTIALS,\n} from './central-authority-connection.test.firebase.const';\nimport { ICentralAuthorityUserProfile } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { ICAConnectionSignUpCredentials } from 'classes/central-authority-class/central-authority-connections/central-authority-connections.types';\nimport { generateCryptoCredentials } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport ErrorExtendedBaseClass from 'classes/basic-classes/error-extended-class-base/error-extended-class-base';\nimport { CA_CONNECTION_ERROR_ACCOUNT_NOT_VERIFIED_CODE } from 'classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const';\n\nexport const connectToFirebase = async (): Promise<\n  Error | CAConnectionWithFirebase\n> => {\n  const connectionFirebase = new CAConnectionWithFirebase();\n  const connectionResult = await connectionFirebase.connect(\n    CA_CONNECTION_FIREBASE_CONFIG\n  );\n\n  if (connectionResult instanceof Error) {\n    console.error(connectionResult);\n    return new Error('Failed connection to the firebase app account');\n  }\n  if (!connectionFirebase.isConnected) {\n    return new Error(\n      'isConnected status flag must be truthly on connection succeed'\n    );\n  }\n  return connectionFirebase;\n};\n\nexport const aurhorizeWithCredentials = async (\n  authCredentials: ICAConnectionSignUpCredentials,\n  connectionFirebase: CAConnectionWithFirebase\n): Promise<Error | CAConnectionWithFirebase> => {\n  const authorizeResult = await connectionFirebase.authorize(authCredentials);\n\n  if (\n    authorizeResult instanceof ErrorExtendedBaseClass &&\n    authorizeResult.code === CA_CONNECTION_ERROR_ACCOUNT_NOT_VERIFIED_CODE\n  ) {\n    alert('Please, veriy your email');\n    return aurhorizeWithCredentials(authCredentials, connectionFirebase);\n  }\n  if (authorizeResult instanceof Error) {\n    return new Error('Failed to sign up to the firebase app');\n  }\n  if (!connectionFirebase.isAuthorized) {\n    return new Error(\n      'isAuthorized connection flag must be truthly on authorization succeed'\n    );\n  }\n  return connectionFirebase;\n};\n\nexport const connectAndAuthorizeInFirebase = async (\n  authCredentials: ICAConnectionSignUpCredentials\n): Promise<CAConnectionWithFirebase | Error> => {\n  const connectionFirebase = await connectToFirebase();\n\n  if (connectionFirebase instanceof Error) {\n    console.error(connectionFirebase);\n    return connectionFirebase;\n  }\n  return aurhorizeWithCredentials(authCredentials, connectionFirebase);\n};\n\n/**\n * connect to firebase with credentials\n * defined\n */\nexport const connectWithFirebase = async (\n  authCredentials = CA_CONNECTION_FIREBASE_CREDENTIALS\n) => {\n  console.warn('CA connection firebase test started');\n\n  if (authCredentials instanceof Error) {\n    return authCredentials;\n  }\n\n  const connectionFirebase = await connectAndAuthorizeInFirebase(\n    authCredentials\n  );\n\n  if (connectionFirebase instanceof Error) {\n    console.error(connectionFirebase);\n    return connectionFirebase;\n  }\n\n  return connectionFirebase;\n};\n\nexport const deleteTheUserFromCA = async (\n  connectionFirebase: CAConnectionWithFirebase,\n  authCredentials: ICAConnectionSignUpCredentials\n): Promise<boolean | Error> => {\n  if (connectionFirebase instanceof CAConnectionWithFirebase) {\n    const deleteResult = await connectionFirebase.delete(authCredentials);\n\n    if (deleteResult instanceof Error) {\n      console.error(deleteResult);\n      return new Error('Failed to delete the user from the Firebase authority');\n    }\n    return true;\n  }\n  return new Error('The connection to the firebase is not valid');\n};\n","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-connection.test/central-authority-connection.test.ts",["1544"],"import { validateUserProfileData } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user';\n\nexport * from './central-authority-connection.test.firebase';\n\nexport const runTestProfileValidation = () => {\n  console.warn('test for CA user profiel data validation started');\n  const test1ProfileValid = {\n    name: '1',\n  };\n\n  if (!validateUserProfileData(test1ProfileValid)) {\n    console.error('The profile data 1 must be valid');\n    return;\n  }\n\n  const test2ProfileValid = {\n    phone: '+79292239192',\n  };\n\n  if (!validateUserProfileData(test2ProfileValid)) {\n    console.error('The profile data 2 must be valid');\n    return;\n  }\n  console.warn('test for CA user profiel data validation succeed');\n\n  const test3ProfileValid = {\n    name: 'User Name',\n    phone: '+79292239192',\n    email: 'ggg@mail.com',\n    photoURL:\n      'https://camo.githubusercontent.com/e7a14b9a151d9b1d23a0d05dac1af86b0e972714/68747470733a2f2f692e696d6775722e636f6d2f4a497942744b572e706e67',\n  };\n\n  if (!validateUserProfileData(test3ProfileValid)) {\n    console.error('The profile data 3 must be valid');\n    return;\n  }\n\n  const testProfileEmailNotValid = {\n    name: 'User Name',\n    phone: '+79292239192',\n    email: 'gggmail.com',\n    photoURL:\n      'https://camo.githubusercontent.com/e7a14b9a151d9b1d23a0d05dac1af86b0e972714/68747470733a2f2f692e696d6775722e636f6d2f4a497942744b572e706e67',\n  };\n\n  if (validateUserProfileData(testProfileEmailNotValid)) {\n    console.error('The email in the profile data is not valid');\n    return;\n  }\n\n  const testProfilePhotoUrlNotValid = {\n    name: 'User Name',\n    phone: '+79292239192',\n    email: 'ggg@mail.com',\n    photoURL:\n      'camo.githubusercontent/e7a14b9a151d9b1d23a0d05dac1af86b0e972714/68747470733a2f2f692e696d6775722e636f6d2f4a497942744b572e706e67',\n  };\n\n  if (validateUserProfileData(testProfilePhotoUrlNotValid)) {\n    console.error('The photo url in the profile data is not valid');\n    return;\n  }\n\n  console.warn('test for CA user profiel data validation succeed');\n};\n","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-identity.test.ts",["1545","1546","1547"],"import { CentralAuthorityIdentity } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport {\n  CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME,\n  CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n} from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport { generateUUID } from 'utils/identity-utils/identity-utils';\nimport { validateIdentityDescriptionVersion } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators';\nimport { validateUserIdentity } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport {\n  ICAUserUniqueIdentifierDescription,\n  ICAUserUniqueIdentifierDescriptionWithOptionalVersion,\n} from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { generateCryptoCredentialsWithUserIdentity } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport { CA_CONNECTION_FIREBASE_CONFIG } from './central-authority-connection.test/central-authority-connection.test.firebase/central-authority-connection.test.firebase.const';\nimport { checkIsValidCryptoCredentials } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport { getUserIdentityByCryptoCredentials } from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\n\nconst validateIdentityDescription = (\n  identityDescription: ICAUserUniqueIdentifierDescription | Error,\n  testIdentityDescription: ICAUserUniqueIdentifierDescriptionWithOptionalVersion\n): undefined | boolean => {\n  if (identityDescription instanceof Error) {\n    console.error(identityDescription);\n    console.error('Failed to serialize the test description');\n    return;\n  }\n  if (identityDescription) {\n    const {\n      [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: identityDescriptionAuthProvider,\n      [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: identityDescriptionUUID,\n      [CA_USER_IDENTITY_VERSION_PROP_NAME]: identityDescriptionVersion,\n    } = identityDescription;\n    const {\n      [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: testIdentityDescriptionAuthProvider,\n      [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: testIdentityDescriptionUUID,\n    } = testIdentityDescription;\n\n    if (!identityDescriptionVersion) {\n      console.error('a version must be defined in identity description');\n      return;\n    }\n    if (!validateIdentityDescriptionVersion(identityDescriptionVersion)) {\n      console.error('the version of the identity description is not valid');\n      return;\n    }\n    if (identityDescriptionUUID !== testIdentityDescriptionUUID) {\n      console.error('uuid is not the same with the test value');\n      return;\n    }\n    if (\n      identityDescriptionAuthProvider !== testIdentityDescriptionAuthProvider\n    ) {\n      console.error('auth provider is not the same as in the test value');\n      return;\n    }\n    return true;\n  }\n  console.error('The user identity description is empty');\n  return;\n};\n\nconst validateUserIdentityInstance = (\n  identityValue: CentralAuthorityIdentity,\n  testIdentityDescription: ICAUserUniqueIdentifierDescriptionWithOptionalVersion\n): identityValue is CentralAuthorityIdentity => {\n  const { identityDescritptionSerialized, identityDescription } = identityValue;\n\n  if (identityDescription instanceof Error) {\n    console.error(identityDescription);\n    console.error('Failed to serialize the test description');\n    return false;\n  }\n  if (identityDescritptionSerialized instanceof Error) {\n    console.error(identityDescritptionSerialized);\n    console.error('Failed to serialize the test user identity description');\n    return false;\n  }\n  if (!validateUserIdentity(identityDescritptionSerialized)) {\n    console.error('The user identity serialized has a wrong format');\n    return false;\n  }\n  if (\n    !validateIdentityDescription(identityDescription, testIdentityDescription)\n  ) {\n    console.error('The identity description have a wrong format');\n    return false;\n  }\n  return true;\n};\n\nexport const runTestCAIdentity = async () => {\n  const testIdentityDescription = {\n    [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: 'https://google.com',\n    [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: generateUUID(),\n  };\n  const identityValue = new CentralAuthorityIdentity(testIdentityDescription);\n\n  if (!validateUserIdentityInstance(identityValue, testIdentityDescription)) {\n    console.error('Failed to create an instance of CAIdentity');\n    return;\n  }\n\n  const { identityDescritptionSerialized } = identityValue;\n  const identityFromIdentityString = new CentralAuthorityIdentity(\n    identityDescritptionSerialized as string\n  );\n\n  if (\n    !validateUserIdentityInstance(\n      identityFromIdentityString,\n      testIdentityDescription\n    )\n  ) {\n    console.error(\n      'Failed to create an instance of CAIdentity from identityDescritptionSerialized of the test Identity description'\n    );\n    return;\n  }\n\n  const {\n    id: userIdentifier,\n  } = identityFromIdentityString as CentralAuthorityIdentity;\n\n  if (userIdentifier instanceof Error || typeof userIdentifier !== 'string') {\n    console.error(\n      'The user identifier (id) prop must not be an error for a valid identity'\n    );\n    return;\n  }\n\n  const testIdentityDescriptionWithWrongGUID = {\n    [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: 'https://google.com',\n    [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]:\n      '76d55caf-fc4a-41a9-8844-19877dcb19a#',\n  };\n  const identityValueFromWrongGUID = new CentralAuthorityIdentity(\n    testIdentityDescriptionWithWrongGUID\n  );\n\n  if (\n    validateUserIdentityInstance(\n      identityValueFromWrongGUID,\n      testIdentityDescriptionWithWrongGUID\n    )\n  ) {\n    console.error(\n      'Wrong guid value does not recognized in the identifier description'\n    );\n    return;\n  }\n\n  const testIdentityDescriptionWithWrongURL = {\n    [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: 'google.com',\n    [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]:\n      '76d55caf-fc4a-41a9-8844-19877dcb19ad',\n  };\n  const identityValueFromWrongURL = new CentralAuthorityIdentity(\n    testIdentityDescriptionWithWrongURL\n  );\n\n  if (\n    validateUserIdentityInstance(\n      identityValueFromWrongURL,\n      testIdentityDescriptionWithWrongURL\n    )\n  ) {\n    console.error(\n      'Wrong url value does not recognized in the identifier description'\n    );\n    return;\n  }\n\n  const testIdentityStringnWithWrongURL =\n    '01htt://googlecom76d55caf-fc4a-41a9-8844-19877dcb19ad';\n  const identityValueFromStringWrongURL = new CentralAuthorityIdentity(\n    testIdentityStringnWithWrongURL\n  );\n\n  if (\n    validateUserIdentityInstance(identityValueFromStringWrongURL, {\n      [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: 'htt://googlecom',\n      [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]:\n        '76d55caf-fc4a-41a9-8844-19877dcb19ad',\n    })\n  ) {\n    console.error(\n      'Wrong url value does not recognized in the identifier string'\n    );\n    return;\n  }\n  if (\n    !(\n      (identityValueFromStringWrongURL as CentralAuthorityIdentity)\n        .id instanceof Error\n    )\n  ) {\n    console.error(\n      'The user identifier (id) prop must be an error for a wrong authority url'\n    );\n    return;\n  }\n\n  const testIdentityStringnWithWrongUUID =\n    '01https://google.com76d55caf-fc4a-41a9-8*44-19877dcb19ad';\n  const identityValueFromStringWrongUUID = new CentralAuthorityIdentity(\n    testIdentityStringnWithWrongUUID\n  );\n\n  if (\n    validateUserIdentityInstance(identityValueFromStringWrongUUID, {\n      [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]:\n        'https://google.com',\n      [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]:\n        '76d55caf-fc4a-41a9-8*44-19877dcb19ad',\n    })\n  ) {\n    console.error(\n      'Wrong UUID value does not recognized in the identifier string'\n    );\n    return;\n  }\n  if (\n    !(\n      (identityValueFromStringWrongUUID as CentralAuthorityIdentity)\n        .id instanceof Error\n    )\n  ) {\n    console.error('The userIdentifier prop must be an error for a wrong uuid');\n    return;\n  }\n\n  const testIdentityStringnWithWrongVersionUnsupported =\n    '11https://google.com76d55caf-fc4a-41a9-8144-19877dcb19ad';\n  const identityValueFromStringWrongVersionUnsupported = new CentralAuthorityIdentity(\n    testIdentityStringnWithWrongVersionUnsupported\n  );\n  const testIdentityDescriptionWithVersionUnsupported = {\n    [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: 'https://google.com',\n    [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]:\n      '76d55caf-fc4a-41a9-8144-19877dcb19ad',\n    [CA_USER_IDENTITY_VERSION_PROP_NAME]: '11',\n  };\n\n  if (\n    validateUserIdentityInstance(\n      identityValueFromStringWrongVersionUnsupported,\n      testIdentityDescriptionWithVersionUnsupported\n    )\n  ) {\n    console.error(\n      `The version unsupported 11 does not recognized in the identifier string`\n    );\n    return;\n  }\n\n  const identityValueFromIdentityDescriptionWrongVersionUnsupported = new CentralAuthorityIdentity(\n    testIdentityDescriptionWithVersionUnsupported\n  );\n\n  if (\n    validateUserIdentityInstance(\n      identityValueFromIdentityDescriptionWrongVersionUnsupported,\n      testIdentityDescriptionWithVersionUnsupported\n    )\n  ) {\n    console.error(\n      `The version unsupported 11 does not recognized in the identifier string`\n    );\n    return;\n  }\n  if (\n    !(\n      (identityValueFromIdentityDescriptionWrongVersionUnsupported as CentralAuthorityIdentity)\n        .id instanceof Error\n    )\n  ) {\n    console.error(\n      'The user identifier (id) prop must be an error for unsupported identity version'\n    );\n    return;\n  }\n  console.warn('The user identity description test is succesfull');\n};\n\nexport const runTestCAIdentityWithAuthorityProviderGenerator = async () => {\n  console.warn('runTestCAIdentityWithAuthorityProviderGenerator:started');\n\n  const cryptoCredentials = await generateCryptoCredentialsWithUserIdentity({\n    authorityProviderURI: CA_CONNECTION_FIREBASE_CONFIG.databaseURL,\n  });\n  if (!checkIsValidCryptoCredentials(cryptoCredentials)) {\n    console.error('The crypto credentials generated is not valid');\n    return;\n  }\n\n  const userIdentityByCryptoCredentials = getUserIdentityByCryptoCredentials(\n    cryptoCredentials\n  );\n  const caUserIdentity = new CentralAuthorityIdentity(cryptoCredentials);\n\n  if (!caUserIdentity.isValid) {\n    console.error('User identity generated is not valid');\n    return;\n  }\n  const stringifiedIdentity = caUserIdentity.toString();\n\n  if (stringifiedIdentity === '') {\n    console.error(stringifiedIdentity);\n    console.error('Failed to parse the identity');\n    return;\n  }\n  if (stringifiedIdentity !== userIdentityByCryptoCredentials) {\n    console.error('Parsed identity is not valid');\n    return;\n  }\n  const identityDescriptionParsed = caUserIdentity.identityDescription;\n\n  if (identityDescriptionParsed instanceof Error) {\n    console.error(identityDescriptionParsed);\n    console.error('Failed to get description by identity string');\n    return;\n  }\n  if (\n    identityDescriptionParsed[\n      CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME\n    ] !== CA_CONNECTION_FIREBASE_CONFIG.databaseURL\n  ) {\n    console.error('Wrong authority provider url got from the identity string');\n    return;\n  }\n  console.warn('runTestCAIdentityWithAuthorityProviderGenerator:success');\n};\n","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority-storage-identity-credentials.test.ts",["1548"],"import { CentralAuthorityIdentityCredentialsStorage } from 'classes/central-authority-class/central-authority-storage/central-authority-storage-identity-credentials/central-authority-storage-identity-credentials';\nimport { ISecretStoreCredentials } from 'classes/secret-storage-class/secret-storage-class.types';\nimport {\n  CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME,\n  CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME,\n} from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport { generateUUID } from 'utils/identity-utils/identity-utils';\nimport CentralAuthorityIdentity from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport { generateKeyPairs } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport { getUserIdentityByCryptoCredentials, getUserCredentialsByUserIdentityAndCryptoKeys, exportCryptoCredentialsToString } from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\nimport { ICAUserUniqueIdentifierDescriptionWithOptionalVersion } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { TCentralAuthorityUserIdentity } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\n\n\nconst runCACredentialsIdentityStorageTestForCredentials = async (\n  storageInstance: CentralAuthorityIdentityCredentialsStorage,\n  testIdentityDescription: ICAUserUniqueIdentifierDescriptionWithOptionalVersion | TCentralAuthorityUserIdentity,\n  ): Promise<boolean | undefined> => {\n  const caIdentityValueTest = new CentralAuthorityIdentity(\n    testIdentityDescription\n  );\n  const identityTest = caIdentityValueTest.toString();\n  const testKeyPairs = await generateKeyPairs();\n\n  if (testKeyPairs instanceof Error) {\n    console.error(testKeyPairs);\n    console.error('Failed to generate key Pairs');\n    return;\n  }\n\n  const setInStorageResult = await storageInstance.setCredentials(\n    identityTest,\n    testKeyPairs\n  );\n\n  if (setInStorageResult instanceof Error) {\n    console.error(setInStorageResult);\n    return;\n  }\n\n  const caCryptoCredentialsTestRead = await storageInstance.getCredentials(identityTest);\n\n  if (caCryptoCredentialsTestRead instanceof Error) {\n    console.error(caCryptoCredentialsTestRead);\n    console.error('Failed to read the crypto credentials saved previosely');\n    return;\n  }\n  if (!caCryptoCredentialsTestRead) {\n    console.error('The crypto credentials saved previousely have an empty value stored');\n    return;\n  }\n\n  const identityValue = getUserIdentityByCryptoCredentials(caCryptoCredentialsTestRead);\n\n  if (identityValue instanceof Error) {\n    console.error(identityValue);\n    console.error('There is a broken identity value was stored');\n    return;\n  }\n  if (identityValue !== identityTest) {\n    console.error('The identity stored have a wrong value not same as stred');\n    return;\n  }\n\n  const caCredentialsTest = getUserCredentialsByUserIdentityAndCryptoKeys(\n    identityTest,\n    testKeyPairs,\n  );\n\n    if (caCredentialsTest instanceof Error) {\n      console.error(caCredentialsTest);\n      console.error('Failed to create CACryproCredentials by the identity and test key pairs');\n      return;\n    }\n\n  const storeResultCaCryptoCredentials = await storageInstance.setCredentials(caCredentialsTest);\n\n  if (storeResultCaCryptoCredentials instanceof Error) {\n    console.error(storeResultCaCryptoCredentials);\n    console.error('Failed to store the CACryptoCredentials format');\n    return;\n  }\n  if (storeResultCaCryptoCredentials !== false) {\n    console.error('Crypto credentials for the same identity must not be rewritten');\n    return;    \n  }\n  \n  const caCryptoCredentialsExportedToStringTest = await exportCryptoCredentialsToString(caCredentialsTest);\n\n  if (caCryptoCredentialsExportedToStringTest instanceof Error) {\n    console.error(caCryptoCredentialsExportedToStringTest);\n    console.error('Failed to export CACryptoCredentials to a string');\n    return;\n  }\n\n  const storeResultCaCryptoCredentialsExportedToString = await storageInstance.setCredentials(caCryptoCredentialsExportedToStringTest);\n\n  if (storeResultCaCryptoCredentialsExportedToString instanceof Error) {\n    console.error(storeResultCaCryptoCredentialsExportedToString);\n    console.error('Failed to store the CACryptoCredentials exported to a string format');\n    return;\n  }\n  if (storeResultCaCryptoCredentialsExportedToString !== false) {\n    console.error('Crypto credentials (exported as string) for the same identity must not be rewritten');\n    return;    \n  }\n  \n  return true;\n};\n\nexport const runCACredentialsIdentityStorageTest = async () => {\n  console.warn('Storage identity test was started');\n  \n  const conectionCredentials: ISecretStoreCredentials = {\n    password: '11234',\n  };\n  const storageInstance = new CentralAuthorityIdentityCredentialsStorage();\n  const connectionResult = await storageInstance.connect(conectionCredentials);\n\n  if (connectionResult instanceof Error) {\n    console.error(connectionResult);\n    console.error(new Error('Failed to connect to the storage'));\n    return;\n  }\n\n  const testIdentityDescription = {\n    [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: 'https://google.com',\n    [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: generateUUID(),\n  };\n  const resultFirst = await runCACredentialsIdentityStorageTestForCredentials(\n    storageInstance,\n    testIdentityDescription\n  );\n\n  if (resultFirst !== true) {\n    console.error('Test for the first credentials was failed');\n    return;\n  }\n\n  const testIdentityDescriptionTwo = {\n    [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: 'https://google1.com',\n    [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: generateUUID(),\n  };\n  const resultTwo = await runCACredentialsIdentityStorageTestForCredentials(\n    storageInstance,\n    testIdentityDescriptionTwo\n  );\n\n  if (resultTwo !== true) {\n    console.error('Test for the second credentials was failed');\n    return;\n  }\n\n  console.warn('Test for a wrong identity valie started');\n  const testIdentityDescriptionWrongFormat = {\n    [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: '',\n    [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: generateUUID(),\n  };\n  const resultMustBeFailed = await runCACredentialsIdentityStorageTestForCredentials(\n    storageInstance,\n    testIdentityDescriptionWrongFormat\n  );\n\n  if (resultMustBeFailed) {\n    console.error('Test for a wrong identity valie must failed');\n    return;\n  }\n  console.warn('Test for a wrong identity value succeed');\n\n  const storageDisconnectResult = await storageInstance.disconnect();\n\n  if (storageDisconnectResult instanceof Error) {\n    console.error(storageDisconnectResult);\n    console.error('Failed to disconnect');\n    return;\n  }\n\n  const caIdentityValueTest = new CentralAuthorityIdentity(\n    testIdentityDescription\n  );\n  const identityTest = caIdentityValueTest.toString();\n    \n  if (!identityTest) {\n    console.error(identityTest);\n    console.error('Failed to generate test identity string on disconnected storage test');\n    return;\n  }\n\n  const testKeyPairs = await generateKeyPairs();\n\n  if (testKeyPairs instanceof Error) {\n    console.error(testKeyPairs);\n    console.error('Failed to generate key pairs on disconnected storage test');\n    return;\n  }\n\n  const setCredentialsResultDisconnected = await storageInstance.setCredentials(\n    identityTest,\n    testKeyPairs\n  );\n\n  if (!(setCredentialsResultDisconnected instanceof Error)) {\n    console.error('Execution of the setCredentials method must failed on disconnected storage')\n    return;\n  }\n\n  const getCredentialsResultDisconnected = await storageInstance.getCredentials(\n    identityTest,\n  );\n\n  if (!(getCredentialsResultDisconnected instanceof Error)) {\n    console.error('Execution of the getCredentials method must failed on disconnected storage')\n    return;\n  }\n  console.warn('Storage identity test was succes');\n};\n","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority.credentials-storage.test.ts",["1549"],"import { generateKeyPairs } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport { runTestForKeyPairs } from './central-aurhority.keys.common.test';\nimport {\n  CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME,\n  CA_AUTH_CREDENTIALS_USER_PASSWORD_PROP_NAME,\n} from 'classes/central-authority-class/central-authority-class-const/central-authority-class-const';\nimport { generateUUID } from 'utils/identity-utils/identity-utils';\nimport { CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_CRYPTO_KEYS_KEY_NAME } from 'classes/central-authority-class/central-authority-storage/central-authority-storage-credentials/central-authority-storage-credentials.const';\nimport { CentralAuthorityCredentialsStorage } from 'classes/central-authority-class/central-authority-storage/central-authority-storage-credentials/central-authority-storage-credentials';\n\nexport const runTestsCredentialsStorage = async () => {\n  const cryptoKeyPairsGenerated = await generateKeyPairs();\n\n  if (cryptoKeyPairsGenerated instanceof Error) {\n    console.error(cryptoKeyPairsGenerated);\n    console.error('Failed to generate a new key pairs');\n    return;\n  }\n\n  console.warn('Run tests for credentials storage keys generated');\n  const result = await runTestForKeyPairs(cryptoKeyPairsGenerated);\n\n  if (result !== true) {\n    console.warn('Failed tests for credentials storage keys generated');\n    return;\n  }\n\n  const cryptoCredentialsStorage = new CentralAuthorityCredentialsStorage();\n  const storageAuthCredentials = {\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: generateUUID(),\n    [CA_AUTH_CREDENTIALS_USER_PASSWORD_PROP_NAME]: 'password',\n  };\n\n  console.warn(\n    'Success result in the tests for credentials storage keys generated'\n  );\n  const connectionResult = await cryptoCredentialsStorage.connect(\n    storageAuthCredentials\n  );\n\n  if (connectionResult instanceof Error) {\n    console.error('Failed to connect to the secret storage');\n    return;\n  }\n\n  const credentials = await cryptoCredentialsStorage.getCredentials();\n\n  if (credentials instanceof Error) {\n    console.error(credentials);\n    console.error('Failed to reade a credentials read from the new instance');\n    return;\n  }\n  if (credentials !== null) {\n    console.error('The credentials read from the new instance must be null');\n    return;\n  }\n\n  const credentialsSetResult = await cryptoCredentialsStorage.setCredentials(\n    cryptoKeyPairsGenerated\n  );\n\n  if (credentialsSetResult instanceof Error) {\n    console.error(credentialsSetResult);\n    console.error('Failed to set the credentials');\n    return;\n  }\n\n  const credentialsCached = await cryptoCredentialsStorage.getCredentials();\n\n  if (credentialsCached instanceof Error) {\n    console.error(credentialsCached);\n    console.error('Failed to read a credentials stored');\n    return;\n  }\n  if (credentialsCached === null) {\n    console.error('The credentials stored are absent in the storage and cache');\n    return;\n  }\n\n  const {\n    [CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPairsStored,\n  } = credentialsCached;\n  const resultTestCredentialsStored = await runTestForKeyPairs(\n    cryptoKeyPairsStored\n  );\n\n  if (resultTestCredentialsStored !== true) {\n    console.warn(\n      'Failed tests for credentials storage keys read from stored values'\n    );\n    return;\n  }\n\n  const resultCryptoCredentialsStorageDisconnect = await cryptoCredentialsStorage.disconnect();\n\n  if (resultCryptoCredentialsStorageDisconnect instanceof Error) {\n    console.error(resultCryptoCredentialsStorageDisconnect);\n    console.error(\n      'Failed to disconnect the first instance of the resultCryptoCredentialsStorageDisconnect'\n    );\n    return;\n  }\n\n  const credentialsReadFromStorageDisconnected = await cryptoCredentialsStorage.getCredentials();\n\n  if (!(credentialsReadFromStorageDisconnected instanceof Error)) {\n    console.error('Any read from the disconnected storage must cause an error');\n    return;\n  }\n\n  const resultSetCredentialsReadFromStorageDisconnected = await cryptoCredentialsStorage.setCredentials(\n    cryptoKeyPairsGenerated\n  );\n\n  if (!(resultSetCredentialsReadFromStorageDisconnected instanceof Error)) {\n    console.error(\n      'Any write from the disconnected storage must cause an error'\n    );\n    return;\n  }\n  /**\n   * create a new instance\n   * to check if it works\n   * and can to read a stored\n   * piveousely crypto credentials.\n   * Connect with the credentials\n   * exactly same as used\n   * for the first connection\n   */\n\n  const cryptoCredentialsStorageSecondInstance = new CentralAuthorityCredentialsStorage();\n  const connectionResultSecondInstance = await cryptoCredentialsStorageSecondInstance.connect(\n    storageAuthCredentials\n  );\n\n  if (connectionResultSecondInstance instanceof Error) {\n    console.error(\n      'Failed to connect to the secret storage with the second instance'\n    );\n    return;\n  }\n\n  const credentialsReadFromStorage = await cryptoCredentialsStorageSecondInstance.getCredentials();\n\n  if (credentialsReadFromStorage instanceof Error) {\n    console.error(credentials);\n    console.error('Failed to read a credentials read from the second instance');\n    return;\n  }\n  if (credentialsReadFromStorage === null) {\n    console.error('The credentials read by second instance must not be empty');\n    return;\n  }\n\n  const {\n    [CENTRAL_AUTHORITY_STORAGE_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPairsStoredByTheFirstInstance,\n  } = credentialsReadFromStorage;\n  const resultTestCredentialsStoredByTheFirstInstance = await runTestForKeyPairs(\n    cryptoKeyPairsStoredByTheFirstInstance\n  );\n\n  if (resultTestCredentialsStoredByTheFirstInstance !== true) {\n    console.warn(\n      'Failed tests for credentials storage keys read from stored values'\n    );\n    return;\n  }\n  console.warn('Succeed in the crypto credentials storage tests');\n  return true;\n};\n","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority.keys.test.ts",["1550"],"import { generateKeyPairs } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport { runTestForKeyPairs } from './central-aurhority.keys.common.test';\n\nexport const runTestKeys = async () => {\n  console.warn('Central authority keys tests start');\n\n  const keyPairs = await generateKeyPairs();\n  return runTestForKeyPairs(keyPairs);\n};\n","/home/paul/projects/decentrilized-protocol/src/test/central-authority.test/central-authority.test.ts",[],"/home/paul/projects/decentrilized-protocol/src/test/common-utils.test/common-utils.caching-decorator.test.ts",["1551","1552"],"import { dataCachingUtilsCachingDecorator as caching } from 'utils/data-cache-utils/data-cache-utils';\nimport { generateUUID } from 'utils/identity-utils/identity-utils';\n\nconst ITERATIONS_COUNT = 60000;\nconst CACHE_CAPACITY = 200;\n\nexport const runTestCachingDecorator = async () => {\n  const values: { [k: string]: string } = {};\n\n  let idx = 0;\n  while (idx < ITERATIONS_COUNT) {\n    values[generateUUID()] = generateUUID();\n    idx += 1;\n  }\n\n  class CachingDecoratorTestClass {\n    @caching(CACHE_CAPACITY)\n    async getValue(key: string): Promise<string | undefined> {\n      return (values as any)[key];\n    }\n  }\n\n  const instance = new CachingDecoratorTestClass();\n  let iteration = 0;\n\n  idx = 0;\n  const keysValues = Object.keys(values);\n  let k;\n\n  iteration += 1;\n  console.log(`The iteration ${iteration}`);\n  while (idx < keysValues.length) {\n    k = keysValues[idx];\n    if ((await instance.getValue(k)) !== values[k]) {\n      console.error(`Value for the key '${k}' is not equals`);\n      return;\n    }\n    idx += 1;\n  }\n  iteration += 1;\n  console.log(`The iteration ${iteration}`);\n  idx = Math.ceil(keysValues.length / 2);\n  while (idx < keysValues.length) {\n    k = keysValues[idx];\n    if ((await instance.getValue(k)) !== values[k]) {\n      console.error(`Value for the key '${k}' is not equals`);\n      return;\n    }\n    idx += 1;\n  }\n  iteration += 1;\n  console.log(`The iteration ${iteration}`);\n  idx = Math.ceil(keysValues.length / 2 + keysValues.length / 4);\n  while (idx < keysValues.length) {\n    k = keysValues[idx];\n    if ((await instance.getValue(k)) !== values[k]) {\n      console.error(`Value for the key '${k}' is not equals`);\n      return;\n    }\n    idx += 1;\n  }\n  iteration += 1;\n  console.log(`The iteration ${iteration}`);\n  idx = Math.ceil(keysValues.length / 3 + keysValues.length / 5);\n  while (idx < keysValues.length) {\n    k = keysValues[idx];\n    if ((await instance.getValue(k)) !== values[k]) {\n      console.error(`Value for the key '${k}' is not equals`);\n      return;\n    }\n    idx += 1;\n  }\n  iteration += 1;\n  console.log(`The iteration ${iteration}`);\n  idx = keysValues.length;\n  while (idx >= 0) {\n    k = keysValues[idx];\n    if ((await instance.getValue(k)) !== values[k]) {\n      console.error(`Value for the key '${k}' is not equals`);\n      return;\n    }\n    idx -= 1;\n  }\n  iteration += 1;\n  console.log(`The iteration ${iteration}`);\n  idx = Math.ceil(keysValues.length / 4 + keysValues.length / 3);\n  while (idx >= 0) {\n    k = keysValues[idx];\n    if ((await instance.getValue(k)) !== values[k]) {\n      console.error(`Value for the key '${k}' is not equals`);\n      return;\n    }\n    idx -= 1;\n  }\n  iteration += 1;\n  console.log(`The iteration ${iteration}`);\n  idx = Math.ceil(keysValues.length / 4 + keysValues.length / 3);\n  while (idx >= 0) {\n    k = keysValues[idx];\n    if ((await instance.getValue(k)) !== values[k]) {\n      console.error(`Value for the key '${k}' is not equals`);\n      return;\n    }\n    idx -= 1;\n  }\n  console.error('Test for caching decorator succeed');\n};\n","/home/paul/projects/decentrilized-protocol/src/test/common-utils.test/common-utils.test.ts",[],"/home/paul/projects/decentrilized-protocol/src/test/http-request-class-base.test/http-request-class-base.test.ts",["1553"],"import { expect } from 'chai';\nimport HttpRequest from 'classes/basic-classes/http-request-class-base/http-request-class-base';\n\nexport function runTestHttpRequest() {\n  describe('test HttpRequest class', async () => {\n    it('check a response from google.com', async () => {\n      const req = new HttpRequest({\n        url: 'google.com',\n      });\n\n      expect(req).to.be.an.instanceof(HttpRequest);\n      await expect(req.send()).to.eventually.fulfilled;\n    });\n  });\n}\n","/home/paul/projects/decentrilized-protocol/src/test/ipfs-swarm-connection.test/ipfs-swarm-connection-ipfs.test.ts",["1554","1555"],"import { SwarmConnectionSubclassIPFS } from 'classes/swarm-connection-class/swarm-connection-class-subclasses/swarm-connection-class-subclass-ipfs/swarm-connection-class-subclass-ipfs';\nimport { initializeMocha, runMocha } from 'test/mocha-chai-initialize';\nimport { expect, assert } from 'chai';\nimport { SWARM_CONNECTION_PASSWORD } from './ipfs-swarm-connection.const';\n\nexport const runTestSwarmConnectionIPFS = async () => {\n  await initializeMocha();\n\n  describe('ipfs swarm connection', () => {\n    it('create ipfs swarm connection', async () => {\n      const connection = new SwarmConnectionSubclassIPFS();\n      const password = SWARM_CONNECTION_PASSWORD;\n\n      try {\n        expect(connection.connect).to.be.a('function');\n        await assert.becomes(connection.connect({\n          password,\n        }), true, 'Connection to the swarm was not established');\n        expect(connection.isConnected).to.equal(true);\n        await assert.becomes(connection.close(), true, 'Connection to the swarm was not closed succesfully');\n        expect(connection.isConnected).to.equal(false);\n        await expect(connection.connect({\n          password,\n        })).to.eventually.be.an.instanceOf(Error);\n        assert(connection.isClosed === true, 'Connection isClosed flag must be true, after the connection was closed previousely');\n        assert(connection.isConnected === false, 'Connection isConnected flag must be false, after the connection was closed previousely');\n        return Promise.resolve();\n      } catch(err) {\n        return Promise.reject(err);\n      }\n    }).timeout(10000)\n  })\n  runMocha();\n};\n","/home/paul/projects/decentrilized-protocol/src/test/ipfs-swarm-connection.test/ipfs-swarm-connection.test.ts",["1556","1557","1558"],"import { SwarmConnection } from 'classes/swarm-connection-class/swarm-connection-class';\nimport { ESwarmConnectionClassSubclassType, ESwarmConnectionSubclassStatus } from 'classes/swarm-connection-class/swarm-connection-class.types';\nimport { expect, assert } from 'chai';\nimport { SWARM_CONNECTION_PASSWORD, SWARM_CONNECTION_OPTIONS } from './ipfs-swarm-connection.const';\nimport { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport { STATUS_CLASS_STATUS_CHANGE_EVENT } from 'classes/basic-classes/status-class-base/status-class-base.const';\n\nexport const runTestSwarmConnection = async () => {\n  describe('swarm connection:: ipfs', () => {\n    it('create ipfs swarm connection', async () => {\n      console.warn('runTestIPFSSwarmConnection');\n      const connectionToSwarm = new SwarmConnection();\n\n      expect(connectionToSwarm).to.be.an.instanceof(SwarmConnection);\n      expect(connectionToSwarm.connect).to.be.a('function');\n      try {\n        await assert.becomes(connectionToSwarm.connect(SWARM_CONNECTION_OPTIONS), true, 'Failed to connect to the Swarm with ipfs');\n        expect(connectionToSwarm.isConnected).to.equal(true);\n        await assert.becomes(connectionToSwarm.close(), true, 'Connection to the swarm was not closed succesfully');\n        expect(connectionToSwarm.isConnected).to.equal(false);\n        await expect(connectionToSwarm.connect(SWARM_CONNECTION_OPTIONS)).to.eventually.be.an.instanceOf(Error);\n        assert(connectionToSwarm.isClosed === true, 'Connection isClosed flag must be true, after the connection was closed previousely');\n        assert(connectionToSwarm.isConnected === false, 'Connection isConnected flag must be false, after the connection was closed previousely');\n        return Promise.resolve();\n      } catch(err) {\n        console.error(err);\n        return Promise.reject(err);\n      }\n    }).timeout(10000);\n\n    it('swarm connection: check status', async () => {\n      console.warn('runTestIPFSSwarmConnection');\n      const connectionToSwarm = new SwarmConnection();\n\n      expect(connectionToSwarm).to.be.an.instanceof(SwarmConnection);\n      expect(connectionToSwarm.connect).to.be.a('function');\n\n      const connectionOptions = {\n        type: ESwarmConnectionClassSubclassType.IPFS,\n        subclassOptions: {\n          password: SWARM_CONNECTION_PASSWORD\n        }\n      };\n\n      try {\n        const { statusEmitter } = connectionToSwarm;\n        const statusesEmitted: ESwarmConnectionSubclassStatus[] = [];\n\n        expect(statusEmitter).to.be.an.instanceof(EventEmitter);\n        statusEmitter.addListener(STATUS_CLASS_STATUS_CHANGE_EVENT, status => statusesEmitted.push(status));\n        await assert.becomes(connectionToSwarm.connect(connectionOptions), true, '');\n        expect(statusesEmitted).to.be.an('array').to.include.members([\n          ESwarmConnectionSubclassStatus.CONNECTED,\n          ESwarmConnectionSubclassStatus.CONNECTING,\n          ESwarmConnectionSubclassStatus.STARTED,\n        ]);\n        return Promise.resolve();\n      } catch(err) {\n        console.error(err);\n        return Promise.reject(err);\n      }\n    }).timeout(10000)\n\n  })\n};\n","/home/paul/projects/decentrilized-protocol/src/test/nodejs-helpers.test/nodejs-helpers.test.firebase/nodejs-helpers.test.firebase.js",["1559"],"const admin = require('firebase-admin');\nconst serviceKey = require('./firebase.serviceKey.json');\n\nconst removeAllUsers = async () => {\n  const initResult = await admin.initializeApp({\n    credential: admin.credential.cert(serviceKey),\n    databaseURL: 'https://protocol-f251b.firebaseio.com',\n  });\n\n  if (initResult instanceof Error) {\n    console.error(initResult);\n    return new Error(\"Can't initialize the application\");\n  }\n\n  function deleteUser(uid) {\n    admin\n      .auth()\n      .deleteUser(uid)\n      .then(function() {\n        console.log('Successfully deleted user', uid);\n      })\n      .catch(function(error) {\n        console.log('Error deleting user:', error);\n      });\n  }\n\n  function getAllUsers(nextPageToken) {\n    admin\n      .auth()\n      .listUsers(100, nextPageToken)\n      .then(function(listUsersResult) {\n        listUsersResult.users.forEach(function(userRecord) {\n          let uid = userRecord.toJSON().uid;\n          deleteUser(uid);\n        });\n        if (listUsersResult.pageToken) {\n          getAllUsers(listUsersResult.pageToken);\n        }\n      })\n      .catch(function(error) {\n        console.log('Error listing users:', error);\n      });\n  }\n  getAllUsers();\n};\n\nremoveAllUsers();\n","/home/paul/projects/decentrilized-protocol/src/test/password-key.test.ts",["1560","1561","1562","1563","1564"],"import {\n  generatePasswordKeyAsString,\n  importPasswordKeyFromString,\n  exportPasswordKey,\n} from 'utils/password-utils/derive-key.password-utils';\nimport {\n  encryptDataToArrayBuffer,\n  encryptDataToString,\n  encryptDataWithPassword,\n} from 'utils/password-utils/encrypt.password-utils';\nimport {\n  decryptDataWithKeyNative,\n  decryptDataWithKey,\n  decryptDataByPassword,\n} from 'utils/password-utils/decrypt.password-utils';\n\nconst testKeyGeneration = async () => {\n  /**\n   * test key generation from a password\n   */\n  // const passwordString = '123';\n  // const passwordKey = await generatePasswordKeyAsString(passwordString);\n  // console.log('passwordKey', passwordKey);\n  // const passwordStringAgain = '123';\n  // const passwordKeyAgain = await generatePasswordKeyAsString(\n  //   passwordStringAgain\n  // );\n  // console.log('passwordKeyAgain', passwordKeyAgain);\n  // console.log('isEquals', passwordKeyAgain === passwordKey);\n  // if (typeof passwordKeyAgain === 'string' && typeof passwordKey === 'string') {\n  //   const resultedKeyImported = await importPasswordKeyFromString(passwordKey);\n  //   const resultedKeyImportedAgain = await importPasswordKeyFromString(\n  //     passwordKeyAgain\n  //   );\n  //   if (\n  //     !(resultedKeyImported instanceof Error) &&\n  //     !(resultedKeyImported instanceof Error)\n  //   ) {\n  //     const exportedImported = await exportPasswordKey(resultedKeyImported);\n  //     const exportedAgainImported = await exportPasswordKey(\n  //       resultedKeyImported\n  //     );\n  //     console.log('exportedImported', exportedImported);\n  //     console.log('exportedAgainImported', exportedAgainImported);\n  //     if (\n  //       !(exportedImported instanceof Error) &&\n  //       !(exportedAgainImported instanceof Error)\n  //     ) {\n  //       console.log('isEquals', exportedImported.k === exportedAgainImported.k);\n  //     }\n  //   }\n  // }\n  const passwordString = '12345678';\n  const passwordKey = await generatePasswordKeyAsString(passwordString);\n\n  if (passwordKey instanceof Error) {\n    console.error(passwordKey);\n    return passwordKey;\n  }\n\n  const data = 'test_string';\n  const chipher = await encryptDataToString(passwordKey, data);\n\n  if (chipher instanceof Error) {\n    console.error(chipher);\n    return chipher;\n  }\n  console.log('chipher', chipher);\n  const decrypted = await decryptDataWithKey(passwordKey, chipher);\n\n  if (decrypted instanceof Error) {\n    console.error(decrypted);\n    return decrypted;\n  }\n  console.log('decrypted', decrypted);\n  console.log('is valid', decrypted === data);\n\n  const dataTest = 'test string fo password';\n  const pwd = 'pwd_test';\n  const encrypted = await encryptDataWithPassword(pwd, dataTest);\n\n  if (encrypted instanceof Error) {\n    console.error(encrypted);\n    return encrypted;\n  }\n\n  const decryptedPwd = await decryptDataByPassword(pwd, encrypted);\n\n  if (decryptedPwd instanceof Error) {\n    console.error(decryptedPwd);\n    return decryptedPwd;\n  }\n  console.log('decryptedPwd', decryptedPwd);\n  console.log('is valid', decryptedPwd === dataTest);\n};\n\ntestKeyGeneration();\n","/home/paul/projects/decentrilized-protocol/src/test/safe-storage.test.ts",["1565","1566","1567"],"import { SafeStorage } from 'classes/safe-storage-class';\nimport { ESAFE_STORAGE_STORAGE_TYPE } from 'classes/safe-storage-class/safe-storage-class.const';\n\nexport const runTestAppendLogStorage = async () => {\n  const safeStorageAppendLog = new SafeStorage({\n    name: 'testStorage',\n    credentials: {\n      password: 'test_password',\n    },\n    storageType: ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG,\n  });\n\n  console.dir(safeStorageAppendLog);\n\n  const connectionResult = await safeStorageAppendLog.connect();\n\n  if (connectionResult instanceof Error) {\n    console.error(connectionResult);\n    return connectionResult;\n  }\n  console.dir(safeStorageAppendLog);\n\n  const pushDataResult = await safeStorageAppendLog.set({ hello: new Date() });\n\n  if (pushDataResult instanceof Error) {\n    return pushDataResult;\n  }\n\n  const pushNewDataResult = await safeStorageAppendLog.set({\n    newHello: new Date(),\n  });\n\n  if (pushNewDataResult instanceof Error) {\n    return pushNewDataResult;\n  }\n\n  console.log('data was pushed in append log storage');\n};\n\nexport const runTestKeyValueStorage = async () => {\n  const safeStorage = new SafeStorage({\n    name: 'testStorageKeyValue',\n    credentials: {\n      password: 'test_password_KV',\n    },\n    storageType: ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE,\n  });\n\n  console.dir(safeStorage);\n\n  const connectionResult = await safeStorage.connect();\n\n  if (connectionResult instanceof Error) {\n    console.error(connectionResult);\n    return connectionResult;\n  }\n  console.dir(safeStorage);\n\n  const pushDataResult = await safeStorage.set(\n    { hello: new Date() },\n    `${new Date()}`\n  );\n\n  if (pushDataResult instanceof Error) {\n    return pushDataResult;\n  }\n\n  const pushNewDataResult = await safeStorage.set(\n    { hello: new Date() },\n    `${new Date()}|||new`\n  );\n\n  if (pushNewDataResult instanceof Error) {\n    return pushNewDataResult;\n  }\n  console.log('data was pushed in key value storage');\n};\n\nexport const runTest = async () => {\n  await runTestAppendLogStorage();\n  // await Promise.all([runTestAppendLogStorage(), runTestKeyValueStorage()]);\n};\n","/home/paul/projects/decentrilized-protocol/src/test/secret-storage.test.ts",["1568"],"import { SecretStorage } from 'classes/secret-storage-class';\n\nexport const runTest = async () => {\n  const secretStorage = new SecretStorage();\n  const password = '494949494';\n  const isAuthorized = await secretStorage.authorize({\n    password,\n  });\n\n  if (isAuthorized instanceof Error) {\n    console.error(isAuthorized);\n    return isAuthorized;\n  }\n  console.log('isAuthorized', isAuthorized);\n\n  const secretStorageNewInstance = new SecretStorage();\n  //should connect because authoirized before and credentials are stored (e.g. in the session storage)\n  const connectionResult = await secretStorageNewInstance.connect();\n\n  if (connectionResult instanceof Error) {\n    console.error(connectionResult);\n    return connectionResult;\n  }\n  console.log('is new instance connected', connectionResult);\n\n  const testValue = 'testy value for the secret storage';\n  const testValueKey = 'test_value';\n  const setTestValueResult = await secretStorage.set(testValueKey, testValue);\n\n  if (setTestValueResult instanceof Error) {\n    console.error(setTestValueResult);\n    return setTestValueResult;\n  }\n  console.log('setTestValueResult', setTestValueResult);\n\n  const getTestValueResult = await secretStorageNewInstance.get(testValueKey);\n\n  if (getTestValueResult instanceof Error) {\n    console.error(getTestValueResult);\n    return getTestValueResult;\n  }\n  console.log('getTestValueResult', getTestValueResult);\n  console.log('is valid', testValue === getTestValueResult);\n};\n","/home/paul/projects/decentrilized-protocol/src/test/swarm-storage-orbit-db.test/swarm-storage-orbit-db.test.const.ts",["1569","1570"],"import { ISwarmStoreConnectorOrbitDBOptions } from 'classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types';\nimport { ISecretStorageOptions, ISecretStoreCredentials } from 'classes/secret-storage-class/secret-storage-class.types';\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME = 'database_test';\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_TWO_DATABASE_DB_NAME = 'database_test_2';\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASE_DB_NAME = 'database_test_3';\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE: ISwarmStoreConnectorOrbitDBOptions<string> = {\n    databases: [{\n        dbName: SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n        isPublic: false,\n    }],\n};\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_ACCESS_CONTROLLER: ISwarmStoreConnectorOrbitDBOptions<string> = {\n    databases: [{\n        dbName: SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n        isPublic: true,\n        grantAcess: async (entity, id) => {\n            return true;\n        }\n    }],\n};\n\nconst USER_ID_KEY = '____userId';\nconst TEST_VALUE_KEY = '____test_value';\nfunction promptUserIdAndTestValue() {\n    const userIdStored = localStorage.getItem(USER_ID_KEY);\n\n    if (!userIdStored) {\n        const userId = String(window.prompt('user id', 'test1'));\n\n        localStorage.setItem(USER_ID_KEY, userId);\n    }\n    \n    const testValueStored = localStorage.getItem(TEST_VALUE_KEY);\n\n    if (!testValueStored) {\n        const tstv = String(window.prompt('test value', 'tv'));\n\n        localStorage.setItem(TEST_VALUE_KEY, tstv);\n    }\n}\npromptUserIdAndTestValue();\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_TEST_VALUE = `${localStorage.getItem(TEST_VALUE_KEY)}${new Date()}`;\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_WITH_IDENTITY = {\n    ...SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE,\n    id: localStorage.getItem(USER_ID_KEY),\n}\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_WITH_IDENTITY_AND_ACCESS_CONTROLLER = {\n    ...SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_ACCESS_CONTROLLER,\n    id: localStorage.getItem(USER_ID_KEY),\n}\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_DATABASE_TWO = {\n    dbName: SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_TWO_DATABASE_DB_NAME,\n    isPublic: false,\n};\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_DATABASE_THREE = {\n    dbName: SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASE_DB_NAME,\n    isPublic: false,\n};\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASES: ISwarmStoreConnectorOrbitDBOptions<string> = {\n    databases: [\n        {\n            dbName: SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n            isPublic: true,\n        },\n        {\n            ...SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_DATABASE_TWO,\n            isPublic: true,\n        },\n        {\n            ...SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_DATABASE_THREE,\n            isPublic: true,\n        },\n    ],\n};\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASES_CUSTOM_ACCESS_CONTROLLER: ISwarmStoreConnectorOrbitDBOptions<string> = {\n    databases: [\n        {\n            dbName: SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n            isPublic: true,\n        },\n        {\n            ...SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_DATABASE_TWO,\n            isPublic: true,\n        },\n        {\n            ...SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_DATABASE_THREE,\n            isPublic: true,\n            grantAcess: async (entity, id): Promise<boolean> => {\n                return !!entity && !!id;\n            }\n        },\n    ],\n};\n\nexport const SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASES_WITH_IDENTITY_AND_ACCESS_CONTROLLER_SECRET_KEYSTORE = {\n    ...SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASES_CUSTOM_ACCESS_CONTROLLER,\n    id: localStorage.getItem(USER_ID_KEY),\n    credentials: {\n        password: '123456',\n    }\n}\n\nexport const SWARM_STORE_CONNECTOR_TEST_SUBCLASS_SECRET_STORAGE_CONNECTOR_OPTIONS: Required<ISecretStorageOptions> = {\n    dbName: '__SwarmStorageConnectorTest___DB__TEST',\n};\n\nexport const SWARM_STORE_CONNECTOR_TEST_SUBCLASS_SECRET_STORAGE_CONNECTOR_CREDENTIALS: ISecretStoreCredentials = {\n    password: '123456',\n};\n\nexport const SWARM_STORE_CONNECTOR_TEST_SUBCLASS_CACHE_OPTIONS: Required<ISecretStorageOptions> = {\n    dbName: '__SwarmStorageConnectorTest___DB__TEST',\n};\n","/home/paul/projects/decentrilized-protocol/src/test/swarm-storage-orbit-db.test/swarm-storage-orbit-db.test.ts",["1571","1572","1573","1574","1575","1576","1577","1578","1579","1580","1581","1582","1583","1584","1585","1586","1587","1588","1589","1590","1591","1592","1593","1594","1595","1596","1597","1598","1599","1600","1601","1602","1603","1604","1605","1606","1607","1608","1609","1610","1611","1612","1613","1614","1615","1616","1617","1618","1619","1620","1621","1622","1623","1624","1625","1626","1627","1628","1629","1630","1631","1632","1633","1634","1635","1636","1637","1638","1639","1640","1641","1642"],"import { IPFS } from 'types/ipfs.types';\nimport ipfs from 'ipfs';\nimport { expect, assert } from 'chai';\nimport { SwarmStoreConnectorOrbitDB } from 'classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db';\nimport { \n    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE,\n    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_TEST_VALUE, \n    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASES,\n    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_TWO_DATABASE_DB_NAME,\n    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASE_DB_NAME,\n    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_DATABASE_TWO,\n    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_DATABASE_THREE,\n    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_WITH_IDENTITY,\n    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_WITH_IDENTITY_AND_ACCESS_CONTROLLER,\n    SWARM_STORE_CONNECTOR_TEST_SUBCLASS_SECRET_STORAGE_CONNECTOR_CREDENTIALS,\n    SWARM_STORE_CONNECTOR_TEST_SUBCLASS_SECRET_STORAGE_CONNECTOR_OPTIONS,\n    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASES_WITH_IDENTITY_AND_ACCESS_CONTROLLER_SECRET_KEYSTORE,\n    SWARM_STORE_CONNECTOR_TEST_SUBCLASS_CACHE_OPTIONS,\n } from './swarm-storage-orbit-db.test.const';\nimport { SWARM_CONNECTION_OPTIONS } from 'test/ipfs-swarm-connection.test/ipfs-swarm-connection.const';\nimport { SwarmConnection } from 'classes/swarm-connection-class/swarm-connection-class';\nimport { ESwarmStoreConnectorOrbitDBEventNames } from 'classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.const';\nimport { ISwarmStoreConnectorOrbitDbDatabaseValue } from 'classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON } from 'const/common-values/common-values';\nimport { SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter } from 'classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter';\nimport { SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS } from 'classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.const';\nimport { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';\nimport { SwarmStoreConnectorOrbitDBSubclassStorageFabric } from 'classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric';\n\nexport const testDatabase = async (\n    connection: SwarmStoreConnectorOrbitDB<string>,\n    dbName: string,\n) => {\n    const testValue = `${new Date()}--te`;\n    const addValueHash = await connection.request(\n        dbName,\n        'add',\n        SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_TEST_VALUE,\n    )\n\n    expect(addValueHash).to.be.a('string');\n   \n    const getValueByHashResult: ISwarmStoreConnectorOrbitDbDatabaseValue<string> = await connection.request(\n        dbName,\n        'get',\n        addValueHash,\n    );\n   \n    expect(getValueByHashResult.id).to.be.equal((connection as any).orbitDb.identity.id);\n    expect(getValueByHashResult.hash).to.be.equal(addValueHash);\n    expect(getValueByHashResult.value).to.be.equal(SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_TEST_VALUE);\n   \n    await expect(connection.request(\n        dbName,\n        'remove',\n        addValueHash,\n    )).eventually.not.rejected.not.be.an('error');\n\n    const getValueByHashAfterRemoveResult = await connection.request(\n        dbName,\n        'get',\n        addValueHash,\n    );\n    \n    assert(getValueByHashAfterRemoveResult == null, 'The value removed before must be empty');\n}\n\nexport const testDatabaseWithRandomValue = async (\n    connection: SwarmStoreConnectorOrbitDB<string>,\n    dbName: string,\n) => {\n    let i = 0;\n\n    while((i += 1) <= 5) {\n        const testValue = `${new Date()}--test-value`;\n        const addValueHash = await connection.request(\n            dbName,\n            'add',\n            testValue,\n        )\n\n        expect(addValueHash).to.be.a('string');\n    \n        const getValueByHashResult: ISwarmStoreConnectorOrbitDbDatabaseValue<string> = (\n            await connection.request(\n                dbName,\n                'get',\n                addValueHash,\n            )\n        );\n    \n        expect(getValueByHashResult.id).to.be.equal((connection as any).orbitDb.identity.id);\n        expect(getValueByHashResult.hash).to.be.equal(addValueHash);\n        expect(getValueByHashResult.value).to.be.equal(testValue);\n    \n        await expect(connection.request(\n            dbName,\n            'remove',\n            addValueHash,\n        )).eventually.not.rejected.not.be.an('error');\n\n        const getValueByHashAfterRemoveResult = await connection.request(\n            dbName,\n            'get',\n            addValueHash,\n        );\n        \n        assert(getValueByHashAfterRemoveResult == null, 'The value removed before must be empty');\n    }\n}\n\nexport const runTestSwarmStoreOrbitDBConnection = async (name?: string) => {\n    describe('swarm store: orbit db', () => {        \n        let ipfsConnection: IPFS | undefined;\n\n        beforeEach(async function () {\n            this.timeout(60000);\n            const swarmConnection = new SwarmConnection();\n\n            expect(swarmConnection).to.be.an.instanceof(SwarmConnection);\n            await assert.becomes(swarmConnection.connect(SWARM_CONNECTION_OPTIONS), true, '');\n            expect(swarmConnection.isConnected).to.equal(true);\n\n            ipfsConnection = swarmConnection.getNativeConnection();\n\n            expect(ipfsConnection).to.be.an.instanceof(ipfs);\n        });\n\n        if (!name || name === 'create swarm store OrbitDB connector - 3 databases') {\n            it('create swarm store OrbitDB connector - 3 databases', async () => {\n                expect(ipfsConnection).to.be.an.instanceof(ipfs);\n    \n                const connection = new SwarmStoreConnectorOrbitDB<string>(\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASES);\n    \n                expect(connection).to.be.an.instanceof(SwarmStoreConnectorOrbitDB);\n                expect(connection.connect).to.be.a('function');\n                \n                let fullProgressEmitted: boolean = false;\n                let readyEmitted: string[] = [];\n    \n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.LOADING, (loadingProgress: number) => {\n                    if (loadingProgress === 100) {\n                        fullProgressEmitted = true;\n                    }\n                });\n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.READY, (dbName: string) => {\n                    if (dbName) {\n                        readyEmitted.push(dbName);\n                    }\n                });\n    \n                await expect(connection.connect({\n                    ipfs: ipfsConnection!,\n                })).to.be.not.eventually.an.instanceof(Error);\n    \n                expect(connection.isClosed).to.be.equal(false);\n                expect(connection.isReady).to.be.equal(true);\n                assert((fullProgressEmitted as boolean) === true, 'The event 100% loading progress does not emitted')\n                expect(readyEmitted)\n                    .to.be.an('array')\n                    .that.include.all.members(\n                        SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASES.databases.map(db => db.dbName)\n                    );\n                \n                await testDatabase(\n                    connection,\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n                );\n                await testDatabase(\n                    connection,\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_TWO_DATABASE_DB_NAME,\n                );\n                await testDatabase(\n                    connection,\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASE_DB_NAME,\n                );\n    \n                let isCloseEmitted: boolean = false;\n    \n                connection[COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON](ESwarmStoreConnectorOrbitDBEventNames.CLOSE, () => {\n                    isCloseEmitted = true;\n                });\n    \n                await expect(connection.close()).to.eventually.be.undefined;\n    \n                assert((isCloseEmitted as boolean) === true, 'The close event must be emitted on SwarmStoreConnector close');\n    \n                const addValueHashAfterClose = await connection.request(\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n                    'add',\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_TEST_VALUE,\n                )\n            \n                expect(addValueHashAfterClose).to.be.an('error');\n            }).timeout(70000);\n        }\n\n        if (!name || name === 'create swarm store OrbitDB connector - 1 database, check database close') {\n            it('create swarm store OrbitDB connector - 1 database, check database close', async () => {\n                expect(ipfsConnection).to.be.an.instanceof(ipfs);\n\n                const connection = new SwarmStoreConnectorOrbitDB<string>(\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE);\n\n                expect(connection).to.be.an.instanceof(SwarmStoreConnectorOrbitDB);\n                expect(connection.connect).to.be.a('function');\n                \n                let fullProgressEmitted: boolean = false;\n                let readyEmitted: string[] = [];\n\n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.LOADING, (loadingProgress: number) => {\n                    if (loadingProgress === 100) {\n                        fullProgressEmitted = true;\n                    }\n                });\n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.READY, (dbName: string) => {\n                    if (dbName) {\n                        readyEmitted.push(dbName);\n                    }\n                });\n\n                await expect(connection.connect({\n                    ipfs: ipfsConnection!,\n                })).to.be.not.eventually.an.instanceof(Error);\n\n                expect(connection.isClosed).to.be.equal(false);\n                expect(connection.isReady).to.be.equal(true);\n                assert((fullProgressEmitted as boolean) === true, 'The event 100% loading progress does not emitted')\n                expect(readyEmitted)\n                    .to.be.an('array')\n                    .that.include.all.members(\n                        SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE.databases.map(db => db.dbName)\n                    );\n                \n                await testDatabase(\n                    connection,\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n                );\n\n                //\n                await expect(connection.openDatabase(SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_DATABASE_TWO))\n                    .to.eventually.be.undefined;\n                await expect(connection.openDatabase(SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_DATABASE_TWO))\n                    .to.eventually.be.an('error');\n\n                //\n                const result = await Promise.all([\n                    connection.openDatabase(SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_DATABASE_THREE),\n                    connection.openDatabase(SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_DATABASE_THREE),\n                ]);\n\n                expect(result)\n                    .to.be.an('array').that.has.property('length', 2);\n                assert(result[0] == null, 'The first instance must be started');\n                expect(result[1]).to.be.an.instanceof(Error);\n\n                let isEmitDbClose: boolean = false;\n\n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.CLOSE_DATABASE, (dbName: string) => {\n                    if (dbName === SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME) {\n                        isEmitDbClose = true;\n                    }\n                })\n                await expect(connection.closeDb(SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME)).to.eventually.eq(undefined);\n                expect(isEmitDbClose).to.be.equal(true);\n                await expect(connection.request(\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n                    'get',\n                    '111'\n                )).to.eventually.be.an('Error');\n                \n                let isCloseEmitted: boolean = false;\n\n                connection[COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON](ESwarmStoreConnectorOrbitDBEventNames.CLOSE, () => {\n                    isCloseEmitted = true;\n                });\n\n                await expect(connection.close()).to.eventually.be.undefined;\n\n                assert((isCloseEmitted as boolean) === true, 'The close event must be emitted on SwarmStoreConnector close');\n\n                const addValueHashAfterClose = await connection.request(\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n                    'add',\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_TEST_VALUE,\n                )\n            \n                expect(addValueHashAfterClose).to.be.an('error');\n            }).timeout(70000);\n        }\n\n        if (!name || name === 'create swarm store OrbitDB connector - 1 database with custom identity') {\n            it('create swarm store OrbitDB connector - 1 database with custom identity', async () => {\n                expect(ipfsConnection).to.be.an.instanceof(ipfs);\n\n                const connection = new SwarmStoreConnectorOrbitDB<string>(\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_WITH_IDENTITY as any,\n                );\n\n                expect(connection).to.be.an.instanceof(SwarmStoreConnectorOrbitDB);\n                expect(connection.connect).to.be.a('function');\n                \n                let fullProgressEmitted: boolean = false;\n                let readyEmitted: string[] = [];\n\n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.LOADING, (loadingProgress: number) => {\n                    if (loadingProgress === 100) {\n                        fullProgressEmitted = true;\n                    }\n                });\n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.READY, (dbName: string) => {\n                    if (dbName) {\n                        readyEmitted.push(dbName);\n                    }\n                });\n\n                await expect(connection.connect({\n                    ipfs: ipfsConnection!,\n                })).to.be.not.eventually.an.instanceof(Error);\n\n                expect(connection.isClosed).to.be.equal(false);\n                expect(connection.isReady).to.be.equal(true);\n                assert(\n                    (fullProgressEmitted as boolean) === true,\n                    'The event 100% loading progress does not emitted',\n                )\n                expect(readyEmitted)\n                    .to.be.an('array')\n                    .that.include.all.members(\n                        SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE.databases.map(db => db.dbName)\n                    );\n\n                await testDatabase(\n                    connection,\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n                );\n            }).timeout(70000);\n        }\n\n        if (!name || name === 'create swarm store OrbitDB connector - 1 database with custom acccess provider') {\n            it('create swarm store OrbitDB connector - 1 database with custom acccess provider', async () => {\n                expect(ipfsConnection).to.be.an.instanceof(ipfs);\n\n                const connection = new SwarmStoreConnectorOrbitDB<string>(\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_WITH_IDENTITY_AND_ACCESS_CONTROLLER as any,\n                );\n\n                expect(connection).to.be.an.instanceof(SwarmStoreConnectorOrbitDB);\n                expect(connection.connect).to.be.a('function');\n                \n                let fullProgressEmitted: boolean = false;\n                let readyEmitted: string[] = [];\n\n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.LOADING, (loadingProgress: number) => {\n                    if (loadingProgress === 100) {\n                        fullProgressEmitted = true;\n                    }\n                });\n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.READY, (dbName: string) => {\n                    if (dbName) {\n                        readyEmitted.push(dbName);\n                    }\n                });\n\n                await expect(connection.connect({\n                    ipfs: ipfsConnection!,\n                })).to.be.not.eventually.an.instanceof(Error);\n\n                expect(connection.isClosed).to.be.equal(false);\n                expect(connection.isReady).to.be.equal(true);\n                assert(\n                    (fullProgressEmitted as boolean) === true,\n                    'The event 100% loading progress does not emitted',\n                )\n                expect(readyEmitted)\n                    .to.be.an('array')\n                    .that.include.all.members(\n                        SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE.databases.map(db => db.dbName)\n                    );\n\n                await testDatabase(\n                    connection,\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n                );\n            }).timeout(70000);\n        }\n\n        if (!name || name === 'create swarm store OrbitDB connector - 3 databases with custom acccess provider and secret keystore') {\n            it('create swarm store OrbitDB connector - 3 databases with custom acccess provider and secret keystore', async () => {\n                expect(ipfsConnection).to.be.an.instanceof(ipfs);\n\n                const connection = new SwarmStoreConnectorOrbitDB<string>(\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASES_WITH_IDENTITY_AND_ACCESS_CONTROLLER_SECRET_KEYSTORE as any,\n                );\n                \n                expect(connection).to.be.an.instanceof(SwarmStoreConnectorOrbitDB);\n                expect(connection.connect).to.be.a('function');\n                \n                let fullProgressEmitted: boolean = false;\n                let readyEmitted: string[] = [];\n\n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.LOADING, (loadingProgress: number) => {\n                    if (loadingProgress === 100) {\n                        fullProgressEmitted = true;\n                    }\n                });\n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.READY, (dbName: string) => {\n                    if (dbName) {\n                        readyEmitted.push(dbName);\n                    }\n                });\n\n                await expect(connection.connect({\n                    ipfs: ipfsConnection!,\n                })).to.be.not.eventually.an.instanceof(Error);\n\n                expect(connection.isClosed).to.be.equal(false);\n                expect(connection.isReady).to.be.equal(true);\n                assert(\n                    (fullProgressEmitted as boolean) === true,\n                    'The event 100% loading progress does not emitted',\n                )\n                expect(readyEmitted)\n                    .to.be.an('array')\n                    .that.include.all.members(\n                        SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE.databases.map(db => db.dbName)\n                    );\n                        \n                await testDatabase(\n                    connection,\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n                );\n                await testDatabase(\n                    connection,\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_TWO_DATABASE_DB_NAME,\n                );\n                await testDatabase(\n                    connection,\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASE_DB_NAME,\n                );\n    \n                let isCloseEmitted: boolean = false;\n    \n                connection[COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON](ESwarmStoreConnectorOrbitDBEventNames.CLOSE, () => {\n                    isCloseEmitted = true;\n                });\n    \n                await expect(connection.close()).to.eventually.be.undefined;\n    \n                assert((isCloseEmitted as boolean) === true, 'The close event must be emitted on SwarmStoreConnector close');\n    \n                const addValueHashAfterClose = await connection.request(\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n                    'add',\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_TEST_VALUE,\n                )\n            \n                expect(addValueHashAfterClose).to.be.an('error');\n            }).timeout(70000);\n        }\n\n        if (!name || name === 'create swarm store OrbitDB connector - 3 databases with custom acccess provider and secret keystore -- with random loop') {\n            it('create swarm store OrbitDB connector - 3 databases with custom acccess provider and secret keystore', async () => {\n                expect(ipfsConnection).to.be.an.instanceof(ipfs);\n\n                const connection = new SwarmStoreConnectorOrbitDB<string>(\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASES_WITH_IDENTITY_AND_ACCESS_CONTROLLER_SECRET_KEYSTORE as any,\n                );\n                \n                expect(connection).to.be.an.instanceof(SwarmStoreConnectorOrbitDB);\n                expect(connection.connect).to.be.a('function');\n                \n                let fullProgressEmitted: boolean = false;\n                let readyEmitted: string[] = [];\n\n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.LOADING, (loadingProgress: number) => {\n                    if (loadingProgress === 100) {\n                        fullProgressEmitted = true;\n                    }\n                });\n                connection.on(ESwarmStoreConnectorOrbitDBEventNames.READY, (dbName: string) => {\n                    if (dbName) {\n                        readyEmitted.push(dbName);\n                    }\n                });\n\n                await expect(connection.connect({\n                    ipfs: ipfsConnection!,\n                })).to.be.not.eventually.an.instanceof(Error);\n\n                expect(connection.isClosed).to.be.equal(false);\n                expect(connection.isReady).to.be.equal(true);\n                assert(\n                    (fullProgressEmitted as boolean) === true,\n                    'The event 100% loading progress does not emitted',\n                )\n                expect(readyEmitted)\n                    .to.be.an('array')\n                    .that.include.all.members(\n                        SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE.databases.map(db => db.dbName)\n                    );\n                        \n                await testDatabaseWithRandomValue(\n                    connection,\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n                );\n                await testDatabaseWithRandomValue(\n                    connection,\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_TWO_DATABASE_DB_NAME,\n                );\n                await testDatabaseWithRandomValue(\n                    connection,\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_THREE_DATABASE_DB_NAME,\n                );\n    \n                let isCloseEmitted: boolean = false;\n    \n                connection[COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON](ESwarmStoreConnectorOrbitDBEventNames.CLOSE, () => {\n                    isCloseEmitted = true;\n                });\n    \n                await expect(connection.close()).to.eventually.be.undefined;\n    \n                assert((isCloseEmitted as boolean) === true, 'The close event must be emitted on SwarmStoreConnector close');\n    \n                const addValueHashAfterClose = await connection.request(\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_DB_NAME,\n                    'add',\n                    SWARM_STORE_CONNECTOR_TEST_CONNECTION_OPTIONS_ONE_DATABASE_TEST_VALUE,\n                )\n            \n                expect(addValueHashAfterClose).to.be.an('error');\n            }).timeout(70000);\n        }\n    })\n\n    async function testCache(cache: SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter) {\n        const testKey = '___test_key__cache';\n        const testValue = '___test_value_cache';\n\n        expect(cache)\n            .to.be.an\n            .instanceof(SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter);\n        expect(cache.db).to.deep.equal({\n            status: SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.OPEN\n        })\n        expect(cache!.status).to.be.equal(SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.OPEN);\n        await expect(cache!.get(\n            testKey,\n        )).to.be.eventually.oneOf([testValue, undefined]);\n        expect(cache!.status).to.be.equal(SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.OPEN);\n        await expect(cache!.put(\n            testKey,\n            testValue,\n        )).to.eventually.be.fulfilled;\n        await expect(cache!.open()).to.eventually.be.fulfilled;\n        expect(cache!.status).to.be.equal(SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.OPEN);\n        // TODO - must provide storing values as buffer fo the SecretStorage\n        await expect(cache!.get(\n            testKey,\n        )).to.be.eventually.equal(testValue);\n\n        const testKeyRandom = `${Date.now()}!@#$%^&**()_)_)*(&*&TY&*%*$^#$*:\":/*/-*)//..,<><.~~~~';`;\n        const testValueRandom = `${new Date()}!@#$%^&**()_)_)*(&*&TY&*%*$^#$*:\":/*/-*)//..,<><.~~~~';`;\n\n        await expect(cache!.put(\n            testKeyRandom,\n            testValueRandom,\n        )).to.eventually.be.fulfilled;\n        // TODO - must provide storing values as buffer fo the SecretStorage\n\n        let cbCalledTimes = 0;\n        const cb = (err: Error | undefined, value: string | undefined) => {\n            if (!err) {\n                cbCalledTimes += Number(!!value);\n            }\n        }\n\n        await expect(cache!.get(\n            testKeyRandom,\n            cb,\n        )).to.be.eventually.equal(testValueRandom);\n        expect(cbCalledTimes).to.equal(1);\n\n        const cbErr = (err: Error | undefined) => {\n            if (!err) {\n                cbCalledTimes += 1;\n            }\n        }\n\n        await expect(cache!.del(\n            testKeyRandom,\n            cbErr,\n        )).to.be.eventually.equal(undefined);\n        expect(cbCalledTimes).to.equal(2);\n        await expect(cache!.close(cbErr,)).to.eventually.be.fulfilled;\n        expect(cbCalledTimes).to.equal(3);\n        expect(cache!.status).to.be.equal(SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.CLOSE);\n    }\n\n    describe('swarm store:: orbit db:: subclasses', () => {\n        if (!name || name === 'subclass swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter') { \n            it('subclass swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter', async () => {\n                let secretStorageAdapter: undefined | SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter;\n                const testKey = '___test_key';\n                const testValue = '___test_value';\n\n                expect(() => {\n                    secretStorageAdapter = new SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter(\n                        SWARM_STORE_CONNECTOR_TEST_SUBCLASS_SECRET_STORAGE_CONNECTOR_CREDENTIALS,\n                        SWARM_STORE_CONNECTOR_TEST_SUBCLASS_SECRET_STORAGE_CONNECTOR_OPTIONS,\n                    );\n                }).to.not.throw();\n                expect(secretStorageAdapter)\n                    .to.be.an\n                    .instanceof(SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter);\n                expect(secretStorageAdapter!.status).to.be.equal(SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.OPEN);\n                await expect(secretStorageAdapter!.get(\n                    testKey,\n                )).to.be.eventually.oneOf([testValue, undefined]);\n                expect(secretStorageAdapter!.status).to.be.equal(SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.OPEN);\n                await expect(secretStorageAdapter!.put(\n                    testKey,\n                    testValue,\n                )).to.eventually.be.fulfilled;\n                await expect(secretStorageAdapter!.open()).to.eventually.be.fulfilled;\n                expect(secretStorageAdapter!.status).to.be.equal(SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.OPEN);\n                // TODO - must provide storing values as buffer fo the SecretStorage\n                await expect(secretStorageAdapter!.get(\n                    testKey,\n                )).to.be.eventually.equal(testValue);\n\n                const testKeyRandom = `${Date.now()}!@#$%^&**()_)_)*(&*&TY&*%*$^#$*:\":/*/-*)//..,<><.~~~~';`;\n                const testValueRandom = `${new Date()}!@#$%^&**()_)_)*(&*&TY&*%*$^#$*:\":/*/-*)//..,<><.~~~~';`;\n\n                await expect(secretStorageAdapter!.put(\n                    testKeyRandom,\n                    testValueRandom,\n                )).to.eventually.be.fulfilled;\n                // TODO - must provide storing values as buffer fo the SecretStorage\n                await expect(secretStorageAdapter!.get(\n                    testKeyRandom,\n                )).to.be.eventually.equal(testValueRandom);\n                await expect(secretStorageAdapter!.close()).to.eventually.be.fulfilled;\n                expect(secretStorageAdapter!.status).to.be.equal(SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.CLOSE);\n            }).timeout(10000);\n        }\n        if (!name || name === 'subclass swarm-store-connector-orbit-db-subclass-storage-cache') {\n            it('subclass swarm-store-connector-orbit-db-subclass-storage-cache', async () => {\n                const password = '123456';\n                let key: CryptoKey;\n                let cache: undefined | SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter;\n\n                await expect((async () => {\n                    key = await SecretStorage.generatePasswordKeyByPasswordString(password) as CryptoKey;\n                    return key;\n                })()).to.eventually.be.fulfilled;\n\n                expect(key!).to.be.an.instanceOf(CryptoKey);\n                expect(() => {\n                    cache = new SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter(\n                        { key },\n                        SWARM_STORE_CONNECTOR_TEST_SUBCLASS_CACHE_OPTIONS,\n                    );\n                }).to.not.throw();\n                await testCache(cache!);\n            }).timeout(10000);\n        }\n        if (!name || name === 'subclass swarm-store-connector-orbit-db-subclass-storage-fabric') {\n            it('subclass swarm-store-connector-orbit-db-subclass-storage-fabric', async () => {\n                const password = '123456';\n                const cachePath = '___cachePath_test';\n                const passwordFailed = '12345';\n\n                expect(() => {\n                    new SwarmStoreConnectorOrbitDBSubclassStorageFabric(\n                        { password: passwordFailed}\n                    );\n                }).to.throw();\n\n                let fabric: undefined | SwarmStoreConnectorOrbitDBSubclassStorageFabric;\n                let cache: undefined | SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter;\n\n                expect(() => {\n                    fabric = new SwarmStoreConnectorOrbitDBSubclassStorageFabric(\n                        { password }\n                    );\n                }).not.to.throw();\n                expect(fabric).to.be.instanceOf(SwarmStoreConnectorOrbitDBSubclassStorageFabric);\n                await expect((async () => {\n                    cache = await fabric!.createStore(cachePath) as SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter;\n                })()).to.eventually.be.fulfilled;\n                await testCache(cache!);\n            }).timeout(10000);\n        }\n    });\n};","/home/paul/projects/decentrilized-protocol/src/test/valiation-utils.test.ts",["1643"],"import { validateBySchema } from 'utils/validation-utils/validation-utils';\n\nexport const runTest = () => {\n  const schema = {\n    title: 'test',\n    type: 'object',\n    $id: 'http://test.schema',\n    description: 'schema for testing of the validation functionality',\n    properties: {\n      notRequired: {\n        type: 'string',\n      },\n      required: {\n        type: 'array',\n        items: {\n          oneOf: [\n            {\n              type: 'number',\n            },\n            {\n              type: 'string',\n            },\n          ],\n        },\n      },\n    },\n    required: ['required'],\n    additionalProperties: false,\n  };\n\n  const result = validateBySchema(schema, undefined);\n\n  if (result !== false) {\n    console.error('Wrong result for undefined');\n  }\n\n  const testData1 = {\n    required: ['1', 1],\n  };\n  const result1 = validateBySchema(schema, testData1);\n\n  if (result1 !== true) {\n    console.error('Wrong result for requered field');\n  }\n\n  const testData2 = {\n    notRequired: '1',\n  };\n  const result2 = validateBySchema(schema, testData2);\n\n  if (result2 !== false) {\n    console.error('Wrong result for data with no required field');\n  }\n\n  const testData3 = {\n    notRequired: '1',\n    required: ['1', 1],\n  };\n  const result3 = validateBySchema(schema, testData3);\n\n  if (result3 !== true) {\n    console.error('Wrong result for data with all fields');\n  }\n\n  const testData4 = {\n    notRequired: '1',\n    required: ['1', 1],\n    additional: 1,\n  };\n  const result4 = validateBySchema(schema, testData4);\n\n  if (result4 !== false) {\n    console.error('Wrong result for data with additional fields');\n  }\n};\n","/home/paul/projects/decentrilized-protocol/src/test/validation-messaging.test/validation-messaging.test.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.const.ts",[],"/home/paul/projects/decentrilized-protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.ts",["1644","1645","1646","1647","1648","1649","1650","1651","1652","1653","1654","1655","1656","1657","1658","1659"],"/home/paul/projects/decentrilized-protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.types.ts",["1660","1661"],"import { PSEUDO_NTP_CLASS_EVENTS } from './pseudo-ntp-class.const';\n\nexport type TPseudoNTPClassResponseRaw = any;\n\n/**\n * @param {number} timestampReq - timestamp when the request was sent\n * @param {number} timestempRes - timestamp when the response was received\n * @param {Date} dateRes - date when the response was received\n * @param {TPseudoNTPClassResponseRaw} responseRaw - reqponse from the server\n */\nexport type TPseudoNTPClassResponseWithTimesamps = {\n  timestampReq: number;\n  timestempRes: number;\n  dateRes: Date;\n  responseRaw: TPseudoNTPClassResponseRaw;\n};\n\n/**\n *  events emitted by the pseudo ntp\n *\n * @export\n * @interface IPseudoNTPClassEvents\n */\nexport interface IPseudoNTPClassEvents {\n  /**\n   * after syncronization with the\n   * server emit the event and\n   * returns the time offset in\n   * seconds\n   */\n  [PSEUDO_NTP_CLASS_EVENTS.TIME_SYNC]: number;\n}\n\nexport type TPseudoNTPClassServerResponse = string | { [key: string]: any };\n\n/**\n *\n * @export\n * @interface IPseudoNTPClassServerConnection\n * @param {string} server - the url of the server connect to\n * @param {string} fieldName - name of the field where is\n * the server's current date as a string in ISO format\n * @param {function} parseCallback - callback which called\n * to parse the response from the server and must return\n * the Date on the server\n */\nexport interface IPseudoNTPClassServerConnectionField {\n  server: string;\n  fieldName: string;\n}\nexport interface IPseudoNTPClassServerConnectionCb {\n  server: string;\n  parseCallback: (response: TPseudoNTPClassServerResponse) => Date | Error;\n}\nexport type IPseudoNTPClassServerConnection =\n  | IPseudoNTPClassServerConnectionCb\n  | IPseudoNTPClassServerConnectionField;\n\nexport type TPseudoNTPClassServersPoolOption = IPseudoNTPClassServerConnection[];\n\n/**\n * @param {number} [1] responseTimeoutS - timeout for reponse from the\n * server in seconds\n * @param {number} [60] syncIntervalS - interval in seconds to request the server\n * to get the time on it\n * @param {number} [10] maxOffsetErrorS - the maximum offset between the client\n * and the server time which will not be suggested as error\n * @param {number} [3] maxFailedResponses - the maximum fails of the responses\n * to switch on the another server\n * @param {number} [5] retryRequestDelayS - the delay to repeat the request\n * after fail\n */\nexport interface IPseudoNTPClassCommonOptions {\n  syncIntervalS?: number;\n  maxFailedResponses?: number;\n  retryRequestDelayS?: number;\n  responseTimeoutS?: number;\n  maxOffsetErrorS?: number;\n}\n\nexport interface IPseudoNTPClassCommonOptionsMilliseconds {\n  syncIntervalMs: number;\n  maxFailedResponses: number;\n  retryRequestDelayMs: number;\n  responseTimeoutMs: number;\n  maxOffsetErrorS: number;\n}\n\n/**\n * options for pseudo ntp class\n *\n * @export\n * @interface IPseudoNTPClassOptions\n * @param {IPseudoNTPClassServerConnection[]} serversPool - this is options for\n * the pool of the servers to receive the current date and time\n */\nexport interface IPseudoNTPClassOptions extends IPseudoNTPClassCommonOptions {\n  serversPool: TPseudoNTPClassServersPoolOption;\n}\n","/home/paul/projects/decentrilized-protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.utils.ts",["1662"],"export const getSecondsByMilliseconds = (ms: number): number =>\n  Math.round(ms / 1000);\n\nexport const getTimestampSeconds = () =>\n  getSecondsByMilliseconds(performance.now());\n\nexport const addSecondsToDate = (date: Date, seconds: number): Date => {\n  date.setSeconds(date.getSeconds() + seconds);\n  return date;\n};\n\nexport const datesDifferenceSeconds = (\n  dateMinuend: Date,\n  dateSubtrahend: Date\n): number => {\n  return getSecondsByMilliseconds(\n    dateMinuend.getTime() - dateSubtrahend.getTime()\n  );\n};\n","/home/paul/projects/decentrilized-protocol/src/const/const-api-conf.ts",[],{"ruleId":"1663","severity":1,"message":"1664","line":2,"column":8,"nodeType":"1665","endLine":2,"endColumn":12},{"ruleId":"1663","severity":1,"message":"1666","line":5,"column":10,"nodeType":"1665","endLine":5,"endColumn":43},{"ruleId":"1663","severity":1,"message":"1667","line":6,"column":10,"nodeType":"1665","endLine":6,"endColumn":43},{"ruleId":"1663","severity":1,"message":"1668","line":7,"column":10,"nodeType":"1665","endLine":7,"endColumn":57},{"ruleId":"1663","severity":1,"message":"1669","line":9,"column":3,"nodeType":"1665","endLine":9,"endColumn":30},{"ruleId":"1663","severity":1,"message":"1670","line":10,"column":3,"nodeType":"1665","endLine":10,"endColumn":77},{"ruleId":"1663","severity":1,"message":"1671","line":12,"column":10,"nodeType":"1665","endLine":12,"endColumn":30},{"ruleId":"1663","severity":1,"message":"1672","line":13,"column":10,"nodeType":"1665","endLine":13,"endColumn":32},{"ruleId":"1663","severity":1,"message":"1673","line":14,"column":10,"nodeType":"1665","endLine":14,"endColumn":36},{"ruleId":"1663","severity":1,"message":"1674","line":16,"column":10,"nodeType":"1665","endLine":16,"endColumn":44},{"ruleId":"1663","severity":1,"message":"1675","line":17,"column":10,"nodeType":"1665","endLine":17,"endColumn":48},{"ruleId":"1663","severity":1,"message":"1676","line":18,"column":10,"nodeType":"1665","endLine":18,"endColumn":28},{"ruleId":"1677","severity":1,"message":"1678","line":52,"column":17,"nodeType":"1679","messageId":"1680","endLine":52,"endColumn":28},{"ruleId":"1663","severity":1,"message":"1681","line":2,"column":10,"nodeType":"1665","endLine":2,"endColumn":13},{"ruleId":"1682","severity":1,"message":"1683","line":9,"column":56,"nodeType":"1684","messageId":"1685","endLine":9,"endColumn":59},{"ruleId":"1682","severity":1,"message":"1683","line":15,"column":55,"nodeType":"1684","messageId":"1685","endLine":15,"endColumn":58},{"ruleId":"1677","severity":1,"message":"1678","line":14,"column":3,"nodeType":"1686","messageId":"1680","endLine":14,"endColumn":69},{"ruleId":"1677","severity":1,"message":"1678","line":20,"column":3,"nodeType":"1686","messageId":"1680","endLine":20,"endColumn":24},{"ruleId":"1677","severity":1,"message":"1678","line":27,"column":3,"nodeType":"1686","messageId":"1680","endLine":27,"endColumn":25},{"ruleId":"1677","severity":1,"message":"1678","line":33,"column":3,"nodeType":"1686","messageId":"1680","endLine":33,"endColumn":37},{"ruleId":"1677","severity":1,"message":"1678","line":49,"column":3,"nodeType":"1686","messageId":"1680","endLine":49,"endColumn":38},{"ruleId":"1687","severity":1,"message":"1688","line":87,"column":15,"nodeType":"1689","messageId":"1690","endLine":87,"endColumn":27},{"ruleId":"1677","severity":1,"message":"1678","line":20,"column":3,"nodeType":"1686","messageId":"1680","endLine":20,"endColumn":20},{"ruleId":"1677","severity":1,"message":"1678","line":27,"column":3,"nodeType":"1686","messageId":"1680","endLine":27,"endColumn":25},{"ruleId":"1677","severity":1,"message":"1678","line":33,"column":3,"nodeType":"1686","messageId":"1680","endLine":33,"endColumn":23},{"ruleId":"1677","severity":1,"message":"1678","line":67,"column":3,"nodeType":"1686","messageId":"1680","endLine":67,"endColumn":20},{"ruleId":"1663","severity":1,"message":"1691","line":32,"column":9,"nodeType":"1665","endLine":32,"endColumn":15},{"ruleId":"1663","severity":1,"message":"1692","line":8,"column":10,"nodeType":"1665","endLine":8,"endColumn":20},{"ruleId":"1682","severity":1,"message":"1683","line":77,"column":27,"nodeType":"1684","messageId":"1685","endLine":77,"endColumn":30},{"ruleId":"1682","severity":1,"message":"1683","line":78,"column":39,"nodeType":"1684","messageId":"1685","endLine":78,"endColumn":42},{"ruleId":"1677","severity":1,"message":"1678","line":91,"column":17,"nodeType":"1679","messageId":"1680","endLine":91,"endColumn":28},{"ruleId":"1687","severity":1,"message":"1688","line":98,"column":36,"nodeType":"1689","messageId":"1690","endLine":98,"endColumn":40},{"ruleId":"1682","severity":1,"message":"1683","line":130,"column":38,"nodeType":"1684","messageId":"1685","endLine":130,"endColumn":41},{"ruleId":"1677","severity":1,"message":"1678","line":223,"column":3,"nodeType":"1686","messageId":"1680","endLine":223,"endColumn":53},{"ruleId":"1663","severity":1,"message":"1693","line":38,"column":7,"nodeType":"1665","endLine":38,"endColumn":17},{"ruleId":"1677","severity":1,"message":"1678","line":59,"column":3,"nodeType":"1686","messageId":"1680","endLine":59,"endColumn":23},{"ruleId":"1677","severity":1,"message":"1678","line":65,"column":3,"nodeType":"1686","messageId":"1680","endLine":65,"endColumn":20},{"ruleId":"1677","severity":1,"message":"1678","line":20,"column":28,"nodeType":"1679","messageId":"1680","endLine":20,"endColumn":65},{"ruleId":"1677","severity":1,"message":"1678","line":35,"column":3,"nodeType":"1686","messageId":"1680","endLine":35,"endColumn":37},{"ruleId":"1677","severity":1,"message":"1678","line":42,"column":3,"nodeType":"1686","messageId":"1680","endLine":42,"endColumn":17},{"ruleId":"1677","severity":1,"message":"1678","line":60,"column":3,"nodeType":"1686","messageId":"1680","endLine":62,"endColumn":4},{"ruleId":"1677","severity":1,"message":"1678","line":81,"column":20,"nodeType":"1679","messageId":"1680","endLine":81,"endColumn":25},{"ruleId":"1677","severity":1,"message":"1678","line":85,"column":3,"nodeType":"1686","messageId":"1680","endLine":85,"endColumn":18},{"ruleId":"1677","severity":1,"message":"1678","line":89,"column":3,"nodeType":"1686","messageId":"1680","endLine":89,"endColumn":18},{"ruleId":"1677","severity":1,"message":"1678","line":96,"column":3,"nodeType":"1686","messageId":"1680","endLine":96,"endColumn":10},{"ruleId":"1677","severity":1,"message":"1678","line":101,"column":3,"nodeType":"1686","messageId":"1680","endLine":101,"endColumn":9},{"ruleId":"1677","severity":1,"message":"1678","line":8,"column":31,"nodeType":"1679","messageId":"1680","endLine":12,"endColumn":40},{"ruleId":"1677","severity":1,"message":"1678","line":41,"column":5,"nodeType":"1686","messageId":"1680","endLine":41,"endColumn":27},{"ruleId":"1677","severity":1,"message":"1678","line":45,"column":5,"nodeType":"1686","messageId":"1680","endLine":45,"endColumn":28},{"ruleId":"1677","severity":1,"message":"1678","line":49,"column":5,"nodeType":"1686","messageId":"1680","endLine":49,"endColumn":27},{"ruleId":"1677","severity":1,"message":"1678","line":64,"column":14,"nodeType":"1679","messageId":"1680","endLine":64,"endColumn":19},{"ruleId":"1694","severity":1,"message":"1695","line":49,"column":3,"nodeType":"1696","endLine":49,"endColumn":62},{"ruleId":"1697","severity":1,"message":"1698","line":49,"column":60,"nodeType":"1686","messageId":"1699"},{"ruleId":"1663","severity":1,"message":"1700","line":2,"column":3,"nodeType":"1665","endLine":2,"endColumn":28},{"ruleId":"1663","severity":1,"message":"1701","line":3,"column":3,"nodeType":"1665","endLine":3,"endColumn":41},{"ruleId":"1663","severity":1,"message":"1702","line":1,"column":10,"nodeType":"1665","endLine":1,"endColumn":39},{"ruleId":"1682","severity":1,"message":"1683","line":13,"column":20,"nodeType":"1684","messageId":"1685","endLine":13,"endColumn":23},{"ruleId":"1682","severity":1,"message":"1683","line":2,"column":7,"nodeType":"1684","messageId":"1685","endLine":2,"endColumn":10},{"ruleId":"1663","severity":1,"message":"1703","line":9,"column":10,"nodeType":"1665","endLine":9,"endColumn":38},{"ruleId":"1682","severity":1,"message":"1683","line":13,"column":12,"nodeType":"1684","messageId":"1685","endLine":13,"endColumn":15},{"ruleId":"1682","severity":1,"message":"1683","line":47,"column":28,"nodeType":"1684","messageId":"1685","endLine":47,"endColumn":31},{"ruleId":"1682","severity":1,"message":"1683","line":67,"column":28,"nodeType":"1684","messageId":"1685","endLine":67,"endColumn":31},{"ruleId":"1682","severity":1,"message":"1683","line":35,"column":58,"nodeType":"1684","messageId":"1685","endLine":35,"endColumn":61},{"ruleId":"1677","severity":1,"message":"1678","line":151,"column":3,"nodeType":"1686","messageId":"1680","endLine":153,"endColumn":4},{"ruleId":"1663","severity":1,"message":"1704","line":3,"column":3,"nodeType":"1665","endLine":3,"endColumn":41},{"ruleId":"1687","severity":1,"message":"1688","line":82,"column":14,"nodeType":"1689","messageId":"1690","endLine":82,"endColumn":19},{"ruleId":"1687","severity":1,"message":"1688","line":82,"column":14,"nodeType":"1689","messageId":"1690","endLine":82,"endColumn":18},{"ruleId":"1677","severity":1,"message":"1678","line":134,"column":3,"nodeType":"1686","messageId":"1680","endLine":134,"endColumn":76},{"ruleId":"1682","severity":1,"message":"1683","line":166,"column":29,"nodeType":"1684","messageId":"1685","endLine":166,"endColumn":32},{"ruleId":"1682","severity":1,"message":"1683","line":196,"column":29,"nodeType":"1684","messageId":"1685","endLine":196,"endColumn":32},{"ruleId":"1682","severity":1,"message":"1683","line":233,"column":20,"nodeType":"1684","messageId":"1685","endLine":233,"endColumn":23},{"ruleId":"1663","severity":1,"message":"1702","line":3,"column":3,"nodeType":"1665","endLine":3,"endColumn":32},{"ruleId":"1677","severity":1,"message":"1678","line":18,"column":3,"nodeType":"1686","messageId":"1680","endLine":18,"endColumn":56},{"ruleId":"1677","severity":1,"message":"1678","line":22,"column":3,"nodeType":"1686","messageId":"1680","endLine":22,"endColumn":64},{"ruleId":"1682","severity":1,"message":"1683","line":35,"column":32,"nodeType":"1684","messageId":"1685","endLine":35,"endColumn":35},{"ruleId":"1687","severity":1,"message":"1688","line":88,"column":13,"nodeType":"1689","messageId":"1690","endLine":88,"endColumn":23},{"ruleId":"1687","severity":1,"message":"1688","line":88,"column":13,"nodeType":"1689","messageId":"1690","endLine":88,"endColumn":22},{"ruleId":"1687","severity":1,"message":"1688","line":119,"column":13,"nodeType":"1689","messageId":"1690","endLine":119,"endColumn":23},{"ruleId":"1687","severity":1,"message":"1688","line":119,"column":13,"nodeType":"1689","messageId":"1690","endLine":119,"endColumn":22},{"ruleId":"1687","severity":1,"message":"1688","line":137,"column":30,"nodeType":"1689","messageId":"1690","endLine":137,"endColumn":40},{"ruleId":"1687","severity":1,"message":"1688","line":137,"column":30,"nodeType":"1689","messageId":"1690","endLine":137,"endColumn":39},{"ruleId":"1687","severity":1,"message":"1688","line":64,"column":26,"nodeType":"1689","messageId":"1690","endLine":64,"endColumn":31},{"ruleId":"1687","severity":1,"message":"1688","line":64,"column":26,"nodeType":"1689","messageId":"1690","endLine":64,"endColumn":30},{"ruleId":"1677","severity":1,"message":"1678","line":127,"column":3,"nodeType":"1686","messageId":"1680","endLine":127,"endColumn":70},{"ruleId":"1677","severity":1,"message":"1678","line":134,"column":3,"nodeType":"1686","messageId":"1680","endLine":134,"endColumn":55},{"ruleId":"1677","severity":1,"message":"1678","line":189,"column":3,"nodeType":"1686","messageId":"1680","endLine":191,"endColumn":4},{"ruleId":"1677","severity":1,"message":"1678","line":234,"column":3,"nodeType":"1686","messageId":"1680","endLine":234,"endColumn":33},{"ruleId":"1663","severity":1,"message":"1705","line":284,"column":9,"nodeType":"1665","endLine":284,"endColumn":21},{"ruleId":"1687","severity":1,"message":"1688","line":588,"column":48,"nodeType":"1689","messageId":"1690","endLine":588,"endColumn":81},{"ruleId":"1687","severity":1,"message":"1688","line":588,"column":48,"nodeType":"1689","messageId":"1690","endLine":588,"endColumn":82},{"ruleId":"1687","severity":1,"message":"1688","line":611,"column":40,"nodeType":"1689","messageId":"1690","endLine":611,"endColumn":73},{"ruleId":"1687","severity":1,"message":"1688","line":611,"column":40,"nodeType":"1689","messageId":"1690","endLine":611,"endColumn":74},{"ruleId":"1687","severity":1,"message":"1688","line":801,"column":26,"nodeType":"1689","messageId":"1690","endLine":801,"endColumn":76},{"ruleId":"1687","severity":1,"message":"1688","line":801,"column":26,"nodeType":"1689","messageId":"1690","endLine":801,"endColumn":75},{"ruleId":"1687","severity":1,"message":"1688","line":920,"column":13,"nodeType":"1689","messageId":"1690","endLine":920,"endColumn":18},{"ruleId":"1687","severity":1,"message":"1688","line":920,"column":13,"nodeType":"1689","messageId":"1690","endLine":920,"endColumn":17},{"ruleId":"1677","severity":1,"message":"1678","line":930,"column":3,"nodeType":"1686","messageId":"1680","endLine":930,"endColumn":28},{"ruleId":"1682","severity":1,"message":"1683","line":98,"column":49,"nodeType":"1684","messageId":"1685","endLine":98,"endColumn":52},{"ruleId":"1677","severity":1,"message":"1678","line":114,"column":3,"nodeType":"1686","messageId":"1680","endLine":114,"endColumn":42},{"ruleId":"1677","severity":1,"message":"1678","line":192,"column":3,"nodeType":"1686","messageId":"1680","endLine":192,"endColumn":20},{"ruleId":"1682","severity":1,"message":"1683","line":230,"column":12,"nodeType":"1684","messageId":"1685","endLine":230,"endColumn":15},{"ruleId":"1663","severity":1,"message":"1706","line":5,"column":3,"nodeType":"1665","endLine":5,"endColumn":49},{"ruleId":"1663","severity":1,"message":"1692","line":7,"column":10,"nodeType":"1665","endLine":7,"endColumn":20},{"ruleId":"1663","severity":1,"message":"1707","line":7,"column":3,"nodeType":"1665","endLine":7,"endColumn":44},{"ruleId":"1663","severity":1,"message":"1708","line":23,"column":3,"nodeType":"1665","endLine":23,"endColumn":44},{"ruleId":"1687","severity":1,"message":"1688","line":157,"column":41,"nodeType":"1689","messageId":"1690","endLine":157,"endColumn":66},{"ruleId":"1687","severity":1,"message":"1688","line":157,"column":41,"nodeType":"1689","messageId":"1690","endLine":157,"endColumn":65},{"ruleId":"1687","severity":1,"message":"1688","line":235,"column":14,"nodeType":"1689","messageId":"1690","endLine":235,"endColumn":39},{"ruleId":"1687","severity":1,"message":"1688","line":235,"column":14,"nodeType":"1689","messageId":"1690","endLine":235,"endColumn":38},{"ruleId":"1682","severity":1,"message":"1683","line":286,"column":40,"nodeType":"1684","messageId":"1685","endLine":286,"endColumn":43},{"ruleId":"1682","severity":1,"message":"1683","line":19,"column":58,"nodeType":"1684","messageId":"1685","endLine":19,"endColumn":61},{"ruleId":"1682","severity":1,"message":"1683","line":34,"column":13,"nodeType":"1684","messageId":"1685","endLine":34,"endColumn":16},{"ruleId":"1682","severity":1,"message":"1683","line":64,"column":13,"nodeType":"1684","messageId":"1685","endLine":64,"endColumn":16},{"ruleId":"1682","severity":1,"message":"1683","line":87,"column":15,"nodeType":"1684","messageId":"1685","endLine":87,"endColumn":18},{"ruleId":"1663","severity":1,"message":"1709","line":11,"column":3,"nodeType":"1665","endLine":11,"endColumn":23},{"ruleId":"1663","severity":1,"message":"1710","line":23,"column":10,"nodeType":"1665","endLine":23,"endColumn":33},{"ruleId":"1663","severity":1,"message":"1711","line":14,"column":3,"nodeType":"1665","endLine":14,"endColumn":45},{"ruleId":"1682","severity":1,"message":"1683","line":113,"column":30,"nodeType":"1684","messageId":"1685","endLine":113,"endColumn":33},{"ruleId":"1682","severity":1,"message":"1683","line":146,"column":28,"nodeType":"1684","messageId":"1685","endLine":146,"endColumn":31},{"ruleId":"1682","severity":1,"message":"1683","line":16,"column":45,"nodeType":"1684","messageId":"1685","endLine":16,"endColumn":48},{"ruleId":"1682","severity":1,"message":"1683","line":20,"column":6,"nodeType":"1684","messageId":"1685","endLine":20,"endColumn":9},{"ruleId":"1682","severity":1,"message":"1683","line":48,"column":6,"nodeType":"1684","messageId":"1685","endLine":48,"endColumn":9},{"ruleId":"1682","severity":1,"message":"1683","line":52,"column":6,"nodeType":"1684","messageId":"1685","endLine":52,"endColumn":9},{"ruleId":"1682","severity":1,"message":"1683","line":62,"column":6,"nodeType":"1684","messageId":"1685","endLine":62,"endColumn":9},{"ruleId":"1682","severity":1,"message":"1683","line":18,"column":62,"nodeType":"1684","messageId":"1685","endLine":18,"endColumn":65},{"ruleId":"1682","severity":1,"message":"1683","line":29,"column":22,"nodeType":"1684","messageId":"1685","endLine":29,"endColumn":25},{"ruleId":"1682","severity":1,"message":"1683","line":75,"column":22,"nodeType":"1684","messageId":"1685","endLine":75,"endColumn":25},{"ruleId":"1682","severity":1,"message":"1683","line":114,"column":38,"nodeType":"1684","messageId":"1685","endLine":114,"endColumn":41},{"ruleId":"1682","severity":1,"message":"1683","line":6,"column":16,"nodeType":"1684","messageId":"1685","endLine":6,"endColumn":19},{"ruleId":"1677","severity":1,"message":"1678","line":40,"column":3,"nodeType":"1686","messageId":"1680","endLine":40,"endColumn":50},{"ruleId":"1677","severity":1,"message":"1678","line":46,"column":3,"nodeType":"1686","messageId":"1680","endLine":46,"endColumn":45},{"ruleId":"1677","severity":1,"message":"1678","line":125,"column":3,"nodeType":"1686","messageId":"1680","endLine":125,"endColumn":29},{"ruleId":"1663","severity":1,"message":"1712","line":546,"column":38,"nodeType":"1665","endLine":546,"endColumn":44},{"ruleId":"1677","severity":1,"message":"1678","line":699,"column":3,"nodeType":"1686","messageId":"1680","endLine":699,"endColumn":61},{"ruleId":"1663","severity":1,"message":"1712","line":858,"column":38,"nodeType":"1665","endLine":858,"endColumn":44},{"ruleId":"1677","severity":1,"message":"1678","line":891,"column":3,"nodeType":"1686","messageId":"1680","endLine":891,"endColumn":35},{"ruleId":"1682","severity":1,"message":"1683","line":972,"column":34,"nodeType":"1684","messageId":"1685","endLine":972,"endColumn":37},{"ruleId":"1677","severity":1,"message":"1678","line":1100,"column":3,"nodeType":"1686","messageId":"1680","endLine":1100,"endColumn":41},{"ruleId":"1663","severity":1,"message":"1713","line":3,"column":3,"nodeType":"1665","endLine":3,"endColumn":28},{"ruleId":"1663","severity":1,"message":"1714","line":3,"column":8,"nodeType":"1665","endLine":3,"endColumn":20},{"ruleId":"1687","severity":1,"message":"1688","line":145,"column":26,"nodeType":"1689","messageId":"1690","endLine":145,"endColumn":39},{"ruleId":"1687","severity":1,"message":"1688","line":169,"column":26,"nodeType":"1689","messageId":"1690","endLine":169,"endColumn":39},{"ruleId":"1677","severity":1,"message":"1678","line":189,"column":3,"nodeType":"1686","messageId":"1680","endLine":189,"endColumn":32},{"ruleId":"1687","severity":1,"message":"1688","line":155,"column":26,"nodeType":"1689","messageId":"1690","endLine":155,"endColumn":39},{"ruleId":"1687","severity":1,"message":"1688","line":179,"column":26,"nodeType":"1689","messageId":"1690","endLine":179,"endColumn":39},{"ruleId":"1682","severity":1,"message":"1683","line":184,"column":37,"nodeType":"1684","messageId":"1685","endLine":184,"endColumn":40},{"ruleId":"1677","severity":1,"message":"1678","line":202,"column":3,"nodeType":"1686","messageId":"1680","endLine":202,"endColumn":32},{"ruleId":"1663","severity":1,"message":"1715","line":17,"column":22,"nodeType":"1665","endLine":17,"endColumn":30},{"ruleId":"1682","severity":1,"message":"1683","line":110,"column":30,"nodeType":"1684","messageId":"1685","endLine":110,"endColumn":33},{"ruleId":"1677","severity":1,"message":"1678","line":182,"column":3,"nodeType":"1686","messageId":"1680","endLine":182,"endColumn":24},{"ruleId":"1677","severity":1,"message":"1678","line":188,"column":3,"nodeType":"1686","messageId":"1680","endLine":188,"endColumn":24},{"ruleId":"1677","severity":1,"message":"1678","line":482,"column":3,"nodeType":"1686","messageId":"1680","endLine":482,"endColumn":20},{"ruleId":"1663","severity":1,"message":"1716","line":1,"column":10,"nodeType":"1665","endLine":1,"endColumn":64},{"ruleId":"1663","severity":1,"message":"1717","line":1,"column":8,"nodeType":"1665","endLine":1,"endColumn":17},{"ruleId":"1663","severity":1,"message":"1718","line":5,"column":3,"nodeType":"1665","endLine":5,"endColumn":70},{"ruleId":"1677","severity":1,"message":"1678","line":24,"column":33,"nodeType":"1679","messageId":"1680","endLine":24,"endColumn":47},{"ruleId":"1682","severity":1,"message":"1683","line":24,"column":40,"nodeType":"1684","messageId":"1685","endLine":24,"endColumn":43},{"ruleId":"1682","severity":1,"message":"1683","line":22,"column":20,"nodeType":"1684","messageId":"1685","endLine":22,"endColumn":23},{"ruleId":"1677","severity":1,"message":"1678","line":92,"column":3,"nodeType":"1686","messageId":"1680","endLine":92,"endColumn":34},{"ruleId":"1677","severity":1,"message":"1678","line":108,"column":3,"nodeType":"1686","messageId":"1680","endLine":108,"endColumn":42},{"ruleId":"1682","severity":1,"message":"1683","line":108,"column":38,"nodeType":"1684","messageId":"1685","endLine":108,"endColumn":41},{"ruleId":"1677","severity":1,"message":"1678","line":112,"column":3,"nodeType":"1686","messageId":"1680","endLine":112,"endColumn":51},{"ruleId":"1677","severity":1,"message":"1678","line":122,"column":3,"nodeType":"1686","messageId":"1680","endLine":122,"endColumn":57},{"ruleId":"1682","severity":1,"message":"1683","line":150,"column":46,"nodeType":"1684","messageId":"1685","endLine":150,"endColumn":49},{"ruleId":"1677","severity":1,"message":"1678","line":157,"column":29,"nodeType":"1679","messageId":"1680","endLine":157,"endColumn":34},{"ruleId":"1677","severity":1,"message":"1678","line":162,"column":27,"nodeType":"1679","messageId":"1680","endLine":162,"endColumn":51},{"ruleId":"1677","severity":1,"message":"1678","line":171,"column":33,"nodeType":"1679","messageId":"1680","endLine":171,"endColumn":38},{"ruleId":"1677","severity":1,"message":"1678","line":176,"column":26,"nodeType":"1679","messageId":"1680","endLine":176,"endColumn":31},{"ruleId":"1677","severity":1,"message":"1678","line":186,"column":3,"nodeType":"1686","messageId":"1680","endLine":189,"endColumn":4},{"ruleId":"1677","severity":1,"message":"1678","line":198,"column":30,"nodeType":"1679","messageId":"1680","endLine":198,"endColumn":56},{"ruleId":"1677","severity":1,"message":"1678","line":302,"column":3,"nodeType":"1686","messageId":"1680","endLine":302,"endColumn":37},{"ruleId":"1677","severity":1,"message":"1678","line":307,"column":3,"nodeType":"1686","messageId":"1680","endLine":307,"endColumn":39},{"ruleId":"1677","severity":1,"message":"1678","line":30,"column":3,"nodeType":"1686","messageId":"1680","endLine":30,"endColumn":27},{"ruleId":"1677","severity":1,"message":"1678","line":128,"column":3,"nodeType":"1686","messageId":"1680","endLine":128,"endColumn":55},{"ruleId":"1677","severity":1,"message":"1678","line":132,"column":3,"nodeType":"1686","messageId":"1680","endLine":135,"endColumn":4},{"ruleId":"1677","severity":1,"message":"1678","line":144,"column":3,"nodeType":"1686","messageId":"1680","endLine":144,"endColumn":78},{"ruleId":"1677","severity":1,"message":"1678","line":148,"column":3,"nodeType":"1686","messageId":"1680","endLine":148,"endColumn":78},{"ruleId":"1677","severity":1,"message":"1678","line":153,"column":3,"nodeType":"1686","messageId":"1680","endLine":155,"endColumn":4},{"ruleId":"1694","severity":1,"message":"1695","line":4,"column":3,"nodeType":"1696","endLine":4,"endColumn":70},{"ruleId":"1697","severity":1,"message":"1698","line":4,"column":68,"nodeType":"1686","messageId":"1699"},{"ruleId":"1663","severity":1,"message":"1719","line":1,"column":8,"nodeType":"1665","endLine":1,"endColumn":32},{"ruleId":"1677","severity":1,"message":"1678","line":421,"column":3,"nodeType":"1686","messageId":"1680","endLine":421,"endColumn":58},{"ruleId":"1682","severity":1,"message":"1683","line":161,"column":33,"nodeType":"1684","messageId":"1685","endLine":161,"endColumn":36},{"ruleId":"1677","severity":1,"message":"1678","line":224,"column":3,"nodeType":"1686","messageId":"1680","endLine":226,"endColumn":4},{"ruleId":"1677","severity":1,"message":"1678","line":208,"column":3,"nodeType":"1686","messageId":"1680","endLine":208,"endColumn":49},{"ruleId":"1677","severity":1,"message":"1678","line":212,"column":3,"nodeType":"1686","messageId":"1680","endLine":212,"endColumn":28},{"ruleId":"1677","severity":1,"message":"1678","line":222,"column":42,"nodeType":"1679","messageId":"1680","endLine":222,"endColumn":47},{"ruleId":"1677","severity":1,"message":"1678","line":250,"column":3,"nodeType":"1686","messageId":"1680","endLine":250,"endColumn":68},{"ruleId":"1677","severity":1,"message":"1678","line":266,"column":3,"nodeType":"1686","messageId":"1680","endLine":269,"endColumn":4},{"ruleId":"1682","severity":1,"message":"1683","line":268,"column":14,"nodeType":"1684","messageId":"1685","endLine":268,"endColumn":17},{"ruleId":"1687","severity":1,"message":"1688","line":271,"column":24,"nodeType":"1689","messageId":"1690","endLine":271,"endColumn":32},{"ruleId":"1677","severity":1,"message":"1678","line":280,"column":3,"nodeType":"1686","messageId":"1680","endLine":280,"endColumn":28},{"ruleId":"1677","severity":1,"message":"1678","line":287,"column":24,"nodeType":"1679","messageId":"1680","endLine":287,"endColumn":29},{"ruleId":"1687","severity":1,"message":"1688","line":289,"column":19,"nodeType":"1689","messageId":"1690","endLine":289,"endColumn":28},{"ruleId":"1682","severity":1,"message":"1683","line":292,"column":26,"nodeType":"1684","messageId":"1685","endLine":292,"endColumn":29},{"ruleId":"1677","severity":1,"message":"1678","line":300,"column":34,"nodeType":"1679","messageId":"1680","endLine":300,"endColumn":39},{"ruleId":"1677","severity":1,"message":"1678","line":307,"column":35,"nodeType":"1679","messageId":"1680","endLine":307,"endColumn":40},{"ruleId":"1677","severity":1,"message":"1678","line":312,"column":41,"nodeType":"1679","messageId":"1680","endLine":318,"endColumn":7},{"ruleId":"1677","severity":1,"message":"1678","line":323,"column":39,"nodeType":"1679","messageId":"1680","endLine":323,"endColumn":44},{"ruleId":"1677","severity":1,"message":"1678","line":332,"column":35,"nodeType":"1679","messageId":"1680","endLine":332,"endColumn":40},{"ruleId":"1677","severity":1,"message":"1678","line":398,"column":48,"nodeType":"1679","messageId":"1680","endLine":404,"endColumn":7},{"ruleId":"1677","severity":1,"message":"1678","line":460,"column":3,"nodeType":"1686","messageId":"1680","endLine":462,"endColumn":4},{"ruleId":"1687","severity":1,"message":"1688","line":511,"column":26,"nodeType":"1689","messageId":"1690","endLine":511,"endColumn":34},{"ruleId":"1682","severity":1,"message":"1683","line":84,"column":11,"nodeType":"1684","messageId":"1685","endLine":84,"endColumn":14},{"ruleId":"1687","severity":1,"message":"1688","line":94,"column":23,"nodeType":"1689","messageId":"1690","endLine":94,"endColumn":32},{"ruleId":"1687","severity":1,"message":"1688","line":100,"column":27,"nodeType":"1689","messageId":"1690","endLine":100,"endColumn":36},{"ruleId":"1682","severity":1,"message":"1683","line":100,"column":40,"nodeType":"1684","messageId":"1685","endLine":100,"endColumn":43},{"ruleId":"1677","severity":1,"message":"1678","line":36,"column":3,"nodeType":"1686","messageId":"1680","endLine":36,"endColumn":18},{"ruleId":"1677","severity":1,"message":"1678","line":152,"column":3,"nodeType":"1686","messageId":"1680","endLine":152,"endColumn":47},{"ruleId":"1677","severity":1,"message":"1678","line":157,"column":3,"nodeType":"1686","messageId":"1680","endLine":157,"endColumn":22},{"ruleId":"1697","severity":1,"message":"1720","line":157,"column":23,"nodeType":"1686","messageId":"1699"},{"ruleId":"1677","severity":1,"message":"1678","line":160,"column":3,"nodeType":"1686","messageId":"1680","endLine":160,"endColumn":25},{"ruleId":"1677","severity":1,"message":"1678","line":168,"column":3,"nodeType":"1686","messageId":"1680","endLine":168,"endColumn":24},{"ruleId":"1677","severity":1,"message":"1678","line":172,"column":3,"nodeType":"1686","messageId":"1680","endLine":172,"endColumn":25},{"ruleId":"1677","severity":1,"message":"1678","line":212,"column":3,"nodeType":"1686","messageId":"1680","endLine":214,"endColumn":4},{"ruleId":"1677","severity":1,"message":"1678","line":245,"column":3,"nodeType":"1686","messageId":"1680","endLine":245,"endColumn":31},{"ruleId":"1677","severity":1,"message":"1678","line":249,"column":3,"nodeType":"1686","messageId":"1680","endLine":249,"endColumn":32},{"ruleId":"1677","severity":1,"message":"1678","line":257,"column":3,"nodeType":"1686","messageId":"1680","endLine":257,"endColumn":31},{"ruleId":"1663","severity":1,"message":"1721","line":2,"column":10,"nodeType":"1665","endLine":2,"endColumn":26},{"ruleId":"1677","severity":1,"message":"1678","line":48,"column":3,"nodeType":"1686","messageId":"1680","endLine":48,"endColumn":46},{"ruleId":"1677","severity":1,"message":"1678","line":59,"column":3,"nodeType":"1686","messageId":"1680","endLine":59,"endColumn":46},{"ruleId":"1682","severity":1,"message":"1683","line":76,"column":24,"nodeType":"1684","messageId":"1685","endLine":76,"endColumn":27},{"ruleId":"1682","severity":1,"message":"1683","line":271,"column":22,"nodeType":"1684","messageId":"1685","endLine":271,"endColumn":25},{"ruleId":"1682","severity":1,"message":"1683","line":286,"column":42,"nodeType":"1684","messageId":"1685","endLine":286,"endColumn":45},{"ruleId":"1677","severity":1,"message":"1678","line":318,"column":27,"nodeType":"1679","messageId":"1680","endLine":318,"endColumn":32},{"ruleId":"1677","severity":1,"message":"1678","line":357,"column":3,"nodeType":"1686","messageId":"1680","endLine":357,"endColumn":50},{"ruleId":"1677","severity":1,"message":"1678","line":413,"column":9,"nodeType":"1722","messageId":"1680","endLine":413,"endColumn":34},{"ruleId":"1677","severity":1,"message":"1678","line":427,"column":9,"nodeType":"1722","messageId":"1680","endLine":427,"endColumn":46},{"ruleId":"1677","severity":1,"message":"1678","line":437,"column":9,"nodeType":"1722","messageId":"1680","endLine":437,"endColumn":27},{"ruleId":"1677","severity":1,"message":"1678","line":452,"column":42,"nodeType":"1679","messageId":"1680","endLine":452,"endColumn":47},{"ruleId":"1677","severity":1,"message":"1678","line":460,"column":3,"nodeType":"1686","messageId":"1680","endLine":462,"endColumn":4},{"ruleId":"1677","severity":1,"message":"1678","line":488,"column":3,"nodeType":"1686","messageId":"1680","endLine":488,"endColumn":47},{"ruleId":"1677","severity":1,"message":"1678","line":500,"column":3,"nodeType":"1686","messageId":"1680","endLine":500,"endColumn":23},{"ruleId":"1677","severity":1,"message":"1678","line":504,"column":3,"nodeType":"1686","messageId":"1680","endLine":504,"endColumn":26},{"ruleId":"1677","severity":1,"message":"1678","line":515,"column":3,"nodeType":"1686","messageId":"1680","endLine":517,"endColumn":4},{"ruleId":"1677","severity":1,"message":"1678","line":549,"column":3,"nodeType":"1686","messageId":"1680","endLine":551,"endColumn":4},{"ruleId":"1687","severity":1,"message":"1688","line":647,"column":7,"nodeType":"1689","messageId":"1690","endLine":647,"endColumn":19},{"ruleId":"1677","severity":1,"message":"1678","line":726,"column":3,"nodeType":"1686","messageId":"1680","endLine":726,"endColumn":52},{"ruleId":"1677","severity":1,"message":"1678","line":837,"column":3,"nodeType":"1686","messageId":"1680","endLine":837,"endColumn":40},{"ruleId":"1723","severity":1,"message":"1724","line":933,"column":13,"nodeType":"1725","endLine":933,"endColumn":33,"fix":"1726"},{"ruleId":"1677","severity":1,"message":"1678","line":988,"column":3,"nodeType":"1686","messageId":"1680","endLine":990,"endColumn":4},{"ruleId":"1677","severity":1,"message":"1678","line":998,"column":39,"nodeType":"1679","messageId":"1680","endLine":1000,"endColumn":7},{"ruleId":"1677","severity":1,"message":"1678","line":1048,"column":35,"nodeType":"1679","messageId":"1680","endLine":1048,"endColumn":54},{"ruleId":"1677","severity":1,"message":"1678","line":1122,"column":7,"nodeType":"1722","messageId":"1680","endLine":1122,"endColumn":31},{"ruleId":"1677","severity":1,"message":"1678","line":13,"column":1,"nodeType":"1722","messageId":"1680","endLine":13,"endColumn":28},{"ruleId":"1677","severity":1,"message":"1678","line":26,"column":1,"nodeType":"1722","messageId":"1680","endLine":26,"endColumn":22},{"ruleId":"1677","severity":1,"message":"1678","line":23,"column":1,"nodeType":"1722","messageId":"1680","endLine":23,"endColumn":37},{"ruleId":"1677","severity":1,"message":"1678","line":10,"column":25,"nodeType":"1679","messageId":"1680","endLine":10,"endColumn":36},{"ruleId":"1663","severity":1,"message":"1727","line":3,"column":3,"nodeType":"1665","endLine":3,"endColumn":16},{"ruleId":"1663","severity":1,"message":"1728","line":4,"column":3,"nodeType":"1665","endLine":4,"endColumn":16},{"ruleId":"1663","severity":1,"message":"1729","line":5,"column":3,"nodeType":"1665","endLine":5,"endColumn":24},{"ruleId":"1663","severity":1,"message":"1730","line":6,"column":3,"nodeType":"1665","endLine":6,"endColumn":26},{"ruleId":"1663","severity":1,"message":"1731","line":7,"column":3,"nodeType":"1665","endLine":7,"endColumn":18},{"ruleId":"1663","severity":1,"message":"1732","line":8,"column":3,"nodeType":"1665","endLine":8,"endColumn":20},{"ruleId":"1663","severity":1,"message":"1733","line":9,"column":3,"nodeType":"1665","endLine":9,"endColumn":22},{"ruleId":"1663","severity":1,"message":"1734","line":11,"column":10,"nodeType":"1665","endLine":11,"endColumn":23},{"ruleId":"1677","severity":1,"message":"1678","line":13,"column":1,"nodeType":"1722","messageId":"1680","endLine":13,"endColumn":50},{"ruleId":"1663","severity":1,"message":"1735","line":13,"column":10,"nodeType":"1665","endLine":13,"endColumn":29},{"ruleId":"1663","severity":1,"message":"1736","line":23,"column":7,"nodeType":"1665","endLine":23,"endColumn":21},{"ruleId":"1677","severity":1,"message":"1678","line":23,"column":24,"nodeType":"1679","messageId":"1680","endLine":23,"endColumn":35},{"ruleId":"1677","severity":1,"message":"1678","line":3,"column":37,"nodeType":"1679","messageId":"1680","endLine":3,"endColumn":42},{"ruleId":"1663","severity":1,"message":"1737","line":3,"column":8,"nodeType":"1665","endLine":3,"endColumn":13},{"ruleId":"1677","severity":1,"message":"1678","line":10,"column":8,"nodeType":"1722","messageId":"1680","endLine":10,"endColumn":40},{"ruleId":"1677","severity":1,"message":"1678","line":39,"column":8,"nodeType":"1722","messageId":"1680","endLine":42,"endColumn":2},{"ruleId":"1677","severity":1,"message":"1678","line":9,"column":55,"nodeType":"1679","messageId":"1680","endLine":9,"endColumn":60},{"ruleId":"1682","severity":1,"message":"1683","line":15,"column":31,"nodeType":"1684","messageId":"1685","endLine":15,"endColumn":34},{"ruleId":"1682","severity":1,"message":"1683","line":16,"column":29,"nodeType":"1684","messageId":"1685","endLine":16,"endColumn":32},{"ruleId":"1682","severity":1,"message":"1683","line":21,"column":14,"nodeType":"1684","messageId":"1685","endLine":21,"endColumn":17},{"ruleId":"1682","severity":1,"message":"1683","line":24,"column":20,"nodeType":"1684","messageId":"1685","endLine":24,"endColumn":23},{"ruleId":"1682","severity":1,"message":"1683","line":28,"column":15,"nodeType":"1684","messageId":"1685","endLine":28,"endColumn":18},{"ruleId":"1682","severity":1,"message":"1683","line":29,"column":15,"nodeType":"1684","messageId":"1685","endLine":29,"endColumn":18},{"ruleId":"1682","severity":1,"message":"1683","line":35,"column":14,"nodeType":"1684","messageId":"1685","endLine":35,"endColumn":17},{"ruleId":"1682","severity":1,"message":"1683","line":36,"column":11,"nodeType":"1684","messageId":"1685","endLine":36,"endColumn":14},{"ruleId":"1682","severity":1,"message":"1683","line":37,"column":10,"nodeType":"1684","messageId":"1685","endLine":37,"endColumn":13},{"ruleId":"1682","severity":1,"message":"1683","line":40,"column":11,"nodeType":"1684","messageId":"1685","endLine":40,"endColumn":14},{"ruleId":"1682","severity":1,"message":"1683","line":58,"column":18,"nodeType":"1684","messageId":"1685","endLine":58,"endColumn":21},{"ruleId":"1682","severity":1,"message":"1683","line":60,"column":12,"nodeType":"1684","messageId":"1685","endLine":60,"endColumn":15},{"ruleId":"1682","severity":1,"message":"1683","line":73,"column":25,"nodeType":"1684","messageId":"1685","endLine":73,"endColumn":28},{"ruleId":"1682","severity":1,"message":"1683","line":74,"column":19,"nodeType":"1684","messageId":"1685","endLine":74,"endColumn":22},{"ruleId":"1682","severity":1,"message":"1683","line":77,"column":11,"nodeType":"1684","messageId":"1685","endLine":77,"endColumn":14},{"ruleId":"1682","severity":1,"message":"1683","line":78,"column":20,"nodeType":"1684","messageId":"1685","endLine":78,"endColumn":23},{"ruleId":"1682","severity":1,"message":"1683","line":79,"column":13,"nodeType":"1684","messageId":"1685","endLine":79,"endColumn":16},{"ruleId":"1682","severity":1,"message":"1683","line":100,"column":57,"nodeType":"1684","messageId":"1685","endLine":100,"endColumn":60},{"ruleId":"1682","severity":1,"message":"1683","line":102,"column":20,"nodeType":"1684","messageId":"1685","endLine":102,"endColumn":23},{"ruleId":"1682","severity":1,"message":"1683","line":102,"column":44,"nodeType":"1684","messageId":"1685","endLine":102,"endColumn":47},{"ruleId":"1682","severity":1,"message":"1683","line":103,"column":30,"nodeType":"1684","messageId":"1685","endLine":103,"endColumn":33},{"ruleId":"1682","severity":1,"message":"1683","line":109,"column":42,"nodeType":"1684","messageId":"1685","endLine":109,"endColumn":45},{"ruleId":"1682","severity":1,"message":"1683","line":130,"column":28,"nodeType":"1684","messageId":"1685","endLine":130,"endColumn":31},{"ruleId":"1682","severity":1,"message":"1683","line":130,"column":52,"nodeType":"1684","messageId":"1685","endLine":130,"endColumn":55},{"ruleId":"1682","severity":1,"message":"1683","line":131,"column":38,"nodeType":"1684","messageId":"1685","endLine":131,"endColumn":41},{"ruleId":"1682","severity":1,"message":"1683","line":133,"column":29,"nodeType":"1684","messageId":"1685","endLine":133,"endColumn":32},{"ruleId":"1682","severity":1,"message":"1683","line":133,"column":35,"nodeType":"1684","messageId":"1685","endLine":133,"endColumn":38},{"ruleId":"1682","severity":1,"message":"1683","line":135,"column":35,"nodeType":"1684","messageId":"1685","endLine":135,"endColumn":38},{"ruleId":"1682","severity":1,"message":"1683","line":136,"column":35,"nodeType":"1684","messageId":"1685","endLine":136,"endColumn":38},{"ruleId":"1682","severity":1,"message":"1683","line":146,"column":47,"nodeType":"1684","messageId":"1685","endLine":146,"endColumn":50},{"ruleId":"1682","severity":1,"message":"1683","line":154,"column":22,"nodeType":"1684","messageId":"1685","endLine":154,"endColumn":25},{"ruleId":"1682","severity":1,"message":"1683","line":180,"column":57,"nodeType":"1684","messageId":"1685","endLine":180,"endColumn":60},{"ruleId":"1682","severity":1,"message":"1683","line":181,"column":47,"nodeType":"1684","messageId":"1685","endLine":181,"endColumn":50},{"ruleId":"1682","severity":1,"message":"1683","line":183,"column":60,"nodeType":"1684","messageId":"1685","endLine":183,"endColumn":63},{"ruleId":"1682","severity":1,"message":"1683","line":184,"column":50,"nodeType":"1684","messageId":"1685","endLine":184,"endColumn":53},{"ruleId":"1682","severity":1,"message":"1683","line":189,"column":23,"nodeType":"1684","messageId":"1685","endLine":189,"endColumn":26},{"ruleId":"1682","severity":1,"message":"1683","line":190,"column":23,"nodeType":"1684","messageId":"1685","endLine":190,"endColumn":26},{"ruleId":"1682","severity":1,"message":"1683","line":191,"column":36,"nodeType":"1684","messageId":"1685","endLine":191,"endColumn":39},{"ruleId":"1682","severity":1,"message":"1683","line":192,"column":49,"nodeType":"1684","messageId":"1685","endLine":192,"endColumn":52},{"ruleId":"1682","severity":1,"message":"1683","line":204,"column":9,"nodeType":"1684","messageId":"1685","endLine":204,"endColumn":12},{"ruleId":"1682","severity":1,"message":"1683","line":208,"column":9,"nodeType":"1684","messageId":"1685","endLine":208,"endColumn":12},{"ruleId":"1682","severity":1,"message":"1683","line":216,"column":24,"nodeType":"1684","messageId":"1685","endLine":216,"endColumn":27},{"ruleId":"1682","severity":1,"message":"1683","line":222,"column":14,"nodeType":"1684","messageId":"1685","endLine":222,"endColumn":17},{"ruleId":"1682","severity":1,"message":"1683","line":223,"column":67,"nodeType":"1684","messageId":"1685","endLine":223,"endColumn":70},{"ruleId":"1682","severity":1,"message":"1683","line":224,"column":57,"nodeType":"1684","messageId":"1685","endLine":224,"endColumn":60},{"ruleId":"1682","severity":1,"message":"1683","line":230,"column":24,"nodeType":"1684","messageId":"1685","endLine":230,"endColumn":27},{"ruleId":"1682","severity":1,"message":"1683","line":236,"column":14,"nodeType":"1684","messageId":"1685","endLine":236,"endColumn":17},{"ruleId":"1682","severity":1,"message":"1683","line":240,"column":24,"nodeType":"1684","messageId":"1685","endLine":240,"endColumn":27},{"ruleId":"1682","severity":1,"message":"1683","line":242,"column":62,"nodeType":"1684","messageId":"1685","endLine":242,"endColumn":65},{"ruleId":"1682","severity":1,"message":"1683","line":246,"column":11,"nodeType":"1684","messageId":"1685","endLine":246,"endColumn":14},{"ruleId":"1682","severity":1,"message":"1683","line":248,"column":24,"nodeType":"1684","messageId":"1685","endLine":248,"endColumn":27},{"ruleId":"1682","severity":1,"message":"1683","line":252,"column":11,"nodeType":"1684","messageId":"1685","endLine":252,"endColumn":14},{"ruleId":"1682","severity":1,"message":"1683","line":254,"column":14,"nodeType":"1684","messageId":"1685","endLine":254,"endColumn":17},{"ruleId":"1682","severity":1,"message":"1683","line":255,"column":42,"nodeType":"1684","messageId":"1685","endLine":255,"endColumn":45},{"ruleId":"1682","severity":1,"message":"1683","line":255,"column":66,"nodeType":"1684","messageId":"1685","endLine":255,"endColumn":69},{"ruleId":"1682","severity":1,"message":"1683","line":256,"column":42,"nodeType":"1684","messageId":"1685","endLine":256,"endColumn":45},{"ruleId":"1682","severity":1,"message":"1683","line":256,"column":56,"nodeType":"1684","messageId":"1685","endLine":256,"endColumn":59},{"ruleId":"1682","severity":1,"message":"1683","line":260,"column":11,"nodeType":"1684","messageId":"1685","endLine":260,"endColumn":14},{"ruleId":"1682","severity":1,"message":"1683","line":262,"column":24,"nodeType":"1684","messageId":"1685","endLine":262,"endColumn":27},{"ruleId":"1682","severity":1,"message":"1683","line":266,"column":11,"nodeType":"1684","messageId":"1685","endLine":266,"endColumn":14},{"ruleId":"1682","severity":1,"message":"1683","line":268,"column":14,"nodeType":"1684","messageId":"1685","endLine":268,"endColumn":17},{"ruleId":"1682","severity":1,"message":"1683","line":269,"column":39,"nodeType":"1684","messageId":"1685","endLine":269,"endColumn":42},{"ruleId":"1682","severity":1,"message":"1683","line":269,"column":63,"nodeType":"1684","messageId":"1685","endLine":269,"endColumn":66},{"ruleId":"1682","severity":1,"message":"1683","line":270,"column":39,"nodeType":"1684","messageId":"1685","endLine":270,"endColumn":42},{"ruleId":"1682","severity":1,"message":"1683","line":270,"column":53,"nodeType":"1684","messageId":"1685","endLine":270,"endColumn":56},{"ruleId":"1682","severity":1,"message":"1683","line":278,"column":63,"nodeType":"1684","messageId":"1685","endLine":278,"endColumn":66},{"ruleId":"1682","severity":1,"message":"1683","line":279,"column":53,"nodeType":"1684","messageId":"1685","endLine":279,"endColumn":56},{"ruleId":"1682","severity":1,"message":"1683","line":280,"column":36,"nodeType":"1684","messageId":"1685","endLine":280,"endColumn":39},{"ruleId":"1682","severity":1,"message":"1683","line":281,"column":26,"nodeType":"1684","messageId":"1685","endLine":281,"endColumn":29},{"ruleId":"1682","severity":1,"message":"1683","line":286,"column":24,"nodeType":"1684","messageId":"1685","endLine":286,"endColumn":27},{"ruleId":"1682","severity":1,"message":"1683","line":288,"column":65,"nodeType":"1684","messageId":"1685","endLine":288,"endColumn":68},{"ruleId":"1682","severity":1,"message":"1683","line":289,"column":48,"nodeType":"1684","messageId":"1685","endLine":289,"endColumn":51},{"ruleId":"1682","severity":1,"message":"1683","line":290,"column":38,"nodeType":"1684","messageId":"1685","endLine":290,"endColumn":41},{"ruleId":"1682","severity":1,"message":"1683","line":295,"column":24,"nodeType":"1684","messageId":"1685","endLine":295,"endColumn":27},{"ruleId":"1682","severity":1,"message":"1683","line":297,"column":66,"nodeType":"1684","messageId":"1685","endLine":297,"endColumn":69},{"ruleId":"1682","severity":1,"message":"1683","line":298,"column":49,"nodeType":"1684","messageId":"1685","endLine":298,"endColumn":52},{"ruleId":"1682","severity":1,"message":"1683","line":299,"column":39,"nodeType":"1684","messageId":"1685","endLine":299,"endColumn":42},{"ruleId":"1682","severity":1,"message":"1683","line":323,"column":16,"nodeType":"1684","messageId":"1685","endLine":323,"endColumn":19},{"ruleId":"1682","severity":1,"message":"1683","line":323,"column":30,"nodeType":"1684","messageId":"1685","endLine":323,"endColumn":33},{"ruleId":"1682","severity":1,"message":"1683","line":323,"column":54,"nodeType":"1684","messageId":"1685","endLine":323,"endColumn":57},{"ruleId":"1682","severity":1,"message":"1683","line":324,"column":16,"nodeType":"1684","messageId":"1685","endLine":324,"endColumn":19},{"ruleId":"1682","severity":1,"message":"1683","line":324,"column":30,"nodeType":"1684","messageId":"1685","endLine":324,"endColumn":33},{"ruleId":"1682","severity":1,"message":"1683","line":324,"column":44,"nodeType":"1684","messageId":"1685","endLine":324,"endColumn":47},{"ruleId":"1682","severity":1,"message":"1683","line":329,"column":14,"nodeType":"1684","messageId":"1685","endLine":329,"endColumn":17},{"ruleId":"1682","severity":1,"message":"1683","line":330,"column":24,"nodeType":"1684","messageId":"1685","endLine":330,"endColumn":27},{"ruleId":"1682","severity":1,"message":"1683","line":332,"column":49,"nodeType":"1684","messageId":"1685","endLine":332,"endColumn":52},{"ruleId":"1682","severity":1,"message":"1683","line":332,"column":63,"nodeType":"1684","messageId":"1685","endLine":332,"endColumn":66},{"ruleId":"1682","severity":1,"message":"1683","line":333,"column":59,"nodeType":"1684","messageId":"1685","endLine":333,"endColumn":62},{"ruleId":"1682","severity":1,"message":"1683","line":334,"column":49,"nodeType":"1684","messageId":"1685","endLine":334,"endColumn":52},{"ruleId":"1682","severity":1,"message":"1683","line":335,"column":45,"nodeType":"1684","messageId":"1685","endLine":335,"endColumn":48},{"ruleId":"1682","severity":1,"message":"1683","line":336,"column":35,"nodeType":"1684","messageId":"1685","endLine":336,"endColumn":38},{"ruleId":"1682","severity":1,"message":"1683","line":341,"column":14,"nodeType":"1684","messageId":"1685","endLine":341,"endColumn":17},{"ruleId":"1682","severity":1,"message":"1683","line":342,"column":24,"nodeType":"1684","messageId":"1685","endLine":342,"endColumn":27},{"ruleId":"1682","severity":1,"message":"1683","line":344,"column":50,"nodeType":"1684","messageId":"1685","endLine":344,"endColumn":53},{"ruleId":"1682","severity":1,"message":"1683","line":344,"column":64,"nodeType":"1684","messageId":"1685","endLine":344,"endColumn":67},{"ruleId":"1682","severity":1,"message":"1683","line":345,"column":60,"nodeType":"1684","messageId":"1685","endLine":345,"endColumn":63},{"ruleId":"1682","severity":1,"message":"1683","line":346,"column":50,"nodeType":"1684","messageId":"1685","endLine":346,"endColumn":53},{"ruleId":"1682","severity":1,"message":"1683","line":347,"column":36,"nodeType":"1684","messageId":"1685","endLine":347,"endColumn":39},{"ruleId":"1682","severity":1,"message":"1683","line":347,"column":60,"nodeType":"1684","messageId":"1685","endLine":347,"endColumn":63},{"ruleId":"1682","severity":1,"message":"1683","line":348,"column":36,"nodeType":"1684","messageId":"1685","endLine":348,"endColumn":39},{"ruleId":"1682","severity":1,"message":"1683","line":348,"column":50,"nodeType":"1684","messageId":"1685","endLine":348,"endColumn":53},{"ruleId":"1682","severity":1,"message":"1683","line":349,"column":46,"nodeType":"1684","messageId":"1685","endLine":349,"endColumn":49},{"ruleId":"1682","severity":1,"message":"1683","line":350,"column":36,"nodeType":"1684","messageId":"1685","endLine":350,"endColumn":39},{"ruleId":"1682","severity":1,"message":"1683","line":355,"column":34,"nodeType":"1684","messageId":"1685","endLine":355,"endColumn":37},{"ruleId":"1682","severity":1,"message":"1683","line":368,"column":24,"nodeType":"1684","messageId":"1685","endLine":368,"endColumn":27},{"ruleId":"1682","severity":1,"message":"1683","line":386,"column":24,"nodeType":"1684","messageId":"1685","endLine":386,"endColumn":27},{"ruleId":"1682","severity":1,"message":"1683","line":388,"column":60,"nodeType":"1684","messageId":"1685","endLine":388,"endColumn":63},{"ruleId":"1682","severity":1,"message":"1683","line":390,"column":25,"nodeType":"1684","messageId":"1685","endLine":390,"endColumn":28},{"ruleId":"1682","severity":1,"message":"1683","line":391,"column":17,"nodeType":"1684","messageId":"1685","endLine":391,"endColumn":20},{"ruleId":"1682","severity":1,"message":"1683","line":393,"column":49,"nodeType":"1684","messageId":"1685","endLine":393,"endColumn":52},{"ruleId":"1682","severity":1,"message":"1683","line":394,"column":39,"nodeType":"1684","messageId":"1685","endLine":394,"endColumn":42},{"ruleId":"1682","severity":1,"message":"1683","line":407,"column":19,"nodeType":"1684","messageId":"1685","endLine":407,"endColumn":22},{"ruleId":"1682","severity":1,"message":"1683","line":420,"column":47,"nodeType":"1684","messageId":"1685","endLine":420,"endColumn":50},{"ruleId":"1682","severity":1,"message":"1683","line":430,"column":56,"nodeType":"1684","messageId":"1685","endLine":430,"endColumn":59},{"ruleId":"1682","severity":1,"message":"1683","line":431,"column":46,"nodeType":"1684","messageId":"1685","endLine":431,"endColumn":49},{"ruleId":"1682","severity":1,"message":"1683","line":8,"column":23,"nodeType":"1684","messageId":"1685","endLine":8,"endColumn":26},{"ruleId":"1682","severity":1,"message":"1683","line":15,"column":23,"nodeType":"1684","messageId":"1685","endLine":15,"endColumn":26},{"ruleId":"1682","severity":1,"message":"1683","line":16,"column":21,"nodeType":"1684","messageId":"1685","endLine":16,"endColumn":24},{"ruleId":"1677","severity":1,"message":"1678","line":20,"column":48,"nodeType":"1679","messageId":"1680","endLine":20,"endColumn":73},{"ruleId":"1682","severity":1,"message":"1683","line":38,"column":25,"nodeType":"1684","messageId":"1685","endLine":38,"endColumn":28},{"ruleId":"1682","severity":1,"message":"1683","line":46,"column":18,"nodeType":"1684","messageId":"1685","endLine":46,"endColumn":21},{"ruleId":"1682","severity":1,"message":"1683","line":1,"column":37,"nodeType":"1684","messageId":"1685","endLine":1,"endColumn":40},{"ruleId":"1682","severity":1,"message":"1683","line":5,"column":34,"nodeType":"1684","messageId":"1685","endLine":5,"endColumn":37},{"ruleId":"1677","severity":1,"message":"1678","line":1,"column":24,"nodeType":"1679","messageId":"1680","endLine":1,"endColumn":61},{"ruleId":"1677","severity":1,"message":"1678","line":8,"column":22,"nodeType":"1679","messageId":"1680","endLine":8,"endColumn":42},{"ruleId":"1677","severity":1,"message":"1678","line":27,"column":10,"nodeType":"1679","messageId":"1680","endLine":31,"endColumn":7},{"ruleId":"1663","severity":1,"message":"1738","line":23,"column":3,"nodeType":"1665","endLine":23,"endColumn":8},{"ruleId":"1663","severity":1,"message":"1739","line":24,"column":3,"nodeType":"1665","endLine":24,"endColumn":9},{"ruleId":"1682","severity":1,"message":"1683","line":32,"column":8,"nodeType":"1684","messageId":"1685","endLine":32,"endColumn":11},{"ruleId":"1663","severity":1,"message":"1740","line":11,"column":24,"nodeType":"1665","endLine":11,"endColumn":33},{"ruleId":"1663","severity":1,"message":"1741","line":4,"column":3,"nodeType":"1665","endLine":4,"endColumn":21},{"ruleId":"1682","severity":1,"message":"1683","line":9,"column":41,"nodeType":"1684","messageId":"1685","endLine":9,"endColumn":44},{"ruleId":"1682","severity":1,"message":"1683","line":13,"column":41,"nodeType":"1684","messageId":"1685","endLine":13,"endColumn":44},{"ruleId":"1682","severity":1,"message":"1683","line":19,"column":44,"nodeType":"1684","messageId":"1685","endLine":19,"endColumn":47},{"ruleId":"1682","severity":1,"message":"1683","line":23,"column":43,"nodeType":"1684","messageId":"1685","endLine":23,"endColumn":46},{"ruleId":"1682","severity":1,"message":"1683","line":7,"column":32,"nodeType":"1684","messageId":"1685","endLine":7,"endColumn":35},{"ruleId":"1682","severity":1,"message":"1683","line":9,"column":42,"nodeType":"1684","messageId":"1685","endLine":9,"endColumn":45},{"ruleId":"1682","severity":1,"message":"1683","line":17,"column":58,"nodeType":"1684","messageId":"1685","endLine":17,"endColumn":61},{"ruleId":"1682","severity":1,"message":"1683","line":50,"column":8,"nodeType":"1684","messageId":"1685","endLine":50,"endColumn":11},{"ruleId":"1682","severity":1,"message":"1683","line":73,"column":36,"nodeType":"1684","messageId":"1685","endLine":73,"endColumn":39},{"ruleId":"1682","severity":1,"message":"1683","line":76,"column":35,"nodeType":"1684","messageId":"1685","endLine":76,"endColumn":38},{"ruleId":"1663","severity":1,"message":"1740","line":14,"column":24,"nodeType":"1665","endLine":14,"endColumn":33},{"ruleId":"1682","severity":1,"message":"1683","line":23,"column":8,"nodeType":"1684","messageId":"1685","endLine":23,"endColumn":11},{"ruleId":"1677","severity":1,"message":"1678","line":56,"column":32,"nodeType":"1679","messageId":"1680","endLine":56,"endColumn":65},{"ruleId":"1677","severity":1,"message":"1678","line":60,"column":40,"nodeType":"1679","messageId":"1680","endLine":60,"endColumn":73},{"ruleId":"1677","severity":1,"message":"1678","line":3,"column":29,"nodeType":"1679","messageId":"1680","endLine":3,"endColumn":34},{"ruleId":"1677","severity":1,"message":"1678","line":14,"column":23,"nodeType":"1679","messageId":"1680","endLine":14,"endColumn":28},{"ruleId":"1663","severity":1,"message":"1742","line":2,"column":3,"nodeType":"1665","endLine":2,"endColumn":68},{"ruleId":"1663","severity":1,"message":"1743","line":11,"column":3,"nodeType":"1665","endLine":11,"endColumn":33},{"ruleId":"1677","severity":1,"message":"1678","line":6,"column":8,"nodeType":"1722","messageId":"1680","endLine":6,"endColumn":63},{"ruleId":"1682","severity":1,"message":"1683","line":7,"column":66,"nodeType":"1684","messageId":"1685","endLine":7,"endColumn":69},{"ruleId":"1677","severity":1,"message":"1678","line":9,"column":8,"nodeType":"1722","messageId":"1680","endLine":9,"endColumn":58},{"ruleId":"1682","severity":1,"message":"1683","line":20,"column":25,"nodeType":"1684","messageId":"1685","endLine":20,"endColumn":28},{"ruleId":"1682","severity":1,"message":"1683","line":10,"column":57,"nodeType":"1684","messageId":"1685","endLine":10,"endColumn":60},{"ruleId":"1682","severity":1,"message":"1683","line":135,"column":13,"nodeType":"1684","messageId":"1685","endLine":135,"endColumn":16},{"ruleId":"1744","severity":2,"message":"1745","line":285,"column":21,"nodeType":"1746","messageId":"1747","endLine":285,"endColumn":55,"fix":"1748"},{"ruleId":"1744","severity":2,"message":"1745","line":305,"column":21,"nodeType":"1746","messageId":"1747","endLine":305,"endColumn":55,"fix":"1749"},{"ruleId":"1663","severity":1,"message":"1750","line":1,"column":10,"nodeType":"1665","endLine":1,"endColumn":35},{"ruleId":"1677","severity":1,"message":"1678","line":9,"column":50,"nodeType":"1679","messageId":"1680","endLine":9,"endColumn":61},{"ruleId":"1677","severity":1,"message":"1678","line":6,"column":50,"nodeType":"1679","messageId":"1680","endLine":6,"endColumn":61},{"ruleId":"1682","severity":1,"message":"1683","line":68,"column":27,"nodeType":"1684","messageId":"1685","endLine":68,"endColumn":30},{"ruleId":"1677","severity":1,"message":"1678","line":16,"column":55,"nodeType":"1679","messageId":"1680","endLine":16,"endColumn":66},{"ruleId":"1751","severity":1,"message":"1752","line":36,"column":7,"nodeType":"1753","endLine":36,"endColumn":78},{"ruleId":"1751","severity":1,"message":"1752","line":41,"column":5,"nodeType":"1753","endLine":41,"endColumn":78},{"ruleId":"1677","severity":1,"message":"1678","line":54,"column":44,"nodeType":"1679","messageId":"1680","endLine":54,"endColumn":55},{"ruleId":"1677","severity":1,"message":"1678","line":107,"column":91,"nodeType":"1679","messageId":"1680","endLine":107,"endColumn":102},{"ruleId":"1663","severity":1,"message":"1754","line":108,"column":9,"nodeType":"1665","endLine":108,"endColumn":20},{"ruleId":"1663","severity":1,"message":"1755","line":6,"column":10,"nodeType":"1665","endLine":6,"endColumn":38},{"ruleId":"1663","severity":1,"message":"1750","line":8,"column":10,"nodeType":"1665","endLine":8,"endColumn":35},{"ruleId":"1677","severity":1,"message":"1678","line":72,"column":36,"nodeType":"1679","messageId":"1680","endLine":74,"endColumn":5},{"ruleId":"1677","severity":1,"message":"1678","line":5,"column":41,"nodeType":"1679","messageId":"1680","endLine":5,"endColumn":46},{"ruleId":"1677","severity":1,"message":"1678","line":92,"column":34,"nodeType":"1679","messageId":"1680","endLine":92,"endColumn":45},{"ruleId":"1744","severity":2,"message":"1745","line":123,"column":7,"nodeType":"1746","messageId":"1747","endLine":123,"endColumn":61,"fix":"1756"},{"ruleId":"1677","severity":1,"message":"1678","line":286,"column":64,"nodeType":"1679","messageId":"1680","endLine":286,"endColumn":75},{"ruleId":"1677","severity":1,"message":"1678","line":111,"column":52,"nodeType":"1679","messageId":"1680","endLine":111,"endColumn":63},{"ruleId":"1677","severity":1,"message":"1678","line":11,"column":43,"nodeType":"1679","messageId":"1680","endLine":11,"endColumn":54},{"ruleId":"1677","severity":1,"message":"1678","line":4,"column":28,"nodeType":"1679","messageId":"1680","endLine":4,"endColumn":39},{"ruleId":"1677","severity":1,"message":"1678","line":7,"column":40,"nodeType":"1679","messageId":"1680","endLine":7,"endColumn":51},{"ruleId":"1682","severity":1,"message":"1683","line":19,"column":25,"nodeType":"1684","messageId":"1685","endLine":19,"endColumn":28},{"ruleId":"1677","severity":1,"message":"1678","line":4,"column":8,"nodeType":"1722","messageId":"1680","endLine":4,"endColumn":37},{"ruleId":"1677","severity":1,"message":"1678","line":6,"column":43,"nodeType":"1679","messageId":"1680","endLine":6,"endColumn":54},{"ruleId":"1757","severity":2,"message":"1758","line":15,"column":16,"nodeType":"1759","messageId":"1760","endLine":15,"endColumn":34},{"ruleId":"1677","severity":1,"message":"1678","line":8,"column":39,"nodeType":"1679","messageId":"1680","endLine":8,"endColumn":50},{"ruleId":"1757","severity":2,"message":"1758","line":15,"column":14,"nodeType":"1759","messageId":"1760","endLine":15,"endColumn":39},{"ruleId":"1757","severity":2,"message":"1758","line":36,"column":14,"nodeType":"1759","messageId":"1760","endLine":36,"endColumn":39},{"ruleId":null,"fatal":true,"severity":2,"message":"1761"},{"ruleId":"1663","severity":1,"message":"1762","line":3,"column":3,"nodeType":"1665","endLine":3,"endColumn":30},{"ruleId":"1663","severity":1,"message":"1763","line":4,"column":3,"nodeType":"1665","endLine":4,"endColumn":20},{"ruleId":"1663","severity":1,"message":"1764","line":7,"column":3,"nodeType":"1665","endLine":7,"endColumn":27},{"ruleId":"1663","severity":1,"message":"1765","line":12,"column":3,"nodeType":"1665","endLine":12,"endColumn":27},{"ruleId":"1677","severity":1,"message":"1678","line":17,"column":27,"nodeType":"1679","messageId":"1680","endLine":17,"endColumn":38},{"ruleId":"1677","severity":1,"message":"1678","line":4,"column":40,"nodeType":"1679","messageId":"1680","endLine":4,"endColumn":51},{"ruleId":"1677","severity":1,"message":"1678","line":40,"column":39,"nodeType":"1679","messageId":"1680","endLine":40,"endColumn":50},{"ruleId":"1677","severity":1,"message":"1678","line":79,"column":24,"nodeType":"1679","messageId":"1680","endLine":79,"endColumn":35},{"ruleId":"1677","severity":1,"message":"1678","line":3,"column":24,"nodeType":"1679","messageId":"1680","endLine":3,"endColumn":35},{"ruleId":"1677","severity":1,"message":"1678","line":21,"column":21,"nodeType":"1679","messageId":"1680","endLine":21,"endColumn":42},{"ruleId":"1677","severity":1,"message":"1678","line":29,"column":1,"nodeType":"1722","messageId":"1680","endLine":29,"endColumn":36},{"ruleId":"1677","severity":1,"message":"1678","line":31,"column":29,"nodeType":"1679","messageId":"1680","endLine":34,"endColumn":5},{"ruleId":"1663","severity":1,"message":"1766","line":35,"column":11,"nodeType":"1665","endLine":35,"endColumn":20},{"ruleId":"1682","severity":1,"message":"1683","line":50,"column":64,"nodeType":"1684","messageId":"1685","endLine":50,"endColumn":67},{"ruleId":"1677","severity":1,"message":"1678","line":69,"column":44,"nodeType":"1679","messageId":"1680","endLine":72,"endColumn":5},{"ruleId":"1682","severity":1,"message":"1683","line":93,"column":68,"nodeType":"1684","messageId":"1685","endLine":93,"endColumn":71},{"ruleId":"1677","severity":1,"message":"1678","line":113,"column":51,"nodeType":"1679","messageId":"1680","endLine":113,"endColumn":75},{"ruleId":"1757","severity":2,"message":"1758","line":138,"column":24,"nodeType":"1759","messageId":"1760","endLine":138,"endColumn":42},{"ruleId":"1767","severity":2,"message":"1768","line":141,"column":21,"nodeType":"1665","messageId":"1769","endLine":141,"endColumn":43,"fix":"1770"},{"ruleId":"1687","severity":1,"message":"1688","line":155,"column":27,"nodeType":"1689","messageId":"1690","endLine":155,"endColumn":42},{"ruleId":"1757","severity":2,"message":"1758","line":208,"column":24,"nodeType":"1759","messageId":"1760","endLine":208,"endColumn":42},{"ruleId":"1767","severity":2,"message":"1768","line":211,"column":21,"nodeType":"1665","messageId":"1769","endLine":211,"endColumn":43,"fix":"1771"},{"ruleId":"1687","severity":1,"message":"1688","line":225,"column":27,"nodeType":"1689","messageId":"1690","endLine":225,"endColumn":42},{"ruleId":"1682","severity":1,"message":"1683","line":299,"column":97,"nodeType":"1684","messageId":"1685","endLine":299,"endColumn":100},{"ruleId":"1757","severity":2,"message":"1758","line":303,"column":24,"nodeType":"1759","messageId":"1760","endLine":303,"endColumn":42},{"ruleId":"1767","severity":2,"message":"1768","line":306,"column":21,"nodeType":"1665","messageId":"1769","endLine":306,"endColumn":43,"fix":"1772"},{"ruleId":"1687","severity":1,"message":"1688","line":320,"column":27,"nodeType":"1689","messageId":"1690","endLine":320,"endColumn":42},{"ruleId":"1682","severity":1,"message":"1683","line":347,"column":119,"nodeType":"1684","messageId":"1685","endLine":347,"endColumn":122},{"ruleId":"1757","severity":2,"message":"1758","line":351,"column":24,"nodeType":"1759","messageId":"1760","endLine":351,"endColumn":42},{"ruleId":"1767","severity":2,"message":"1768","line":354,"column":21,"nodeType":"1665","messageId":"1769","endLine":354,"endColumn":43,"fix":"1773"},{"ruleId":"1687","severity":1,"message":"1688","line":368,"column":27,"nodeType":"1689","messageId":"1690","endLine":368,"endColumn":42},{"ruleId":"1682","severity":1,"message":"1683","line":395,"column":138,"nodeType":"1684","messageId":"1685","endLine":395,"endColumn":141},{"ruleId":"1757","severity":2,"message":"1758","line":399,"column":24,"nodeType":"1759","messageId":"1760","endLine":399,"endColumn":42},{"ruleId":"1767","severity":2,"message":"1768","line":402,"column":21,"nodeType":"1665","messageId":"1769","endLine":402,"endColumn":43,"fix":"1774"},{"ruleId":"1687","severity":1,"message":"1688","line":416,"column":27,"nodeType":"1689","messageId":"1690","endLine":416,"endColumn":42},{"ruleId":"1682","severity":1,"message":"1683","line":469,"column":138,"nodeType":"1684","messageId":"1685","endLine":469,"endColumn":141},{"ruleId":"1757","severity":2,"message":"1758","line":473,"column":24,"nodeType":"1759","messageId":"1760","endLine":473,"endColumn":42},{"ruleId":"1767","severity":2,"message":"1768","line":476,"column":21,"nodeType":"1665","messageId":"1769","endLine":476,"endColumn":43,"fix":"1775"},{"ruleId":"1687","severity":1,"message":"1688","line":490,"column":27,"nodeType":"1689","messageId":"1690","endLine":490,"endColumn":42},{"ruleId":"1677","severity":1,"message":"1678","line":539,"column":5,"nodeType":"1722","messageId":"1680","endLine":539,"endColumn":99},{"ruleId":"1744","severity":2,"message":"1745","line":549,"column":16,"nodeType":"1689","messageId":"1747","endLine":549,"endColumn":22,"fix":"1776"},{"ruleId":"1687","severity":1,"message":"1688","line":549,"column":16,"nodeType":"1689","messageId":"1690","endLine":549,"endColumn":22},{"ruleId":"1744","severity":2,"message":"1745","line":550,"column":22,"nodeType":"1689","messageId":"1747","endLine":550,"endColumn":28,"fix":"1777"},{"ruleId":"1687","severity":1,"message":"1688","line":550,"column":22,"nodeType":"1689","messageId":"1690","endLine":550,"endColumn":28},{"ruleId":"1744","severity":2,"message":"1745","line":553,"column":16,"nodeType":"1689","messageId":"1747","endLine":553,"endColumn":22,"fix":"1778"},{"ruleId":"1687","severity":1,"message":"1688","line":553,"column":16,"nodeType":"1689","messageId":"1690","endLine":553,"endColumn":22},{"ruleId":"1687","severity":1,"message":"1688","line":554,"column":22,"nodeType":"1689","messageId":"1690","endLine":554,"endColumn":28},{"ruleId":"1744","severity":2,"message":"1745","line":554,"column":22,"nodeType":"1689","messageId":"1747","endLine":554,"endColumn":28,"fix":"1779"},{"ruleId":"1744","severity":2,"message":"1745","line":558,"column":22,"nodeType":"1689","messageId":"1747","endLine":558,"endColumn":28,"fix":"1780"},{"ruleId":"1687","severity":1,"message":"1688","line":558,"column":22,"nodeType":"1689","messageId":"1690","endLine":558,"endColumn":28},{"ruleId":"1687","severity":1,"message":"1688","line":559,"column":16,"nodeType":"1689","messageId":"1690","endLine":559,"endColumn":22},{"ruleId":"1744","severity":2,"message":"1745","line":559,"column":16,"nodeType":"1689","messageId":"1747","endLine":559,"endColumn":22,"fix":"1781"},{"ruleId":"1687","severity":1,"message":"1688","line":561,"column":22,"nodeType":"1689","messageId":"1690","endLine":561,"endColumn":28},{"ruleId":"1744","severity":2,"message":"1745","line":561,"column":22,"nodeType":"1689","messageId":"1747","endLine":561,"endColumn":28,"fix":"1782"},{"ruleId":"1744","severity":2,"message":"1745","line":568,"column":22,"nodeType":"1689","messageId":"1747","endLine":568,"endColumn":28,"fix":"1783"},{"ruleId":"1687","severity":1,"message":"1688","line":568,"column":22,"nodeType":"1689","messageId":"1690","endLine":568,"endColumn":28},{"ruleId":"1677","severity":1,"message":"1678","line":575,"column":20,"nodeType":"1679","messageId":"1680","endLine":575,"endColumn":74},{"ruleId":"1744","severity":2,"message":"1745","line":581,"column":22,"nodeType":"1689","messageId":"1747","endLine":581,"endColumn":28,"fix":"1784"},{"ruleId":"1687","severity":1,"message":"1688","line":581,"column":22,"nodeType":"1689","messageId":"1690","endLine":581,"endColumn":28},{"ruleId":"1677","severity":1,"message":"1678","line":587,"column":23,"nodeType":"1679","messageId":"1680","endLine":587,"endColumn":50},{"ruleId":"1744","severity":2,"message":"1745","line":593,"column":22,"nodeType":"1689","messageId":"1747","endLine":593,"endColumn":28,"fix":"1785"},{"ruleId":"1687","severity":1,"message":"1688","line":593,"column":22,"nodeType":"1689","messageId":"1690","endLine":593,"endColumn":28},{"ruleId":"1744","severity":2,"message":"1745","line":598,"column":22,"nodeType":"1689","messageId":"1747","endLine":598,"endColumn":28,"fix":"1786"},{"ruleId":"1687","severity":1,"message":"1688","line":598,"column":22,"nodeType":"1689","messageId":"1690","endLine":598,"endColumn":28},{"ruleId":"1687","severity":1,"message":"1688","line":600,"column":16,"nodeType":"1689","messageId":"1690","endLine":600,"endColumn":22},{"ruleId":"1744","severity":2,"message":"1745","line":600,"column":16,"nodeType":"1689","messageId":"1747","endLine":600,"endColumn":22,"fix":"1787"},{"ruleId":"1687","severity":1,"message":"1688","line":619,"column":24,"nodeType":"1689","messageId":"1690","endLine":619,"endColumn":45},{"ruleId":"1687","severity":1,"message":"1688","line":620,"column":30,"nodeType":"1689","messageId":"1690","endLine":620,"endColumn":51},{"ruleId":"1687","severity":1,"message":"1688","line":623,"column":24,"nodeType":"1689","messageId":"1690","endLine":623,"endColumn":45},{"ruleId":"1687","severity":1,"message":"1688","line":624,"column":30,"nodeType":"1689","messageId":"1690","endLine":624,"endColumn":51},{"ruleId":"1687","severity":1,"message":"1688","line":628,"column":30,"nodeType":"1689","messageId":"1690","endLine":628,"endColumn":51},{"ruleId":"1687","severity":1,"message":"1688","line":629,"column":24,"nodeType":"1689","messageId":"1690","endLine":629,"endColumn":45},{"ruleId":"1687","severity":1,"message":"1688","line":631,"column":30,"nodeType":"1689","messageId":"1690","endLine":631,"endColumn":51},{"ruleId":"1687","severity":1,"message":"1688","line":638,"column":30,"nodeType":"1689","messageId":"1690","endLine":638,"endColumn":51},{"ruleId":"1687","severity":1,"message":"1688","line":643,"column":30,"nodeType":"1689","messageId":"1690","endLine":643,"endColumn":51},{"ruleId":"1687","severity":1,"message":"1688","line":646,"column":30,"nodeType":"1689","messageId":"1690","endLine":646,"endColumn":51},{"ruleId":"1687","severity":1,"message":"1688","line":647,"column":24,"nodeType":"1689","messageId":"1690","endLine":647,"endColumn":45},{"ruleId":"1677","severity":1,"message":"1678","line":656,"column":31,"nodeType":"1679","messageId":"1680","endLine":656,"endColumn":42},{"ruleId":"1687","severity":1,"message":"1688","line":661,"column":24,"nodeType":"1689","messageId":"1690","endLine":661,"endColumn":28},{"ruleId":"1687","severity":1,"message":"1688","line":668,"column":33,"nodeType":"1689","messageId":"1690","endLine":668,"endColumn":39},{"ruleId":"1677","severity":1,"message":"1678","line":692,"column":31,"nodeType":"1679","messageId":"1680","endLine":692,"endColumn":42},{"ruleId":"1687","severity":1,"message":"1688","line":693,"column":35,"nodeType":"1689","messageId":"1690","endLine":693,"endColumn":42},{"ruleId":"1687","severity":1,"message":"1688","line":695,"column":33,"nodeType":"1689","messageId":"1690","endLine":695,"endColumn":39},{"ruleId":"1677","severity":1,"message":"1678","line":3,"column":24,"nodeType":"1679","messageId":"1680","endLine":3,"endColumn":29},{"ruleId":"1663","severity":1,"message":"1788","line":9,"column":3,"nodeType":"1665","endLine":9,"endColumn":29},{"ruleId":"1677","severity":1,"message":"1678","line":91,"column":3,"nodeType":"1686","messageId":"1680","endLine":91,"endColumn":17},{"ruleId":"1677","severity":1,"message":"1678","line":101,"column":3,"nodeType":"1686","messageId":"1680","endLine":101,"endColumn":16},{"ruleId":"1677","severity":1,"message":"1678","line":112,"column":19,"nodeType":"1679","messageId":"1680","endLine":112,"endColumn":47},{"ruleId":"1682","severity":1,"message":"1683","line":134,"column":14,"nodeType":"1684","messageId":"1685","endLine":134,"endColumn":17},{"ruleId":"1677","severity":1,"message":"1678","line":154,"column":3,"nodeType":"1686","messageId":"1680","endLine":154,"endColumn":56},{"ruleId":"1687","severity":1,"message":"1688","line":197,"column":31,"nodeType":"1689","messageId":"1690","endLine":197,"endColumn":43},{"ruleId":"1687","severity":1,"message":"1688","line":222,"column":35,"nodeType":"1689","messageId":"1690","endLine":222,"endColumn":56},{"ruleId":"1687","severity":1,"message":"1688","line":235,"column":34,"nodeType":"1689","messageId":"1690","endLine":235,"endColumn":46},{"ruleId":"1677","severity":1,"message":"1678","line":255,"column":3,"nodeType":"1686","messageId":"1680","endLine":255,"endColumn":44},{"ruleId":"1677","severity":1,"message":"1678","line":268,"column":3,"nodeType":"1686","messageId":"1680","endLine":268,"endColumn":39},{"ruleId":"1677","severity":1,"message":"1678","line":326,"column":3,"nodeType":"1686","messageId":"1680","endLine":326,"endColumn":27},{"ruleId":"1677","severity":1,"message":"1678","line":339,"column":3,"nodeType":"1686","messageId":"1680","endLine":339,"endColumn":40},{"ruleId":"1682","severity":1,"message":"1683","line":379,"column":39,"nodeType":"1684","messageId":"1685","endLine":379,"endColumn":42},{"ruleId":"1677","severity":1,"message":"1678","line":433,"column":3,"nodeType":"1686","messageId":"1680","endLine":433,"endColumn":74},{"ruleId":"1687","severity":1,"message":"1688","line":537,"column":10,"nodeType":"1689","messageId":"1690","endLine":537,"endColumn":38},{"ruleId":"1682","severity":1,"message":"1683","line":3,"column":42,"nodeType":"1684","messageId":"1685","endLine":3,"endColumn":45},{"ruleId":"1682","severity":1,"message":"1683","line":34,"column":71,"nodeType":"1684","messageId":"1685","endLine":34,"endColumn":74},{"ruleId":"1677","severity":1,"message":"1678","line":4,"column":36,"nodeType":"1679","messageId":"1680","endLine":4,"endColumn":41},"@typescript-eslint/no-unused-vars","'logo' is defined but never used.","Identifier","'runTestFirebaseConnectionDatabase' is defined but never used.","'runTestFirebaseCredentialsStorage' is defined but never used.","'runTestCAIdentityWithAuthorityProviderGenerator' is defined but never used.","'runTestCAConnectionFirebase' is defined but never used.","'runTestCAConnectionFirebaseCryptoCredentialsGenerateByFirebaseAuthProvider' is defined but never used.","'runTestErrorExtended' is defined but never used.","'runTestSwarmConnection' is defined but never used.","'runTestSwarmConnectionIPFS' is defined but never used.","'runTestSwarmStoreOrbitDBConnection' is defined but never used.","'runTestValidateMessagingTimestampsTest' is defined but never used.","'runTestHttpRequest' is defined but never used.","@typescript-eslint/explicit-function-return-type","Missing return type on function.","ArrowFunctionExpression","missingReturnType","'any' is defined but never used.","@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny","FunctionExpression","@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull","'result' is assigned a value but never used.","'ownValueOf' is defined but never used.","'thirdParam' is assigned a value but never used.","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","@typescript-eslint/no-empty-function","Unexpected empty constructor.","unexpected","'TCACryptoKeyPairsExported' is defined but never used.","'validateUserIdentityDescriptionVersion' is defined but never used.","'TCentralAuthorityUserIdentity' is defined but never used.","'CONST_VALIDATION_SCHEMES_URL' is defined but never used.","'TCentralAuthorityUserCryptoCredentials' is defined but never used.","'signInResult' is assigned a value but never used.","'TCentralAuthorityUserCryptoCredentialsExported' is defined but never used.","'CA_IDENTITY_CREDENTIALS_STORAGE_FULL_NAME' is defined but never used.","'importCryptoCredentialsFromExportedFromat' is defined but never used.","'TCACryptoPubilicKeys' is defined but never used.","'dataValidatorUtilUUIDV4' is defined but never used.","'CA_CRYPTO_KEY_PAIRS_STRINGIFIED_MIN_LENGTH' is defined but never used.","'status' is assigned a value but never used.","'TSecretStoreConfiguration' is defined but never used.","'encodingDown' is defined but never used.","'ownKeyOf' is defined but never used.","'TPASSWORD_ENCRYPTION_KEY_IMPORT_NATIVE_SUPPORTED_TYPES' is defined but never used.","'Multiaddr' is defined but never used.","'SWARM_CONNECTION_SUBCLASS_IPFS_CONFIG_DELEGATE_BOOTSTRAP_MULTIADDRS' is defined but never used.","'CentralAuthorityIdentity' is defined but never used.","Unexpected empty async method 'load'.","'IdentityProvider' is defined but never used.","FunctionDeclaration","no-useless-rename","Destructuring assignment databases unnecessarily renamed.","Property",{"range":"1789","text":"1790"},"'encryptNative' is defined but never used.","'decryptNative' is defined but never used.","'exportKeyPairAsString' is defined but never used.","'importKeyPairFromString' is defined but never used.","'encryptToString' is defined but never used.","'decryptFromString' is defined but never used.","'encryptToTypedArray' is defined but never used.","'calculateHash' is defined but never used.","'arrayBufferToBase64' is defined but never used.","'testEncryption' is assigned a value but never used.","'Mocha' is defined but never used.","'isJWK' is defined but never used.","'getJWK' is defined but never used.","'exportKey' is defined but never used.","'typedArrayToString' is defined but never used.","'PASSWORD_ENCRYPTION_UTILS_ENCRYPTION_INITIALIZATION_VECTOR_LENGTH' is defined but never used.","'TCRYPTO_UTIL_ENCRYPT_KEY_TYPES' is defined but never used.","@typescript-eslint/no-unnecessary-type-assertion","This assertion is unnecessary since it does not change the type of the expression.","TSAsExpression","unnecessaryAssertion",{"range":"1791","text":"1792"},{"range":"1793","text":"1792"},"'generateCryptoCredentials' is defined but never used.","no-self-compare","Comparing to itself is potentially pointless.","BinaryExpression","'credentials' is assigned a value but never used.","'ICentralAuthorityUserProfile' is defined but never used.",{"range":"1794","text":"1792"},"@typescript-eslint/unbound-method","Avoid referencing unbound methods which may cause unintentional scoping of `this`.","MemberExpression","unbound","Parsing error: \"parserOptions.project\" has been set for @typescript-eslint/parser.\nThe file does not match your project config: src/test/nodejs-helpers.test/nodejs-helpers.test.firebase/nodejs-helpers.test.firebase.js.\nThe file must be included in at least one of the projects provided.","'importPasswordKeyFromString' is defined but never used.","'exportPasswordKey' is defined but never used.","'encryptDataToArrayBuffer' is defined but never used.","'decryptDataWithKeyNative' is defined but never used.","'testValue' is assigned a value but never used.","prefer-const","'readyEmitted' is never reassigned. Use 'const' instead.","useConst",{"range":"1795","text":"1796"},{"range":"1797","text":"1796"},{"range":"1798","text":"1796"},{"range":"1799","text":"1796"},{"range":"1800","text":"1796"},{"range":"1801","text":"1796"},{"range":"1802","text":"1792"},{"range":"1803","text":"1792"},{"range":"1804","text":"1792"},{"range":"1805","text":"1792"},{"range":"1806","text":"1792"},{"range":"1807","text":"1792"},{"range":"1808","text":"1792"},{"range":"1809","text":"1792"},{"range":"1810","text":"1792"},{"range":"1811","text":"1792"},{"range":"1812","text":"1792"},{"range":"1813","text":"1792"},"'TPseudoNTPClassResponseRaw' is defined but never used.",[27905,27925],"databases",[9411,9435],"",[10219,10243],[5613,5641],[7072,7075],"const",[10363,10366],[15013,15016],[17212,17215],[19488,19491],[23003,23006],[26227,26228],[26359,26360],[26466,26467],[26598,26599],[26714,26715],[26772,26773],[26981,26982],[27289,27290],[27701,27702],[28010,28011],[28178,28179],[28286,28287]]