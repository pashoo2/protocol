[{"/home/paul/projects/protocol/docs/assets/js/main.js":"1","/home/paul/projects/protocol/docs/assets/js/search.js":"2","/home/paul/projects/protocol/module-build/index.js":"3","/home/paul/projects/protocol/module-build/module-build.js":"4","/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-class.ts":"5","/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-class.types.ts":"6","/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-connections/channel-authority-connection-with-server-api/channel-authority-connection-with-server-api.ts":"7","/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-connections/channel-authority-connection-with-server-api/channel-authority-connection-with-server-api.types.ts":"8","/home/paul/projects/protocol/src/backog-classes/channel-authority-class/index.ts":"9","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.const.ts":"10","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.ts":"11","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.types.ts":"12","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.utils.ts":"13","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/index.ts":"14","/home/paul/projects/protocol/src/classes/basic-classes/error-extended-class-base/error-extended-class-base.ts":"15","/home/paul/projects/protocol/src/classes/basic-classes/error-extended-scoped-class-base/error-extended-scoped-class-base.ts":"16","/home/paul/projects/protocol/src/classes/basic-classes/error-extended-scoped-class-base/index.ts":"17","/home/paul/projects/protocol/src/classes/basic-classes/event-emitter-class-base/event-emitter-class-base.ts":"18","/home/paul/projects/protocol/src/classes/basic-classes/event-emitter-class-base/index.ts":"19","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-base-body-processor.ts":"20","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-base-response-error.ts":"21","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-response-processor.ts":"22","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-utils.ts":"23","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.const.ts":"24","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.ts":"25","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.types.ts":"26","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.utils.ts":"27","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/index.ts":"28","/home/paul/projects/protocol/src/classes/basic-classes/mime-types-class-base/index.ts":"29","/home/paul/projects/protocol/src/classes/basic-classes/mime-types-class-base/mime-types-class-base.const.ts":"30","/home/paul/projects/protocol/src/classes/basic-classes/mime-types-class-base/mime-types-class-base.ts":"31","/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/index.ts":"32","/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.const.ts":"33","/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.ts":"34","/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.types.ts":"35","/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/index.ts":"36","/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/queued-encryption-class-base.ts":"37","/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/queued-encryption-class-base.types.ts":"38","/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/index.ts":"39","/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/status-class-base.const.ts":"40","/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/status-class-base.ts":"41","/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/status-class-base.types.ts":"42","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const-auth-credentials.ts":"43","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const-crypto-keys-usages.ts":"44","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const.ts":"45","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/index.ts":"46","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-common.ts":"47","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-credentials.ts":"48","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-keys.ts":"49","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types.ts":"50","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/index.ts":"51","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v1/central-authority-class-user-identity-formatters-formatter-v1.ts":"52","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v1/index.ts":"53","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v2/central-authority-class-user-identity-formatters-formatter-v2.const.ts":"54","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v2/central-authority-class-user-identity-formatters-formatter-v2.ts":"55","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v2/index.ts":"56","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.const.ts":"57","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.ts":"58","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.types.ts":"59","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.utils.ts":"60","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/index.ts":"61","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/central-authority-class-user-identity-parsers-parser-v1.const.ts":"62","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/central-authority-class-user-identity-parsers-parser-v1.ts":"63","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/index.ts":"64","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v2/central-authority-class-user-identity-parsers-parser-v2.const.ts":"65","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v2/central-authority-class-user-identity-parsers-parser-v2.ts":"66","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v2/index.ts":"67","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.const.ts":"68","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.ts":"69","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.types.ts":"70","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.utils.ts":"71","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/index.ts":"72","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v1/central-authority-class-user-identity-validator-v1.ts":"73","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v1/index.ts":"74","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v2/central-authority-class-user-identity-validator-v2.ts":"75","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v2/index.ts":"76","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.const.ts":"77","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.ts":"78","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.types.ts":"79","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.utils.ts":"80","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/index.ts":"81","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const.ts":"82","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.ts":"83","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types.ts":"84","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/index.ts":"85","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class.const.ts":"86","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class.ts":"87","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class.types.ts":"88","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/central-authority-connection-firebase-base.const.ts":"89","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/central-authority-connection-firebase-base.ts":"90","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/central-authority-connection-firebase-base.types.ts":"91","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/index.ts":"92","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-connection-implementation/central-authority-connection-firebase-connection-implementation.ts":"93","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-connection-implementation/index.ts":"94","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.const.ts":"95","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.ts":"96","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.types.ts":"97","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/index.ts":"98","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database.const.ts":"99","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database.ts":"100","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/index.ts":"101","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators/central-authority-connection-firebase-utils.validators.const.ts":"102","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators/central-authority-connection-firebase-utils.validators.ts":"103","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators/index.ts":"104","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/index.ts":"105","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.auth.ts":"106","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.error-codes.ts":"107","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.restrictions.ts":"108","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.ts":"109","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/index.ts":"110","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.ts":"111","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.types.configuration.ts":"112","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/index.ts":"113","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const-error-codes.ts":"114","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const-status.ts":"115","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const.ts":"116","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/index.ts":"117","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-pool/central-authority-connections-pool.ts":"118","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-pool/central-authority-connections-pool.types.ts":"119","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-pool/index.ts":"120","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.common/central-authority-connections-utils.common.ts":"121","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.normalizers.ts":"122","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.ts":"123","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.validators/central-authority-connections-utils.validators.const.ts":"124","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.validators/central-authority-connections-utils.validators.ts":"125","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/index.ts":"126","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections.const.ts":"127","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections.types.ts":"128","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/index.ts":"129","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.const.ts":"130","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.ts":"131","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.types.ts":"132","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/index.ts":"133","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/index.ts":"134","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.const.ts":"135","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.ts":"136","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.types.ts":"137","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/index.ts":"138","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/index.ts":"139","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/index.ts":"140","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-swarm-credentials-provider/central-authority-swarm-credentials-provider.ts":"141","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-swarm-credentials-provider/central-authority-swarm-credentials-provider.types.ts":"142","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-swarm-credentials-provider/index.ts":"143","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-common.ts":"144","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-export.ts":"145","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-generate.ts":"146","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-import.ts":"147","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys.const.ts":"148","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys.ts":"149","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/index.ts":"150","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials-crypto-keys.ts":"151","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials.const.ts":"152","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials.ts":"153","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/index.ts":"154","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/index.ts":"155","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials.ts":"156","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/index.ts":"157","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys-schemas.ts":"158","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys.ts":"159","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/index.ts":"160","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user.schemes.ts":"161","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user.ts":"162","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/index.ts":"163","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/index.ts":"164","/home/paul/projects/protocol/src/classes/central-authority-class/index.ts":"165","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.const.ts":"166","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.ts":"167","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.types.ts":"168","/home/paul/projects/protocol/src/classes/connection-bridge/index.ts":"169","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.const.ts":"170","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.ts":"171","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.types.ts":"172","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/index.ts":"173","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.const.ts":"174","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.ts":"175","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.types.ts":"176","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/index.ts":"177","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/index.ts":"178","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class.const.ts":"179","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class.ts":"180","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class.types.ts":"181","/home/paul/projects/protocol/src/classes/filestorage-class/index.ts":"182","/home/paul/projects/protocol/src/classes/index.ts":"183","/home/paul/projects/protocol/src/classes/open-storage/index.ts":"184","/home/paul/projects/protocol/src/classes/open-storage/open-storage.const.ts":"185","/home/paul/projects/protocol/src/classes/open-storage/open-storage.ts":"186","/home/paul/projects/protocol/src/classes/open-storage/open-storage.types.ts":"187","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/index.ts":"188","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.const.ts":"189","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.ts":"190","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.types.ts":"191","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.utils.ts":"192","/home/paul/projects/protocol/src/classes/safe-storage-class/index.ts":"193","/home/paul/projects/protocol/src/classes/safe-storage-class/safe-storage-class.const.ts":"194","/home/paul/projects/protocol/src/classes/safe-storage-class/safe-storage-class.ts":"195","/home/paul/projects/protocol/src/classes/safe-storage-class/safe-storage-class.types.ts":"196","/home/paul/projects/protocol/src/classes/secret-storage-class/index.ts":"197","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/index.ts":"198","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-login/index.ts":"199","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-login/secret-storage-class-utils-login.const.ts":"200","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-login/secret-storage-class-utils-login.ts":"201","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-main/index.ts":"202","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-main/secret-storage-class-utils-main.ts":"203","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-password/index.ts":"204","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-password/secret-storage-class-utils-password.ts":"205","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class.const.ts":"206","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class.ts":"207","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class.types.ts":"208","/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/index.ts":"209","/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/sensitive-data-session-storage.const.ts":"210","/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/sensitive-data-session-storage.ts":"211","/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/sensitive-data-session-storage.types.ts":"212","/home/paul/projects/protocol/src/classes/storage-providers/index.ts":"213","/home/paul/projects/protocol/src/classes/storage-providers/storage-level-js-provider/index.ts":"214","/home/paul/projects/protocol/src/classes/storage-providers/storage-level-js-provider/secret-storage-level-js-provider.const.ts":"215","/home/paul/projects/protocol/src/classes/storage-providers/storage-level-js-provider/secret-storage-level-js-provider.ts":"216","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-forage-provider/index.ts":"217","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-forage-provider/secret-storage-local-forage-provider.const.ts":"218","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-forage-provider/secret-storage-local-forage-provider.ts":"219","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-storage-provider/index.ts":"220","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-storage-provider/secret-storage-local-storage-provider.ts":"221","/home/paul/projects/protocol/src/classes/storage-providers/storage-providers.const.ts":"222","/home/paul/projects/protocol/src/classes/storage-providers/storage-providers.ts":"223","/home/paul/projects/protocol/src/classes/storage-providers/storage-providers.types.ts":"224","/home/paul/projects/protocol/src/classes/storage-providers/storage-session-storage-provider/index.ts":"225","/home/paul/projects/protocol/src/classes/storage-providers/storage-session-storage-provider/secret-storage-session-storage-provider.ts":"226","/home/paul/projects/protocol/src/classes/swarm-message/index.ts":"227","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-constructor.const.ts":"228","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-constructor.ts":"229","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-constructor.types.ts":"230","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/index.ts":"231","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-parser/index.ts":"232","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-parser/swarm-message-subclass-parser.ts":"233","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-parser/swarm-message-subclass-parser.types.ts":"234","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/index.ts":"235","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.const.ts":"236","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.ts":"237","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.types.ts":"238","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/index.ts":"239","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/index.ts":"240","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/index.ts":"241","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/index.ts":"242","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/swarm-message-subclass-validator-fields-validator-body-raw.const.ts":"243","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/swarm-message-subclass-validator-fields-validator-body-raw.ts":"244","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/index.ts":"245","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/swarm-message-subclass-validator-fields-validator-signature.const.ts":"246","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/swarm-message-subclass-validator-fields-validator-signature.ts":"247","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/index.ts":"248","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied.ts":"249","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied.types.ts":"250","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/index.ts":"251","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized.ts":"252","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized.types.ts":"253","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/index.ts":"254","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.const.ts":"255","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.ts":"256","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.types.ts":"257","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/index.ts":"258","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.const.ts":"259","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.ts":"260","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.types.ts":"261","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/index.ts":"262","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/swarm-message-subclass-validator-fields-validator-validator-type.ts":"263","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/swarm-message-subclass-validator-fields-validator-validator-type.types.ts":"264","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/index.ts":"265","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.const.ts":"266","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.ts":"267","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types.ts":"268","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator.ts":"269","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator.types.ts":"270","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/index.ts":"271","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/swarm-message-subclass-validator-signature-validator.ts":"272","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/swarm-message-subclass-validator-signature-validator.types.ts":"273","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.const.ts":"274","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.ts":"275","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.types.ts":"276","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/index.ts":"277","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-parser/index.ts":"278","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-parser/swarm-message-utils-body-parser.ts":"279","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-parser/swarm-message-utils-body-parser.types.ts":"280","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-serializer/index.ts":"281","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-serializer/swarm-message-utils-body-serializer.ts":"282","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-serializer/swarm-message-utils-body-serializer.types.ts":"283","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-parser/index.ts":"284","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-parser/swarm-message-utils-message-parser.ts":"285","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-parser/swarm-message-utils-message-parser.types.ts":"286","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-serializer/index.ts":"287","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-serializer/swarm-message-utils-message-serializer.ts":"288","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-serializer/swarm-message-utils-message-serializer.types.ts":"289","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/index.ts":"290","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.const.ts":"291","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.ts":"292","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.types.ts":"293","/home/paul/projects/protocol/src/classes/swarm-message-store/index.ts":"294","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/index.ts":"295","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-common/index.ts":"296","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-common/swarm-message-store-utils-common.ts":"297","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-connector-options-provider/index.ts":"298","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-connector-options-provider/swarm-message-store-utils-connector-options-provider.ts":"299","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store.const.ts":"300","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store.ts":"301","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store.types.ts":"302","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/index.ts":"303","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-message-encrypted-cache.utils.ts":"304","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.const.ts":"305","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.ts":"306","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types.ts":"307","/home/paul/projects/protocol/src/classes/swarm-store-class/index.ts":"308","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class.const.ts":"309","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class.ts":"310","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class.types.ts":"311","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/index.ts":"312","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/index.ts":"313","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/index.ts":"314","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/index.ts":"315","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.const.ts":"316","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.ts":"317","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.types.ts":"318","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/index.ts":"319","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const.ts":"320","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.ts":"321","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types.ts":"322","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/index.ts":"323","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider.const.ts":"324","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider.ts":"325","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/index.ts":"326","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.const.ts":"327","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.ts":"328","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.utils.ts":"329","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-cache/index.ts":"330","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-cache/swarm-store-connector-orbit-db-subclass-storage-cache.ts":"331","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/index.ts":"332","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.ts":"333","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.types.ts":"334","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/index.ts":"335","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.const.ts":"336","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.ts":"337","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.types.ts":"338","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.const.ts":"339","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.ts":"340","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types.ts":"341","/home/paul/projects/protocol/src/components/app-render.tsx":"342","/home/paul/projects/protocol/src/components/app.tsx":"343","/home/paul/projects/protocol/src/components/connect-to-swarm/connect-to-swarm.const.ts":"344","/home/paul/projects/protocol/src/components/connect-to-swarm/connect-to-swarm.tsx":"345","/home/paul/projects/protocol/src/components/connect-to-swarm/connect-to-swarm.utils.ts":"346","/home/paul/projects/protocol/src/components/connect-to-swarm/index.ts":"347","/home/paul/projects/protocol/src/components/filestore-add-file/filestore-add-file.tsx":"348","/home/paul/projects/protocol/src/components/filestore-add-file/filestore-add-file.utils.ts":"349","/home/paul/projects/protocol/src/components/filestore-add-file/index.ts":"350","/home/paul/projects/protocol/src/components/sensitive-data-storage/index.ts":"351","/home/paul/projects/protocol/src/components/sensitive-data-storage/sensitive-data-storage.tsx":"352","/home/paul/projects/protocol/src/const/common-date-time/common-date-time-main.ts":"353","/home/paul/projects/protocol/src/const/common-date-time/common-date-time-ntp-servers.const.ts":"354","/home/paul/projects/protocol/src/const/common-date-time/common-date-time-timezone.const.ts":"355","/home/paul/projects/protocol/src/const/common-date-time/index.ts":"356","/home/paul/projects/protocol/src/const/common-values/common-values-env.ts":"357","/home/paul/projects/protocol/src/const/common-values/common-values.ts":"358","/home/paul/projects/protocol/src/const/common-values/index.ts":"359","/home/paul/projects/protocol/src/const/const-api-conf.ts":"360","/home/paul/projects/protocol/src/const/const-crypto-keys/const-crypto-keys.ts":"361","/home/paul/projects/protocol/src/const/const-crypto-keys/index.ts":"362","/home/paul/projects/protocol/src/const/const-validation-regex/const-validation-regex-common.ts":"363","/home/paul/projects/protocol/src/const/const-validation-regex/index.ts":"364","/home/paul/projects/protocol/src/const/const-validation-schemes/const-validation-schemes-common.ts":"365","/home/paul/projects/protocol/src/const/const-validation-schemes/const-validation-schemes-credentials.ts":"366","/home/paul/projects/protocol/src/const/const-validation-schemes/const-validation-schemes.ts":"367","/home/paul/projects/protocol/src/const/const-validation-schemes/index.ts":"368","/home/paul/projects/protocol/src/const/const-validation-values/const-validation-values-messaging-date.ts":"369","/home/paul/projects/protocol/src/const/const-validation-values/index.ts":"370","/home/paul/projects/protocol/src/const/const-values-restrictions-common.ts":"371","/home/paul/projects/protocol/src/dev.ts":"372","/home/paul/projects/protocol/src/index.ts":"373","/home/paul/projects/protocol/src/prod.ts":"374","/home/paul/projects/protocol/src/react-app-env.d.ts":"375","/home/paul/projects/protocol/src/types/channels.types.ts":"376","/home/paul/projects/protocol/src/types/common.types.ts":"377","/home/paul/projects/protocol/src/types/encryption-keys.types.ts":"378","/home/paul/projects/protocol/src/types/helper.types.ts":"379","/home/paul/projects/protocol/src/types/index.d.ts":"380","/home/paul/projects/protocol/src/types/ipfs.d.ts":"381","/home/paul/projects/protocol/src/types/ipfs.types.d.ts":"382","/home/paul/projects/protocol/src/types/libp2p-bootstrap.d.ts":"383","/home/paul/projects/protocol/src/types/libp2p-delegated-content-routing.d.ts":"384","/home/paul/projects/protocol/src/types/libp2p-delegated-peer-routing.d.ts":"385","/home/paul/projects/protocol/src/types/libp2p-gossipsub.d.ts":"386","/home/paul/projects/protocol/src/types/libp2p-kad-dht.d.ts":"387","/home/paul/projects/protocol/src/types/libp2p-mdns.d.ts":"388","/home/paul/projects/protocol/src/types/libp2p-secio.d.ts":"389","/home/paul/projects/protocol/src/types/libp2p-spdy.d.ts":"390","/home/paul/projects/protocol/src/types/libp2p-stardust.d.ts":"391","/home/paul/projects/protocol/src/types/libp2p-tcp.d.ts":"392","/home/paul/projects/protocol/src/types/libp2p-webrtc-direct.d.ts":"393","/home/paul/projects/protocol/src/types/libp2p-webrtc-star.d.ts":"394","/home/paul/projects/protocol/src/types/libp2p-websocket-star.d.ts":"395","/home/paul/projects/protocol/src/types/libp2p-websockets.d.ts":"396","/home/paul/projects/protocol/src/types/libp2p.d.ts":"397","/home/paul/projects/protocol/src/types/main.types.ts":"398","/home/paul/projects/protocol/src/types/multiaddr.d.ts":"399","/home/paul/projects/protocol/src/types/orbit-db-cache.d.ts":"400","/home/paul/projects/protocol/src/types/orbit-db-identity-provider-ext.d.ts":"401","/home/paul/projects/protocol/src/types/orbit-db-keystore.d.ts":"402","/home/paul/projects/protocol/src/types/orbit-db-storage-adapter.d.ts":"403","/home/paul/projects/protocol/src/types/pull-mplex.d.ts":"404","/home/paul/projects/protocol/src/types/storage.types.ts":"405","/home/paul/projects/protocol/src/types/users.types.ts":"406","/home/paul/projects/protocol/src/utils/common-utils/common-utils-array.ts":"407","/home/paul/projects/protocol/src/utils/common-utils/common-utils-check-value.ts":"408","/home/paul/projects/protocol/src/utils/common-utils/common-utils-date-time-synced.ts":"409","/home/paul/projects/protocol/src/utils/common-utils/common-utils-date-time.ts":"410","/home/paul/projects/protocol/src/utils/common-utils/common-utils-main.ts":"411","/home/paul/projects/protocol/src/utils/common-utils/common-utils-number.ts":"412","/home/paul/projects/protocol/src/utils/common-utils/common-utils-objects.ts":"413","/home/paul/projects/protocol/src/utils/common-utils/common-utils-timer.ts":"414","/home/paul/projects/protocol/src/utils/common-utils/common-utils-url.ts":"415","/home/paul/projects/protocol/src/utils/common-utils/common-utils.ts":"416","/home/paul/projects/protocol/src/utils/common-utils/index.ts":"417","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.const.ts":"418","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.ts":"419","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.types.ts":"420","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/index.ts":"421","/home/paul/projects/protocol/src/utils/data-cache-utils/index.ts":"422","/home/paul/projects/protocol/src/utils/data-compression-utils/data-compression-utils-strings.ts":"423","/home/paul/projects/protocol/src/utils/data-compression-utils/data-compression-utils.const.ts":"424","/home/paul/projects/protocol/src/utils/data-compression-utils/data-compression-utils.ts":"425","/home/paul/projects/protocol/src/utils/data-compression-utils/index.ts":"426","/home/paul/projects/protocol/src/utils/data-sign-utils/data-sign-utils.const.ts":"427","/home/paul/projects/protocol/src/utils/data-sign-utils/data-sign-utils.ts":"428","/home/paul/projects/protocol/src/utils/data-sign-utils/data-sign-utils.types.ts":"429","/home/paul/projects/protocol/src/utils/data-sign-utils/index.ts":"430","/home/paul/projects/protocol/src/utils/data-sign-utils/keys.data-sign-utils.ts":"431","/home/paul/projects/protocol/src/utils/data-sign-utils/main.data-sign-utils.const.ts":"432","/home/paul/projects/protocol/src/utils/data-sign-utils/sign-data.encryption-utils.ts":"433","/home/paul/projects/protocol/src/utils/data-sign-utils/verify-data.encryption-utils.ts":"434","/home/paul/projects/protocol/src/utils/data-validators-utils/data-validators-utils-common.ts":"435","/home/paul/projects/protocol/src/utils/data-validators-utils/data-validators-utils.ts":"436","/home/paul/projects/protocol/src/utils/data-validators-utils/index.ts":"437","/home/paul/projects/protocol/src/utils/encryption-keys-utils/encryption-keys-utils.const.ts":"438","/home/paul/projects/protocol/src/utils/encryption-keys-utils/encryption-keys-utils.ts":"439","/home/paul/projects/protocol/src/utils/encryption-keys-utils/index.ts":"440","/home/paul/projects/protocol/src/utils/encryption-utils/crypto-utils.const.ts":"441","/home/paul/projects/protocol/src/utils/encryption-utils/crypto-utils.types.ts":"442","/home/paul/projects/protocol/src/utils/encryption-utils/decrypt-data.encryption-utils.ts":"443","/home/paul/projects/protocol/src/utils/encryption-utils/encrypt-data.encryption-utils.ts":"444","/home/paul/projects/protocol/src/utils/encryption-utils/encryption-utils.ts":"445","/home/paul/projects/protocol/src/utils/encryption-utils/index.ts":"446","/home/paul/projects/protocol/src/utils/encryption-utils/keys.encryption-utils.ts":"447","/home/paul/projects/protocol/src/utils/encryption-utils/main.crypto-utils.const.ts":"448","/home/paul/projects/protocol/src/utils/encryption-utils/salt-utils.const.ts":"449","/home/paul/projects/protocol/src/utils/encryption-utils/salt-utils.ts":"450","/home/paul/projects/protocol/src/utils/encryption-utils/salt-utils.types.ts":"451","/home/paul/projects/protocol/src/utils/files-utils/files-utils-download.ts":"452","/home/paul/projects/protocol/src/utils/files-utils/files-utils-size.ts":"453","/home/paul/projects/protocol/src/utils/files-utils/index.ts":"454","/home/paul/projects/protocol/src/utils/firebase-utils/firebase-utils.ts":"455","/home/paul/projects/protocol/src/utils/firebase-utils/index.ts":"456","/home/paul/projects/protocol/src/utils/hash-calculation-utils/hash-calculation-utils.const.ts":"457","/home/paul/projects/protocol/src/utils/hash-calculation-utils/hash-calculation-utils.ts":"458","/home/paul/projects/protocol/src/utils/hash-calculation-utils/index.ts":"459","/home/paul/projects/protocol/src/utils/identity-utils/identity-utils.ts":"460","/home/paul/projects/protocol/src/utils/identity-utils/index.ts":"461","/home/paul/projects/protocol/src/utils/index.ts":"462","/home/paul/projects/protocol/src/utils/ipfs-utils/index.ts":"463","/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils-libp2p/index.js":"464","/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils-libp2p/ipfs-utils-libp2p.const.ts":"465","/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils-libp2p/ipfs-utils-libp2p.ts":"466","/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils.const.ts":"467","/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils.ts":"468","/home/paul/projects/protocol/src/utils/lazy-loading-utils/index.ts":"469","/home/paul/projects/protocol/src/utils/lazy-loading-utils/lazy-loading-utils.ts":"470","/home/paul/projects/protocol/src/utils/main-utils.ts":"471","/home/paul/projects/protocol/src/utils/password-utils/decrypt.password-utils.ts":"472","/home/paul/projects/protocol/src/utils/password-utils/derive-key.password-utils.ts":"473","/home/paul/projects/protocol/src/utils/password-utils/encrypt.password-utils.ts":"474","/home/paul/projects/protocol/src/utils/password-utils/index.ts":"475","/home/paul/projects/protocol/src/utils/password-utils/password-utils.const.ts":"476","/home/paul/projects/protocol/src/utils/password-utils/password-utils.types.ts":"477","/home/paul/projects/protocol/src/utils/string-encoding-utils.ts":"478","/home/paul/projects/protocol/src/utils/string-utilities.ts":"479","/home/paul/projects/protocol/src/utils/typed-array-utils.ts":"480","/home/paul/projects/protocol/src/utils/validation-utils/index.ts":"481","/home/paul/projects/protocol/src/utils/validation-utils/validation-utils-timestamp.ts":"482","/home/paul/projects/protocol/src/utils/validation-utils/validation-utils-validation-error.ts":"483","/home/paul/projects/protocol/src/utils/validation-utils/validation-utils.ts":"484","/home/paul/projects/protocol/src/components/userProfile/index.ts":"485","/home/paul/projects/protocol/src/components/userProfile/userProfile.tsx":"486","/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/index.ts":"487","/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/statused-class-helper.const.ts":"488","/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/statused-class-helper.ts":"489","/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/statused-class-helper.types.ts":"490","/home/paul/projects/protocol/src/classes/swarm-messages-database/index.ts":"491","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database.ts":"492","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database.types.ts":"493","/home/paul/projects/protocol/src/components/message-component/index.ts":"494","/home/paul/projects/protocol/src/components/message-component/message-component.tsx":"495","/home/paul/projects/protocol/src/components/swarm-messages-database-component/index.ts":"496","/home/paul/projects/protocol/src/components/swarm-messages-database-component/swarm-messages-database-component.tsx":"497","/home/paul/projects/protocol/src/components/swarm-messages-database-component/swarm-messages-database-component.types.ts":"498","/home/paul/projects/protocol/src/components/swarm-messages-database-component/swarm-messages-database-component.utils.ts":"499","/home/paul/projects/protocol/src/components/swarm-store-db-component/index.ts":"500","/home/paul/projects/protocol/src/components/swarm-store-db-component/swarm-store-db-component.tsx":"501","/home/paul/projects/protocol/src/classes/basic-classes/event-emitter-class-base/event-emitter-class-base.types.ts":"502","/home/paul/projects/protocol/src/classes/storage-providers/storage-in-memory-provider/index.ts":"503","/home/paul/projects/protocol/src/classes/storage-providers/storage-in-memory-provider/storage-in-memory-provider.ts":"504","/home/paul/projects/protocol/src/classes/storage-providers/storage-in-memory-provider/storage-in-memory-provider.types.ts":"505","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/index.ts":"506","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.const.ts":"507","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.ts":"508","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.types.ts":"509","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database.const.ts":"510","/home/paul/projects/protocol/src/utils/throttling-utils/index.ts":"511","/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/index.ts":"512","/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/throttling-utils-idle-callback.const.ts":"513","/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/throttling-utils-idle-callback.ts":"514","/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/throttling-utils-idle-callback.types.ts":"515","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/index.ts":"516","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/index.ts":"517","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.ts":"518","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/index.ts":"519","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-message-with-meta.ts":"520","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-swarm-message.ts":"521","/home/paul/projects/protocol/src/utils/common-utils/common-utils-classes.ts":"522","/home/paul/projects/protocol/src/utils/common-utils/common-utils-maps.ts":"523","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-memoization.ts":"524","/home/paul/projects/protocol/src/components/connect-to-swarm-immediate/connect-to-swarm-immediate.const.ts":"525","/home/paul/projects/protocol/src/components/connect-to-swarm-immediate/connect-to-swarm-immediate.tsx":"526","/home/paul/projects/protocol/src/components/connect-to-swarm-immediate/index.ts":"527","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.const.ts":"528","/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-main.ts":"529","/home/paul/projects/protocol/src/const/const-helpers.ts":"530","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-main.ts":"531","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.types.ts":"532","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-common/index.ts":"533","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-common/swarm-message-utils-common-decrypted.ts":"534","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/index.ts":"535","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store-subclasses/swarm-messages-database-messages-cached-store-core/swarm-messages-database-messages-cached-store-core.ts":"536","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store-subclasses/swarm-messages-database-messages-cached-store-feed/swarm-messages-database-messages-cached-store-feed.ts":"537","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store-subclasses/swarm-messages-database-messages-cached-store-keyvalue/swarm-messages-database-messages-cached-store-keyvalue.ts":"538","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.const.ts":"539","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.ts":"540","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.types.ts":"541"},{"size":315454,"mtime":1596130938122,"results":"542","hashOfConfig":"543"},{"size":3256798,"mtime":1596130938134,"results":"544","hashOfConfig":"543"},{"size":44,"mtime":1594985692484,"results":"545","hashOfConfig":"543"},{"size":2379,"mtime":1594985692484,"results":"546","hashOfConfig":"543"},{"size":33,"mtime":1596228865129,"results":"547","hashOfConfig":"548"},{"size":602,"mtime":1596228865129,"results":"549","hashOfConfig":"548"},{"size":43,"mtime":1596228865129,"results":"550","hashOfConfig":"548"},{"size":163,"mtime":1596228865129,"results":"551","hashOfConfig":"548"},{"size":93,"mtime":1596228865129,"results":"552","hashOfConfig":"548"},{"size":216,"mtime":1596228865129,"results":"553","hashOfConfig":"548"},{"size":3259,"mtime":1596228865129,"results":"554","hashOfConfig":"548"},{"size":1937,"mtime":1596228865129,"results":"555","hashOfConfig":"548"},{"size":561,"mtime":1596228865129,"results":"556","hashOfConfig":"548"},{"size":140,"mtime":1596228865129,"results":"557","hashOfConfig":"548"},{"size":615,"mtime":1596228865129,"results":"558","hashOfConfig":"548"},{"size":606,"mtime":1596228865129,"results":"559","hashOfConfig":"548"},{"size":52,"mtime":1596228865129,"results":"560","hashOfConfig":"548"},{"size":374,"mtime":1599915233503,"results":"561","hashOfConfig":"548"},{"size":44,"mtime":1599766058405,"results":"562","hashOfConfig":"548"},{"size":2819,"mtime":1596228865129,"results":"563","hashOfConfig":"548"},{"size":1636,"mtime":1596228865129,"results":"564","hashOfConfig":"548"},{"size":4314,"mtime":1596228865129,"results":"565","hashOfConfig":"548"},{"size":4372,"mtime":1596228865129,"results":"566","hashOfConfig":"548"},{"size":1314,"mtime":1596228865129,"results":"567","hashOfConfig":"548"},{"size":8342,"mtime":1599075093618,"results":"568","hashOfConfig":"548"},{"size":1874,"mtime":1596228865129,"results":"569","hashOfConfig":"548"},{"size":2614,"mtime":1596228865129,"results":"570","hashOfConfig":"548"},{"size":193,"mtime":1596228865129,"results":"571","hashOfConfig":"548"},{"size":89,"mtime":1596228865129,"results":"572","hashOfConfig":"548"},{"size":728,"mtime":1596228865129,"results":"573","hashOfConfig":"548"},{"size":1648,"mtime":1596228865129,"results":"574","hashOfConfig":"548"},{"size":146,"mtime":1596228865129,"results":"575","hashOfConfig":"548"},{"size":191,"mtime":1596228865129,"results":"576","hashOfConfig":"548"},{"size":2582,"mtime":1596228865129,"results":"577","hashOfConfig":"548"},{"size":978,"mtime":1596228865129,"results":"578","hashOfConfig":"548"},{"size":103,"mtime":1596228865129,"results":"579","hashOfConfig":"548"},{"size":4922,"mtime":1596228865129,"results":"580","hashOfConfig":"548"},{"size":2663,"mtime":1596228865129,"results":"581","hashOfConfig":"548"},{"size":125,"mtime":1596228865129,"results":"582","hashOfConfig":"548"},{"size":58,"mtime":1596228865129,"results":"583","hashOfConfig":"548"},{"size":2081,"mtime":1596228865129,"results":"584","hashOfConfig":"548"},{"size":216,"mtime":1596228865129,"results":"585","hashOfConfig":"548"},{"size":2025,"mtime":1596228865129,"results":"586","hashOfConfig":"548"},{"size":785,"mtime":1596228865129,"results":"587","hashOfConfig":"548"},{"size":66,"mtime":1596228865129,"results":"588","hashOfConfig":"548"},{"size":185,"mtime":1596228865129,"results":"589","hashOfConfig":"548"},{"size":3031,"mtime":1596228865129,"results":"590","hashOfConfig":"548"},{"size":900,"mtime":1596228865129,"results":"591","hashOfConfig":"548"},{"size":881,"mtime":1596228865129,"results":"592","hashOfConfig":"548"},{"size":187,"mtime":1596228865129,"results":"593","hashOfConfig":"548"},{"size":237,"mtime":1596228865129,"results":"594","hashOfConfig":"548"},{"size":1579,"mtime":1596228865129,"results":"595","hashOfConfig":"548"},{"size":81,"mtime":1596228865129,"results":"596","hashOfConfig":"548"},{"size":360,"mtime":1596228865129,"results":"597","hashOfConfig":"548"},{"size":1786,"mtime":1596228865129,"results":"598","hashOfConfig":"548"},{"size":169,"mtime":1596228865129,"results":"599","hashOfConfig":"548"},{"size":738,"mtime":1596228865129,"results":"600","hashOfConfig":"548"},{"size":224,"mtime":1596228865129,"results":"601","hashOfConfig":"548"},{"size":379,"mtime":1596228865129,"results":"602","hashOfConfig":"548"},{"size":2670,"mtime":1596228865129,"results":"603","hashOfConfig":"548"},{"size":293,"mtime":1596228865129,"results":"604","hashOfConfig":"548"},{"size":781,"mtime":1596228865129,"results":"605","hashOfConfig":"548"},{"size":1934,"mtime":1596228865129,"results":"606","hashOfConfig":"548"},{"size":157,"mtime":1596228865129,"results":"607","hashOfConfig":"548"},{"size":1081,"mtime":1596228865129,"results":"608","hashOfConfig":"548"},{"size":1962,"mtime":1596228865129,"results":"609","hashOfConfig":"548"},{"size":157,"mtime":1596228865129,"results":"610","hashOfConfig":"548"},{"size":671,"mtime":1596228865129,"results":"611","hashOfConfig":"548"},{"size":215,"mtime":1596228865129,"results":"612","hashOfConfig":"548"},{"size":340,"mtime":1596228865129,"results":"613","hashOfConfig":"548"},{"size":3790,"mtime":1596228865129,"results":"614","hashOfConfig":"548"},{"size":281,"mtime":1596228865129,"results":"615","hashOfConfig":"548"},{"size":1720,"mtime":1596228865129,"results":"616","hashOfConfig":"548"},{"size":70,"mtime":1596228865129,"results":"617","hashOfConfig":"548"},{"size":1742,"mtime":1596228865129,"results":"618","hashOfConfig":"548"},{"size":70,"mtime":1596228865129,"results":"619","hashOfConfig":"548"},{"size":684,"mtime":1596228865129,"results":"620","hashOfConfig":"548"},{"size":224,"mtime":1596228865129,"results":"621","hashOfConfig":"548"},{"size":76,"mtime":1596228865129,"results":"622","hashOfConfig":"548"},{"size":3995,"mtime":1596228865129,"results":"623","hashOfConfig":"548"},{"size":293,"mtime":1596228865129,"results":"624","hashOfConfig":"548"},{"size":1035,"mtime":1596228865129,"results":"625","hashOfConfig":"548"},{"size":7347,"mtime":1596228865129,"results":"626","hashOfConfig":"548"},{"size":2890,"mtime":1596228865129,"results":"627","hashOfConfig":"548"},{"size":185,"mtime":1596228865129,"results":"628","hashOfConfig":"548"},{"size":2194,"mtime":1596228865129,"results":"629","hashOfConfig":"548"},{"size":32602,"mtime":1597690277860,"results":"630","hashOfConfig":"548"},{"size":6918,"mtime":1597690277860,"results":"631","hashOfConfig":"548"},{"size":132,"mtime":1596228865129,"results":"632","hashOfConfig":"548"},{"size":38705,"mtime":1597690277860,"results":"633","hashOfConfig":"548"},{"size":261,"mtime":1596228865129,"results":"634","hashOfConfig":"548"},{"size":62,"mtime":1596228865129,"results":"635","hashOfConfig":"548"},{"size":20633,"mtime":1596228865129,"results":"636","hashOfConfig":"548"},{"size":83,"mtime":1596228865129,"results":"637","hashOfConfig":"548"},{"size":311,"mtime":1596228865129,"results":"638","hashOfConfig":"548"},{"size":14817,"mtime":1596228865129,"results":"639","hashOfConfig":"548"},{"size":1182,"mtime":1596228865129,"results":"640","hashOfConfig":"548"},{"size":263,"mtime":1596228865129,"results":"641","hashOfConfig":"548"},{"size":145,"mtime":1596228865129,"results":"642","hashOfConfig":"548"},{"size":4334,"mtime":1596228865133,"results":"643","hashOfConfig":"548"},{"size":151,"mtime":1596228865133,"results":"644","hashOfConfig":"548"},{"size":651,"mtime":1596228865133,"results":"645","hashOfConfig":"548"},{"size":756,"mtime":1596228865133,"results":"646","hashOfConfig":"548"},{"size":155,"mtime":1596228865133,"results":"647","hashOfConfig":"548"},{"size":231,"mtime":1596228865133,"results":"648","hashOfConfig":"548"},{"size":79,"mtime":1596228865133,"results":"649","hashOfConfig":"548"},{"size":110,"mtime":1596228865133,"results":"650","hashOfConfig":"548"},{"size":77,"mtime":1596228865133,"results":"651","hashOfConfig":"548"},{"size":75,"mtime":1596228865133,"results":"652","hashOfConfig":"548"},{"size":285,"mtime":1596228865133,"results":"653","hashOfConfig":"548"},{"size":717,"mtime":1596228865133,"results":"654","hashOfConfig":"548"},{"size":306,"mtime":1596228865133,"results":"655","hashOfConfig":"548"},{"size":346,"mtime":1596228865133,"results":"656","hashOfConfig":"548"},{"size":385,"mtime":1596228865133,"results":"657","hashOfConfig":"548"},{"size":333,"mtime":1596228865133,"results":"658","hashOfConfig":"548"},{"size":130,"mtime":1596228865133,"results":"659","hashOfConfig":"548"},{"size":186,"mtime":1596228865133,"results":"660","hashOfConfig":"548"},{"size":26530,"mtime":1597690277860,"results":"661","hashOfConfig":"548"},{"size":4012,"mtime":1597690277860,"results":"662","hashOfConfig":"548"},{"size":115,"mtime":1596228865133,"results":"663","hashOfConfig":"548"},{"size":758,"mtime":1596228865133,"results":"664","hashOfConfig":"548"},{"size":868,"mtime":1596228865133,"results":"665","hashOfConfig":"548"},{"size":181,"mtime":1596228865133,"results":"666","hashOfConfig":"548"},{"size":192,"mtime":1596228865133,"results":"667","hashOfConfig":"548"},{"size":1300,"mtime":1596228865133,"results":"668","hashOfConfig":"548"},{"size":123,"mtime":1596228865133,"results":"669","hashOfConfig":"548"},{"size":579,"mtime":1596228865133,"results":"670","hashOfConfig":"548"},{"size":4767,"mtime":1597690277860,"results":"671","hashOfConfig":"548"},{"size":111,"mtime":1596228865133,"results":"672","hashOfConfig":"548"},{"size":900,"mtime":1596228865133,"results":"673","hashOfConfig":"548"},{"size":19491,"mtime":1596228865133,"results":"674","hashOfConfig":"548"},{"size":2065,"mtime":1596228865133,"results":"675","hashOfConfig":"548"},{"size":224,"mtime":1596228865133,"results":"676","hashOfConfig":"548"},{"size":70,"mtime":1596228865133,"results":"677","hashOfConfig":"548"},{"size":1588,"mtime":1596228865133,"results":"678","hashOfConfig":"548"},{"size":15819,"mtime":1601144133529,"results":"679","hashOfConfig":"548"},{"size":3718,"mtime":1596228865133,"results":"680","hashOfConfig":"548"},{"size":248,"mtime":1596228865133,"results":"681","hashOfConfig":"548"},{"size":78,"mtime":1596228865133,"results":"682","hashOfConfig":"548"},{"size":126,"mtime":1596228865133,"results":"683","hashOfConfig":"548"},{"size":16199,"mtime":1596228865133,"results":"684","hashOfConfig":"548"},{"size":1944,"mtime":1596228865133,"results":"685","hashOfConfig":"548"},{"size":135,"mtime":1596228865133,"results":"686","hashOfConfig":"548"},{"size":3963,"mtime":1596228865133,"results":"687","hashOfConfig":"548"},{"size":3616,"mtime":1596228865133,"results":"688","hashOfConfig":"548"},{"size":7635,"mtime":1596228865133,"results":"689","hashOfConfig":"548"},{"size":4936,"mtime":1596228865133,"results":"690","hashOfConfig":"548"},{"size":453,"mtime":1596228865133,"results":"691","hashOfConfig":"548"},{"size":310,"mtime":1596228865133,"results":"692","hashOfConfig":"548"},{"size":365,"mtime":1596228865133,"results":"693","hashOfConfig":"548"},{"size":3256,"mtime":1596228865133,"results":"694","hashOfConfig":"548"},{"size":255,"mtime":1596228865133,"results":"695","hashOfConfig":"548"},{"size":14855,"mtime":1596228865133,"results":"696","hashOfConfig":"548"},{"size":206,"mtime":1596228865133,"results":"697","hashOfConfig":"548"},{"size":117,"mtime":1596228865133,"results":"698","hashOfConfig":"548"},{"size":3800,"mtime":1596228865133,"results":"699","hashOfConfig":"548"},{"size":65,"mtime":1596228865133,"results":"700","hashOfConfig":"548"},{"size":665,"mtime":1596228865133,"results":"701","hashOfConfig":"548"},{"size":4724,"mtime":1596228865133,"results":"702","hashOfConfig":"548"},{"size":129,"mtime":1596228865133,"results":"703","hashOfConfig":"548"},{"size":1589,"mtime":1596228865133,"results":"704","hashOfConfig":"548"},{"size":504,"mtime":1596228865133,"results":"705","hashOfConfig":"548"},{"size":115,"mtime":1596228865133,"results":"706","hashOfConfig":"548"},{"size":180,"mtime":1596228865133,"results":"707","hashOfConfig":"548"},{"size":243,"mtime":1596228865133,"results":"708","hashOfConfig":"548"},{"size":2330,"mtime":1597514290391,"results":"709","hashOfConfig":"548"},{"size":19715,"mtime":1601927580116,"results":"710","hashOfConfig":"548"},{"size":5747,"mtime":1600804786075,"results":"711","hashOfConfig":"548"},{"size":37,"mtime":1596228865133,"results":"712","hashOfConfig":"548"},{"size":252,"mtime":1596228865133,"results":"713","hashOfConfig":"548"},{"size":2927,"mtime":1599251468606,"results":"714","hashOfConfig":"548"},{"size":403,"mtime":1596228865133,"results":"715","hashOfConfig":"548"},{"size":296,"mtime":1596228865133,"results":"716","hashOfConfig":"548"},{"size":352,"mtime":1596228865133,"results":"717","hashOfConfig":"548"},{"size":7138,"mtime":1596228865133,"results":"718","hashOfConfig":"548"},{"size":1533,"mtime":1596228865133,"results":"719","hashOfConfig":"548"},{"size":296,"mtime":1596228865133,"results":"720","hashOfConfig":"548"},{"size":51,"mtime":1596228865133,"results":"721","hashOfConfig":"548"},{"size":1371,"mtime":1596228865133,"results":"722","hashOfConfig":"548"},{"size":5084,"mtime":1596228865133,"results":"723","hashOfConfig":"548"},{"size":8365,"mtime":1596228865133,"results":"724","hashOfConfig":"548"},{"size":125,"mtime":1596228865133,"results":"725","hashOfConfig":"548"},{"size":381,"mtime":1596228865133,"results":"726","hashOfConfig":"548"},{"size":110,"mtime":1596228865133,"results":"727","hashOfConfig":"548"},{"size":46,"mtime":1596228865133,"results":"728","hashOfConfig":"548"},{"size":5218,"mtime":1596228865133,"results":"729","hashOfConfig":"548"},{"size":1237,"mtime":1596229427362,"results":"730","hashOfConfig":"548"},{"size":165,"mtime":1596228865133,"results":"731","hashOfConfig":"548"},{"size":839,"mtime":1596228865133,"results":"732","hashOfConfig":"548"},{"size":15598,"mtime":1596228865133,"results":"733","hashOfConfig":"548"},{"size":3120,"mtime":1596228865133,"results":"734","hashOfConfig":"548"},{"size":514,"mtime":1596228865133,"results":"735","hashOfConfig":"548"},{"size":128,"mtime":1596228865133,"results":"736","hashOfConfig":"548"},{"size":1490,"mtime":1596228865133,"results":"737","hashOfConfig":"548"},{"size":32729,"mtime":1596228865133,"results":"738","hashOfConfig":"548"},{"size":1469,"mtime":1596228865133,"results":"739","hashOfConfig":"548"},{"size":181,"mtime":1596228865133,"results":"740","hashOfConfig":"548"},{"size":160,"mtime":1596228865133,"results":"741","hashOfConfig":"548"},{"size":111,"mtime":1596228865137,"results":"742","hashOfConfig":"548"},{"size":298,"mtime":1596228865137,"results":"743","hashOfConfig":"548"},{"size":1497,"mtime":1596228865137,"results":"744","hashOfConfig":"548"},{"size":51,"mtime":1596228865137,"results":"745","hashOfConfig":"548"},{"size":1440,"mtime":1596228865137,"results":"746","hashOfConfig":"548"},{"size":55,"mtime":1596228865137,"results":"747","hashOfConfig":"548"},{"size":563,"mtime":1596228865137,"results":"748","hashOfConfig":"548"},{"size":363,"mtime":1596228865137,"results":"749","hashOfConfig":"548"},{"size":31216,"mtime":1597514290391,"results":"750","hashOfConfig":"548"},{"size":4378,"mtime":1597514290395,"results":"751","hashOfConfig":"548"},{"size":50,"mtime":1596228865137,"results":"752","hashOfConfig":"548"},{"size":198,"mtime":1596228865137,"results":"753","hashOfConfig":"548"},{"size":4903,"mtime":1596228865137,"results":"754","hashOfConfig":"548"},{"size":1186,"mtime":1596228865137,"results":"755","hashOfConfig":"548"},{"size":325,"mtime":1596228865137,"results":"756","hashOfConfig":"548"},{"size":111,"mtime":1596228865137,"results":"757","hashOfConfig":"548"},{"size":80,"mtime":1596228865137,"results":"758","hashOfConfig":"548"},{"size":6259,"mtime":1600194989661,"results":"759","hashOfConfig":"548"},{"size":119,"mtime":1596228865137,"results":"760","hashOfConfig":"548"},{"size":216,"mtime":1596228865137,"results":"761","hashOfConfig":"548"},{"size":7065,"mtime":1596228865137,"results":"762","hashOfConfig":"548"},{"size":57,"mtime":1596228865137,"results":"763","hashOfConfig":"548"},{"size":3103,"mtime":1596228865137,"results":"764","hashOfConfig":"548"},{"size":1153,"mtime":1596228865137,"results":"765","hashOfConfig":"548"},{"size":643,"mtime":1596228865137,"results":"766","hashOfConfig":"548"},{"size":2053,"mtime":1600196265809,"results":"767","hashOfConfig":"548"},{"size":59,"mtime":1596228865137,"results":"768","hashOfConfig":"548"},{"size":3122,"mtime":1596228865137,"results":"769","hashOfConfig":"548"},{"size":234,"mtime":1596228865137,"results":"770","hashOfConfig":"548"},{"size":2057,"mtime":1596228865137,"results":"771","hashOfConfig":"548"},{"size":14050,"mtime":1600457727843,"results":"772","hashOfConfig":"548"},{"size":8822,"mtime":1600454546015,"results":"773","hashOfConfig":"548"},{"size":157,"mtime":1596228865137,"results":"774","hashOfConfig":"548"},{"size":105,"mtime":1596228865137,"results":"775","hashOfConfig":"548"},{"size":7058,"mtime":1600457727923,"results":"776","hashOfConfig":"548"},{"size":2529,"mtime":1600455337160,"results":"777","hashOfConfig":"548"},{"size":173,"mtime":1596228865137,"results":"778","hashOfConfig":"548"},{"size":76,"mtime":1596228865137,"results":"779","hashOfConfig":"548"},{"size":11327,"mtime":1596228865137,"results":"780","hashOfConfig":"548"},{"size":4943,"mtime":1596228865137,"results":"781","hashOfConfig":"548"},{"size":313,"mtime":1596228865137,"results":"782","hashOfConfig":"548"},{"size":226,"mtime":1596228865137,"results":"783","hashOfConfig":"548"},{"size":714,"mtime":1596228865137,"results":"784","hashOfConfig":"548"},{"size":163,"mtime":1596228865137,"results":"785","hashOfConfig":"548"},{"size":308,"mtime":1596228865137,"results":"786","hashOfConfig":"548"},{"size":773,"mtime":1596228865137,"results":"787","hashOfConfig":"548"},{"size":165,"mtime":1596228865137,"results":"788","hashOfConfig":"548"},{"size":129,"mtime":1596228865137,"results":"789","hashOfConfig":"548"},{"size":832,"mtime":1596228865137,"results":"790","hashOfConfig":"548"},{"size":203,"mtime":1596228865137,"results":"791","hashOfConfig":"548"},{"size":551,"mtime":1596228865137,"results":"792","hashOfConfig":"548"},{"size":54,"mtime":1596228865137,"results":"793","hashOfConfig":"548"},{"size":201,"mtime":1596228865137,"results":"794","hashOfConfig":"548"},{"size":552,"mtime":1596228865137,"results":"795","hashOfConfig":"548"},{"size":53,"mtime":1596228865137,"results":"796","hashOfConfig":"548"},{"size":275,"mtime":1596228865137,"results":"797","hashOfConfig":"548"},{"size":494,"mtime":1596228865137,"results":"798","hashOfConfig":"548"},{"size":2310,"mtime":1596228865137,"results":"799","hashOfConfig":"548"},{"size":249,"mtime":1596228865137,"results":"800","hashOfConfig":"548"},{"size":281,"mtime":1596228865137,"results":"801","hashOfConfig":"548"},{"size":803,"mtime":1596228865137,"results":"802","hashOfConfig":"548"},{"size":1917,"mtime":1596228865137,"results":"803","hashOfConfig":"548"},{"size":214,"mtime":1596228865137,"results":"804","hashOfConfig":"548"},{"size":175,"mtime":1596228865137,"results":"805","hashOfConfig":"548"},{"size":890,"mtime":1596228865137,"results":"806","hashOfConfig":"548"},{"size":49,"mtime":1596228865137,"results":"807","hashOfConfig":"548"},{"size":299,"mtime":1596228865137,"results":"808","hashOfConfig":"548"},{"size":260,"mtime":1596228865137,"results":"809","hashOfConfig":"548"},{"size":1914,"mtime":1596228865137,"results":"810","hashOfConfig":"548"},{"size":60,"mtime":1596228865137,"results":"811","hashOfConfig":"548"},{"size":13918,"mtime":1601148184986,"results":"812","hashOfConfig":"548"},{"size":3837,"mtime":1596228865137,"results":"813","hashOfConfig":"548"},{"size":151,"mtime":1596228865137,"results":"814","hashOfConfig":"548"},{"size":6686,"mtime":1596228865137,"results":"815","hashOfConfig":"548"},{"size":1544,"mtime":1596228865137,"results":"816","hashOfConfig":"548"},{"size":760,"mtime":1596228865137,"results":"817","hashOfConfig":"548"},{"size":3561,"mtime":1596228865137,"results":"818","hashOfConfig":"548"},{"size":2165,"mtime":1596228865137,"results":"819","hashOfConfig":"548"},{"size":271,"mtime":1596228865137,"results":"820","hashOfConfig":"548"},{"size":109,"mtime":1596228865137,"results":"821","hashOfConfig":"548"},{"size":189,"mtime":1596228865137,"results":"822","hashOfConfig":"548"},{"size":206,"mtime":1596228865137,"results":"823","hashOfConfig":"548"},{"size":117,"mtime":1596228865137,"results":"824","hashOfConfig":"548"},{"size":209,"mtime":1596228865137,"results":"825","hashOfConfig":"548"},{"size":210,"mtime":1596228865137,"results":"826","hashOfConfig":"548"},{"size":115,"mtime":1596228865137,"results":"827","hashOfConfig":"548"},{"size":201,"mtime":1596228865137,"results":"828","hashOfConfig":"548"},{"size":210,"mtime":1600455337164,"results":"829","hashOfConfig":"548"},{"size":123,"mtime":1596228865137,"results":"830","hashOfConfig":"548"},{"size":221,"mtime":1596228865137,"results":"831","hashOfConfig":"548"},{"size":214,"mtime":1600455337164,"results":"832","hashOfConfig":"548"},{"size":159,"mtime":1596228865141,"results":"833","hashOfConfig":"548"},{"size":99,"mtime":1596228865141,"results":"834","hashOfConfig":"548"},{"size":713,"mtime":1596228865141,"results":"835","hashOfConfig":"548"},{"size":199,"mtime":1596228865141,"results":"836","hashOfConfig":"548"},{"size":177,"mtime":1596228865137,"results":"837","hashOfConfig":"548"},{"size":125,"mtime":1596228865137,"results":"838","hashOfConfig":"548"},{"size":52,"mtime":1596228865137,"results":"839","hashOfConfig":"548"},{"size":4384,"mtime":1600804786115,"results":"840","hashOfConfig":"548"},{"size":72,"mtime":1596228865137,"results":"841","hashOfConfig":"548"},{"size":8113,"mtime":1600457727455,"results":"842","hashOfConfig":"548"},{"size":2657,"mtime":1600804786143,"results":"843","hashOfConfig":"548"},{"size":41218,"mtime":1601927580432,"results":"844","hashOfConfig":"548"},{"size":12882,"mtime":1601927580536,"results":"845","hashOfConfig":"548"},{"size":105,"mtime":1596228865141,"results":"846","hashOfConfig":"548"},{"size":2914,"mtime":1596228865141,"results":"847","hashOfConfig":"548"},{"size":316,"mtime":1596228865141,"results":"848","hashOfConfig":"548"},{"size":6539,"mtime":1596229427362,"results":"849","hashOfConfig":"548"},{"size":4123,"mtime":1596229427362,"results":"850","hashOfConfig":"548"},{"size":168,"mtime":1596228865141,"results":"851","hashOfConfig":"548"},{"size":3775,"mtime":1599680404366,"results":"852","hashOfConfig":"548"},{"size":23764,"mtime":1600804786835,"results":"853","hashOfConfig":"548"},{"size":12310,"mtime":1602350238986,"results":"854","hashOfConfig":"548"},{"size":50,"mtime":1596228865141,"results":"855","hashOfConfig":"548"},{"size":226,"mtime":1596228865141,"results":"856","hashOfConfig":"548"},{"size":534,"mtime":1596228865141,"results":"857","hashOfConfig":"548"},{"size":245,"mtime":1596228865141,"results":"858","hashOfConfig":"548"},{"size":270,"mtime":1596228865141,"results":"859","hashOfConfig":"548"},{"size":7621,"mtime":1600457728075,"results":"860","hashOfConfig":"548"},{"size":2471,"mtime":1600457728111,"results":"861","hashOfConfig":"548"},{"size":218,"mtime":1596228865141,"results":"862","hashOfConfig":"548"},{"size":1314,"mtime":1601404609791,"results":"863","hashOfConfig":"548"},{"size":37038,"mtime":1602014411964,"results":"864","hashOfConfig":"548"},{"size":6555,"mtime":1601665109054,"results":"865","hashOfConfig":"548"},{"size":161,"mtime":1596228865141,"results":"866","hashOfConfig":"548"},{"size":126,"mtime":1596228865141,"results":"867","hashOfConfig":"548"},{"size":2905,"mtime":1596228865141,"results":"868","hashOfConfig":"548"},{"size":218,"mtime":1596228865141,"results":"869","hashOfConfig":"548"},{"size":157,"mtime":1596228865141,"results":"870","hashOfConfig":"548"},{"size":677,"mtime":1596228865141,"results":"871","hashOfConfig":"548"},{"size":1470,"mtime":1596228865141,"results":"872","hashOfConfig":"548"},{"size":73,"mtime":1596228865141,"results":"873","hashOfConfig":"548"},{"size":763,"mtime":1601232768984,"results":"874","hashOfConfig":"548"},{"size":155,"mtime":1596228865141,"results":"875","hashOfConfig":"548"},{"size":3803,"mtime":1596228865141,"results":"876","hashOfConfig":"548"},{"size":205,"mtime":1596228865141,"results":"877","hashOfConfig":"548"},{"size":287,"mtime":1596228865141,"results":"878","hashOfConfig":"548"},{"size":542,"mtime":1596228865141,"results":"879","hashOfConfig":"548"},{"size":9243,"mtime":1596228865141,"results":"880","hashOfConfig":"548"},{"size":286,"mtime":1596228865141,"results":"881","hashOfConfig":"548"},{"size":1178,"mtime":1596228865141,"results":"882","hashOfConfig":"548"},{"size":39263,"mtime":1600804787403,"results":"883","hashOfConfig":"548"},{"size":1846,"mtime":1600804787431,"results":"884","hashOfConfig":"548"},{"size":260,"mtime":1596228865141,"results":"885","hashOfConfig":"548"},{"size":581,"mtime":1601317505315,"results":"886","hashOfConfig":"548"},{"size":2568,"mtime":1601401517578,"results":"887","hashOfConfig":"548"},{"size":14585,"mtime":1601737585360,"results":"888","hashOfConfig":"548"},{"size":709,"mtime":1599758849225,"results":"889","hashOfConfig":"548"},{"size":122,"mtime":1596228865141,"results":"890","hashOfConfig":"548"},{"size":3980,"mtime":1597690277860,"results":"891","hashOfConfig":"548"},{"size":1044,"mtime":1596228865141,"results":"892","hashOfConfig":"548"},{"size":38,"mtime":1596228865141,"results":"893","hashOfConfig":"548"},{"size":42,"mtime":1596228865141,"results":"894","hashOfConfig":"548"},{"size":1397,"mtime":1596228865141,"results":"895","hashOfConfig":"548"},{"size":72,"mtime":1596228865141,"results":"896","hashOfConfig":"548"},{"size":434,"mtime":1596228865141,"results":"897","hashOfConfig":"548"},{"size":54,"mtime":1596228865141,"results":"898","hashOfConfig":"548"},{"size":148,"mtime":1596228865141,"results":"899","hashOfConfig":"548"},{"size":27,"mtime":1596228865141,"results":"900","hashOfConfig":"548"},{"size":228,"mtime":1596228865141,"results":"901","hashOfConfig":"548"},{"size":71,"mtime":1596228865141,"results":"902","hashOfConfig":"548"},{"size":78,"mtime":1596228865141,"results":"903","hashOfConfig":"548"},{"size":206,"mtime":1596228865141,"results":"904","hashOfConfig":"548"},{"size":37,"mtime":1596228865141,"results":"905","hashOfConfig":"548"},{"size":1749,"mtime":1596228865141,"results":"906","hashOfConfig":"548"},{"size":49,"mtime":1596228865141,"results":"907","hashOfConfig":"548"},{"size":1713,"mtime":1596228865141,"results":"908","hashOfConfig":"548"},{"size":480,"mtime":1596228865141,"results":"909","hashOfConfig":"548"},{"size":56,"mtime":1596228865141,"results":"910","hashOfConfig":"548"},{"size":153,"mtime":1596228865141,"results":"911","hashOfConfig":"548"},{"size":1262,"mtime":1596228865141,"results":"912","hashOfConfig":"548"},{"size":58,"mtime":1596228865141,"results":"913","hashOfConfig":"548"},{"size":592,"mtime":1596228865141,"results":"914","hashOfConfig":"548"},{"size":113,"mtime":1596228865141,"results":"915","hashOfConfig":"548"},{"size":113,"mtime":1602351384831,"results":"916","hashOfConfig":"548"},{"size":27,"mtime":1596228865141,"results":"917","hashOfConfig":"548"},{"size":40,"mtime":1596228865141,"results":"918","hashOfConfig":"548"},{"size":534,"mtime":1596228865141,"results":"919","hashOfConfig":"548"},{"size":260,"mtime":1601735328664,"results":"920","hashOfConfig":"548"},{"size":215,"mtime":1596228865141,"results":"921","hashOfConfig":"548"},{"size":1344,"mtime":1601148185598,"results":"922","hashOfConfig":"548"},{"size":385,"mtime":1596228865141,"results":"923","hashOfConfig":"548"},{"size":23,"mtime":1596228865141,"results":"924","hashOfConfig":"548"},{"size":11616,"mtime":1596228865141,"results":"925","hashOfConfig":"548"},{"size":35,"mtime":1596228865141,"results":"926","hashOfConfig":"548"},{"size":51,"mtime":1596228865141,"results":"927","hashOfConfig":"548"},{"size":48,"mtime":1596228865141,"results":"928","hashOfConfig":"548"},{"size":35,"mtime":1596228865141,"results":"929","hashOfConfig":"548"},{"size":33,"mtime":1596228865141,"results":"930","hashOfConfig":"548"},{"size":1466,"mtime":1596229427366,"results":"931","hashOfConfig":"548"},{"size":31,"mtime":1596228865141,"results":"932","hashOfConfig":"548"},{"size":30,"mtime":1596228865141,"results":"933","hashOfConfig":"548"},{"size":256,"mtime":1596228865141,"results":"934","hashOfConfig":"548"},{"size":237,"mtime":1596228865141,"results":"935","hashOfConfig":"548"},{"size":88,"mtime":1596228865141,"results":"936","hashOfConfig":"548"},{"size":37,"mtime":1596228865141,"results":"937","hashOfConfig":"548"},{"size":40,"mtime":1596228865141,"results":"938","hashOfConfig":"548"},{"size":274,"mtime":1596228865141,"results":"939","hashOfConfig":"548"},{"size":25,"mtime":1596228865141,"results":"940","hashOfConfig":"548"},{"size":393,"mtime":1596228865141,"results":"941","hashOfConfig":"548"},{"size":28,"mtime":1596228865141,"results":"942","hashOfConfig":"548"},{"size":2965,"mtime":1596228865145,"results":"943","hashOfConfig":"548"},{"size":261,"mtime":1596228865145,"results":"944","hashOfConfig":"548"},{"size":1233,"mtime":1596228865145,"results":"945","hashOfConfig":"548"},{"size":43,"mtime":1596228865145,"results":"946","hashOfConfig":"548"},{"size":29,"mtime":1596228865145,"results":"947","hashOfConfig":"548"},{"size":261,"mtime":1600196006744,"results":"948","hashOfConfig":"548"},{"size":338,"mtime":1596228865145,"results":"949","hashOfConfig":"548"},{"size":5586,"mtime":1601735328736,"results":"950","hashOfConfig":"548"},{"size":72,"mtime":1596228865145,"results":"951","hashOfConfig":"548"},{"size":2441,"mtime":1596228865145,"results":"952","hashOfConfig":"548"},{"size":266,"mtime":1596228865145,"results":"953","hashOfConfig":"548"},{"size":2445,"mtime":1601729898027,"results":"954","hashOfConfig":"548"},{"size":1190,"mtime":1601144101370,"results":"955","hashOfConfig":"548"},{"size":1540,"mtime":1596228865145,"results":"956","hashOfConfig":"548"},{"size":345,"mtime":1596228865145,"results":"957","hashOfConfig":"548"},{"size":527,"mtime":1596228865145,"results":"958","hashOfConfig":"548"},{"size":38,"mtime":1596228865145,"results":"959","hashOfConfig":"548"},{"size":573,"mtime":1601148185802,"results":"960","hashOfConfig":"548"},{"size":66,"mtime":1596228865145,"results":"961","hashOfConfig":"548"},{"size":3866,"mtime":1596228865145,"results":"962","hashOfConfig":"548"},{"size":178,"mtime":1596228865145,"results":"963","hashOfConfig":"548"},{"size":176,"mtime":1596228865145,"results":"964","hashOfConfig":"548"},{"size":145,"mtime":1601735328876,"results":"965","hashOfConfig":"548"},{"size":532,"mtime":1596228865145,"results":"966","hashOfConfig":"548"},{"size":63,"mtime":1596228865145,"results":"967","hashOfConfig":"548"},{"size":50,"mtime":1596228865145,"results":"968","hashOfConfig":"548"},{"size":142,"mtime":1596228865145,"results":"969","hashOfConfig":"548"},{"size":1750,"mtime":1596228865145,"results":"970","hashOfConfig":"548"},{"size":136,"mtime":1596228865145,"results":"971","hashOfConfig":"548"},{"size":2250,"mtime":1596228865145,"results":"972","hashOfConfig":"548"},{"size":303,"mtime":1596228865145,"results":"973","hashOfConfig":"548"},{"size":13200,"mtime":1596228865145,"results":"974","hashOfConfig":"548"},{"size":497,"mtime":1596228865145,"results":"975","hashOfConfig":"548"},{"size":1992,"mtime":1596228865145,"results":"976","hashOfConfig":"548"},{"size":2317,"mtime":1596228865145,"results":"977","hashOfConfig":"548"},{"size":986,"mtime":1596228865145,"results":"978","hashOfConfig":"548"},{"size":48,"mtime":1596228865145,"results":"979","hashOfConfig":"548"},{"size":90,"mtime":1596228865145,"results":"980","hashOfConfig":"548"},{"size":281,"mtime":1596228865145,"results":"981","hashOfConfig":"548"},{"size":6713,"mtime":1596228865145,"results":"982","hashOfConfig":"548"},{"size":89,"mtime":1596228865145,"results":"983","hashOfConfig":"548"},{"size":1920,"mtime":1596228865145,"results":"984","hashOfConfig":"548"},{"size":2301,"mtime":1596228865145,"results":"985","hashOfConfig":"548"},{"size":2307,"mtime":1596228865145,"results":"986","hashOfConfig":"548"},{"size":4384,"mtime":1596228865145,"results":"987","hashOfConfig":"548"},{"size":141,"mtime":1596228865145,"results":"988","hashOfConfig":"548"},{"size":405,"mtime":1596228865145,"results":"989","hashOfConfig":"548"},{"size":10164,"mtime":1596228865145,"results":"990","hashOfConfig":"548"},{"size":153,"mtime":1596228865145,"results":"991","hashOfConfig":"548"},{"size":186,"mtime":1596228865145,"results":"992","hashOfConfig":"548"},{"size":3133,"mtime":1596228865145,"results":"993","hashOfConfig":"548"},{"size":132,"mtime":1596228865145,"results":"994","hashOfConfig":"548"},{"size":778,"mtime":1596228865145,"results":"995","hashOfConfig":"548"},{"size":633,"mtime":1596228865145,"results":"996","hashOfConfig":"548"},{"size":77,"mtime":1596228865145,"results":"997","hashOfConfig":"548"},{"size":547,"mtime":1596228865145,"results":"998","hashOfConfig":"548"},{"size":34,"mtime":1596228865145,"results":"999","hashOfConfig":"548"},{"size":706,"mtime":1599251468998,"results":"1000","hashOfConfig":"548"},{"size":1478,"mtime":1596228865145,"results":"1001","hashOfConfig":"548"},{"size":91,"mtime":1596228865145,"results":"1002","hashOfConfig":"548"},{"size":75,"mtime":1596228865145,"results":"1003","hashOfConfig":"548"},{"size":34,"mtime":1596228865145,"results":"1004","hashOfConfig":"548"},{"size":672,"mtime":1596228865145,"results":"1005","hashOfConfig":"548"},{"size":67,"mtime":1596142287416,"results":"1006","hashOfConfig":"1007"},{"size":81,"mtime":1596142634503,"results":"1008","hashOfConfig":"1007"},{"size":348,"mtime":1596142287416,"results":"1009","hashOfConfig":"1007"},{"size":8741,"mtime":1596142287416,"results":"1010","hashOfConfig":"1007"},{"size":1986,"mtime":1596142287416,"results":"1011","hashOfConfig":"1007"},{"size":799,"mtime":1596142287416,"results":"1012","hashOfConfig":"1007"},{"size":38,"mtime":1596228865145,"results":"1013","hashOfConfig":"548"},{"size":560,"mtime":1596228865145,"results":"1014","hashOfConfig":"548"},{"size":718,"mtime":1596228865145,"results":"1015","hashOfConfig":"548"},{"size":3088,"mtime":1596228865145,"results":"1016","hashOfConfig":"548"},{"size":5878,"mtime":1596228865145,"results":"1017","hashOfConfig":"548"},{"size":2767,"mtime":1599251469042,"results":"1018","hashOfConfig":"548"},{"size":213,"mtime":1596228865145,"results":"1019","hashOfConfig":"548"},{"size":2121,"mtime":1599249695237,"results":"1020","hashOfConfig":"548"},{"size":473,"mtime":1596228865145,"results":"1021","hashOfConfig":"548"},{"size":575,"mtime":1596228865145,"results":"1022","hashOfConfig":"548"},{"size":462,"mtime":1596228865145,"results":"1023","hashOfConfig":"548"},{"size":3985,"mtime":1596228865145,"results":"1024","hashOfConfig":"548"},{"size":137,"mtime":1596228865145,"results":"1025","hashOfConfig":"548"},{"size":1042,"mtime":1596228865145,"results":"1026","hashOfConfig":"548"},{"size":564,"mtime":1596228865145,"results":"1027","hashOfConfig":"548"},{"size":1175,"mtime":1596228865145,"results":"1028","hashOfConfig":"548"},{"size":31,"mtime":1597690277860,"results":"1029","hashOfConfig":"548"},{"size":792,"mtime":1597690277860,"results":"1030","hashOfConfig":"548"},{"size":137,"mtime":1599302612423,"results":"1031","hashOfConfig":"548"},{"size":344,"mtime":1599307338745,"results":"1032","hashOfConfig":"548"},{"size":8611,"mtime":1599420101695,"results":"1033","hashOfConfig":"548"},{"size":3626,"mtime":1599767254839,"results":"1034","hashOfConfig":"548"},{"size":143,"mtime":1600803588450,"results":"1035","hashOfConfig":"548"},{"size":30217,"mtime":1601927580984,"results":"1036","hashOfConfig":"548"},{"size":14512,"mtime":1602360285796,"results":"1037","hashOfConfig":"548"},{"size":37,"mtime":1596229427366,"results":"1038","hashOfConfig":"548"},{"size":1359,"mtime":1599854391758,"results":"1039","hashOfConfig":"548"},{"size":53,"mtime":1599758544823,"results":"1040","hashOfConfig":"548"},{"size":10789,"mtime":1602014412116,"results":"1041","hashOfConfig":"548"},{"size":1350,"mtime":1601927581328,"results":"1042","hashOfConfig":"548"},{"size":4984,"mtime":1602014412212,"results":"1043","hashOfConfig":"548"},{"size":44,"mtime":1599758328791,"results":"1044","hashOfConfig":"548"},{"size":4579,"mtime":1599854392018,"results":"1045","hashOfConfig":"548"},{"size":191,"mtime":1599915233531,"results":"1046","hashOfConfig":"548"},{"size":46,"mtime":1600195027328,"results":"1047","hashOfConfig":"548"},{"size":3765,"mtime":1601322489544,"results":"1048","hashOfConfig":"548"},{"size":50,"mtime":1600196623925,"results":"1049","hashOfConfig":"548"},{"size":127,"mtime":1600279163479,"results":"1050","hashOfConfig":"548"},{"size":440,"mtime":1600279448865,"results":"1051","hashOfConfig":"548"},{"size":8834,"mtime":1601318086035,"results":"1052","hashOfConfig":"548"},{"size":3706,"mtime":1600454545455,"results":"1053","hashOfConfig":"548"},{"size":1144,"mtime":1601405120753,"results":"1054","hashOfConfig":"548"},{"size":92,"mtime":1601671709894,"results":"1055","hashOfConfig":"548"},{"size":164,"mtime":1600524475842,"results":"1056","hashOfConfig":"548"},{"size":144,"mtime":1600524767782,"results":"1057","hashOfConfig":"548"},{"size":1400,"mtime":1601405121661,"results":"1058","hashOfConfig":"548"},{"size":471,"mtime":1601322287022,"results":"1059","hashOfConfig":"548"},{"size":49,"mtime":1601232705716,"results":"1060","hashOfConfig":"548"},{"size":49,"mtime":1601232709956,"results":"1061","hashOfConfig":"548"},{"size":54693,"mtime":1602360285436,"results":"1062","hashOfConfig":"548"},{"size":67,"mtime":1601130014858,"results":"1063","hashOfConfig":"548"},{"size":1610,"mtime":1602014411192,"results":"1064","hashOfConfig":"548"},{"size":2117,"mtime":1601148184806,"results":"1065","hashOfConfig":"548"},{"size":230,"mtime":1601148185702,"results":"1066","hashOfConfig":"548"},{"size":802,"mtime":1601669163350,"results":"1067","hashOfConfig":"548"},{"size":1540,"mtime":1601735328844,"results":"1068","hashOfConfig":"548"},{"size":1011,"mtime":1602351672665,"results":"1069","hashOfConfig":"548"},{"size":595,"mtime":1601405121381,"results":"1070","hashOfConfig":"548"},{"size":46,"mtime":1601316618931,"results":"1071","hashOfConfig":"548"},{"size":623,"mtime":1601840573514,"results":"1072","hashOfConfig":"548"},{"size":519,"mtime":1601672464467,"results":"1073","hashOfConfig":"548"},{"size":66,"mtime":1601731488823,"results":"1074","hashOfConfig":"548"},{"size":1521,"mtime":1602358343519,"results":"1075","hashOfConfig":"548"},{"size":4959,"mtime":1602360285488,"results":"1076","hashOfConfig":"548"},{"size":56,"mtime":1602358832026,"results":"1077","hashOfConfig":"548"},{"size":360,"mtime":1602360285060,"results":"1078","hashOfConfig":"548"},{"size":137,"mtime":1602347160380,"results":"1079","hashOfConfig":"548"},{"size":7549,"mtime":1602360285584,"results":"1080","hashOfConfig":"548"},{"size":960,"mtime":1602360285608,"results":"1081","hashOfConfig":"548"},{"size":965,"mtime":1602360285644,"results":"1082","hashOfConfig":"548"},{"size":103,"mtime":1602360285668,"results":"1083","hashOfConfig":"548"},{"size":57,"mtime":1602360250808,"results":"1084","hashOfConfig":"548"},{"size":4247,"mtime":1602360285712,"results":"1085","hashOfConfig":"548"},{"filePath":"1086","messages":"1087","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"5wmogl",{"filePath":"1088","messages":"1089","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"1090","messages":"1091","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"1092","messages":"1093","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"1094","messages":"1095","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"koaha4",{"filePath":"1096","messages":"1097","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1098","messages":"1099","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1100","messages":"1101","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1102","messages":"1103","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1104","messages":"1105","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1106","messages":"1107","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1108"},{"filePath":"1109","messages":"1110","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1111"},{"filePath":"1112","messages":"1113","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1114"},{"filePath":"1115","messages":"1116","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1117","messages":"1118","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1119","messages":"1120","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1121","messages":"1122","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1123","messages":"1124","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1125"},{"filePath":"1126","messages":"1127","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1128","messages":"1129","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1130"},{"filePath":"1131","messages":"1132","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1133","messages":"1134","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1135"},{"filePath":"1136","messages":"1137","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1138"},{"filePath":"1139","messages":"1140","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1141","messages":"1142","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1143"},{"filePath":"1144","messages":"1145","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1146","messages":"1147","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1148"},{"filePath":"1149","messages":"1150","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1151","messages":"1152","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1153","messages":"1154","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1155","messages":"1156","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1157","messages":"1158","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1159","messages":"1160","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1161","messages":"1162","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1163","messages":"1164","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1165","messages":"1166","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1167","messages":"1168","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1169","messages":"1170","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1171","messages":"1172","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1173","messages":"1174","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1175","messages":"1176","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1177","messages":"1178","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1179","messages":"1180","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1181","messages":"1182","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1183","messages":"1184","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1185","messages":"1186","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1187","messages":"1188","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1189"},{"filePath":"1190","messages":"1191","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1192","messages":"1193","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1194","messages":"1195","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1196","messages":"1197","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1198","messages":"1199","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1200","messages":"1201","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1202","messages":"1203","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1204","messages":"1205","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1206","messages":"1207","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1208","messages":"1209","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1210","messages":"1211","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1212","messages":"1213","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1214","messages":"1215","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1216"},{"filePath":"1217","messages":"1218","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1219","messages":"1220","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1221","messages":"1222","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1223","messages":"1224","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1225","messages":"1226","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1227","messages":"1228","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1229","messages":"1230","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1231","messages":"1232","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1233","messages":"1234","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1235","messages":"1236","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1237"},{"filePath":"1238","messages":"1239","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1240","messages":"1241","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1242","messages":"1243","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1244","messages":"1245","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1246","messages":"1247","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1248","messages":"1249","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1250","messages":"1251","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1252","messages":"1253","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1254","messages":"1255","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1256"},{"filePath":"1257","messages":"1258","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1259"},{"filePath":"1260","messages":"1261","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1262","messages":"1263","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1264","messages":"1265","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1266"},{"filePath":"1267","messages":"1268","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1269","messages":"1270","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1271","messages":"1272","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1273","messages":"1274","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1275","messages":"1276","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1277","messages":"1278","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1279","messages":"1280","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1281","messages":"1282","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1283","messages":"1284","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1285","messages":"1286","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1287"},{"filePath":"1288","messages":"1289","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1290","messages":"1291","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1292","messages":"1293","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1294"},{"filePath":"1295","messages":"1296","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1297"},{"filePath":"1298","messages":"1299","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1300","messages":"1301","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1302","messages":"1303","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1304"},{"filePath":"1305","messages":"1306","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1307","messages":"1308","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1309","messages":"1310","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1311"},{"filePath":"1312","messages":"1313","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1314","messages":"1315","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1316","messages":"1317","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1318","messages":"1319","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1320","messages":"1321","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1322","messages":"1323","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1324","messages":"1325","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1326","messages":"1327","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1328","messages":"1329","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1330","messages":"1331","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1332","messages":"1333","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1334","messages":"1335","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1336","messages":"1337","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1338","messages":"1339","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1340","messages":"1341","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1342"},{"filePath":"1343","messages":"1344","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1345","messages":"1346","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1347","messages":"1348","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1349","messages":"1350","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1351","messages":"1352","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1353","messages":"1354","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1355","messages":"1356","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1357"},{"filePath":"1358","messages":"1359","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1360","messages":"1361","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1362","messages":"1363","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1364","messages":"1365","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1366","messages":"1367","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1368","messages":"1369","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1370","messages":"1371","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1372","messages":"1373","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1374","messages":"1375","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1376","messages":"1377","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1378","messages":"1379","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1380","messages":"1381","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1382","messages":"1383","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1384","messages":"1385","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1386","messages":"1387","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1388","messages":"1389","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1390","messages":"1391","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1392","messages":"1393","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1394","messages":"1395","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1396"},{"filePath":"1397","messages":"1398","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1399"},{"filePath":"1400","messages":"1401","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1402","messages":"1403","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1404","messages":"1405","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1406","messages":"1407","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1408","messages":"1409","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1410","messages":"1411","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1412","messages":"1413","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1414","messages":"1415","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1416"},{"filePath":"1417","messages":"1418","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1419","messages":"1420","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1421","messages":"1422","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1423","messages":"1424","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1425","messages":"1426","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1427","messages":"1428","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1429"},{"filePath":"1430","messages":"1431","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1432","messages":"1433","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1434","messages":"1435","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1436"},{"filePath":"1437","messages":"1438","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1439","messages":"1440","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1441","messages":"1442","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1443","messages":"1444","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1445","messages":"1446","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1447"},{"filePath":"1448","messages":"1449","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1450"},{"filePath":"1451","messages":"1452","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1453","messages":"1454","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1455","messages":"1456","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1457"},{"filePath":"1458","messages":"1459","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1460","messages":"1461","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1462","messages":"1463","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1464","messages":"1465","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1466"},{"filePath":"1467","messages":"1468","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1469","messages":"1470","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1471","messages":"1472","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1473","messages":"1474","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1475"},{"filePath":"1476","messages":"1477","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1478","messages":"1479","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1480"},{"filePath":"1481","messages":"1482","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1483","messages":"1484","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1485","messages":"1486","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1487","messages":"1488","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1489","messages":"1490","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1491","messages":"1492","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1493","messages":"1494","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1495","messages":"1496","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1497","messages":"1498","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1499"},{"filePath":"1500","messages":"1501","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1502"},{"filePath":"1503","messages":"1504","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1505","messages":"1506","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1507","messages":"1508","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1509","messages":"1510","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1511"},{"filePath":"1512","messages":"1513","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1514","messages":"1515","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1516","messages":"1517","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1518","messages":"1519","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1520","messages":"1521","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1522","messages":"1523","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1524","messages":"1525","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1526","messages":"1527","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1528"},{"filePath":"1529","messages":"1530","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1531","messages":"1532","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1533","messages":"1534","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1535","messages":"1536","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1537"},{"filePath":"1538","messages":"1539","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1540","messages":"1541","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1542","messages":"1543","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1544","messages":"1545","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1546"},{"filePath":"1547","messages":"1548","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1549"},{"filePath":"1550","messages":"1551","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1552","messages":"1553","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1554","messages":"1555","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1556","messages":"1557","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1558"},{"filePath":"1559","messages":"1560","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1561","messages":"1562","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1563","messages":"1564","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1565","messages":"1566","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1567","messages":"1568","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1569","messages":"1570","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1571","messages":"1572","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1573","messages":"1574","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1575","messages":"1576","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1577","messages":"1578","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1579","messages":"1580","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1581","messages":"1582","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1583","messages":"1584","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1585","messages":"1586","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1587","messages":"1588","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1589","messages":"1590","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1591","messages":"1592","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1593","messages":"1594","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1595"},{"filePath":"1596","messages":"1597","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1598","messages":"1599","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1600","messages":"1601","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1602","messages":"1603","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1604"},{"filePath":"1605","messages":"1606","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1607","messages":"1608","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1609","messages":"1610","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1611","messages":"1612","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1613","messages":"1614","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1615","messages":"1616","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1617","messages":"1618","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1619","messages":"1620","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1621","messages":"1622","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1623","messages":"1624","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1625","messages":"1626","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1627","messages":"1628","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1629","messages":"1630","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1631","messages":"1632","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1633","messages":"1634","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1635","messages":"1636","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1637","messages":"1638","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1639","messages":"1640","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1641","messages":"1642","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1643","messages":"1644","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1645","messages":"1646","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1647","messages":"1648","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1649","messages":"1650","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1651","messages":"1652","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1653","messages":"1654","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1655","messages":"1656","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1657","messages":"1658","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1659","messages":"1660","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1661","messages":"1662","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1663","messages":"1664","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1665","messages":"1666","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1667"},{"filePath":"1668","messages":"1669","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1670","messages":"1671","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1672","messages":"1673","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1674","messages":"1675","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1676","messages":"1677","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1678","messages":"1679","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1680","messages":"1681","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1682","messages":"1683","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1684","messages":"1685","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1686","messages":"1687","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1688","messages":"1689","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1690","messages":"1691","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1692","messages":"1693","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1694","messages":"1695","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1696","messages":"1697","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1698","messages":"1699","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1700","messages":"1701","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1702","messages":"1703","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1704","messages":"1705","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1706","messages":"1707","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1708","messages":"1709","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1710","messages":"1711","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1712","messages":"1713","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1714"},{"filePath":"1715","messages":"1716","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1717","messages":"1718","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1719","messages":"1720","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1721","messages":"1722","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1723","messages":"1724","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1725","messages":"1726","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1727","messages":"1728","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1729"},{"filePath":"1730","messages":"1731","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1732","messages":"1733","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1734"},{"filePath":"1735","messages":"1736","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1737"},{"filePath":"1738","messages":"1739","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1740","messages":"1741","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1742","messages":"1743","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1744","messages":"1745","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1746"},{"filePath":"1747","messages":"1748","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1749","messages":"1750","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1751","messages":"1752","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1753","messages":"1754","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1755","messages":"1756","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"1757","messages":"1758","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1759","messages":"1760","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1761","messages":"1762","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1763","messages":"1764","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1765","messages":"1766","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1767","messages":"1768","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1769"},{"filePath":"1770","messages":"1771","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1772","messages":"1773","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1774","messages":"1775","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1776","messages":"1777","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1778"},{"filePath":"1779","messages":"1780","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1781"},{"filePath":"1782","messages":"1783","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1784","messages":"1785","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1786","messages":"1787","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1788"},{"filePath":"1789","messages":"1790","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1791","messages":"1792","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1793","messages":"1794","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1795","messages":"1796","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1797","messages":"1798","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1799","messages":"1800","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1801","messages":"1802","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1803","messages":"1804","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1805"},{"filePath":"1806","messages":"1807","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1808","messages":"1809","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1810","messages":"1811","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1812","messages":"1813","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1814"},{"filePath":"1815","messages":"1816","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1817","messages":"1818","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1819","messages":"1820","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1821"},{"filePath":"1822","messages":"1823","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1824","messages":"1825","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1826","messages":"1827","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1828"},{"filePath":"1829","messages":"1830","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1831","messages":"1832","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1833"},{"filePath":"1834","messages":"1835","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1836"},{"filePath":"1837","messages":"1838","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1839","messages":"1840","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1841"},{"filePath":"1842","messages":"1843","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1844"},{"filePath":"1845","messages":"1846","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1847","messages":"1848","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1849","messages":"1850","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1851","messages":"1852","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1853","messages":"1854","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1855","messages":"1856","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1857","messages":"1858","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1859","messages":"1860","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1861","messages":"1862","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1863","messages":"1864","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1865","messages":"1866","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1867","messages":"1868","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1869","messages":"1870","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1871","messages":"1872","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1873","messages":"1874","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1875","messages":"1876","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1877","messages":"1878","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1879","messages":"1880","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1881","messages":"1882","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1883","messages":"1884","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1885","messages":"1886","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1887","messages":"1888","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1889","messages":"1890","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1891","messages":"1892","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1893","messages":"1894","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1895","messages":"1896","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1897","messages":"1898","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1899","messages":"1900","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1901","messages":"1902","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1903","messages":"1904","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1905"},{"filePath":"1906","messages":"1907","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1908","messages":"1909","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1910","messages":"1911","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1912","messages":"1913","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1914","messages":"1915","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1916","messages":"1917","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1918","messages":"1919","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1920","messages":"1921","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1922","messages":"1923","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1924","messages":"1925","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1926","messages":"1927","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1928","messages":"1929","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1930"},{"filePath":"1931","messages":"1932","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1933"},{"filePath":"1934","messages":"1935","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1936","messages":"1937","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1938","messages":"1939","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1940","messages":"1941","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1942"},{"filePath":"1943","messages":"1944","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1945","messages":"1946","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1947","messages":"1948","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1949","messages":"1950","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1951","messages":"1952","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1953","messages":"1954","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1955"},{"filePath":"1956","messages":"1957","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1958","messages":"1959","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1960","messages":"1961","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1962","messages":"1963","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1964","messages":"1965","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1966"},{"filePath":"1967","messages":"1968","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1969"},{"filePath":"1970","messages":"1971","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1972","messages":"1973","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1974","messages":"1975","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1976"},{"filePath":"1977","messages":"1978","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1979","messages":"1980","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1981"},{"filePath":"1982","messages":"1983","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1984","messages":"1985","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1986","messages":"1987","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1988","messages":"1989","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1990","messages":"1991","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1992","messages":"1993","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1994","messages":"1995","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1996","messages":"1997","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1998","messages":"1999","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2000","messages":"2001","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2002","messages":"2003","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2004","messages":"2005","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2006","messages":"2007","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2008","messages":"2009","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2010","messages":"2011","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2012","messages":"2013","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2014","messages":"2015","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2016","messages":"2017","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2018"},{"filePath":"2019","messages":"2020","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2021"},{"filePath":"2022","messages":"2023","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2024"},{"filePath":"2025","messages":"2026","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2027"},{"filePath":"2028","messages":"2029","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2030"},{"filePath":"2031","messages":"2032","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2033","messages":"2034","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2035","messages":"2036","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2037","messages":"2038","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2039"},{"filePath":"2040","messages":"2041","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2042","messages":"2043","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2044","messages":"2045","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2046","messages":"2047","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2048","messages":"2049","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2050"},{"filePath":"2051","messages":"2052","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2053","messages":"2054","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2055","messages":"2056","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2057"},{"filePath":"2058","messages":"2059","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2060","messages":"2061","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2062","messages":"2063","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2064","messages":"2065","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2066","messages":"2067","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2068","messages":"2069","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2070","messages":"2071","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2072","messages":"2073","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2074","messages":"2075","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2076","messages":"2077","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2078","messages":"2079","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2080","messages":"2081","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2082","messages":"2083","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2084","messages":"2085","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2086","messages":"2087","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2088","messages":"2089","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"slcij1",{"filePath":"2090","messages":"2091","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"2092","messages":"2093","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2094","messages":"2095","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2096"},{"filePath":"2097","messages":"2098","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2099"},{"filePath":"2100","messages":"2101","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2102"},{"filePath":"2103","messages":"2104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2105","messages":"2106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2107","messages":"2108","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2109","messages":"2110","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2111","messages":"2112","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2113","messages":"2114","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2115","messages":"2116","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2117","messages":"2118","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2119","messages":"2120","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2121","messages":"2122","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2123"},{"filePath":"2124","messages":"2125","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2126","messages":"2127","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2128","messages":"2129","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2130","messages":"2131","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2132","messages":"2133","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2134","messages":"2135","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2136"},{"filePath":"2137","messages":"2138","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2139","messages":"2140","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2141","messages":"2142","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2143","messages":"2144","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2145","messages":"2146","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2147"},{"filePath":"2148","messages":"2149","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2150"},{"filePath":"2151","messages":"2152","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2153","messages":"2154","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2155"},{"filePath":"2156","messages":"2157","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"2158","messages":"2159","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2160","messages":"2161","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2162","messages":"2163","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2164","messages":"2165","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2166"},{"filePath":"2167","messages":"2168","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2169","messages":"2170","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2171"},{"filePath":"2172","messages":"2173","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2174","messages":"2175","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2176"},{"filePath":"2177","messages":"2178","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2179"},{"filePath":"2180","messages":"2181","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2182","messages":"2183","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2184"},{"filePath":"2185","messages":"2186","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2187","messages":"2188","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2189","messages":"2190","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2191","messages":"2192","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2193","messages":"2194","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2195","messages":"2196","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2197","messages":"2198","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2199","messages":"2200","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2201","messages":"2202","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2203","messages":"2204","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2205"},{"filePath":"2206","messages":"2207","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2208"},{"filePath":"2209","messages":"2210","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2211","messages":"2212","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2213","messages":"2214","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"2215","messages":"2216","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2217","messages":"2218","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2219"},{"filePath":"2220","messages":"2221","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2222"},{"filePath":"2223","messages":"2224","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2225"},{"filePath":"2226","messages":"2227","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2228"},{"filePath":"2229","messages":"2230","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2231"},{"filePath":"2232","messages":"2233","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2234","messages":"2235","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2236","messages":"2237","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2238","messages":"2239","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2240","messages":"2241","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2242","messages":"2243","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2244","messages":"2245","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"2246","messages":"2247","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2248","messages":"2249","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2250","messages":"2251","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2252","messages":"2253","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2254","messages":"2255","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2256","messages":"2257","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2258","messages":"2259","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2260","messages":"2261","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2262","messages":"2263","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2264","messages":"2265","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/home/paul/projects/protocol/docs/assets/js/main.js",["2266"],"/home/paul/projects/protocol/docs/assets/js/search.js",["2267"],"/home/paul/projects/protocol/module-build/index.js",["2268"],"/home/paul/projects/protocol/module-build/module-build.js",["2269"],"/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-class.ts",[],"/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-class.types.ts",[],"/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-connections/channel-authority-connection-with-server-api/channel-authority-connection-with-server-api.ts",[],"/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-connections/channel-authority-connection-with-server-api/channel-authority-connection-with-server-api.types.ts",[],"/home/paul/projects/protocol/src/backog-classes/channel-authority-class/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.const.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.ts",["2270","2271","2272","2273","2274","2275","2276"],"import { ASYNC_QUEUE_BASE_CLASS_OPTIONS } from './async-queue-class-base.const';\nimport { extend } from '../../../utils/common-utils/common-utils-objects';\nimport {\n  TAsyncQueueBaseClassPromiseProviderPending,\n  TAsyncQueueBaseClassPromiseProvider,\n} from './async-queue-class-base.types';\nimport {\n  TAsyncQueueBaseClass,\n  IAsyncQueueBaseClassOptions,\n} from './async-queue-class-base.types';\nimport { getRun } from './async-queue-class-base.utils';\nimport { delay } from '../../../utils/common-utils/common-utils-timer';\nimport { TAsyncQueueBaseClassPromiseProviderBatch } from './async-queue-class-base.types';\n\nexport class AsyncQueueClassBase extends TAsyncQueueBaseClass {\n  protected queue: TAsyncQueueBaseClassPromiseProvider<any>[] = [];\n\n  protected batch: Promise<any[]> | void = undefined;\n\n  protected runPromiseProvider?: ReturnType<typeof getRun>;\n\n  constructor(options?: Partial<IAsyncQueueBaseClassOptions>) {\n    super(\n      extend(\n        options || {},\n        ASYNC_QUEUE_BASE_CLASS_OPTIONS\n      ) as IAsyncQueueBaseClassOptions\n    );\n    this.runPromiseProvider = getRun(this.options.promiseTimeout);\n  }\n\n  public do = async <T>(\n    promiseProvider: TAsyncQueueBaseClassPromiseProviderPending<T>\n  ): Promise<T | Error | (T extends any[] ? Array<T | Error> : never)> => {\n    return new Promise((res) => {\n      this.queue.push(() => {\n        return this.createPromise<T>(promiseProvider)\n          .then(res)\n          .catch(res);\n      });\n      this.start();\n    });\n  };\n\n  protected async createBatch(): Promise<any[]> {\n    if (!this.queue.length) {\n      return [];\n    }\n\n    const { options } = this;\n    const promisePendingBatch = this.queue.splice(0, options.batchSize);\n\n    if (!this.runPromiseProvider) {\n      throw new Error('runPromiseProvider is not defined');\n    }\n    return Promise.all(\n      promisePendingBatch.map(this.runPromiseProvider)\n    ).catch((err) => new Array(promisePendingBatch.length).fill(err)); // fill with an error if the batch was rejected\n  }\n\n  protected start = async () => {\n    if (this.batch) {\n      return;\n    }\n    if (!this.queue.length) {\n      return;\n    }\n    this.batch = this.createBatch();\n    try {\n      await this.batch;\n    } catch (err) {\n      console.error('AsyncQueueClassBase::error');\n      console.error(err);\n    }\n\n    const { delayMs } = this.options;\n\n    await delay(delayMs);\n    this.batch = undefined;\n    this.start();\n  };\n\n  protected isBatch<T>(\n    promiseProvider: any\n  ): promiseProvider is TAsyncQueueBaseClassPromiseProviderBatch<T> {\n    return promiseProvider instanceof Array;\n  }\n  protected createPromise<T>(promiseProvider: any): Promise<T | Error>;\n  protected createPromise<T>(promiseProvider: any[]): Promise<Array<T | Error>>;\n  protected createPromise<T>(\n    promiseProvider: TAsyncQueueBaseClassPromiseProviderPending<T>\n  ): Promise<Array<T | Error> | T | Error> {\n    let result;\n\n    if (!this.runPromiseProvider) {\n      throw new Error('runPromiseProvider is not defined');\n    }\n    if (this.isBatch<T>(promiseProvider)) {\n      result = Promise.all(promiseProvider.map(this.runPromiseProvider));\n    } else {\n      result = this.runPromiseProvider(promiseProvider);\n    }\n    this.start();\n    return result;\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.types.ts",["2277","2278"],"export interface IAsyncQueueBaseClassOptions {\n  /**\n   * a number of promises in one batch\n   *\n   * @type {number}\n   * @memberof IAsyncQueueBaseClassOptions\n   */\n  batchSize: number;\n  /**\n   * timeout for a one batch\n   *\n   * @type {number}\n   * @memberof IAsyncQueueBaseClassOptions\n   */\n  promiseTimeout: number;\n  /**\n   * a delay between executing of a two batches\n   *\n   * @type {number}\n   * @memberof IAsyncQueueBaseClassOptions\n   */\n  delayMs: number;\n}\n\nexport type TAsyncQueueBaseClassPromiseProvider<T> = () => Promise<T>;\n\nexport type TAsyncQueueBaseClassPromiseProviderBatch<\n  T\n> = TAsyncQueueBaseClassPromiseProvider<T>[];\n\nexport type TAsyncQueueBaseClassPromiseProviderPending<T> =\n  | TAsyncQueueBaseClassPromiseProvider<T>\n  | TAsyncQueueBaseClassPromiseProviderBatch<T>;\n\nexport interface IAsyncQueueBaseClass {\n  /**\n   * resolve promises provided in queue\n   *\n   * @template T\n   * @param {Promise<T>[]} pending\n   * @returns {(Promise<T | Error>)}\n   * @memberof IAsyncQueueBaseClass\n   */\n  do<T>(\n    pending: TAsyncQueueBaseClassPromiseProviderBatch<T>\n  ): Promise<Array<T | Error> | Error>;\n  do<T>(pending: TAsyncQueueBaseClassPromiseProvider<T>): Promise<T | Error>;\n}\n\nexport abstract class TAsyncQueueBaseClass implements IAsyncQueueBaseClass {\n  /**\n   * queue of promises pending\n   *\n   * @protected\n   * @abstract\n   * @type {(Promise<any>[] | void)}\n   * @memberof TAsyncQueueBaseClass\n   */\n  protected abstract queue: TAsyncQueueBaseClassPromiseProvider<any>[];\n\n  /**\n   * the currently executing batch of a promises\n   *\n   * @protected\n   * @abstract\n   * @type {(Promise<any>[] | void)}\n   * @memberof TAsyncQueueBaseClass\n   */\n  protected abstract batch: Promise<any[]> | void;\n\n  constructor(protected options: IAsyncQueueBaseClassOptions) {}\n\n  public abstract async do<T>(\n    pending: TAsyncQueueBaseClassPromiseProviderPending<T>\n  ): Promise<T | Error | Array<T | Error>>;\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.utils.ts",["2279"],"import { TAsyncQueueBaseClassPromiseProvider } from './async-queue-class-base.types';\nimport { timeout } from '../../../utils/common-utils/common-utils-timer';\n\nconst returnError = (res: any) => {\n  return res instanceof Error ? res : new Error(String(res));\n};\n\nexport const getRun = (timeoutMs: number) => <T>(\n  promiseProvider: TAsyncQueueBaseClassPromiseProvider<T>\n): Promise<T | Error> => {\n  try {\n    return Promise.race([promiseProvider(), timeout(timeoutMs)]).catch(\n      returnError\n    );\n  } catch (err) {\n    return Promise.resolve(err);\n  }\n};\n","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/error-extended-class-base/error-extended-class-base.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/error-extended-scoped-class-base/error-extended-scoped-class-base.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/error-extended-scoped-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/event-emitter-class-base/event-emitter-class-base.ts",["2280","2281"],"import EEmitter from 'events';\nimport TypedEmitter from 'strict-event-emitter-types';\n\nexport class EventEmitter<IEvents extends Record<string, any>> extends EEmitter\n  implements TypedEmitter<EEmitter, IEvents> {}\n\nexport function getEventEmitterInstance<\n  IEvents extends Record<string, any>\n>(): TypedEmitter<EEmitter, IEvents> {\n  return new EventEmitter<IEvents>();\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/event-emitter-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-base-body-processor.ts",["2282"],"import { IHttpRequestOptions } from '../http-request-class-base.types';\nimport {\n  HTTP_REQUEST_METHOD,\n  HTTP_REQUEST_CONTENT_TYPE,\n} from '../http-request-class-base.const';\nimport {\n  objectToUrlEncodedString,\n  IParamsObject,\n  objectToFormData,\n  IParamsObjectFormData,\n} from '../http-request-class-base.utils';\n\nexport class HttpRequestBodyProcessor {\n  protected static logError(methodName: string, err: string | Error) {\n    console.error(`HttpRequestBodyProcessor::${methodName}`, err);\n  }\n\n  constructor(protected options: IHttpRequestOptions) {}\n\n  private get bodyRAW() {\n    const { options } = this;\n    const { body } = options;\n\n    return body;\n  }\n\n  private get bodyType() {\n    const { bodyRAW: body } = this;\n\n    return typeof body;\n  }\n\n  protected processBodyAsMultipart() {\n    const { bodyRAW: body, bodyType } = this;\n\n    if (body instanceof FormData) {\n      return body;\n    }\n    if (bodyType === 'object') {\n      return objectToFormData(body as IParamsObjectFormData);\n    }\n    HttpRequestBodyProcessor.logError(\n      'checkBodyIsMultipart',\n      'a wrong type of the body'\n    );\n    return undefined;\n  }\n\n  protected processBodyAsUrlEncoded() {\n    const { bodyRAW: body, bodyType } = this;\n\n    switch (bodyType) {\n      case 'string':\n        return encodeURI(String(body));\n      case 'object':\n        return objectToUrlEncodedString(body as IParamsObject);\n      default: {\n        HttpRequestBodyProcessor.logError(\n          'processBodyAsUrlEncoded',\n          'a wrong type of the body'\n        );\n        return undefined;\n      }\n    }\n  }\n\n  protected processBodyAsJSON(): string | FormData | undefined {\n    const { bodyRAW: body, bodyType } = this;\n\n    switch (bodyType) {\n      case 'string':\n        return body as string;\n      case 'number':\n      case 'object':\n        return JSON.stringify(body);\n      default:\n        return undefined;\n    }\n  }\n\n  protected preProcessBody(): string | FormData | undefined {\n    const { options } = this;\n    const { contentType } = options;\n\n    if (typeof contentType === 'string') {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      switch (contentType!) {\n        case HTTP_REQUEST_CONTENT_TYPE.JSON:\n          return this.processBodyAsJSON();\n        case HTTP_REQUEST_CONTENT_TYPE.URL_ENCODED:\n          return this.processBodyAsUrlEncoded();\n        case HTTP_REQUEST_CONTENT_TYPE.MULTIPART:\n          return this.processBodyAsMultipart();\n      }\n    }\n    return undefined;\n  }\n\n  protected getBody(): string | FormData | undefined {\n    const { options } = this;\n    const { method } = options;\n\n    if (\n      method === HTTP_REQUEST_METHOD.GET ||\n      method === HTTP_REQUEST_METHOD.DELETE\n    ) {\n      return undefined;\n    }\n    return this.preProcessBody();\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-base-response-error.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-response-processor.ts",["2283"],"import { HttpResponseError } from './http-request-class-base-response-error';\nimport { THttpResponseResult } from '../http-request-class-base.types';\nimport {\n  isSucceedResponse,\n  getContentTypeRAW,\n} from '../http-request-class-base-utils';\nimport { HTTP_RESPONSE_TYPES } from '../http-request-class-base.const';\nimport { MimeTypeClass } from 'classes/basic-classes/mime-types-class-base/mime-types-class-base';\nimport { getFilenameByUrl } from '../../../../utils/files-utils/files-utils-download';\n\nexport class HttpRequestResponseProcessor {\n  constructor(protected response: Response) {}\n\n  protected getHeader(name: string) {\n    return this.response.headers.get(name);\n  }\n\n  protected getFileNameByResponse(extension?: string | null) {\n    const contentDisposition = this.getHeader('content-disposition');\n    let fileName = '' as string | undefined;\n\n    if (contentDisposition) {\n      const fileNameMatch = /filename=\"(.+)\"/.exec(contentDisposition);\n\n      if (fileNameMatch?.length === 2) fileName = fileNameMatch[1];\n    }\n    if (!fileName) {\n      fileName = getFilenameByUrl(this.response.url);\n    }\n\n    if (extension) {\n      return fileName && fileName.endsWith(extension)\n        ? fileName\n        : `${fileName}.${extension}`;\n    }\n    return fileName;\n  }\n\n  protected logError(error: Error): Error {\n    console.error(error);\n    return error;\n  }\n\n  protected async processAsText(): Promise<string | Error> {\n    const { response } = this;\n\n    try {\n      const result = await response.text();\n\n      return result;\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processAsFormData(): Promise<Error | FormData> {\n    const { response } = this;\n    let result;\n\n    try {\n      if (typeof response.formData === 'function') {\n        result = await response.formData();\n      } else {\n      }\n\n      return new Error(\"Can't process the response as FormData\");\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processAsBlob(): Promise<Error | object> {\n    const { response } = this;\n\n    try {\n      const result = await response.blob();\n\n      return result;\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processAsFile(\n    mimeType?: string | null,\n    extension?: string | null\n  ): Promise<Error | object> {\n    const { response } = this;\n\n    try {\n      const result = await response.blob();\n\n      if (result instanceof Blob) {\n        return new File(\n          [result],\n          this.getFileNameByResponse(extension) || 'unknown',\n          {\n            type: mimeType || undefined,\n          }\n        );\n      }\n      return new Error(\"Can't process the response as a file\");\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processAsJSON(): Promise<Error | object> {\n    const { response } = this;\n\n    try {\n      const result = await response.json();\n\n      if (result && typeof result === 'object') {\n        return result;\n      }\n      return new Error(\"Can't process the response as json\");\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processResponse(): Promise<Error | THttpResponseResult> {\n    const { response } = this;\n    const contentType = getContentTypeRAW(response);\n\n    if (contentType) {\n      const mimeType = new MimeTypeClass(contentType);\n\n      if (mimeType.isBlob) {\n        return this.processAsBlob();\n      }\n      if (mimeType.isJSON) {\n        return this.processAsJSON();\n      }\n      if (mimeType.isText) {\n        return this.processAsText();\n      }\n      if (mimeType.isFile) {\n        return this.processAsFile(contentType, mimeType.extension);\n      }\n      return new Error('There is unknown mime-type of the response content');\n    }\n\n    return new Error('There is no \"Content-Type\" in the response headers');\n  }\n\n  public async getResult(): Promise<\n    Error | HttpResponseError | THttpResponseResult\n  > {\n    const { response } = this;\n\n    if (response.type === HTTP_RESPONSE_TYPES.OPAQUE) {\n      return undefined;\n    }\n    if (response.type === HTTP_RESPONSE_TYPES.OPAQUE_REDIRECT) {\n      return undefined;\n    }\n    if (!isSucceedResponse(response)) {\n      return new HttpResponseError(response);\n    }\n    return this.processResponse();\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-utils.ts",["2284","2285"],"import {\n  HTTP_REQUEST_ERROR_CODES_RANGE,\n  HTTP_REQUEST_CONTENT_TYPE,\n  HTTP_REQUEST_HEADERS_NAMES,\n  HTTP_REQUEST_CONTENT_TYPES_KNOWN,\n  HTTP_RESPONSE_TYPES,\n} from './http-request-class-base.const';\nimport {\n  TQueryStringParamsObject,\n  TQueryStringAllowedParamValue,\n  TQueryStringParams,\n} from './http-request-class-base.types';\nimport { concatStrings } from 'utils/string-utilities';\n\nconst { NO_ERROR, CLIENT_ERROR } = HTTP_REQUEST_ERROR_CODES_RANGE;\nconst [MIN_CODE_SUCCESS, MAX_CODE_SUCCESS] = NO_ERROR;\nconst [MIN_CODE_ERROR_CLIENT, MAX_CODE_ERROR_CLIENT] = CLIENT_ERROR;\n\nexport const isSucceedResponse = (response: Response): boolean => {\n  const { status, type } = response;\n\n  if (type === HTTP_RESPONSE_TYPES.ERROR) {\n    return false;\n  }\n\n  if (!status) {\n    return false;\n  }\n  if (status >= MIN_CODE_SUCCESS && status <= MAX_CODE_SUCCESS) {\n    return true;\n  }\n  return false;\n};\n\nexport const isClientSideError = (response: Response): boolean => {\n  const { status } = response;\n\n  if (!status) {\n    return false;\n  }\n  if (status >= MIN_CODE_ERROR_CLIENT && status <= MAX_CODE_ERROR_CLIENT) {\n    return true;\n  }\n  return false;\n};\n\nexport const getContentType = (response: Response): void | string => {\n  const { headers } = response;\n\n  if (headers) {\n    const contentType = headers.get(\n      HTTP_REQUEST_HEADERS_NAMES.CONTENT_TYPE\n    ) as HTTP_REQUEST_CONTENT_TYPE;\n\n    if (contentType && HTTP_REQUEST_CONTENT_TYPES_KNOWN.includes(contentType)) {\n      return contentType;\n    }\n  }\n  return undefined;\n};\n\nexport const getContentTypeRAW = (response: Response): void | string => {\n  const { headers } = response;\n\n  if (headers) {\n    const contentType = headers.get(HTTP_REQUEST_HEADERS_NAMES.CONTENT_TYPE);\n\n    if (typeof contentType === 'string') {\n      return contentType;\n    }\n  }\n  return undefined;\n};\n\nexport const getNetworkError = (response: Response): Error | void => {\n  if (typeof (response as any).error === 'function') {\n    const networkError = (response as any).error();\n\n    return networkError;\n  }\n  return undefined;\n};\n\n/**\n * resolve a param as a string can be used as\n * a query string param\n * @param {object | string | number | Array<object | string | number> } paramValue\n * @returns string\n */\nexport const resolveQueryStringParam = (\n  paramValue: TQueryStringAllowedParamValue\n): string => {\n  if (paramValue instanceof Array) {\n    return `[${paramValue.map(resolveQueryStringParam)}]`;\n  }\n\n  const paramValueType = typeof paramValue;\n  let resolvedValue;\n\n  try {\n    switch (paramValueType) {\n      case 'string':\n        resolvedValue = paramValue as string;\n        break;\n      case 'number':\n        resolvedValue = String(paramValue);\n        break;\n      default:\n        resolvedValue = JSON.stringify(paramValue);\n        break;\n    }\n    if (resolvedValue) {\n      return encodeURIComponent(resolvedValue);\n    }\n  } catch (err) {\n    console.error(err);\n  }\n  return '';\n};\n\n/**\n *\n * @param {object} obj\n * @returns {string} - string in the format of\n * param1=value1....&paramN=valueN\n */\nexport const queryStringFromObject = (\n  obj: TQueryStringParamsObject\n): string => {\n  if (obj && typeof obj === 'object') {\n    const paramNames = Object.keys(obj);\n    const paramsCount = paramNames.length;\n    const paramsLastIdx = paramsCount - 1;\n    let idx = 0;\n    let result = '';\n    let paramName;\n    let paramValue;\n    let paramValueString;\n\n    for (; idx < paramsCount; idx += 1) {\n      paramName = paramNames[idx];\n      paramValue = obj[paramName];\n      paramValueString = resolveQueryStringParam(paramValue);\n      result = `${encodeURIComponent(paramName)}=${paramValueString}${\n        idx !== paramsLastIdx ? '&' : ''\n      }`;\n    }\n    return result;\n  }\n  return '';\n};\n\nexport const resolveQueryStringParams = (\n  ...params: TQueryStringParams[]\n): string => {\n  const paramsCount = params.length;\n  let idx = 0;\n  let result = '';\n  let paramValue;\n  let paramStringValue;\n\n  for (; idx < paramsCount; idx += 1) {\n    paramValue = params[idx];\n    if (paramValue && typeof paramValue === 'object') {\n      paramStringValue = queryStringFromObject(\n        paramValue as TQueryStringParamsObject\n      );\n    } else {\n      paramStringValue = resolveQueryStringParam(paramValue);\n    }\n    result = concatStrings('&', result, paramStringValue);\n  }\n  return result;\n};\n","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.const.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.ts",["2286","2287"],"import validator from 'validator';\nimport { HttpRequestBodyProcessor } from './http-request-class-base-subclasses/http-request-class-base-body-processor';\nimport {\n  IHttpRequestOptions,\n  IHttpRequestHeaders,\n  THttpResponseResult,\n  THttpRequestToken,\n  TQueryStringParams,\n} from './http-request-class-base.types';\nimport {\n  HTTP_REQUEST_HEADERS_NAMES,\n  HTTP_REQUEST_METHOD,\n  HTTP_REQUEST_MODE,\n  HTTP_REQUEST_CONTENT_TYPE,\n  HTTP_REQUEST_MODES_SUPPORTED,\n} from './http-request-class-base.const';\nimport { HttpRequestResponseProcessor } from './http-request-class-base-subclasses/http-request-class-response-processor';\nimport { HttpResponseError } from './http-request-class-base-subclasses/http-request-class-base-response-error';\nimport { ownValueOf } from 'types/helper.types';\nimport { resolveQueryStringParams } from './http-request-class-base-utils';\nimport { prefixUrlWithHTTPProtocol } from './http-request-class-base.utils';\n\nexport class HttpRequest extends HttpRequestBodyProcessor {\n  public static ContentType = HTTP_REQUEST_CONTENT_TYPE;\n\n  public static HeaderName = HTTP_REQUEST_HEADERS_NAMES;\n\n  public static RequestMode = HTTP_REQUEST_MODE;\n\n  public static RequestMethod = HTTP_REQUEST_METHOD;\n\n  protected static baseUrl?: string;\n\n  private static token?: THttpRequestToken;\n\n  public static setBaseUrl(baseUrl: string): void | Error {\n    if (!validator.isURL(baseUrl)) {\n      return new Error('This is not a valid url');\n    }\n    HttpRequest.baseUrl = baseUrl;\n  }\n\n  public static setToken(token: THttpRequestToken): void | Error {\n    HttpRequest.token = token;\n  }\n\n  protected baseUrl?: string = HttpRequest.baseUrl;\n\n  protected url?: string;\n\n  protected method?: string;\n\n  protected mode?: RequestMode;\n\n  protected token?: THttpRequestToken = HttpRequest.token;\n\n  protected contentType?: string;\n\n  protected queryStringParams?: string;\n\n  protected credentials?: RequestCredentials;\n\n  /**\n   * Creates an instance of HttpRequest.\n   * @param {IHttpRequestOptions} options\n   * @memberof HttpRequest\n   * @throws\n   */\n  constructor(options: IHttpRequestOptions) {\n    super(options);\n\n    const resultSetOptions = this.setOptions(options);\n\n    if (resultSetOptions instanceof Error) {\n      console.error(\n        'HttpRequest::setOptions::failed',\n        resultSetOptions,\n        options\n      );\n      throw resultSetOptions;\n    }\n  }\n\n  /**\n   *  /**\n   * send the request to the server\n   * on the url defined in the\n   * options\n   *\n   * @memberof HttpRequest\n   *  @returns {(Promise<string | object | Error | FormData | Blob | HttpResponseError | File | undefined>)}\n   */\n  public send = async (): Promise<\n    | string\n    | object\n    | Error\n    | FormData\n    | Blob\n    | HttpResponseError\n    | File\n    | undefined\n  > => {\n    const { url, method, credentials, mode } = this;\n    const body = this.getBody();\n    const headers = this.getRequestHeaders();\n    const cache = this.getCacheMode();\n\n    try {\n      const response = await fetch(url!, {\n        mode,\n        body,\n        headers,\n        cache,\n        method,\n        credentials,\n      });\n\n      return this.preProcessResponse(response);\n    } catch (err) {\n      console.error(`HttpRequest::${url}::send::failed`, err);\n      return err;\n    }\n  };\n\n  protected getRequestMethod(\n    method: string | undefined,\n    options: IHttpRequestOptions\n  ): Error | HTTP_REQUEST_METHOD {\n    if (!method) {\n      const { body } = options;\n\n      if (body) {\n        return HTTP_REQUEST_METHOD.POST;\n      }\n      return HTTP_REQUEST_METHOD.GET;\n    }\n\n    const methodRes = method.trim().toUpperCase();\n\n    if (HTTP_REQUEST_METHOD.hasOwnProperty(methodRes)) {\n      return (HTTP_REQUEST_METHOD as any)[methodRes] as ownValueOf<\n        typeof HTTP_REQUEST_METHOD\n      >;\n    }\n    return new Error(`An unknown request method \"${method}\"`);\n  }\n\n  protected getCredentials(\n    options: IHttpRequestOptions\n  ): RequestCredentials | undefined {\n    const { withCookie, credentials } = options;\n\n    if (credentials) {\n      return credentials;\n    }\n    if (withCookie) {\n      return 'same-origin';\n    }\n  }\n\n  protected getRequestMode(\n    method: HTTP_REQUEST_METHOD,\n    options: IHttpRequestOptions\n  ): RequestMode | Error | undefined {\n    const { mode, contentType, body, token } = options;\n\n    if (!mode) {\n      if (token) {\n        return 'cors';\n      }\n      if (\n        method === HTTP_REQUEST_METHOD.DELETE ||\n        method === HTTP_REQUEST_METHOD.PUT\n      ) {\n        return 'cors';\n      }\n      if (\n        contentType !== HTTP_REQUEST_CONTENT_TYPE.URL_ENCODED &&\n        contentType !== HTTP_REQUEST_CONTENT_TYPE.MULTIPART &&\n        contentType !== HTTP_REQUEST_CONTENT_TYPE.PLAIN\n      ) {\n        return 'cors';\n      }\n      if (body instanceof ReadableStream) {\n        return 'cors';\n      }\n      return undefined;\n    }\n\n    if (typeof mode === 'string') {\n      const methodRes = mode.trim().toLowerCase();\n\n      if ((HTTP_REQUEST_MODES_SUPPORTED as string[]).includes(methodRes)) {\n        return methodRes as RequestMode;\n      }\n      return new Error(`An unknown request mode \"${mode}\"`);\n    }\n  }\n\n  /**\n   * resolve the url where to send the request\n   * depending on the options url\n   * base url and a query string\n   */\n  protected resolveTargetUrl(url: string): string {\n    const { baseUrl, queryStringParams } = this;\n    const urlInstance = new URL(\n      baseUrl ? url : prefixUrlWithHTTPProtocol(url),\n      baseUrl ? prefixUrlWithHTTPProtocol(baseUrl) : undefined\n    );\n\n    if (queryStringParams) {\n      urlInstance.search = queryStringParams;\n    }\n    return String(urlInstance);\n  }\n\n  protected getQueryStringParams(params: TQueryStringParams): string {\n    const { queryStringParams } = this;\n    const resolvedParams = resolveQueryStringParams(\n      queryStringParams || '',\n      params\n    );\n\n    return resolvedParams;\n  }\n\n  /**\n   * @protected\n   * @param {IHttpRequestOptions} options\n   * @memberof HttpRequest\n   * @throws\n   */\n  protected setOptions(options: IHttpRequestOptions) {\n    if (!options) {\n      throw new Error('The options must be defined for the request');\n    }\n    if (typeof options !== 'object') {\n      return new Error('The options must be an object');\n    }\n    if (typeof options.url !== 'string') {\n      return new Error('The url must be defined in options');\n    }\n\n    const { url, baseUrl, method, token, queryStringParams } = options;\n\n    if (typeof url !== 'string') {\n      return new Error('The url must be defined in options');\n    }\n    if (typeof baseUrl === 'string') {\n      if (!validator.isURL(baseUrl)) {\n        return new Error('The baseUrl is not valid');\n      }\n      this.baseUrl = baseUrl;\n    } else if (!validator.isURL(url)) {\n      this.baseUrl = '';\n      try {\n        new URL(url); // maybe it's data url\n      } catch (err) {\n        return new Error('The url is not valid');\n      }\n    }\n    if (token) {\n      this.token = token;\n    }\n\n    const methodRes = this.getRequestMethod(method, options);\n\n    if (methodRes instanceof Error) {\n      return methodRes;\n    }\n    this.method = methodRes;\n\n    const modeRes = this.getRequestMode(methodRes, options);\n\n    if (modeRes instanceof Error) {\n      return modeRes;\n    }\n    this.mode = modeRes;\n    this.credentials = this.getCredentials(options);\n    if (queryStringParams) {\n      this.queryStringParams = this.getQueryStringParams(queryStringParams);\n    }\n    this.url = this.resolveTargetUrl(url);\n  }\n\n  protected getRequestHeaders(): HeadersInit {\n    const { options, token } = this;\n    const { contentType } = options;\n    const headers: IHttpRequestHeaders = {};\n\n    if (contentType) {\n      headers[HTTP_REQUEST_HEADERS_NAMES.CONTENT_TYPE] = contentType;\n    }\n    if (token) {\n      headers[HTTP_REQUEST_HEADERS_NAMES.AUTHORIZATION] = `Bearer ${token}`;\n    }\n    return headers as HeadersInit;\n  }\n\n  protected getCacheMode(): RequestCache {\n    const { options } = this;\n    const { cache } = options;\n\n    return cache as RequestCache;\n  }\n\n  protected preProcessResponse(\n    response: Response\n  ): Promise<Error | HttpResponseError | THttpResponseResult> {\n    const responseProcessor = new HttpRequestResponseProcessor(response);\n\n    return responseProcessor.getResult();\n  }\n}\n\nexport default HttpRequest;\n","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.types.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.utils.ts",["2288"],"import { CONST_API_CONF_CURRENT_PROTOCOL_USED } from 'const/const-api-conf';\nimport { HTTP_REQUEST_URL_PROTOCOL_DELIIMETR_REGEXP } from './http-request-class-base.const';\n\nexport interface IParamsObject {\n  [paramName: string]: string | number | object;\n}\n/**\n * transforms object to a stirng url encoded\n * where a param names will be the object's\n * keys and it's values will be the object's\n * values\n * @param obj\n * @param {string} obj[name]\n */\nexport const objectToUrlEncodedString = (obj: IParamsObject): string => {\n  return Object.keys(obj).reduce((querystring, paramName) => {\n    const paramValue = obj[paramName] || '';\n    const paramValueType = typeof paramValue;\n    let paramValueCasted;\n\n    if (paramValueType === 'object') {\n      paramValueCasted = JSON.stringify(paramValue);\n    } else {\n      paramValueCasted = String(paramValue);\n    }\n    return `${querystring}${querystring.length ? '&' : ''}${encodeURIComponent(\n      paramName\n    )}=${encodeURIComponent(paramValueCasted)}`;\n  }, '');\n};\n\nexport interface IParamsObjectFormData {\n  [paramName: string]: string | File | Blob | object;\n}\n\nexport const objectToFormData = (obj: IParamsObjectFormData): FormData => {\n  let paramValueCasted;\n  let thirdParam;\n\n  return Object.keys(obj).reduce((formData: FormData, paramName) => {\n    const paramValue = obj[paramName] || '';\n    const paramValueType = typeof paramValue;\n\n    paramValueCasted = undefined;\n    thirdParam = undefined;\n    if (paramValue instanceof File) {\n      paramValueCasted = paramValue;\n      thirdParam = paramValueCasted.name;\n    } else if (paramValue instanceof Blob) {\n      paramValueCasted = paramValue;\n      thirdParam = 'file';\n    } else if (paramValueType === 'object') {\n      paramValueCasted = JSON.stringify(paramValue);\n    } else if (paramValueType === 'string' || paramValueType === 'number') {\n      paramValueCasted = String(paramValue);\n    }\n    if (paramValueCasted) {\n      formData.append(paramName, paramValueCasted, paramValueType);\n    } else {\n      console.error(\n        `Can't append the ${paramName} field as the form data value`\n      );\n    }\n    return formData;\n  }, new FormData());\n};\n\nexport const prefixUrlWithHTTPProtocol = (urlString: string): string => {\n  const urlTrimmed = urlString.trim().toLowerCase();\n\n  if (urlTrimmed.startsWith('data:')) {\n    return urlTrimmed;\n  }\n  return urlTrimmed.startsWith('http://') || urlTrimmed.startsWith('https://')\n    ? urlTrimmed\n    : `${CONST_API_CONF_CURRENT_PROTOCOL_USED}//${urlTrimmed.replace(\n        HTTP_REQUEST_URL_PROTOCOL_DELIIMETR_REGEXP,\n        ''\n      )}`;\n};\n","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/mime-types-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/mime-types-class-base/mime-types-class-base.const.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/mime-types-class-base/mime-types-class-base.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.const.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.types.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/queued-encryption-class-base.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/queued-encryption-class-base.types.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/status-class-base.const.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/status-class-base.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/status-class-base.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const-auth-credentials.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const-crypto-keys-usages.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-common.ts",["2289","2290"],"import { IUserDescription, TUesrIdentity } from 'types/users.types';\nimport { IHttpRequestOptions } from 'classes/basic-classes/http-request-class-base/http-request-class-base.types';\nimport {\n  CA_AUTH_CREDENTIALS_USER_PASSWORD_PROP_NAME,\n  CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME,\n  CA_AUTH_CREDENTIALS_USER_SECRET_LOGIN_PROP_NAME,\n} from '../central-authority-class-const/central-authority-class-const-auth-credentials';\nimport { TCACryptoKeyPairs } from './central-authority-class-types-crypto-keys';\nimport {\n  TCentralAuthorityUserCryptoCredentials,\n  TCentralAuthorityCredentialsStorageAuthCredentials,\n} from './central-authority-class-types-crypto-credentials';\nimport { ISensitiveDataSessionStorage } from 'classes/sensitive-data-session-storage/sensitive-data-session-storage.types';\n\nexport type TCentralAuthorityUserIdentity = string;\n\nexport type TCentralAuthorityUserLogin = string;\n\nexport type TCentralAuthorityUserPassword = string;\n\nexport interface ICentralAuthorityUserAuthCredentials {\n  login: TCentralAuthorityUserLogin;\n  password?: TCentralAuthorityUserPassword;\n  session?: ISensitiveDataSessionStorage;\n}\n\nexport type TCentralAuthorityUserAuthCredentialsWithPwd = Required<\n  Pick<ICentralAuthorityUserAuthCredentials, 'login' | 'password'>\n>;\n\n/**\n * this credentials used to authorize the user on a central authority\n * provider service and getting access to a local data encrypted.\n * The secret login property used to encrypt some part of a local data\n * and may be empty. If it's empty then user identity value will be used\n * for encryption. But it may take no effect cause it is public value\n * in most cases.\n */\nexport type TCentralAuthorityAuthCredentials = {\n  [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: TCentralAuthorityUserIdentity;\n  [CA_AUTH_CREDENTIALS_USER_PASSWORD_PROP_NAME]: string;\n  [CA_AUTH_CREDENTIALS_USER_SECRET_LOGIN_PROP_NAME]?: string;\n};\n\nexport interface ICentralAuthorityUserProfile {\n  name?: string | null;\n  email?: string | null;\n  phone?: string | null;\n  photoURL?: string | null;\n}\n\nexport interface ICentralAuthorityStorageCryptoCredentials {\n  connect(\n    credentials?: TCentralAuthorityCredentialsStorageAuthCredentials\n  ): Promise<boolean | Error>;\n  setCredentials(cryptoKeyPairs: TCACryptoKeyPairs): Promise<Error | boolean>;\n  getCredentials(): Promise<\n    TCentralAuthorityUserCryptoCredentials | Error | null\n  >;\n  disconnect(): Promise<boolean | Error>;\n}\n\nexport interface ICentralAuthorityConnectionOptions {\n  serverUrl: string;\n  getUsersDescriptionsRequestOptions: IHttpRequestOptions;\n}\n\nexport abstract class CentralAuthorityConnection {\n  constructor() {}\n  /**\n   * request the users descriptions by the user identities\n   */\n  public abstract getUsersDescription(\n    users: TUesrIdentity[]\n  ): Promise<(IUserDescription | null)[] | Error>;\n}\n\nexport interface ICentralAuthorityConnection {\n  new (): CentralAuthorityConnection;\n}\n\nexport type TInstanceOfCentralAuthorityConnection = InstanceType<\n  ICentralAuthorityConnection\n>;\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-credentials.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-keys.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v1/central-authority-class-user-identity-formatters-formatter-v1.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v1/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v2/central-authority-class-user-identity-formatters-formatter-v2.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v2/central-authority-class-user-identity-formatters-formatter-v2.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v2/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.utils.ts",["2291"],"import { IUserIdentityFormatter } from './central-authority-class-user-identity-formatters.types';\nimport {\n  validateUserIdentityDescriptionVersion,\n  validateUserIdentityDescription,\n} from '../central-authority-class-user-identity-validators/central-authority-class-user-identity-validators';\nimport {\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_PARSER_VERSIONS_SUPPORTED,\n} from '../central-authority-class-user-identity.const';\nimport { CA_USER_IDENTITY_FORMATTERS_BY_VERSION } from './central-authority-class-user-identity-formatters.const';\nimport { ICAUserUniqueIdentifierDescription } from '../central-authority-class-user-identity.types';\nimport { TCentralAuthorityUserIdentity } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { validateUserIdentity } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\n\nexport const getSerializerForIdentityVersion = (\n  userIdentityVersion: string\n): Error | IUserIdentityFormatter => {\n  const serializerFunction =\n    CA_USER_IDENTITY_FORMATTERS_BY_VERSION[userIdentityVersion];\n\n  if (typeof serializerFunction === 'function') {\n    return serializerFunction;\n  }\n  return new Error(\n    `There is no serializer was found for the identity version ${userIdentityVersion}`\n  );\n};\n\nexport const serializeIdentity = (\n  identity: ICAUserUniqueIdentifierDescription\n): TCentralAuthorityUserIdentity | Error => {\n  const validationResult = validateUserIdentityDescription(identity);\n\n  if (validationResult instanceof Error) {\n    return new Error('The user identity description have a wrong format');\n  }\n\n  const { [CA_USER_IDENTITY_VERSION_PROP_NAME]: version } = identity;\n\n  if (!CA_USER_IDENTITY_PARSER_VERSIONS_SUPPORTED.includes(version)) {\n    return new Error(`The version of the user identity given is not supported`);\n  }\n\n  const serializerFunction = getSerializerForIdentityVersion(version);\n\n  if (serializerFunction instanceof Error) {\n    console.error(serializerFunction);\n    return new Error(\n      `There is no serializer function for the user identity description version ${version}`\n    );\n  }\n\n  const serializeResult = serializerFunction(identity);\n\n  if (serializeResult instanceof Error) {\n    return new Error(\n      `Failed serialization for the user identity description version ${version}`\n    );\n  }\n  if (!validateUserIdentity(serializeResult)) {\n    return new Error(\n      `Failed serialization to the right format for the user identity description version ${version}`\n    );\n  }\n  return serializeResult;\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/central-authority-class-user-identity-parsers-parser-v1.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/central-authority-class-user-identity-parsers-parser-v1.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v2/central-authority-class-user-identity-parsers-parser-v2.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v2/central-authority-class-user-identity-parsers-parser-v2.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v2/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.types.ts",["2292"],"import { TCentralAuthorityUserIdentity } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { ICAUserIdentityDescription } from '../central-authority-class-user-identity.types';\n\nexport interface IParser {\n  (userIdentityWithoutVersion: string): ICAUserIdentityDescription | Error;\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.utils.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v1/central-authority-class-user-identity-validator-v1.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v1/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v2/central-authority-class-user-identity-validator-v2.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v2/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.types.ts",["2293"],"export interface IUserIdentityDescriptionValidator {\n  (v: any): boolean;\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.utils.ts",["2294","2295","2296"],"import { CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME } from './../central-authority-class-user-identity.const';\nimport { CA_USER_IDENTITY_VALIDATORS_BY_VERSION } from './central-authority-class-user-identity-validators.const';\nimport { IUserIdentityDescriptionValidator } from './central-authority-class-user-identity-validators.types';\nimport {\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT,\n  CA_USER_IDENTITY_PARSER_VERSIONS_SUPPORTED,\n} from '../central-authority-class-user-identity.const';\nimport { ICAUserUniqueIdentifierMetadata } from '../central-authority-class-user-identity.types';\nimport { dataValidatorUtilURL } from 'utils/data-validators-utils/data-validators-utils';\n\nexport const validateIdentityDescriptionVersion = (\n  version: any\n): version is string => {\n  if (typeof version !== 'string') {\n    console.error('An identity description version must be a string');\n    return false;\n  }\n  if (version.length !== CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT) {\n    console.error(\n      `An identity description version length must be a ${CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT} characters`\n    );\n    return false;\n  }\n  if (!CA_USER_IDENTITY_PARSER_VERSIONS_SUPPORTED.includes(version)) {\n    console.error(`The version ${version} is not supported`);\n    return false;\n  }\n  return true;\n};\n\nexport const getValidatorByIdentityVersion = (\n  identityVersion: string\n): IUserIdentityDescriptionValidator | Error => {\n  const validator = CA_USER_IDENTITY_VALIDATORS_BY_VERSION[identityVersion];\n\n  if (typeof validator === 'function') {\n    return validator;\n  }\n  return new Error(\n    `There is no validator for the identity version ${identityVersion}`\n  );\n};\n\nexport const validateUserIdentityDescriptionVersion = (\n  identityVersion: string,\n  userIdentityDescription: any\n): boolean | Error => {\n  const validatorForVersion = getValidatorByIdentityVersion(identityVersion);\n\n  if (validatorForVersion instanceof Error) {\n    console.error(validatorForVersion);\n    return new Error(\n      `Can't define a validator for the user's identity version ${validatorForVersion}`\n    );\n  }\n\n  const validationResult = validatorForVersion(userIdentityDescription);\n\n  if (validationResult !== true) {\n    return new Error(\"There is a wrong format of user's identity\");\n  }\n  return true;\n};\n\nexport const validateUserIdentityDescription = (\n  userIdetnityDescription: any\n): boolean | Error => {\n  if (userIdetnityDescription && typeof userIdetnityDescription === 'object') {\n    const {\n      [CA_USER_IDENTITY_VERSION_PROP_NAME]: version,\n    } = userIdetnityDescription;\n\n    if (!version) {\n      return new Error(\n        'There is no version defined in the user identity description object'\n      );\n    }\n    if (validateIdentityDescriptionVersion(version)) {\n      return validateUserIdentityDescriptionVersion(\n        version,\n        userIdetnityDescription\n      );\n    }\n    return new Error(\n      'There is a wrong version in the user identity description object'\n    );\n  }\n  return new Error('There is a wrong format of the user identity description');\n};\n\nexport const checkIsValidUserIdentityMetadata = (\n  identityMetadata: ICAUserUniqueIdentifierMetadata\n): boolean | Error => {\n  if (typeof identityMetadata !== 'object') {\n    return new Error('Identity metadata must be an object');\n  }\n  if (identityMetadata instanceof Error) {\n    return identityMetadata;\n  }\n  if (!identityMetadata) {\n    return new Error('Identity metadata must not be empty');\n  }\n\n  const {\n    [CA_USER_IDENTITY_VERSION_PROP_NAME]: version,\n    [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: authorityProviderURI,\n  } = identityMetadata;\n\n  if (version && !validateIdentityDescriptionVersion(version)) {\n    return new Error('Version in Identity metadata have a wrong format');\n  }\n  if (!dataValidatorUtilURL(authorityProviderURI)) {\n    return new Error('The URL of an authority provider is not valid');\n  }\n  return true;\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.ts",["2297"],"import {\n  ICAUserUniqueIdentifierDescription,\n  ICAUserUniqueIdentifierDescriptionWithOptionalVersion,\n  ICAIdentityCommonInstance,\n  TUserIdentityVersion,\n  TCAUserIdentityRawTypes,\n} from './central-authority-class-user-identity.types';\nimport { TCentralAuthorityUserIdentity } from '../central-authority-class-types/central-authority-class-types';\nimport { validateUserIdentitySilent } from '../central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { parseIdentity } from './central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers';\nimport { serializeIdentity } from './central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters';\nimport {\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_CURRENT,\n  CA_USER_IDENTITY_AUTH_PROVIDER_URL_DELIMETER,\n} from './central-authority-class-user-identity.const';\nimport { CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME } from '../central-authority-class-const/central-authority-class-const';\n\nexport class CentralAuthorityIdentity implements ICAIdentityCommonInstance {\n  protected _userIdentitySerialized?: Error | TCentralAuthorityUserIdentity;\n\n  protected _userIdentityParsed?: Error | ICAUserUniqueIdentifierDescription;\n\n  public isValid?: boolean;\n\n  constructor(protected _userIdentity: TCAUserIdentityRawTypes) {\n    if (_userIdentity instanceof CentralAuthorityIdentity) {\n      return _userIdentity;\n    }\n    if (!_userIdentity) {\n      return;\n    }\n\n    let identity = _userIdentity;\n\n    if (typeof _userIdentity === 'object') {\n      //check may be it is a crypto credentials object\n      const identityVal = ((_userIdentity as unknown) as any)[\n        CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME\n      ];\n\n      if (typeof identityVal === 'string') {\n        identity = identityVal;\n      }\n    }\n    if (validateUserIdentitySilent(identity)) {\n      this.parseUserIdentity(identity);\n    } else {\n      const userIdentityDescription = this.extendDescriptionWithVersion(\n        identity as ICAUserUniqueIdentifierDescriptionWithOptionalVersion\n      );\n\n      this.serializeUserIdentityDescription(userIdentityDescription);\n    }\n  }\n\n  protected extendDescriptionWithVersion(\n    _userIdentityDescription: ICAUserUniqueIdentifierDescriptionWithOptionalVersion\n  ): ICAUserUniqueIdentifierDescription {\n    const {\n      [CA_USER_IDENTITY_VERSION_PROP_NAME]: version,\n    } = _userIdentityDescription;\n\n    if (!version) {\n      // extend the description with the\n      // current version\n      const result = {\n        ..._userIdentityDescription,\n        [CA_USER_IDENTITY_VERSION_PROP_NAME]: CA_USER_IDENTITY_VERSION_CURRENT,\n      };\n\n      this._userIdentity = result;\n      return result as ICAUserUniqueIdentifierDescription;\n    }\n    return _userIdentityDescription as ICAUserUniqueIdentifierDescription;\n  }\n\n  public get identityDescription(): ICAUserUniqueIdentifierDescription | Error {\n    const res = this.checkUserIdentityDescriptionIsValid();\n\n    if (res instanceof Error) {\n      return res;\n    }\n\n    const { _userIdentityParsed } = this;\n\n    if (!_userIdentityParsed) {\n      return new Error('Failed to parse the user identity');\n    }\n    return _userIdentityParsed;\n  }\n\n  public get identityDescritptionSerialized():\n    | TCentralAuthorityUserIdentity\n    | Error {\n    const res = this.checkUserIdentityDescriptionIsValid();\n\n    if (res instanceof Error) {\n      return res;\n    }\n\n    const { _userIdentitySerialized } = this;\n\n    if (!_userIdentitySerialized) {\n      return new Error('Failed to serialize the user identity');\n    }\n    return _userIdentitySerialized;\n  }\n\n  /**\n   * uniquely identifies the user\n   */\n  public get id(): string | Error {\n    const res = this.checkUserIdentityDescriptionIsValid();\n\n    if (res instanceof Error) {\n      return res;\n    }\n\n    const { authorityProviderURI, userUniqueIdentifier } = this\n      .identityDescription as ICAUserUniqueIdentifierDescription;\n\n    return `${authorityProviderURI}${CA_USER_IDENTITY_AUTH_PROVIDER_URL_DELIMETER}${userUniqueIdentifier}`;\n  }\n\n  public get version(): TUserIdentityVersion | Error {\n    const res = this.checkUserIdentityDescriptionIsValid();\n\n    if (res instanceof Error) {\n      return res;\n    }\n\n    return (((this.identityDescription as ICAUserUniqueIdentifierDescription)\n      .version ||\n      CA_USER_IDENTITY_VERSION_CURRENT) as unknown) as TUserIdentityVersion;\n  }\n\n  public toString(): TCentralAuthorityUserIdentity {\n    const res = this.checkUserIdentityDescriptionIsValid();\n\n    if (res instanceof Error) {\n      return '';\n    }\n    return this.identityDescritptionSerialized as string;\n  }\n\n  protected checkUserIdentityDescriptionIsValid = (): Error | void => {\n    const { _userIdentitySerialized, isValid, _userIdentityParsed } = this;\n    let err: Error | void;\n\n    if (!isValid) {\n      err = new Error('The identity is not valid');\n    }\n    if (!_userIdentityParsed) {\n      err = new Error('There is no user identity parsed');\n    }\n    if (_userIdentityParsed instanceof Error) {\n      err = _userIdentityParsed;\n    }\n    if (!_userIdentitySerialized) {\n      err = new Error('The identity description serialized is not defined');\n    }\n    if (_userIdentitySerialized instanceof Error) {\n      err = _userIdentitySerialized;\n    }\n    if (err instanceof Error) {\n      console.error(err);\n      return err;\n    }\n  };\n\n  protected setIdentityIsValid(): void {\n    if (this.isValid !== false) {\n      this.isValid = true;\n    }\n  }\n\n  protected parseUserIdentity(\n    userIdentity: TCentralAuthorityUserIdentity\n  ): void {\n    if (userIdentity) {\n      const parsedUserIdentity = parseIdentity(userIdentity);\n      if (parsedUserIdentity instanceof Error) {\n        console.error(parsedUserIdentity);\n        this._userIdentityParsed = parsedUserIdentity;\n        this._userIdentitySerialized = new Error(\n          'Failed to parse the user identity'\n        );\n      } else {\n        this._userIdentityParsed = parsedUserIdentity;\n        this._userIdentitySerialized = userIdentity;\n        this.setIdentityIsValid();\n        return;\n      }\n    } else {\n      const err = new Error('The user identity serialized is not defined');\n\n      this._userIdentityParsed = err;\n      this._userIdentitySerialized = err;\n    }\n    this.isValid = false;\n  }\n\n  protected serializeUserIdentityDescription(\n    userIdentityDescription: ICAUserUniqueIdentifierDescription\n  ) {\n    if (userIdentityDescription) {\n      const serializedDescription = serializeIdentity(userIdentityDescription);\n\n      if (serializedDescription instanceof Error) {\n        this._userIdentityParsed = new Error(\n          'Failed to serialize the user identity description'\n        );\n        this._userIdentitySerialized = serializedDescription;\n      } else {\n        this._userIdentityParsed = userIdentityDescription;\n        this._userIdentitySerialized = serializedDescription;\n        this.setIdentityIsValid();\n        return;\n      }\n    } else {\n      const err = new Error('The user identifier description is not defined');\n\n      this._userIdentitySerialized = err;\n      this._userIdentityParsed = err;\n    }\n    this.isValid = false;\n  }\n}\n\nexport default CentralAuthorityIdentity;\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/central-authority-connection-firebase-base.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/central-authority-connection-firebase-base.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/central-authority-connection-firebase-base.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-connection-implementation/central-authority-connection-firebase-connection-implementation.ts",["2298","2299","2300","2301"],"import firebase from 'firebase';\nimport 'firebase/auth';\nimport memoize from 'lodash.memoize';\nimport CAConnectionWithFirebaseBase from '../central-authority-connection-firebase-base/central-authority-connection-firebase-base';\nimport {\n  ICAConnection,\n  ICAConnectionSignUpCredentials,\n  ICAConnectionUserAuthorizedResult,\n} from '../../central-authority-connections.types';\nimport { isEmptyObject } from 'utils/common-utils/common-utils-objects';\nimport {\n  ICentralAuthorityUserProfile,\n  TCentralAuthorityUserCryptoCredentials,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { getVersionOfCryptoCredentials } from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\nimport {\n  CA_USER_IDENTITY_VERSIONS,\n  CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME,\n  CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_CURRENT,\n} from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport { generateCryptoCredentialsWithUserIdentityV2 } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport { validateUserIdentityVersion } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { TUserIdentityVersion } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { ICAConnectionConfigurationFirebase } from '../central-authority-connection-firebase.types.configuration';\nimport { CA_CONNECTION_STATUS } from '../../central-authority-connections-const/central-authority-connections-const';\n\n/**\n *\n * This is the class realized connection with the Firebase.\n * It allows to sign up and authorize on it, set a crypto credentials\n * for the user and read credentials for another users.\n * The versions of a connections to the Firebase must\n * extends this class. This implementation is compilant\n * to the V1 and V2 of the user identity.\n *\n * @export\n * @class CAConnectionWithFirebase\n * @implements {ICAConnection}\n */\nexport class CAConnectionWithFirebaseImplementation\n  extends CAConnectionWithFirebaseBase\n  implements ICAConnection {\n  public get cryptoCredentials():\n    | TCentralAuthorityUserCryptoCredentials\n    | undefined {\n    const { valueofCredentialsSignUpOnAuthorizedSuccess } = this;\n\n    if (valueofCredentialsSignUpOnAuthorizedSuccess) {\n      const { cryptoCredentials } = valueofCredentialsSignUpOnAuthorizedSuccess;\n\n      return cryptoCredentials;\n    }\n  }\n\n  public get authProviderURL() {\n    const { databaseURL } = this;\n\n    return databaseURL instanceof Error ? undefined : databaseURL;\n  }\n\n  /**\n   * the current status of the connection\n   * to the Firebase remote database\n   *\n   * @readonly\n   * @type {CA_CONNECTION_STATUS}\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  public get status(): CA_CONNECTION_STATUS {\n    const { isConnected, isAuthorized, isAnonymousely } = this;\n\n    if (!isConnected) {\n      return CA_CONNECTION_STATUS.DISCONNECTED;\n    }\n    if (isAuthorized) {\n      return CA_CONNECTION_STATUS.AUTHORIZED;\n    }\n    if (isAnonymousely) {\n      return CA_CONNECTION_STATUS.CONNECTED;\n    }\n    return CA_CONNECTION_STATUS.DISCONNECTED;\n  }\n\n  /**\n   * whether the user is connected anonymousely\n   * or not. User must be authorized or connected\n   * anonymousely\n   *\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected isAnonymousely = false;\n\n  protected userLogin?: string;\n\n  /**\n   * list with identity versions supported by the connection\n   *\n   * @type {Array<TUserIdentityVersion>}\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected readonly supportedVersions: Array<TUserIdentityVersion> = [\n    CA_USER_IDENTITY_VERSIONS['01'],\n    CA_USER_IDENTITY_VERSIONS['02'],\n  ];\n\n  /**\n   * checks whether the identity version\n   * is supported by the connection\n   *\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  public isVersionSupported = memoize(\n    (version: TUserIdentityVersion): boolean =>\n      this.supportedVersions.includes(version)\n  );\n\n  /**\n   * connect to the Firebase database. To authorize\n   * in the database to set credentials it is necesssry\n   * to authorize in.\n   * To read credentials of another user authorization is not\n   * necessary.\n   * Connection will be established in the anonymous mode\n   *\n   * @param {ICAConnectionConfigurationFirebase} configuration\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof CAConnectionWithFirebaseBase\n   */\n  public async connect(\n    configuration: ICAConnectionConfigurationFirebase\n  ): Promise<boolean | Error> {\n    // if there is an active apps exists then it is necessary\n    // to provide the app name, elswere the Firebase will throw\n    // an error.\n    const appName = firebase.apps.length\n      ? configuration.databaseURL\n      : undefined;\n    const resultConnection = await super.connect(configuration, appName);\n\n    if (resultConnection instanceof Error) {\n      return resultConnection;\n    }\n    return true;\n  }\n\n  public async signInAnonymousely(): Promise<Error | void> {\n    try {\n      // may be authentificated with session\n      //await this.signInWithSessionPersisted();\n      const connectAnonymouselyResult = await this.app\n        .auth()\n        .signInAnonymously();\n      if (connectAnonymouselyResult instanceof Error) {\n        return connectAnonymouselyResult;\n      }\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to connect anonymousely');\n    }\n\n    const connectWithStorageResult = await this.startConnectionWithCredentialsStorage();\n\n    if (connectWithStorageResult instanceof Error) {\n      console.error(connectWithStorageResult);\n      return new Error('Failed to connect to the credentials storage');\n    }\n    this.setIsAnonymousely();\n  }\n\n  /**\n   * return a credentials for the user\n   * with the id = userId.\n   * For the v1 the user id must be a uuidV4.\n   * For the v2 the user id must be a login/email/uuid.\n   * under which the user was registered the\n   * Firebase account.\n   *\n   * @param {string} userId\n   * @returns {(Promise<Error | null | TCentralAuthorityUserCryptoCredentials>)}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  public async getUserCredentials(\n    userId: string\n  ): Promise<Error | null | TCentralAuthorityUserCryptoCredentials> {\n    const { status } = this;\n\n    if (status !== CA_CONNECTION_STATUS.DISCONNECTED) {\n      const { connectionWithCredentialsStorage } = this;\n\n      return connectionWithCredentialsStorage!.getUserCredentials(userId);\n    }\n    return new Error('Not connected to the Firebase');\n  }\n\n  /**\n   * @param {ICAConnectionSignUpCredentials} firebaseCredentials\n   * @param firebaseCredentials.login - there must be an email to authorize with a Firebase account\n   * @param firebaseCredentials.password - password used for encrypt a sensitive data and authorize\n   * in the Firebase account\n   * @param profile - if provided then the user profile will be set in firebase\n   */\n  public async authorize(\n    firebaseCredentials: ICAConnectionSignUpCredentials,\n    profile?: Partial<ICentralAuthorityUserProfile>\n  ): Promise<ICAConnectionUserAuthorizedResult | Error> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return this.onAuthorizationFailed(isConnected);\n    }\n\n    let authHandleResult;\n    const { isAuthorized } = this;\n\n    if (isAuthorized) {\n      authHandleResult = this.valueofCredentialsSignUpOnAuthorizedSuccess!!;\n    } else {\n      // try to sign in with the credentials, then try to sign up\n      // const userLoggedPromise = this.waitingUserInit();\n      const signInResult = await this.signIn(firebaseCredentials);\n\n      if (signInResult instanceof Error) {\n        console.warn('Failed to sign in with the credentials given');\n\n        if (!firebaseCredentials.password) {\n          // if there is no password provided, return the error\n          return signInResult;\n        }\n\n        // if failed to sign in with the credentials\n        // try to sign up\n        const signUpResult = await this.signUp(firebaseCredentials);\n\n        if (signUpResult instanceof Error) {\n          console.error('The user was failed to sign up');\n          return this.onAuthorizationFailed(signUpResult);\n        }\n      }\n      // const user = await userLoggedPromise;\n      // if (!user) {\n      //   return new Error('Failed to get the user authorized');\n      // }\n      // if (user instanceof Error) {\n      //   return new Error('Error on login');\n      // }\n      // if (!user.emailVerified) {\n\n      // check if the account was verfied by the user\n      const isVerifiedResult = await this.chekIfVerifiedAccount();\n\n      if (isVerifiedResult instanceof Error) {\n        console.error('The account is not verified');\n        return this.onAuthorizationFailed(isVerifiedResult);\n      }\n      //}\n\n      const connectWithStorageResult = await this.startConnectionWithCredentialsStorage();\n\n      if (connectWithStorageResult instanceof Error) {\n        console.error(connectWithStorageResult);\n        return new Error('Failed to connect to the credentials storage');\n      }\n      // set the user login to use it to generate\n      // crypto credentials\n      this.setUserLogin(firebaseCredentials.login);\n\n      let cryptoCredentials:\n        | TCentralAuthorityUserCryptoCredentials\n        | Error\n        | undefined;\n\n      if (firebaseCredentials.session) {\n        const sessionCryptoCredentials = await this.readCryptoCrdentialsFromSession(\n          firebaseCredentials.session\n        );\n\n        if (sessionCryptoCredentials instanceof Error) {\n          console.error(\n            'Failed to get credentials from the session cause the error',\n            sessionCryptoCredentials\n          );\n        }\n        cryptoCredentials = sessionCryptoCredentials;\n      }\n      // create a new credentnials for the user or return\n      // an existing.\n      // if a crytpto credentials provided in signUpCredentials\n      // it will be used to set in the Firebase credentials\n      // storage\n      if (!cryptoCredentials || cryptoCredentials instanceof Error) {\n        cryptoCredentials = await this.createOrReturnExistingCredentialsForUser(\n          firebaseCredentials\n        );\n      }\n      if (cryptoCredentials instanceof Error) {\n        console.error('Failed to get a crypto credentials valid for the user');\n        return this.onAuthorizationFailed(cryptoCredentials);\n      }\n\n      // give user's profile\n      // with a credentials\n      authHandleResult = await this.returnOnAuthorizedResult(cryptoCredentials);\n      if (firebaseCredentials.session) {\n        const setCredentialsInSessionResult = await this.setCurrentUserCryptoCredentialsInSession(\n          firebaseCredentials.session,\n          cryptoCredentials\n        );\n\n        if (setCredentialsInSessionResult instanceof Error) {\n          console.error(\n            'Failed to set the credentials in the user session',\n            setCredentialsInSessionResult\n          );\n        }\n      }\n    }\n\n    if (authHandleResult instanceof Error) {\n      return this.onAuthorizationFailed(authHandleResult);\n    }\n    // if a profile data is necessary to be set\n    // by a profile data from the arguments given\n    if (profile && !isEmptyObject(profile)) {\n      const setProfileResult = await this.setProfileData(profile);\n\n      if (setProfileResult instanceof Error) {\n        console.error(setProfileResult);\n        return this.onAuthorizationFailed('Failed to set the profile data');\n      }\n\n      // set porofile is the user's profile\n      // data stored in the firebase\n      authHandleResult = {\n        profile: setProfileResult,\n        // TODO it is necessry to set this credentials in the database\n        cryptoCredentials: authHandleResult.cryptoCredentials,\n      };\n    }\n    // set the authentification success\n    // result. To return it on the second authorization\n    // request\n    this.valueofCredentialsSignUpOnAuthorizedSuccess = authHandleResult;\n    this.setValueofCredentialsSignUpOnAuthorizedSuccess(authHandleResult);\n    this.unsetIsAnonymousely();\n    return authHandleResult;\n  }\n\n  /**\n   * disconnect from the app and sign out\n   * if authorized\n   *\n   * @returns\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  public async disconnect() {\n    const { app } = this;\n    if (!app) {\n      return;\n    }\n    if ((app as any).isDeleted_) {\n      return;\n    }\n    if (this.status === CA_CONNECTION_STATUS.AUTHORIZED) {\n      const signOutResult = await this.signOut();\n\n      if (signOutResult instanceof Error) {\n        return signOutResult;\n      }\n      if (signOutResult !== true) {\n        return new Error('An unknown error has occurred while sign out');\n      }\n    }\n    return this.disconnectFromTheApp();\n  }\n\n  public async delete(\n    firebaseCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | boolean> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { currentUser } = this;\n\n    if (currentUser instanceof Error) {\n      console.error(currentUser);\n      return new Error('Failed to read the current user');\n    }\n    if (currentUser == null) {\n      return new Error('There is no current user');\n    }\n\n    // try to sign in with the credentials.\n    // it is required by the firebase to sign in before\n    // delete the user.\n    const signInResult = await this.signIn(firebaseCredentials);\n\n    if (signInResult instanceof Error) {\n      console.error('Failed to sign in before the user deletion');\n      return signInResult;\n    }\n\n    try {\n      const result = (await currentUser.delete()) as unknown; // or maybe deleteWithCompletion method\n\n      if (result instanceof Error) {\n        console.error(result);\n        return new Error('Failed to delete the user from the firebase');\n      }\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to delete the user from the authority');\n    }\n\n    // disconnection from the firebase\n    // is not necessry cause the firebase\n    // disconnects automatically if the user\n    // delete himself\n    return true;\n  }\n\n  /**\n   * set that connected anonymousely\n   * to the Firebase\n   *\n   * @protected\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected setIsAnonymousely() {\n    this.isAnonymousely = true;\n  }\n\n  /**\n   * unset that connected to the Firebase\n   * anonymousely\n   *\n   * @protected\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected unsetIsAnonymousely() {\n    this.isAnonymousely = false;\n  }\n\n  protected setValueofCredentialsSignUpOnAuthorizedSuccess(\n    authResult: ICAConnectionUserAuthorizedResult\n  ) {\n    this.valueofCredentialsSignUpOnAuthorizedSuccess = authResult;\n  }\n\n  protected unsetValueofCredentialsSignUpOnAuthorizedSuccess() {\n    this.valueofCredentialsSignUpOnAuthorizedSuccess = undefined;\n  }\n\n  /**\n   * set identity versions which are\n   * supported by the connection\n   * instance\n   *\n   * @protected\n   * @param {Array<TUserIdentityVersion>} [supportedVersions]\n   * @returns {(Error | void)}\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected setVersionsSupported(\n    supportedVersions?: Array<TUserIdentityVersion>\n  ): Error | void {\n    if (supportedVersions instanceof Array) {\n      const len = supportedVersions.length;\n      let idx = 0;\n      let version;\n\n      for (; idx++; len < idx) {\n        version = supportedVersions[idx];\n        if (validateUserIdentityVersion(version)) {\n          this.supportedVersions.push(version);\n        }\n        return new Error('The version is not supproted');\n      }\n    }\n    return new Error('The argument must be an Array');\n  }\n\n  protected setUserLogin(login: string) {\n    this.userLogin = login;\n  }\n\n  /**\n   * this method generates credentials compilant to the version\n   * version 2 of the user identity. The firebase app user uid\n   * is used as the user id.\n   *\n   * @protected\n   * @returns {(Promise<\n   *     Error | TCentralAuthorityUserCryptoCredentials\n   *   >)}\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected generateNewCryptoCredentialsForConfigurationProvidedV2 = async (): Promise<\n    Error | TCentralAuthorityUserCryptoCredentials\n  > => {\n    const { databaseURL, currentUser } = this;\n\n    if (!currentUser) {\n      return new Error('The user is not defined');\n    }\n    if (databaseURL instanceof Error) {\n      return databaseURL;\n    }\n\n    const cryptoCredentials = await generateCryptoCredentialsWithUserIdentityV2(\n      {\n        [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: databaseURL,\n        [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: currentUser.uid,\n      }\n    );\n\n    if (cryptoCredentials instanceof Error) {\n      console.error(cryptoCredentials);\n      return new Error('Failed to generate a new crypto credentials');\n    }\n    return cryptoCredentials;\n  };\n\n  /**\n   * substitute the method to support v2 identity\n   *\n   * @protected\n   * @param {ICAConnectionSignUpCredentials} signUpCredentials\n   * @returns {(Promise<Error | TCentralAuthorityUserCryptoCredentials>)}\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected async generateAndSetCredentialsForTheCurrentUser(\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials> {\n    const credentialsProvidedCheckResult = this.checkSignUpCredentials(\n      signUpCredentials\n    );\n\n    if (credentialsProvidedCheckResult instanceof Error) {\n      console.error(credentialsProvidedCheckResult);\n      return credentialsProvidedCheckResult;\n    }\n\n    const { cryptoCredentials } = signUpCredentials;\n    const V1 = CA_USER_IDENTITY_VERSIONS['01'];\n    let credentialsForV1 = false;\n\n    if (this.isVersionSupported(V1)) {\n      credentialsForV1 =\n        CA_USER_IDENTITY_VERSION_CURRENT === CA_USER_IDENTITY_VERSIONS['01'];\n\n      if (cryptoCredentials) {\n        // check a version of the credentials\n        // to decide what to do next\n        const cryptoCredentialsVersion = getVersionOfCryptoCredentials(\n          cryptoCredentials\n        );\n\n        if (cryptoCredentialsVersion instanceof Error) {\n          console.error(cryptoCredentialsVersion);\n          return new Error(\n            'Failed to define a version of the crypto credentials'\n          );\n        }\n        if (cryptoCredentialsVersion === CA_USER_IDENTITY_VERSIONS['01']) {\n          // if the credentials version is 01 we may use the\n          // current implementation cause it is fully\n          // compilant to that version\n          credentialsForV1 = true;\n        } else {\n          credentialsForV1 = false;\n        }\n      }\n      // if a credentials for the V1 must be generated and set\n      if (credentialsForV1 === true) {\n        return this.createOrSetCredentialsInDB(signUpCredentials);\n      }\n    }\n    // if the version is not 01, then provide another implementations\n    // of the methods to generate and set the crypto credentials\n    return this.createOrSetCredentialsInDB(\n      signUpCredentials,\n      this.generateNewCryptoCredentialsForConfigurationProvidedV2\n    );\n  }\n\n  /**\n   * disconnect from the Firebase app\n   *\n   * @protected\n   * @returns {(Promise<Error | void>)}\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected async disconnectFromTheApp(): Promise<Error | void> {\n    this.unsetIsAnonymousely();\n    this.unsetValueofCredentialsSignUpOnAuthorizedSuccess();\n\n    const disconnectFromStorageResult = await this.disconnectCredentialsStorage();\n\n    if (disconnectFromStorageResult instanceof Error) {\n      return disconnectFromStorageResult;\n    }\n\n    const { app } = this;\n\n    if (app) {\n      try {\n        // delete the application to allow connect to the Firebase with the same settings\n        await app.delete();\n      } catch (err) {\n        console.error(err);\n        return new Error('Failed to disconnect from the Firebase app');\n      }\n    } else {\n      return new Error('There is no active Firebase App instance to close');\n    }\n  }\n}\n\nexport default CAConnectionWithFirebaseImplementation;\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-connection-implementation/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.ts",["2302","2303","2304","2305","2306"],"import { CAConnectionWithFirebaseUtilDatabase } from '../central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database';\nimport {\n  getUserIdentityByCryptoCredentials,\n  exportCryptoCredentialsToString,\n  importCryptoCredentialsFromAString,\n} from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\nimport {\n  CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_KEY_PREFIX,\n  CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY,\n  CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_MAXIMUM_STORED_VALUES_CHECK,\n} from './central-authority-connection-firebase-utils.credentials-storage.const';\nimport {\n  ICAConnectionFirebase,\n  ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure,\n} from './central-authority-connection-firebase-utils.credentials-storage.types';\nimport { encodeForFirebaseKey } from 'utils/firebase-utils/firebase-utils';\nimport { validateUserIdentity } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { TCentralAuthorityUserCryptoCredentials } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { checkIsValidExportedCryptoCredentialsToString } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport { ICAConnectionSignUpCredentials } from '../../../central-authority-connections.types';\n\n/**\n * This class is used for storing\n * and reading the user's credentials.\n * It also used for reading\n * credentials of another user from the\n * Firebase remote database.\n * @export\n * @class CAConnectionFirestoreUtilsCredentialsStrorage\n * @extends {CAConnectionWithFirebaseUtilDatabase}\n */\nexport class CAConnectionFirestoreUtilsCredentialsStrorage extends CAConnectionWithFirebaseUtilDatabase {\n  protected connectionToFirebase?: ICAConnectionFirebase;\n\n  protected get firebaseUserData(): firebase.User | null | Error {\n    const isConnected = this.checkIsConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { app } = this;\n\n    try {\n      return app!!.auth().currentUser;\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to get the user id for firebase');\n    }\n  }\n\n  protected get firebaseUserId(): string | Error {\n    const { firebaseUserData: userData } = this;\n\n    if (userData instanceof Error) {\n      console.error(userData);\n      return new Error('Failed to read the user data from a firebase');\n    }\n    if (userData == null) {\n      return new Error('There is no user data');\n    }\n    try {\n      return userData.uid;\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to get the user id for firebase');\n    }\n  }\n\n  constructor(connectionToFirebase: ICAConnectionFirebase) {\n    super();\n\n    this.setUpConnection(connectionToFirebase);\n  }\n\n  /**\n   * returns a string will used to store/read value of\n   * the user credentials\n   * @protected\n   * @param {string} userId\n   * @returns {string}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  protected getCredentialsKeyByUserId(userId: string): string {\n    return `${CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_KEY_PREFIX}${encodeForFirebaseKey(\n      userId\n    )}`;\n  }\n\n  protected checkIsConnected(): boolean | Error {\n    const isConnectedToDatabase = super.checkIsConnected();\n\n    if (isConnectedToDatabase instanceof Error) {\n      return isConnectedToDatabase;\n    }\n\n    const { app, connectionToFirebase } = this;\n\n    if (!connectionToFirebase) {\n      return new Error(\n        'There is no instance implements a connection to the Firebase application'\n      );\n    }\n    if (!connectionToFirebase.isConnected) {\n      return new Error(\n        'There is no active connection to the firebase appliction'\n      );\n    }\n    if (!app) {\n      return new Error('There is no app connection');\n    }\n    return true;\n  }\n\n  protected checkIsAuthorized(): boolean | Error {\n    const isConnectedToDatabase = this.checkIsConnected();\n\n    if (isConnectedToDatabase instanceof Error) {\n      return isConnectedToDatabase;\n    }\n\n    const { firebaseUserId, connectionToFirebase } = this;\n\n    if (!connectionToFirebase || !connectionToFirebase.isUserSignedIn) {\n      return new Error(\n        'The user is not authorized in the Firebase application'\n      );\n    }\n    if (firebaseUserId instanceof Error) {\n      console.error(firebaseUserId);\n      return new Error('The user is not authorized');\n    }\n    return true;\n  }\n\n  protected setUpConnection(connectionToFirebase: ICAConnectionFirebase) {\n    this.connectionToFirebase = connectionToFirebase;\n\n    const app = connectionToFirebase.getApp();\n\n    if (!app) {\n      throw new Error(\n        'There is no insatnce which implements a connection to the Firebase app'\n      );\n    }\n    this.app = app;\n  }\n\n  /**\n   *\n   * check if a credentials set in the storage\n   * are in the valid format\n   * @protected\n   * @param {*} storedCredentialsValue\n   * @returns {storedCredentialsValue is ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  protected checkStoredCredentialsFormat(\n    storedCredentialsValue: any\n  ): storedCredentialsValue is ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure {\n    if (storedCredentialsValue instanceof Error) {\n      console.error(storedCredentialsValue);\n      return false;\n    }\n    if (storedCredentialsValue && typeof storedCredentialsValue === 'object') {\n      const {\n        credentials,\n        [CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY]: firebaseId,\n      } = storedCredentialsValue;\n\n      // an id set for the user by the Firebase\n      if (typeof firebaseId === 'string') {\n        if (checkIsValidExportedCryptoCredentialsToString(credentials)) {\n          return true;\n        }\n        console.error(\n          \"Credentials are't exists or invalid in the stored credentials\"\n        );\n      } else {\n        console.error(\n          'Firebase user id is not valid in the stored credentials'\n        );\n      }\n    }\n    return false;\n  }\n\n  protected async getCredentialsByValueStored(\n    storedCredentialsValue: any,\n    signUpCredentials?: ICAConnectionSignUpCredentials\n  ): Promise<TCentralAuthorityUserCryptoCredentials | null | Error> {\n    if (storedCredentialsValue == null) {\n      return null;\n    }\n    if (storedCredentialsValue instanceof Error) {\n      return storedCredentialsValue;\n    }\n    if (!this.checkStoredCredentialsFormat(storedCredentialsValue)) {\n      return new Error('the value stored have an unknown format');\n    }\n\n    const { credentials: exportedCredentials } = storedCredentialsValue;\n    const importedCredentials = await importCryptoCredentialsFromAString(\n      exportedCredentials,\n      signUpCredentials?.password\n    );\n\n    if (importedCredentials instanceof Error) {\n      console.error(importedCredentials);\n      return new Error('Failed to import credentials value stored');\n    }\n    return importedCredentials;\n  }\n\n  /**\n   *\n   * filter a value stored for the user key\n   * to get a value of the credentials\n   * for the user\n   * @protected\n   * @param {{\n   *     [key: string]: any;\n   *   }} [valueStored]\n   * @returns {(Promise<TCentralAuthorityUserCryptoCredentials | null | Error>)}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  protected async filterCredentialsValues(\n    valueStored: Record<string, any>,\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<TCentralAuthorityUserCryptoCredentials | null | Error> {\n    if (!valueStored) {\n      return null;\n    }\n    if (valueStored instanceof Error) {\n      return valueStored;\n    }\n\n    const keys = Object.keys(valueStored);\n\n    // if an empty object\n    if (keys.length === 0) {\n      return null;\n    }\n\n    const len = Math.min(\n      keys.length,\n      CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_MAXIMUM_STORED_VALUES_CHECK\n    );\n    let idx = 0;\n    let keyValueStored;\n    let valueValueStored;\n    let credentialsImported;\n\n    // for each property of the value stored\n    // check wherether it is a valid\n    // crypto credentials\n    for (; idx < len; idx++) {\n      keyValueStored = keys[idx];\n      valueValueStored = valueStored[keyValueStored];\n      credentialsImported = await this.getCredentialsByValueStored(\n        valueValueStored,\n        signUpCredentials\n      );\n\n      if (!(credentialsImported instanceof Error)) {\n        return credentialsImported;\n      }\n    }\n    return null;\n  }\n\n  // check if there is a credentials for the current user is exists\n  // and return it if exists\n  public async getCredentialsForTheCurrentUser(\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | null | TCentralAuthorityUserCryptoCredentials> {\n    const isAuthorizedResult = this.checkIsAuthorized();\n\n    if (isAuthorizedResult instanceof Error) {\n      console.error(isAuthorizedResult);\n      return new Error('The user is not authorized');\n    }\n\n    const { firebaseUserId } = this;\n\n    if (firebaseUserId instanceof Error) {\n      console.error(firebaseUserId);\n      return new Error('Failed to get user id of the firebase user');\n    }\n\n    const { database } = this;\n\n    if (!database) {\n      return new Error('There is no connection to the database server');\n    }\n    try {\n      // read a value storerd as user's\n      // credentials in the database\n      const snapshot = await database\n        .ref(CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_KEY_PREFIX)\n        .orderByChild(\n          CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY\n        )\n        .equalTo(firebaseUserId)\n        .once('value');\n      if (snapshot.exists()) {\n        const valueStored = snapshot.val();\n        return this.filterCredentialsValues(valueStored, signUpCredentials);\n      }\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to read the user data from the database');\n    }\n    return null;\n  }\n\n  // store the credentials value\n  // for the current user\n  public async setUserCredentials(\n    credentials: TCentralAuthorityUserCryptoCredentials,\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials> {\n    const isAuthorizedResult = this.checkIsAuthorized();\n\n    if (isAuthorizedResult instanceof Error) {\n      console.error(isAuthorizedResult);\n      return new Error('The user is not authorized');\n    }\n\n    const { firebaseUserId } = this;\n\n    if (firebaseUserId instanceof Error) {\n      console.error(firebaseUserId);\n      return new Error('Failed to get user id of the firebase user');\n    }\n\n    // check if a credentials value is\n    // already exists for the user\n    const credentialsForTheCurrentUser = await this.getCredentialsForTheCurrentUser(\n      signUpCredentials\n    );\n\n    if (\n      credentialsForTheCurrentUser != null &&\n      !(credentialsForTheCurrentUser instanceof Error)\n    ) {\n      // if a credentials are already stored for the user\n      // return it\n      return credentialsForTheCurrentUser;\n    }\n\n    const userId = getUserIdentityByCryptoCredentials(credentials);\n\n    if (userId instanceof Error) {\n      console.error(userId);\n      return new Error(\"Failed to get a user's identity from the credentials\");\n    }\n    if (!signUpCredentials.password) {\n      return new Error('The password is required to encrypt the private keys');\n    }\n\n    const exportedCryptoCredentials = await exportCryptoCredentialsToString(\n      credentials,\n      undefined,\n      signUpCredentials.password\n    );\n\n    if (exportedCryptoCredentials instanceof Error) {\n      console.error(exportedCryptoCredentials);\n      return new Error('Failed to export the crypto credentials value');\n    }\n\n    // check if the user id is not exists in the database\n    // user id is a user identity\n    // TODO - it's necessary to implement on the Firebase server to check whether the user can update credentials for the userid\n    const credentialsForTheUserId = await this.getUserCredentials(userId);\n\n    if (\n      credentialsForTheUserId != null &&\n      !(credentialsForTheUserId instanceof Error)\n    ) {\n      return new Error(\n        'A crypto credentials is already exists for the user id'\n      );\n    }\n\n    const keyForValue = this.getCredentialsKeyByUserId(userId);\n    const storeResult = await this.setValue<\n      ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure\n    >(keyForValue, {\n      credentials: exportedCryptoCredentials,\n      [CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY]: firebaseUserId,\n    });\n\n    if (storeResult instanceof Error) {\n      console.error(storeResult);\n      return new Error('Failed to store the credentials in the database');\n    }\n    return credentials;\n  }\n\n  /**\n   *\n   * return a credentials for the user\n   * with the id = userId.\n   * For the v1 the user id must be a uuidV4.\n   * For the v2 the user id must be a login(email)\n   * under which the user was registered the\n   * Firebase account.\n   *\n   * @param {string} userId\n   * @returns {(Promise<Error | null | TCentralAuthorityUserCryptoCredentials>)}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  public async getUserCredentials(\n    userId: string\n  ): Promise<Error | null | TCentralAuthorityUserCryptoCredentials> {\n    if (!this.checkIsConnected()) {\n      return new Error('There is no active connection to the Firebase');\n    }\n    if (!validateUserIdentity(userId)) {\n      return new Error('The user identity is not valid');\n    }\n\n    const keyForValue = this.getCredentialsKeyByUserId(userId);\n    const storedCredentialsValue = await this.getValue<\n      ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure\n    >(keyForValue);\n\n    return this.getCredentialsByValueStored(storedCredentialsValue);\n  }\n\n  // disconnect from the database\n  public async disconnect(): Promise<Error | boolean> {\n    const isConnected = this.checkIsConnected();\n\n    if (!isConnected) {\n      return true;\n    }\n    const { database } = this;\n\n    if (!database) {\n      return new Error('There is no active database connection');\n    }\n    try {\n      await database.goOffline();\n    } catch (err) {\n      console.error();\n      return new Error('Failed to disconnect from the databases');\n    }\n    return true;\n  }\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.types.ts",["2307"],"import * as firebase from 'firebase/app';\nimport { CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY } from './central-authority-connection-firebase-utils.credentials-storage.const';\nimport { TCentralAuthorityUserCryptoCredentials } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { CA_CONNECTION_STATUS } from 'classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const';\n\nexport interface ICAConnectionFirestoreUtilsCredentialsStrorage {\n  setUserCredentials(\n    userId: string,\n    cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): Promise<Error | boolean>;\n  getUserCredentials(\n    userId: string\n  ): Promise<Error | null | TCentralAuthorityUserCryptoCredentials>;\n}\n\nexport interface ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure {\n  [CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY]: string;\n  credentials: string;\n}\n\nexport interface ICAConnectionFirebase {\n  isConnected: boolean;\n  isUserSignedIn: boolean;\n  getApp(): void | firebase.app.App;\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database.ts",["2308","2309","2310","2311","2312","2313","2314"],"import * as firebase from 'firebase';\nimport {\n  CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MAX_LENGTH,\n  CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MIN_LENGTH,\n} from './central-authority-connection-firebase-utils.database.const';\n\nexport class CAConnectionWithFirebaseUtilDatabase {\n  protected app?: firebase.app.App;\n\n  protected database?: firebase.database.Database;\n\n  protected wasConnected: boolean = false;\n\n  public get isConnected(): boolean {\n    const { wasConnected, database } = this;\n\n    return wasConnected && !!database;\n  }\n\n  protected setWasConnectedStatus(wasConnected = false) {\n    this.wasConnected = !!wasConnected;\n  }\n\n  protected setDatabaseInstance(db: firebase.database.Database) {\n    this.database = db;\n  }\n\n  protected checkIsConnected(): Error | boolean {\n    const { isConnected } = this;\n\n    if (!isConnected) {\n      return new Error('There is no connection with the remote database');\n    }\n    return true;\n  }\n\n  protected checkKeyValue(key: any): key is string {\n    if (typeof key !== 'string') {\n      console.error('Key must be a string');\n      return false;\n    }\n\n    const keyLen = key.length;\n\n    if (keyLen > CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MAX_LENGTH) {\n      console.error(\n        `Key must be less than ${CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MAX_LENGTH}, but the value is ${keyLen} characters len`\n      );\n      return false;\n    }\n    if (keyLen < CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MIN_LENGTH) {\n      console.error(\n        `Key must be greater than ${CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MAX_LENGTH}, but the value is ${keyLen} characters len`\n      );\n      return false;\n    }\n    return true;\n  }\n\n  public async connect(): Promise<boolean | Error> {\n    const { isConnected, app } = this;\n\n    if (isConnected) {\n      return true;\n    }\n    if (!app) {\n      return new Error('The app is not defined');\n    }\n    try {\n      const database = app.database();\n\n      await database.goOnline();\n      this.setDatabaseInstance(database);\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to connect to the Database server');\n    }\n    this.setWasConnectedStatus(true);\n    return true;\n  }\n\n  /**\n   * This method destroys the\n   * application instance, Not just\n   * go offline. This means that\n   * the reconnection with calling of\n   * the 'connect' method will failed\n   * and therefore is not allowed.\n   *\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof CAConnectionWithFirebaseUtilDatabase\n   */\n  public async disconnect(): Promise<boolean | Error> {\n    const isConnected = this.checkIsConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { database } = this;\n\n    try {\n      await database!!.goOffline();\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to go offline before destroy the application');\n    }\n    this.setWasConnectedStatus(false);\n    return true;\n  }\n\n  protected checkBeforeReadWrite(key: string): Error | boolean {\n    const isConnectedResult = this.checkIsConnected();\n\n    if (isConnectedResult instanceof Error) {\n      return isConnectedResult;\n    }\n    if (!this.checkKeyValue(key)) {\n      return new Error('The key value is not valid');\n    }\n    return true;\n  }\n\n  public async setValue<T>(key: string, value: T): Promise<Error | boolean> {\n    const canWrite = this.checkBeforeReadWrite(key);\n\n    if (canWrite instanceof Error) {\n      return canWrite;\n    }\n\n    const { database } = this;\n\n    try {\n      await database!!.ref(key).set(value);\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to store the value in the database');\n    }\n    return true;\n  }\n\n  public async getValue<T>(key: string): Promise<Error | null | T> {\n    const canRead = this.checkBeforeReadWrite(key);\n\n    if (canRead instanceof Error) {\n      return canRead;\n    }\n\n    const { database } = this;\n\n    try {\n      const snapshot = await database!!.ref(key).once('value');\n      const isExists = snapshot.exists();\n\n      if (!isExists) {\n        return null;\n      }\n      return snapshot.val() as T;\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to read the value from the storage');\n    }\n  }\n}\n\nexport default CAConnectionWithFirebaseUtilDatabase;\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators/central-authority-connection-firebase-utils.validators.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators/central-authority-connection-firebase-utils.validators.ts",["2315"],"import { validateBySchema } from 'utils/validation-utils/validation-utils';\nimport { ICAConnectionConfigurationFirebase } from '../../central-authority-connection-firebase.types.configuration';\nimport { CA_AUTH_CONNECTION_FIREBASE_UTILS_VALIDATOR_SCHEME_CONNECTION_OPTIONS } from './central-authority-connection-firebase-utils.validators.const';\nimport validator from 'validator';\n\nexport const valiateCAAuthConnectionFirebaseUtilsConnetionConfiguration = (\n  configuration: any\n): configuration is ICAConnectionConfigurationFirebase => {\n  if (\n    !validateBySchema(\n      CA_AUTH_CONNECTION_FIREBASE_UTILS_VALIDATOR_SCHEME_CONNECTION_OPTIONS,\n      configuration\n    )\n  ) {\n    return false;\n  }\n  return validator.isURL(configuration.databaseURL);\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.auth.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.error-codes.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.restrictions.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.types.configuration.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const-error-codes.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const-status.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-pool/central-authority-connections-pool.ts",["2316","2317"],"import { normalizeUrl } from 'utils/common-utils/common-utils-url';\nimport {\n  ICAConnectionsPoolOptions,\n  ICAConnectionsPoolConnections,\n  IAuthProviderConnectionConfiguration,\n  ICAConnectionsPoolCurrentConnections,\n  ICAConnectionPool,\n} from './central-authority-connections-pool.types';\nimport {\n  normalizeCAConnectionAuthProviderURL,\n  validateCAConnectionAuthProviderType,\n  validateCAConnectionAuthProviderConnectionConfiguration,\n  validateCAConnectionAuthProviderUrl,\n} from '../central-authority-connections-utils/central-authority-connections-utils';\nimport {\n  ICAConnection,\n  TCAAuthProviderIdentity,\n  ICAConnectionSignUpCredentials,\n} from '../central-authority-connections.types';\nimport { getConnectionConstructorAuthProviderType } from '../central-authority-connections-utils/central-authority-connections-utils.common/central-authority-connections-utils.common';\nimport { ICentralAuthorityUserProfile } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { CA_CONNECTION_STATUS } from '../central-authority-connections-const/central-authority-connections-const';\nimport { ICAConnectionUserAuthorizedResult } from '../central-authority-connections.types';\nimport { TCAuthProviderIdentifier } from '../../central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { ICAConnectionPoolAuthResult } from './central-authority-connections-pool.types';\nimport { checkIsValidCryptoCredentials } from '../../central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport CentralAuthorityIdentity from '../../central-authority-class-user-identity/central-authority-class-user-identity';\nimport { CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME } from '../../central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport { compareAuthProvidersIdentities } from '../../central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\n\n/**\n * This is used to establish connections\n * with auth providers to collect a\n * crypto keys of swarm users.\n *\n * @export\n * @class CAConnectionsPool\n */\nexport class CAConnectionsPool implements ICAConnectionPool {\n  public userAuthResult?: ICAConnectionPoolAuthResult;\n\n  /**\n   * States of connections to auth\n   * providers\n   *\n   * @protected\n   * @type {ICAConnectionsPoolConnections}\n   * @memberof CAConnectionsPool\n   */\n  protected providersConnectionState: ICAConnectionsPoolConnections = {};\n\n  /**\n   * connection throught which the user\n   * is authorized on auth provider service.\n   * Search trought all the connections\n   * connection with the auth flag.\n   *\n   * @readonly\n   * @protected\n   * @type {(ICAConnection | void)}\n   * @memberof CAConnectionsPool\n   */\n  protected get authConnection(): {\n    connection: ICAConnection;\n    authProviderId: TCAuthProviderIdentifier;\n  } | void {\n    const { providersConnectionState } = this;\n    const providersConnectionsStates = Object.values(providersConnectionState);\n    let idx = 0;\n    let authProviderConnection;\n    let authProviderUrl;\n    const len = providersConnectionsStates.length;\n\n    while (idx < len) {\n      ({\n        connection: authProviderConnection,\n        caProviderUrl: authProviderUrl,\n      } = providersConnectionsStates[idx++]);\n      if (\n        authProviderConnection &&\n        authProviderConnection.status === CA_CONNECTION_STATUS.AUTHORIZED\n      ) {\n        return {\n          connection: authProviderConnection,\n          authProviderId:\n            authProviderUrl ||\n            (authProviderConnection.authProviderURL as string),\n        };\n      }\n    }\n  }\n\n  /**\n   * Creates an instance of CAConnectionsPool.\n   * @param {ICAConnectionsPoolOptions} options\n   * @memberof CAConnectionsPool\n   * @throws\n   */\n  constructor(options: ICAConnectionsPoolOptions) {\n    this.setOptions(options);\n  }\n\n  /**\n   * at now it is alias for the connect method\n   *\n   * @param {TCAAuthProviderIdentity} authProvider\n   * @returns\n   * @memberof CAConnectionsPool\n   */\n  public getConnection(authProvider: TCAAuthProviderIdentity) {\n    return this.connect(authProvider);\n  }\n\n  /**\n   * establish a new connection with the auth\n   * provider or returns an existing connection\n   * if it is active(status !== DISCONNECTED)\n   *\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @returns {(Promise<ICAConnection | Error>)}\n   * @memberof CAConnectionsPool\n   */\n  public async connect(\n    authProviderUrl: TCAAuthProviderIdentity,\n    isAuthentificateAnonymousely: boolean = true\n  ): Promise<ICAConnection | Error> {\n    if (!validateCAConnectionAuthProviderUrl(authProviderUrl)) {\n      return new Error(\n        'The url provided as the auth provider service url is not valid'\n      );\n    }\n\n    const currentConnectionWithAuthProvider = this.getActiveConnectionWithAuthProvider(\n      authProviderUrl\n    );\n\n    if (currentConnectionWithAuthProvider instanceof Error) {\n      console.error(currentConnectionWithAuthProvider);\n      return new Error(\n        `Failed to resolve an active connection with the provider ${authProviderUrl}`\n      );\n    }\n    if (currentConnectionWithAuthProvider) {\n      return currentConnectionWithAuthProvider;\n    }\n\n    const connectionWithAuthProvider = await this.connectWithAuthProvider(\n      authProviderUrl\n    );\n\n    if (connectionWithAuthProvider instanceof Error) {\n      return connectionWithAuthProvider;\n    }\n    if (isAuthentificateAnonymousely) {\n      const ananymousResult = await connectionWithAuthProvider.signInAnonymousely();\n\n      if (ananymousResult instanceof Error) {\n        return ananymousResult;\n      }\n      return this.addConectionWithProvider(\n        authProviderUrl,\n        connectionWithAuthProvider\n      );\n    }\n    return connectionWithAuthProvider;\n  }\n\n  /**\n   * authorize on the service or return an existing\n   * connection which is the user authorized through\n   *\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @param {ICAConnectionSignUpCredentials} signUpCredentials\n   * @param {Partial<ICentralAuthorityUserProfile>} [profile]\n   * @returns {(Promise<Error | ICAConnection>)}\n   * @memberof CAConnectionsPool\n   */\n  public async authorize(\n    authProviderUrl: TCAAuthProviderIdentity,\n    signUpCredentials: ICAConnectionSignUpCredentials,\n    profile?: Partial<ICentralAuthorityUserProfile>\n  ): Promise<Error | ICAConnection> {\n    if (!validateCAConnectionAuthProviderUrl(authProviderUrl)) {\n      return new Error(\n        'The url provided as the auth provider service url is not valid'\n      );\n    }\n    if (this.userAuthResult) {\n      // if the user is already authorized on auth provider service\n      const signOutResult = await this.signOut();\n\n      if (signOutResult instanceof Error) {\n        console.error(signOutResult);\n        return new Error(\n          'The user is already authorized on the auth provider service, and failed to sign out from it'\n        );\n      }\n    }\n\n    const currentConnectionWithProviderAuthOn = this.authConnection;\n    const normalizedUrl = normalizeUrl(authProviderUrl);\n\n    if (normalizedUrl instanceof Error) {\n      console.error(normalizedUrl);\n      return new Error('Failed to normalize the url of the auth provider');\n    }\n    if (currentConnectionWithProviderAuthOn) {\n      const {\n        authProviderId: currentAuthProviderUrl,\n        connection,\n      } = currentConnectionWithProviderAuthOn;\n      const normalizedUrlAuthProviderCurrent = normalizeUrl(\n        currentAuthProviderUrl\n      );\n\n      if (normalizedUrlAuthProviderCurrent !== normalizedUrl) {\n        return new Error(\n          `Already authorized on the ${normalizedUrlAuthProviderCurrent} service, differ from the requested ${authProviderUrl}`\n        );\n      }\n      return connection;\n    }\n\n    const connectionWithAuthProvider = await this.connect(\n      authProviderUrl,\n      false\n    );\n\n    if (connectionWithAuthProvider instanceof Error) {\n      console.error(connectionWithAuthProvider);\n      return new Error(\n        `Failed to connect with the auth provider ${authProviderUrl}`\n      );\n    }\n\n    const authResult = await connectionWithAuthProvider.authorize(\n      signUpCredentials,\n      profile\n    );\n\n    if (authResult instanceof Error) {\n      const disconnectFromTheConnectionResult = await connectionWithAuthProvider.disconnect();\n\n      if (disconnectFromTheConnectionResult instanceof Error) {\n        console.error(disconnectFromTheConnectionResult);\n        console.error(\n          new Error(\n            'Failed to disconnect form the auth provider which failed to authorize on'\n          )\n        );\n      }\n      console.error(\n        `Failed to authorize with the auth provider ${authProviderUrl}`\n      );\n      return authResult;\n    }\n\n    const addConnectionResult = await this.addConectionWithProvider(\n      authProviderUrl,\n      connectionWithAuthProvider\n    );\n\n    if (addConnectionResult instanceof Error) {\n      try {\n        await connectionWithAuthProvider.disconnect();\n      } catch (err) {\n        console.error('Failed to disconnect', err);\n      }\n      return addConnectionResult;\n    }\n    this.setAuthResult(authProviderUrl, authResult);\n    return connectionWithAuthProvider;\n  }\n\n  /**\n   * disconnect from the auth provider.\n   * succed even if not connected to.\n   *\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @returns {(Promise<void | Error>)}\n   * @memberof CAConnectionsPool\n   */\n  public async disconnect(\n    authProviderUrl: TCAuthProviderIdentifier\n  ): Promise<void | Error> {\n    const currentConnectionWithAuthProvider = this.getConnectionWithAuthProvider(\n      authProviderUrl\n    );\n\n    if (currentConnectionWithAuthProvider instanceof Error) {\n      return currentConnectionWithAuthProvider;\n    }\n    if (currentConnectionWithAuthProvider) {\n      const disconnectionResult = await currentConnectionWithAuthProvider.disconnect();\n\n      if (disconnectionResult instanceof Error) {\n        console.error(disconnectionResult);\n        return new Error(\n          `Failed to disconnect from the auth provider ${authProviderUrl}`\n        );\n      }\n    }\n    return this.unsetConnectionWithAuthProvider(authProviderUrl);\n  }\n\n  /**\n   * disconnect from all the active connections\n   *\n   * @returns {(Promise<Error | void>)}\n   * @memberof CAConnectionsPool\n   */\n  public async close(): Promise<Error | void> {\n    const { providersConnectionState } = this;\n    const providerConnectionStateValues = Object.values(\n      providersConnectionState\n    );\n    const disconnectResults = [];\n    const len = providerConnectionStateValues.length;\n    let idx = 0;\n    let connectionToAuthProviderStateDesc;\n    let connectionToAuthProvider;\n    let errorMessage = '';\n\n    while (idx < len) {\n      connectionToAuthProviderStateDesc = providerConnectionStateValues[idx++];\n      ({\n        connection: connectionToAuthProvider,\n      } = connectionToAuthProviderStateDesc);\n      idx += 1;\n      if (connectionToAuthProvider) {\n        const connectionToAuthProviderUrl =\n          connectionToAuthProviderStateDesc.caProviderUrl;\n\n        if (\n          connectionToAuthProvider.status !== CA_CONNECTION_STATUS.DISCONNECTED\n        ) {\n          disconnectResults.push(\n            connectionToAuthProvider\n              .disconnect()\n              .then((result) => {\n                if (result instanceof Error) {\n                  console.error(result);\n                  errorMessage += `/nThe error has occured when disconnect from the auth provider ${connectionToAuthProviderUrl}`;\n                } else {\n                  this.unsetConnectionWithAuthProvider(\n                    connectionToAuthProviderUrl\n                  );\n                }\n              })\n              .catch((err) => {\n                console.error(err);\n                errorMessage += `/nCrashed while disconnect from the auth provider ${connectionToAuthProviderUrl}`;\n              })\n          );\n        }\n        this.unsetConnectionWithAuthProvider(connectionToAuthProviderUrl);\n      }\n    }\n    // wait till all connections will be pro\n    await Promise.all(disconnectResults);\n    if (errorMessage) {\n      return new Error(errorMessage);\n    }\n  }\n\n  /**\n   * sign out from the auth provider service\n   * which is currently authorized on and close the connection\n   *\n   * @returns {(Promise<Error | void>)}\n   * @memberof CAConnectionsPool\n   */\n  public async signOut(): Promise<Error | void> {\n    const { authConnection } = this;\n\n    this.unsetAuthResult();\n    if (authConnection) {\n      const { connection, authProviderId: authProviderUrl } = authConnection;\n\n      if (connection) {\n        const disconnectResult = await this.disconnect(authProviderUrl);\n\n        if (disconnectResult instanceof Error) {\n          console.error(disconnectResult);\n          return new Error(\n            `Failed to disconnect from the auth procider ${authProviderUrl} on sign out from it`\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns user's profile stored by the CA\n   * provider on which the user is authorized on.\n   * If the user is not authorized on a CA\n   * then undefined will be returned.\n   *\n   * @memberof CAConnectionsPool\n   */\n  public getCAUserProfile = async () => {\n    const authConnection = this.authConnection;\n    if (!authConnection) {\n      return;\n    }\n    return authConnection.connection?.getCAUserProfile();\n  };\n\n  /**\n   * set the auth result and check the auth provider\n   * in the result is equals to the auth provider id.\n   *\n   * @protected\n   * @param {TCAAuthProviderIdentity} authProviderId\n   * @param {ICAConnectionUserAuthorizedResult} authResult\n   * @returns {(Error | void)}\n   * @memberof CAConnectionsPool\n   */\n  protected setAuthResult(\n    authProviderId: TCAAuthProviderIdentity,\n    authResult: ICAConnectionUserAuthorizedResult\n  ): Error | void {\n    const { cryptoCredentials } = authResult;\n    const validationResult = checkIsValidCryptoCredentials(cryptoCredentials);\n\n    if (!validationResult) {\n      return new Error('The crypto credentials are not valid');\n    }\n\n    const userIdentity = new CentralAuthorityIdentity(\n      cryptoCredentials.userIdentity\n    );\n\n    if (userIdentity.identityDescription instanceof Error) {\n      return new Error('The user identity is not valid');\n    }\n    if (\n      !compareAuthProvidersIdentities(\n        userIdentity.identityDescription[\n          CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME\n        ],\n        authProviderId\n      )\n    ) {\n      return new Error(`\n        The auth provider url from the auth crdentials ${userIdentity.identityDescription[CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]} is not equals to the provider the user authorized on ${authProviderId}\n      `);\n    }\n\n    this.userAuthResult = {\n      ...authResult,\n      authProviderId,\n    };\n  }\n\n  protected unsetAuthResult() {\n    this.userAuthResult = undefined;\n  }\n\n  /**\n   * returns the current state of a connection\n   * to the auth provider.\n   *\n   * @protected\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @returns {(ICAConnectionsPoolCurrentConnections | undefined | Error)}\n   * @memberof CAConnectionsPool\n   */\n  protected getAuthProviderStateDesc(\n    authProviderUrl: TCAAuthProviderIdentity\n  ): ICAConnectionsPoolCurrentConnections | undefined | Error {\n    const normalizedUrl = normalizeUrl(authProviderUrl);\n\n    if (normalizedUrl instanceof Error) {\n      console.error(normalizedUrl);\n      return new Error('The url is not valid');\n    }\n\n    const { providersConnectionState } = this;\n\n    return providersConnectionState[normalizedUrl];\n  }\n\n  protected async addConectionWithProvider(\n    authProviderUrl: string,\n    connectionWithAuthProvider: ICAConnection\n  ): Promise<ICAConnection | Error> {\n    const setConnectionInAuhProviderConnectionStatesStore = this.setConnectionWithAuthProvider(\n      authProviderUrl,\n      connectionWithAuthProvider\n    );\n\n    if (setConnectionInAuhProviderConnectionStatesStore instanceof Error) {\n      console.error(setConnectionInAuhProviderConnectionStatesStore);\n\n      const disconnectResult = await connectionWithAuthProvider.disconnect();\n\n      if (disconnectResult instanceof Error) {\n        console.error(disconnectResult);\n      }\n      return new Error('Failed to set connection with auth provider');\n    }\n    return connectionWithAuthProvider;\n  }\n\n  /**\n   * returns connection which is active\n   * and the status !== DISCONNECTED\n   *\n   * @protected\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @returns {(ICAConnection | void | Error)}\n   * @memberof CAConnectionsPool\n   */\n  protected getActiveConnectionWithAuthProvider(\n    authProviderUrl: TCAAuthProviderIdentity\n  ): ICAConnection | void | Error {\n    const authProviderState = this.getAuthProviderStateDesc(authProviderUrl);\n\n    if (authProviderState instanceof Error) {\n      return authProviderState;\n    }\n    if (authProviderState) {\n      const { connection } = authProviderState;\n\n      if (\n        connection &&\n        connection.status !== CA_CONNECTION_STATUS.DISCONNECTED\n      ) {\n        return connection;\n      }\n    }\n  }\n\n  /**\n   * returns any connection\n   *\n   * @protected\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @returns {(ICAConnection | void | Error)}\n   * @memberof CAConnectionsPool\n   */\n  protected getConnectionWithAuthProvider(\n    authProviderUrl: TCAAuthProviderIdentity\n  ): ICAConnection | void | Error {\n    const authProviderState = this.getAuthProviderStateDesc(authProviderUrl);\n\n    if (authProviderState instanceof Error) {\n      return authProviderState;\n    }\n    if (authProviderState) {\n      return authProviderState.connection;\n    }\n  }\n\n  /**\n   * updates the current state of connection\n   * with the auth provider.\n   *\n   * @protected\n   * @param {ICAConnectionsPoolCurrentConnections} authProviderConnectionState\n   * @memberof CAConnectionsPool\n   */\n  protected updateStateAuthProvider(\n    authProviderConnectionState: Partial<\n      ICAConnectionsPoolCurrentConnections\n    > & { caProviderUrl: ICAConnectionsPoolCurrentConnections['caProviderUrl'] }\n  ) {\n    const { caProviderUrl } = authProviderConnectionState;\n\n    if (!caProviderUrl) {\n      return new Error('An url of the auth provider must be specified');\n    }\n\n    const authProviderUrlNormalized = normalizeCAConnectionAuthProviderURL(\n      caProviderUrl\n    );\n\n    if (authProviderUrlNormalized instanceof Error) {\n      return authProviderUrlNormalized;\n    }\n\n    const { providersConnectionState } = this;\n    const existingState = providersConnectionState[authProviderUrlNormalized];\n\n    if (!existingState) {\n      providersConnectionState[\n        caProviderUrl\n      ] = authProviderConnectionState as ICAConnectionsPoolCurrentConnections;\n    } else {\n      Object.assign(existingState, authProviderConnectionState);\n    }\n  }\n\n  /**\n   * set an active connection with an\n   * auth provider in the auth\n   * providers state.\n   *\n   * @protected\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @param {ICAConnection} connection\n   * @returns\n   * @memberof CAConnectionsPool\n   */\n  protected setConnectionWithAuthProvider(\n    authProviderUrl: TCAAuthProviderIdentity,\n    connection: ICAConnection\n  ) {\n    const authProviderUrlNormalized = normalizeUrl(authProviderUrl);\n\n    if (authProviderUrlNormalized instanceof Error) {\n      console.error(authProviderUrlNormalized);\n      return new Error('The url is not valid');\n    }\n\n    if (!connection) {\n      return new Error(\n        `Connection with the auth provider ${authProviderUrl} must be specified`\n      );\n    }\n    if (\n      typeof connection.authorize !== 'function' ||\n      typeof connection.connect !== 'function'\n    ) {\n      return new Error('The instance of the CAConnection is not valid');\n    }\n    if (connection.status === CA_CONNECTION_STATUS.DISCONNECTED) {\n      return new Error('The connection must be in active state');\n    }\n\n    const existingConnection = this.getActiveConnectionWithAuthProvider(\n      authProviderUrl\n    );\n\n    if (existingConnection instanceof Error) {\n      return existingConnection;\n    }\n    if (existingConnection) {\n      return new Error(\n        `Connection with the ${authProviderUrl} is already exists`\n      );\n    }\n    return this.updateStateAuthProvider({\n      connection,\n      caProviderUrl: authProviderUrl,\n    });\n  }\n\n  /**\n   * unset the current connection in the auth provider\n   * connections states store\n   *\n   * @protected\n   * @memberof CAConnectionsPool\n   */\n  protected unsetConnectionWithAuthProvider(\n    authProviderUrl: TCAAuthProviderIdentity\n  ): Error | void {\n    return this.updateStateAuthProvider({\n      caProviderUrl: authProviderUrl,\n      connection: undefined,\n    });\n  }\n\n  /**\n   * establish a new connection with the auth\n   * provider.\n   *\n   * @protected\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @returns {(Promise<Error | ICAConnection>)}\n   * @memberof CAConnectionsPool\n   */\n  protected async connectWithAuthProvider(\n    authProviderUrl: TCAAuthProviderIdentity\n  ): Promise<Error | ICAConnection> {\n    const normalizedAuthProviderUrl = normalizeUrl(authProviderUrl);\n\n    if (normalizedAuthProviderUrl instanceof Error) {\n      console.error(normalizedAuthProviderUrl);\n      return new Error('The url provided for the auth provider is not valid');\n    }\n\n    const stateOfAuthProvider = this.getAuthProviderStateDesc(authProviderUrl);\n\n    if (stateOfAuthProvider instanceof Error) {\n      console.error(stateOfAuthProvider);\n      return new Error(\n        `The configuration for the ${authProviderUrl} is not valid`\n      );\n    }\n    if (!stateOfAuthProvider) {\n      return new Error(`The url provided ${authProviderUrl} is not known`);\n    }\n\n    const { options, caProvider } = stateOfAuthProvider;\n\n    if (!options) {\n      return new Error(\n        `Connection options is not specified for the auth provider ${authProviderUrl}`\n      );\n    }\n    if (caProvider == null) {\n      return new Error(\n        'Auth provider type is not specified in the current state'\n      );\n    }\n\n    const ConnectionConstructor = getConnectionConstructorAuthProviderType(\n      caProvider\n    );\n\n    if (!ConnectionConstructor) {\n      return new Error(\n        `There is no constructor class for the auth provider ${authProviderUrl}`\n      );\n    }\n    if (ConnectionConstructor instanceof Error) {\n      console.error(ConnectionConstructor);\n      return new Error(\n        `An error has occurred on define constructor class for the auth provider ${authProviderUrl}`\n      );\n    }\n\n    let connectionWithAuthProvider;\n    try {\n      connectionWithAuthProvider = new ConnectionConstructor();\n    } catch (err) {\n      console.error(err);\n      return new Error('The error has occurred when construct the connection');\n    }\n\n    const connectionResult = await connectionWithAuthProvider.connect(options);\n\n    if (connectionResult instanceof Error) {\n      console.error(connectionResult);\n      return new Error(\n        `Failed to connect with the auth provider ${authProviderUrl}`\n      );\n    }\n    return connectionWithAuthProvider;\n  }\n\n  /**\n   * add auth provider in the description\n   * of a state of connections\n   *\n   * @protected\n   * @param {IAuthProviderConnectionConfiguration} authProviderConnectionConfiguration\n   * @memberof CAConnectionsPool\n   * @throws\n   */\n  protected addAuthProvider = (\n    authProviderConnectionConfiguration: IAuthProviderConnectionConfiguration\n  ): void => {\n    if (!authProviderConnectionConfiguration) {\n      throw new Error('Configuration for the auth provider is not defined');\n    }\n    if (typeof authProviderConnectionConfiguration !== 'object') {\n      throw new Error('Configuration must be an object');\n    }\n\n    const {\n      caProvider,\n      caProviderUrl,\n      options,\n    } = authProviderConnectionConfiguration;\n\n    if (caProvider == null) {\n      throw new Error('Provider type must be defined');\n    }\n    if (!validateCAConnectionAuthProviderType(caProvider)) {\n      throw new Error('The auth provider type is wrong');\n    }\n\n    const authProviderUrlNormalized = normalizeCAConnectionAuthProviderURL(\n      caProviderUrl\n    );\n    const { providersConnectionState } = this;\n\n    if (authProviderUrlNormalized instanceof Error) {\n      throw authProviderUrlNormalized;\n    }\n    if (providersConnectionState[authProviderUrlNormalized]) {\n      throw new Error(\n        `Configuration was already set for the auth provider ${authProviderUrlNormalized}`\n      );\n    }\n    if (!options) {\n      throw new Error(\n        `Configuration for the auth provider ${authProviderUrlNormalized} is not specified`\n      );\n    }\n    if (\n      !validateCAConnectionAuthProviderConnectionConfiguration(\n        caProvider,\n        options\n      )\n    ) {\n      throw new Error(\n        `The configuration for the auth provider ${authProviderUrlNormalized} is not valid`\n      );\n    }\n\n    const setAuthProviderConnectionStateResult = this.updateStateAuthProvider({\n      caProvider,\n      caProviderUrl,\n      options,\n    });\n\n    if (setAuthProviderConnectionStateResult instanceof Error) {\n      throw setAuthProviderConnectionStateResult;\n    }\n  };\n\n  /**\n   * set options for auth providers connections constructors\n   *\n   * @protected\n   * @param {IAuthProviderConnectionConfiguration[]} providers\n   * @memberof CAConnectionsPool\n   * @throws\n   */\n  protected setOptionsOfAuthProviders(\n    providers: IAuthProviderConnectionConfiguration[]\n  ): void {\n    if (!providers) {\n      throw new Error('Providers property must be specified');\n    }\n    if (!(providers instanceof Array)) {\n      throw new Error('Providers must be an instance of Array');\n    }\n    if (!providers.length) {\n      throw new Error('Providers property must not be an empty array');\n    }\n    // add each auth provider configuration\n    // to connect on in a feature\n    providers.forEach(this.addAuthProvider);\n  }\n\n  /**\n   * set options for the instance.\n   *\n   * @protected\n   * @param {ICAConnectionsPoolOptions} options\n   * @memberof CAConnectionsPool\n   * @throws\n   */\n  protected setOptions(options: ICAConnectionsPoolOptions): void {\n    const { providers } = options;\n\n    this.setOptionsOfAuthProviders(providers);\n  }\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-pool/central-authority-connections-pool.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-pool/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.common/central-authority-connections-utils.common.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.normalizers.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.validators/central-authority-connections-utils.validators.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.validators/central-authority-connections-utils.validators.ts",["2318","2319"],"import {\n  CA_CONNECTION_AUTH_PROVIDERS,\n  CA_CONNECTIONS_POOL_AUTH_PROVIDERS_CONNECTION_CONSTRUCTORS,\n} from '../../central-authority-connections.const';\nimport { CA_CONNECTIONS_AUTH_PROVIDERS_VALUES } from './central-authority-connections-utils.validators.const';\nimport validator from 'validator';\nimport { TCAAuthProviderIdentity } from '../../central-authority-connections.types';\n\nexport const validateCAConnectionAuthProviderType = (\n  caAuthProvider: any\n): caAuthProvider is CA_CONNECTION_AUTH_PROVIDERS =>\n  CA_CONNECTIONS_AUTH_PROVIDERS_VALUES.includes(caAuthProvider);\n\nexport const validateCAConnectionAuthProviderUrl = (\n  caAuthProviderUrl: string\n): caAuthProviderUrl is TCAAuthProviderIdentity => {\n  try {\n    return validator.isURL(caAuthProviderUrl);\n  } catch {\n    return false;\n  }\n};\n\nexport const validateCAConnectionAuthProviderConnectionConfiguration = (\n  authProviderType: CA_CONNECTION_AUTH_PROVIDERS,\n  connectionConf: any\n): boolean => {\n  if (validateCAConnectionAuthProviderType(authProviderType)) {\n    const AuthProviderConnectionConstructor =\n      CA_CONNECTIONS_POOL_AUTH_PROVIDERS_CONNECTION_CONSTRUCTORS[\n        authProviderType\n      ];\n\n    return AuthProviderConnectionConstructor.validateConfiguration(\n      connectionConf\n    );\n  }\n  return false;\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-swarm-credentials-provider/central-authority-swarm-credentials-provider.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-swarm-credentials-provider/central-authority-swarm-credentials-provider.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-swarm-credentials-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-common.ts",["2320","2321","2322","2323"],"import {\n  isCryptoKeyPair,\n  isCryptoKey,\n  isCryptoKeyPairExportedAsString,\n} from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport {\n  TCACryptoKeyPairs,\n  TCACryptoPubilicKeys,\n  TCACryptoKeyPairsExported,\n} from '../../central-authority-class-types/central-authority-class-types';\nimport {\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_STRINGIFIED_MIN_LENGTH,\n} from './central-authority-util-crypto-keys.const';\n\nexport const checkIsCryptoKeyPairsExportedAsString = (v: any): boolean => {\n  return (\n    typeof v === 'string' &&\n    v.length >= CA_CRYPTO_KEY_PAIRS_STRINGIFIED_MIN_LENGTH\n  );\n};\n\n/**\n * check is a given value\n * have a key pairs in a\n * raw format\n * @param keyPairs\n * @returns {boolean}\n */\nexport const checkIsCryptoKeyPairs = (\n  keyPairs: any,\n  checkPrivateKeys: boolean = true\n): keyPairs is TCACryptoKeyPairs => {\n  if (keyPairs && typeof keyPairs === 'object') {\n    const {\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signKeyPair,\n    } = keyPairs;\n\n    if (!isCryptoKeyPair(encryptionKeyPair, checkPrivateKeys)) {\n      console.error('Encryption key pair is not valid');\n      return false;\n    }\n    if (!isCryptoKeyPair(signKeyPair, checkPrivateKeys)) {\n      console.error('Data sign key pair is not valid');\n      return false;\n    }\n    return true;\n  }\n  console.error('A wrong format of the keyPairs');\n  return false;\n};\n\n/**\n * check is a given value\n * have a key pairs in an\n * exported format\n * @param keyPairs\n * @returns {boolean}\n */\nexport const checkIsCryptoKeyPairsExported = (\n  keyPairs: any\n): keyPairs is TCACryptoKeyPairsExported => {\n  if (keyPairs && typeof keyPairs === 'object') {\n    const {\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPairExported,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signKeyPairExported,\n    } = keyPairs;\n\n    if (!isCryptoKeyPairExportedAsString(encryptionKeyPairExported)) {\n      console.error('Encryption key pair exported is not valid');\n      return false;\n    }\n    if (!isCryptoKeyPairExportedAsString(signKeyPairExported)) {\n      console.error('Data sign key pair exported is not valid');\n      return false;\n    }\n    return true;\n  }\n  console.error('A wrong format of the keyPairs exported');\n  return false;\n};\n\nexport const checkIsPublicKeys = (\n  keysPublic: any\n): keysPublic is TCACryptoPubilicKeys => {\n  if (keysPublic && typeof keysPublic === 'object') {\n    if (\n      !isCryptoKey(keysPublic[CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME])\n    ) {\n      console.error('Encryption public key is not valid');\n      return false;\n    }\n    if (!isCryptoKey(keysPublic[CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME])) {\n      console.error('Sign data public key is not valid');\n      return false;\n    }\n    return true;\n  }\n  console.error('A wrong format for the keysPublic');\n  return false;\n};\n\n/**\n * returns only a public keys\n * from a key pairs object\n * @param keyPairs\n * @returns {Error | object}\n */\nexport const getPublicKeysFromCryptoKeyPairs = (\n  keyPairs: TCACryptoKeyPairs\n): TCACryptoPubilicKeys | Error => {\n  if (!checkIsCryptoKeyPairs(keyPairs)) {\n    return new Error('There is a wrong format of the key pairs');\n  }\n\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: dataSignKeyPair,\n  }: TCACryptoKeyPairs = keyPairs;\n  const publicKeys = {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]:\n      encryptionKeyPair.publicKey,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: dataSignKeyPair.publicKey,\n  };\n\n  if (checkIsPublicKeys(publicKeys)) {\n    return publicKeys;\n  }\n  return new Error(\n    'Failed to receive a valid public keys from the encryption key pairs'\n  );\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-export.ts",["2324"],"import {\n  exportKeyPairAsString as exportKeyPairDataEncryptAsString,\n  exportKeyAsString as exportPublicKeyDataEncryptAsString,\n} from 'utils/encryption-utils';\nimport {\n  dataSignExportKeyPairAsString as exportKeyPairDataSignAsString,\n  dataSignExportKeyAsString as exportPublicKeyDataSignAsString,\n} from 'utils/data-sign-utils';\nimport {\n  TCACryptoKeyPairs,\n  TCACryptoPubilicKeys,\n} from '../../central-authority-class-types/central-authority-class-types';\nimport {\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME,\n} from './central-authority-util-crypto-keys.const';\nimport {\n  checkIsCryptoKeyPairs,\n  getPublicKeysFromCryptoKeyPairs,\n} from './central-authority-util-crypto-keys-common';\nimport { compressString } from 'utils/data-compression-utils/data-compression-utils-strings';\nimport { stringify } from 'utils/main-utils';\n\n/**\n * export two key pairs\n * (data sign and data encryption)\n * as a one string\n * @param {object} cryptoKeyPairs\n * @returns {Promise<string | Error>}\n */\nexport const exportKeyPairsAsString = async (\n  cryptoKeyPairs: TCACryptoKeyPairs,\n  password?: string\n): Promise<string | Error> => {\n  if (!checkIsCryptoKeyPairs(cryptoKeyPairs, !!password)) {\n    return new Error('The keypair is not valid');\n  }\n\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signDataKeyPair,\n  } = cryptoKeyPairs;\n  const [encryptionKeyPairString, signDataKeyPairString] = await Promise.all([\n    exportKeyPairDataEncryptAsString(encryptionKeyPair, password),\n    exportKeyPairDataSignAsString(signDataKeyPair, password),\n  ]);\n\n  if (encryptionKeyPairString instanceof Error) {\n    return encryptionKeyPairString;\n  }\n  if (signDataKeyPairString instanceof Error) {\n    return signDataKeyPairString;\n  }\n  try {\n    const stringifyResult = stringify({\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPairString,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signDataKeyPairString,\n    });\n\n    if (stringifyResult instanceof Error) {\n      return stringifyResult;\n    }\n    return compressString(stringifyResult);\n  } catch (err) {\n    return err;\n  }\n};\n\n/**\n * export a public keys only\n * from a keyPairs as a string\n * @param {object} keyPairs\n * @returns {string | Error}\n */\nexport const exportPublicKeysAsString = async (\n  keyPairs: TCACryptoKeyPairs\n): Promise<string | Error> => {\n  const publicKeys = getPublicKeysFromCryptoKeyPairs(keyPairs);\n\n  if (publicKeys instanceof Error) {\n    return publicKeys;\n  }\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]: encryptionPublicKey,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: signPublicKey,\n  } = publicKeys;\n\n  const [\n    encryptionPublicKeyExported,\n    signPublicKeyExported,\n  ] = await Promise.all([\n    exportPublicKeyDataEncryptAsString(encryptionPublicKey),\n    exportPublicKeyDataSignAsString(signPublicKey),\n  ]);\n\n  if (encryptionPublicKeyExported instanceof Error) {\n    console.error('export of the encryptionPublicKey was failed');\n    return encryptionPublicKeyExported;\n  }\n  if (signPublicKeyExported instanceof Error) {\n    console.error('export of the signPublicKeyExported was failed');\n    return signPublicKeyExported;\n  }\n  try {\n    return stringify({\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]: encryptionPublicKeyExported,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: signPublicKeyExported,\n    });\n  } catch (err) {\n    return err;\n  }\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-generate.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-import.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials-crypto-keys.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials.ts",["2325","2326"],"import { TCentralAuthorityUserCryptoCredentials } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-credentials';\nimport {\n  checkIsCryptoKeyPairs,\n  exportKeyPairsAsString,\n  importKeyPairsFromString,\n} from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport { validateUserIdentity } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport {\n  CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME,\n  CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME,\n} from 'classes/central-authority-class/central-authority-class-const/central-authority-class-const';\nimport {\n  TCentralAuthorityUserIdentity,\n  TCACryptoKeyPairs,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { CentralAuthorityIdentity } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport {\n  checkIsValidCryptoCredentials,\n  checkIsValidCryptoCredentialsExportedFormat,\n  checkIsValidExportedCryptoCredentialsToString,\n} from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport { stringify } from 'utils/main-utils';\nimport { TUserIdentityVersion } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { calcCryptoKeyPairHash } from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport { TCAAuthProviderIdentity } from '../../central-authority-connections/central-authority-connections.types';\nimport { normalizeUrl } from '../../../../utils/common-utils/common-utils-url';\nimport { CA_UTILS_CRYPTO_CREDENTIALS_NORMALIZE_URL_OPTIONS } from './central-authority-utils-crypto-credentials.const';\n\nexport const exportCryptoCredentialsToString = async (\n  userCryptoCredentials: TCentralAuthorityUserCryptoCredentials,\n  withoutIdentityVersion: boolean = false,\n  password?: string\n): Promise<Error | string> => {\n  if (!checkIsValidCryptoCredentials(userCryptoCredentials, !!password)) {\n    return new Error('The given value is not a valid crypto credentials');\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeys,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  } = userCryptoCredentials;\n  const exportedCryptoKeys = await exportKeyPairsAsString(cryptoKeys, password);\n\n  if (exportedCryptoKeys instanceof Error) {\n    return exportedCryptoKeys;\n  }\n\n  const cryptoCredentialsExported = {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: exportedCryptoKeys,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  };\n  if (withoutIdentityVersion) {\n    const userCAIdentity = new CentralAuthorityIdentity(userIdentity);\n    const { id } = userCAIdentity;\n\n    if (id instanceof Error) {\n      return new Error('The identity is not valid');\n    }\n    cryptoCredentialsExported[CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME] = id;\n  }\n\n  if (!checkIsValidCryptoCredentialsExportedFormat(cryptoCredentialsExported)) {\n    return new Error(\n      'Failed to create a crypto credentials in the exported format'\n    );\n  }\n  try {\n    const exportedCryptoCredentialsAsString = stringify(\n      cryptoCredentialsExported\n    );\n\n    if (\n      !checkIsValidExportedCryptoCredentialsToString(\n        exportedCryptoCredentialsAsString\n      )\n    ) {\n      return new Error(\n        'Failed cause the crypto credentials exported as a sting have a wrong format'\n      );\n    }\n    return exportedCryptoCredentialsAsString;\n  } catch (err) {\n    console.error(err);\n    return new Error('Failed to stringify the crypto credentials');\n  }\n};\n\n// allow to absent for a private keys in a pairs\nexport const exportCryptoCredentialsToStringWithoutTheCAIdentityVersion = (\n  userCryptoCredentials: TCentralAuthorityUserCryptoCredentials\n): Promise<Error | string> =>\n  exportCryptoCredentialsToString(userCryptoCredentials, true);\n\nexport const compareAuthProvidersIdentities = (\n  ...authProvidersIds: TCAAuthProviderIdentity[]\n): boolean => {\n  const { length: len } = authProvidersIds;\n\n  if (len < 2) {\n    return true;\n  }\n\n  const firstAuthProviderId = normalizeUrl(\n    authProvidersIds[0],\n    CA_UTILS_CRYPTO_CREDENTIALS_NORMALIZE_URL_OPTIONS\n  );\n  let idx = 0;\n\n  while (++idx < len) {\n    if (\n      firstAuthProviderId !==\n      normalizeUrl(\n        authProvidersIds[idx],\n        CA_UTILS_CRYPTO_CREDENTIALS_NORMALIZE_URL_OPTIONS\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const compareCryptoCredentials = async (\n  ...credentials: TCentralAuthorityUserCryptoCredentials[]\n): Promise<boolean | Error> => {\n  if (!(credentials instanceof Array)) {\n    return new Error('Crdentails to compare must be an array');\n  }\n\n  const cryptoCredentialsBase = credentials[0];\n\n  if (!checkIsValidCryptoCredentials(cryptoCredentialsBase)) {\n    return new Error('The crypto credentials on index 0 is not valid');\n  }\n  if (credentials.length === 1) {\n    return true;\n  }\n\n  const userIdentityBase = new CentralAuthorityIdentity(\n    cryptoCredentialsBase[CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]\n  );\n\n  if (!userIdentityBase.isValid) {\n    return new Error(\n      'The user identity is not valid in the crypto credentials base'\n    );\n  }\n\n  const cryptoCredentialsKeysBase =\n    cryptoCredentialsBase[CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME];\n  const cryptoCredentialsEncryptKeyPairHashBase = await calcCryptoKeyPairHash(\n    cryptoCredentialsKeysBase.encryptionKeyPair\n  );\n\n  if (cryptoCredentialsEncryptKeyPairHashBase instanceof Error) {\n    return new Error('Failed to calculate hash of the encrypt key pairs base');\n  }\n\n  const cryptoCredentialsSignKeyPairHashBase = await calcCryptoKeyPairHash(\n    cryptoCredentialsKeysBase.signDataKeyPair\n  );\n\n  if (cryptoCredentialsSignKeyPairHashBase instanceof Error) {\n    return new Error(\n      'Failed to calculate hash of the data sign key pairs base'\n    );\n  }\n\n  let idx = 1;\n  const length = credentials.length;\n  let nextCryptoCredentials = null;\n  let keyPairs = null;\n  let userIdentity = null;\n  let encryptionKeyPairsHash = null;\n  let signPairsHash = null;\n\n  for (; idx < length; idx += 1) {\n    nextCryptoCredentials = credentials[idx];\n\n    if (!checkIsValidCryptoCredentials(nextCryptoCredentials)) {\n      return new Error(`The crypto credentials on index ${idx} is not valid`);\n    }\n\n    userIdentity = new CentralAuthorityIdentity(\n      nextCryptoCredentials[CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]\n    );\n\n    if (!userIdentity.isValid) {\n      return new Error(\n        `The user identity is not valid in the crypto credentials on index ${idx}`\n      );\n    }\n    if (userIdentity.id !== userIdentityBase.id) {\n      return new Error(`The user identity are different on index ${idx}`);\n    }\n\n    keyPairs = nextCryptoCredentials[CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME];\n    encryptionKeyPairsHash = await calcCryptoKeyPairHash(\n      keyPairs.encryptionKeyPair\n    );\n\n    if (cryptoCredentialsEncryptKeyPairHashBase !== encryptionKeyPairsHash) {\n      return new Error(\n        `The encryption key pairs are different on index ${idx}`\n      );\n    }\n\n    signPairsHash = await calcCryptoKeyPairHash(keyPairs.signDataKeyPair);\n\n    if (cryptoCredentialsSignKeyPairHashBase !== signPairsHash) {\n      return new Error(`The data sign key pairs are different on index ${idx}`);\n    }\n  }\n  return true;\n};\n\nexport const importCryptoCredentialsFromExportedFromat = async (\n  cryptoCredentialsExported: any,\n  password?: string\n): Promise<Error | TCentralAuthorityUserCryptoCredentials> => {\n  if (!checkIsValidCryptoCredentialsExportedFormat(cryptoCredentialsExported)) {\n    return new Error('The crypto credentials exported have a wrong format');\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeysExported,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentityExported,\n  } = cryptoCredentialsExported;\n  const cryptoKeysImported = await importKeyPairsFromString(\n    cryptoKeysExported,\n    password\n  );\n\n  if (cryptoKeysImported instanceof Error) {\n    console.error(cryptoKeysImported);\n    return new Error(\n      'Failed to import a crypto key pairs from the given string'\n    );\n  }\n\n  const cryptoCredentials = {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeysImported,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentityExported,\n  };\n\n  if (!checkIsValidCryptoCredentials(cryptoCredentials, !!password)) {\n    return new Error(\n      'Failed to return the crypto credentials imorted in the valid format'\n    );\n  }\n  return cryptoCredentials;\n};\n\nexport const importCryptoCredentialsFromAString = async (\n  cryptoCredentialsString: any,\n  password?: string\n): Promise<Error | TCentralAuthorityUserCryptoCredentials> => {\n  const typeCryptoCredentials = typeof cryptoCredentialsString;\n\n  if (typeCryptoCredentials !== 'string') {\n    return new Error(\n      `The cryptoCredentials value have the wrong type::${typeCryptoCredentials}::`\n    );\n  }\n  if (!checkIsValidExportedCryptoCredentialsToString(cryptoCredentialsString)) {\n    return new Error('The cryptoCredentials value have a wrong format');\n  }\n\n  let cryptoCredentialsExported;\n\n  try {\n    cryptoCredentialsExported = JSON.parse(cryptoCredentialsString);\n  } catch (err) {\n    console.error(err);\n    return new Error('Failed to parse the given crypto credentials string');\n  }\n  return importCryptoCredentialsFromExportedFromat(\n    cryptoCredentialsExported,\n    password\n  );\n};\n\nexport const getUserCredentialsByUserIdentityAndCryptoKeys = (\n  userIdentity: TCentralAuthorityUserIdentity,\n  cryptoKeyPairs: TCACryptoKeyPairs,\n  checkPrivateKey: boolean = true\n): Error | TCentralAuthorityUserCryptoCredentials => {\n  if (!validateUserIdentity(userIdentity)) {\n    return new Error('The user identity has a wrong format');\n  }\n  if (!checkIsCryptoKeyPairs(cryptoKeyPairs, checkPrivateKey)) {\n    return new Error('The crypto key pairs has a wrong format');\n  }\n\n  const cryptoCredentials = {\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPairs,\n  };\n\n  if (!checkIsValidCryptoCredentials(cryptoCredentials, checkPrivateKey)) {\n    return new Error('Failed to create a valid crypto credentials');\n  }\n  return cryptoCredentials;\n};\n\nexport const getExportedAsStringCryptoCredentials = async (\n  identity: TCentralAuthorityUserIdentity,\n  cryptoCredentialsKeyPairs: TCACryptoKeyPairs,\n  checkPrivateKey: boolean = true\n): Promise<Error | string> => {\n  try {\n    // parse the identity\n    const caIdentity = new CentralAuthorityIdentity(identity);\n    const { isValid } = caIdentity;\n\n    if (!isValid) {\n      return new Error('The identity is not valid or have an unknown format');\n    }\n    if (!checkIsCryptoKeyPairs(cryptoCredentialsKeyPairs, checkPrivateKey)) {\n      return new Error(\n        'The crypto keys are not valid or have an unknown format'\n      );\n    }\n\n    const caUserCryptoCredentials = getUserCredentialsByUserIdentityAndCryptoKeys(\n      identity,\n      cryptoCredentialsKeyPairs,\n      checkPrivateKey\n    );\n\n    if (caUserCryptoCredentials instanceof Error) {\n      console.error(caUserCryptoCredentials);\n      return new Error('Failed to get User crypto credentials');\n    }\n    return exportCryptoCredentialsToString(caUserCryptoCredentials);\n  } catch (err) {\n    console.error(err);\n    return new Error('Failed to process the credentials or identity');\n  }\n};\n\nexport const getExportedCryptoCredentialsByCAIdentity = async (\n  caIdentity: CentralAuthorityIdentity | string,\n  cryptoCredentialsKeyPairs: TCACryptoKeyPairs,\n  checkPrivateKey: boolean = true\n): Promise<Error | string> => {\n  if (caIdentity instanceof CentralAuthorityIdentity) {\n    if (caIdentity.isValid) {\n      return getExportedAsStringCryptoCredentials(\n        String(caIdentity), // conver it to identity\n        cryptoCredentialsKeyPairs,\n        checkPrivateKey\n      );\n    }\n    return new Error('The CA identity is wrong');\n  }\n  return new Error('The CA identity must be an instance of caIdentity');\n};\n\nexport const replaceCryptoCredentialsIdentity = (\n  cryptoCredentials: TCentralAuthorityUserCryptoCredentials,\n  identity: TCentralAuthorityUserIdentity,\n  checkPrivateKey: boolean = true\n): Error | TCentralAuthorityUserCryptoCredentials => {\n  if (checkIsValidCryptoCredentials(cryptoCredentials, checkPrivateKey)) {\n    return {\n      ...cryptoCredentials,\n      [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: identity,\n    };\n  }\n  return new Error('The crypto credentials have a wrong format');\n};\n\nexport const getUserIdentityByCryptoCredentials = (\n  cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n): Error | TCentralAuthorityUserIdentity => {\n  if (typeof cryptoCredentials !== 'object') {\n    return new Error('The crypto credentials have an unknown format');\n  }\n\n  const {\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  } = cryptoCredentials;\n\n  if (validateUserIdentity(userIdentity)) {\n    return userIdentity;\n  }\n  return new Error('The user identity is not valid');\n};\n\nexport const getCryptoKeyPairsByCryptoCredentials = (\n  cryptoCredentials: TCentralAuthorityUserCryptoCredentials,\n  checkPrivateKey: boolean = true\n): Error | TCACryptoKeyPairs => {\n  if (typeof cryptoCredentials !== 'object') {\n    return new Error('The crypto credentials have an unknown format');\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPairs,\n  } = cryptoCredentials;\n\n  if (checkIsCryptoKeyPairs(cryptoKeyPairs, checkPrivateKey)) {\n    return cryptoKeyPairs;\n  }\n  return new Error('The crypto key pairs are not valid');\n};\n\nexport const getUserIdentityVersion = (\n  userIdentity: TCentralAuthorityUserIdentity | CentralAuthorityIdentity\n): TUserIdentityVersion | Error => {\n  if (\n    !(userIdentity instanceof CentralAuthorityIdentity) &&\n    typeof userIdentity !== 'string'\n  ) {\n    return new Error(\n      'The userIdentity must be a string or an instance of the CentralAuthorityIdentity class'\n    );\n  }\n\n  const userIdentityObj = new CentralAuthorityIdentity(userIdentity);\n\n  if (!userIdentityObj.isValid) {\n    return new Error('The user identity is not valid');\n  }\n  return userIdentityObj.version;\n};\n\nexport const getVersionOfCryptoCredentials = (\n  cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n): TUserIdentityVersion | Error => {\n  const userIdentity = getUserIdentityByCryptoCredentials(cryptoCredentials);\n\n  if (userIdentity instanceof Error) {\n    return userIdentity;\n  }\n  return getUserIdentityVersion(userIdentity);\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys-schemas.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys.ts",["2327","2328","2329","2330","2331","2332"],"import {\n  CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME,\n  CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME,\n  CA_CREDENTIALS_KEY_CRYPTO_CREDENTIALS_EXPORTED_AS_STRING_MIN_LENGTH,\n} from 'classes/central-authority-class/central-authority-class-const/central-authority-class-const';\nimport {\n  TCentralAuthorityUserCryptoCredentials,\n  TCentralAuthorityUserCryptoCredentialsExported,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { checkIsCryptoKeyPairs } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport { validateBySchema } from 'utils/validation-utils/validation-utils';\n\nimport { validateUserIdentity } from '../central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { caValidatorsCryptoKeysExportedObjectValidationSchema } from './central-authority-validators-crypto-keys-schemas';\n\nexport const caValidateCryptoKeyPairExportedObject = (value: any): boolean =>\n  validateBySchema(caValidatorsCryptoKeysExportedObjectValidationSchema, value);\n\n/**\n * validate is a given value has\n * a valid crypto key pair and\n * the user identity\n * in the raw format\n * @param {any} cryptoCredentials\n */\nexport const checkIsValidCryptoCredentials = (\n  cryptoCredentials: any,\n  checkPrivateKey: boolean = true\n): cryptoCredentials is TCentralAuthorityUserCryptoCredentials => {\n  if (!cryptoCredentials || typeof cryptoCredentials !== 'object') {\n    return false;\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeys,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  } = cryptoCredentials;\n\n  if (!cryptoKeys) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case a crypto keys was not found'\n    );\n    return false;\n  }\n  if (!userIdentity) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case a user identity value was not found'\n    );\n    return false;\n  }\n  if (!validateUserIdentity(userIdentity)) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case the user identity value have a wrong type'\n    );\n    return false;\n  }\n  if (!checkIsCryptoKeyPairs(cryptoKeys, checkPrivateKey)) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case the crypto keys value have a wrong type'\n    );\n    return false;\n  }\n  return true;\n};\n\n/**\n * validate is a given value has\n * a valid crypto key pair by a function provided\n * and user's identity\n * @param {any} cryptoCredentials\n */\nexport const checkIsValidCryptoCredentialsWithFunc = (\n  cryptoCredentials: any,\n  credentialsValidationFunction: (c: any) => boolean\n): cryptoCredentials is TCentralAuthorityUserCryptoCredentialsExported => {\n  if (!cryptoCredentials || typeof cryptoCredentials !== 'object') {\n    return false;\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeys,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  } = cryptoCredentials;\n\n  if (!cryptoKeys) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, case a crypto keys was not found'\n    );\n    return false;\n  }\n  if (!userIdentity) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, cause a user identity value was not found'\n    );\n    return false;\n  }\n  if (!validateUserIdentity(userIdentity)) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, cause the user identity value have a wrong type'\n    );\n    return false;\n  }\n  if (!credentialsValidationFunction(cryptoKeys)) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, cause the crypto keys exported as a string value have a wrong type'\n    );\n    return false;\n  }\n  return true;\n};\n\n/**\n * validate is a given value has\n * a valid crypto key pair and\n * the user identity\n * in the exported format\n * @param {any} cryptoCredentials\n */\nexport const checkIsValidCryptoCredentialsExportedFormat = (\n  cryptoCredentials: any\n): cryptoCredentials is TCentralAuthorityUserCryptoCredentialsExported => {\n  if (\n    !checkIsValidCryptoCredentialsWithFunc(\n      cryptoCredentials,\n      checkIsValidExportedCryptoCredentialsToString\n    )\n  ) {\n    return false;\n  }\n  return true;\n};\n\nexport const checkIsValidExportedCryptoCredentialsToString = (\n  cryptoCredentialsExportedAsString: any\n): boolean => {\n  return (\n    typeof cryptoCredentialsExportedAsString === 'string' &&\n    cryptoCredentialsExportedAsString.length >\n      CA_CREDENTIALS_KEY_CRYPTO_CREDENTIALS_EXPORTED_AS_STRING_MIN_LENGTH\n  );\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user.schemes.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user.ts",["2333"],"import { ICentralAuthorityUserProfile } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { validateBySchema } from 'utils/validation-utils/validation-utils';\nimport { CA_VALIDATORS_USER_PROFILE_SCHEME } from './central-authority-validators-user.schemes';\n\nexport const validateUserProfileData = (\n  profileData: any\n): profileData is ICentralAuthorityUserProfile => {\n  return validateBySchema(CA_VALIDATORS_USER_PROFILE_SCHEME, profileData);\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/index.ts",[],"/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.const.ts",[],"/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.ts",["2334","2335","2336","2337","2338","2339","2340","2341","2342","2343","2344","2345"],"import assert from 'assert';\nimport {\n  IConnectionBridgeOptions,\n  IConnectionBridge,\n} from './connection-bridge.types';\nimport { ESwarmStoreConnector } from '../swarm-store-class/swarm-store-class.const';\nimport {\n  ICentralAuthorityOptions,\n  ICentralAuthority,\n} from '../central-authority-class/central-authority-class.types';\nimport {\n  TSwarmMessageConstructorOptions,\n  ISwarmMessageConstructor,\n} from '../swarm-message/swarm-message-constructor.types';\nimport {\n  ISwarmMessageStoreOptions,\n  ISwarmMessageStore,\n} from '../swarm-message-store/swarm-message-store.types';\nimport { extend } from '../../utils/common-utils/common-utils-objects';\nimport {\n  CONNECTION_BRIDGE_OPTIONS_DEFAULT_AUTH_PROVIDERS_POOL,\n  CONNECTION_BRIDGE_SESSION_STORAGE_KEYS,\n  CONNECTION_BRIDGE_STORAGE_DATABASE_PREFIX,\n} from './connection-bridge.const';\nimport { CentralAuthority } from '../central-authority-class/central-authority-class';\nimport { ipfsUtilsConnectBasic } from '../../utils/ipfs-utils/ipfs-utils';\nimport { SwarmMessageStore } from '../swarm-message-store/swarm-message-store';\nimport { ISensitiveDataSessionStorage } from 'classes/sensitive-data-session-storage/sensitive-data-session-storage.types';\nimport { SensitiveDataSessionStorage } from 'classes/sensitive-data-session-storage';\nimport {\n  ISwarmMessageEncryptedCacheFabric,\n  ISwarmMessageConstructorWithEncryptedCacheFabric,\n} from '../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport { CONNECTION_BRIDGE_STORAGE_DATABASE_NAME } from './connection-bridge.const';\nimport {\n  getSwarmMessageEncryptedCacheFabric,\n  getSwarmMessageConstructorWithCacheFabric,\n} from '../swarm-messgae-encrypted-cache/swarm-message-encrypted-cache.utils';\nimport { ISwarmMessgaeEncryptedCache } from '../swarm-messgae-encrypted-cache';\nimport { ISensitiveDataSessionStorageOptions } from '../sensitive-data-session-storage/sensitive-data-session-storage.types';\nimport {\n  ISecretStorage,\n  TSecretStorageAuthorizeCredentials,\n} from '../secret-storage-class/secret-storage-class.types';\nimport { SecretStorage } from '../secret-storage-class/secret-storage-class';\nimport { IStorageProviderOptions } from '../storage-providers/storage-providers.types';\nimport { TSwarmStoreDatabaseType } from '../swarm-store-class/swarm-store-class.types';\n\n/**\n * this class used if front of connection\n * to the swarm, swarm database and\n * central authority, to simplify connection\n * process.\n *\n * @export\n * @class ConnectionBridge\n */\nexport class ConnectionBridge<\n  P extends ESwarmStoreConnector = ESwarmStoreConnector.OrbitDB,\n  DbType extends TSwarmStoreDatabaseType<P> = TSwarmStoreDatabaseType<P>\n> implements IConnectionBridge {\n  public caConnection?: ICentralAuthority;\n\n  public storage?: ISwarmMessageStore<P, DbType>;\n\n  public messageConstructor?: ISwarmMessageConstructor;\n\n  public swarmMessageEncryptedCacheFabric?: ISwarmMessageEncryptedCacheFabric;\n\n  public swarmMessageConstructorFabric?: ISwarmMessageConstructorWithEncryptedCacheFabric;\n\n  public get secretStorage() {\n    return this._secretStorage;\n  }\n\n  protected options?: IConnectionBridgeOptions<P, true>;\n\n  protected optionsCA?: ICentralAuthorityOptions;\n\n  protected optionsMessageConstructor?: TSwarmMessageConstructorOptions;\n\n  protected optionsSwarmConnection?: any;\n\n  protected optionsMessageStorage?: ISwarmMessageStoreOptions<P>;\n\n  protected session?: ISensitiveDataSessionStorage;\n\n  protected userDataStore?: ISensitiveDataSessionStorage;\n\n  protected swarmMessageEncryptedCache?: ISwarmMessgaeEncryptedCache;\n\n  protected _secretStorage?: ISecretStorage;\n\n  protected swarmConnection?: {\n    getNativeConnection(): any;\n  };\n\n  /**\n   * Connect to the central authority,\n   * create the message constructor,\n   * create swarm connection, start\n   * connection with the swarm message storage.\n   *\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  public async connect(options: IConnectionBridgeOptions<P>): Promise<void> {\n    await this.setOptions(options);\n    try {\n      await this.startSession();\n      await this.startCentralAuthorityConnection();\n      await this.createSwarmMessageEncryptedCacheFabric();\n      await this.createSwarmMessageConstructorFabric();\n      await this.startSwarmMessageEncryptedCache();\n      await this.createMessageConstructor();\n      await this.startSwarmConnection();\n      await this.startSwarmMessageStorageConnection();\n      await this.setSessionExists();\n      await this.startSecretStorage();\n    } catch (err) {\n      console.error('connection to the swarm failed', err);\n      await this.close();\n      throw err;\n    }\n  }\n\n  /**\n   * @param {ISensitiveDataSessionStorageOptions} sessionParams\n   * @returns\n   * @memberof ConnectionBridge\n   */\n  public async checkSessionAvailable(\n    options?: ISensitiveDataSessionStorageOptions | IConnectionBridgeOptions<P>\n  ) {\n    const sessionParams = (options as IConnectionBridgeOptions<P>)?.auth\n      ? (options as IConnectionBridgeOptions<P>)?.auth.session\n      : (options as ISensitiveDataSessionStorageOptions | undefined);\n\n    if (!sessionParams) {\n      return false;\n    }\n    await this.startUserDataStore();\n    if (\n      !(await this.userDataStore?.getItem(\n        CONNECTION_BRIDGE_SESSION_STORAGE_KEYS.USER_LOGIN\n      ))\n    ) {\n      return false;\n    }\n\n    const session = await this.createSessionFromStorage({\n      ...sessionParams,\n      clearStorageAfterConnect: false,\n    });\n\n    return !!(await session.getItem(\n      CONNECTION_BRIDGE_SESSION_STORAGE_KEYS.SESSION_DATA_AVAILABLE\n    ));\n  }\n\n  /**\n   * close all the connections and\n   * release all instances\n   *\n   * @returns {Promise<void>}\n   * @memberof ConnectionBridge\n   */\n  public async close(): Promise<void> {\n    await this.closeStorage();\n    await this.closeMessageConstructor();\n    await this.closeSwarmConnection();\n    await this.closeSwarmMessageEncryptedCacheFabric();\n    await this.closeSwarmMessageConstructorFabric();\n    await this.closeCentralAuthorityConnection();\n  }\n\n  /**\n   * set options for the CentralAuthority connection.\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected setOptionsCA(): ICentralAuthorityOptions {\n    const { options } = this;\n    const { auth: authOptions, user: userOptions } = options!;\n\n    assert(authOptions, 'Authorization options must be defined');\n    assert(\n      typeof authOptions === 'object',\n      'Authorization options must be an object'\n    );\n    assert(userOptions, 'User options must be defined');\n    assert(typeof userOptions === 'object', 'User options must be an object');\n\n    const authProvidersPool: ICentralAuthorityOptions['authProvidersPool'] = extend(\n      authOptions.authProvidersPool,\n      CONNECTION_BRIDGE_OPTIONS_DEFAULT_AUTH_PROVIDERS_POOL\n    );\n    const optionsCentralAuthority: ICentralAuthorityOptions = {\n      user: {\n        profile: userOptions.profile,\n        authProviderUrl: authOptions.providerUrl,\n        credentials: {\n          ...authOptions.credentials,\n          session: this.session,\n        },\n      },\n      authProvidersPool,\n    };\n\n    this.optionsCA = optionsCentralAuthority;\n    return optionsCentralAuthority;\n  }\n\n  /**\n   *\n   *\n   * @protected\n   * @returns {TSwarmMessageConstructorOptions}\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected setOptionsMessageConstructor(): TSwarmMessageConstructorOptions {\n    const { caConnection } = this;\n\n    if (!caConnection) {\n      throw new Error('There is no connection to the central authoriry');\n    }\n    return {\n      caConnection,\n      instances: {\n        encryptedCache: this.swarmMessageEncryptedCache,\n      },\n    };\n  }\n\n  /**\n   * set options for the SwarmConnection provider\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   */\n  protected setOptionsSwarmConnection() {}\n\n  /**\n   * set options for the message storage\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected async setOptionsMessageStorage(): Promise<\n    ISwarmMessageStoreOptions<P>\n  > {\n    const { messageConstructor, caConnection, swarmConnection } = this;\n    const options = this.options!;\n    const { auth: authOptions, storage: storageOptions } = options;\n\n    if (!messageConstructor) {\n      throw new Error('There is no message constructor defined');\n    }\n    if (!caConnection) {\n      throw new Error(\n        'There is no message central authority connection defined'\n      );\n    }\n    if (!swarmConnection) {\n      throw new Error('There is no swarm connection provider');\n    }\n\n    const userId = caConnection.getUserIdentity();\n\n    if (typeof userId !== 'string') {\n      throw new Error('Failed to get the user identity');\n    }\n\n    const authCredentials = {\n      ...(authOptions.credentials as ISwarmMessageStoreOptions<\n        P\n      >['credentials']),\n      session: this.session,\n    };\n    const messageStorageOptions: ISwarmMessageStoreOptions<P> = {\n      ...storageOptions,\n      credentials: authCredentials,\n      userId,\n      databasesListStorage: await this.startEncryptedCache(\n        CONNECTION_BRIDGE_STORAGE_DATABASE_PREFIX.DATABASE_LIST_STORAGE\n      ),\n      swarmMessageConstructorFabric: this.swarmMessageConstructorFabric,\n      messageConstructors: {\n        default: messageConstructor,\n      },\n      providerConnectionOptions: {\n        ipfs: swarmConnection.getNativeConnection(),\n      },\n    };\n\n    return messageStorageOptions;\n  }\n\n  protected async startUserDataStore() {\n    if (!this.userDataStore) {\n      const userDataStore = new SensitiveDataSessionStorage();\n\n      await userDataStore.connect({\n        storagePrefix:\n          CONNECTION_BRIDGE_STORAGE_DATABASE_PREFIX.USER_DATA_STORAGE,\n      });\n      this.userDataStore = userDataStore;\n    }\n  }\n\n  /**\n   *\n   *\n   * @protected\n   * @param {IConnectionBridgeOptions<P>} options\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected async setOptions(options: IConnectionBridgeOptions<P>) {\n    await this.startUserDataStore();\n    assert(options, 'Options must be provided');\n    assert(typeof options === 'object', 'Options must be an object');\n    if (options.auth.credentials?.login) {\n      await this.userDataStore?.setItem(\n        CONNECTION_BRIDGE_SESSION_STORAGE_KEYS.USER_LOGIN,\n        options.auth.credentials.login\n      );\n      this.options = (options as unknown) as IConnectionBridgeOptions<P, true>;\n    } else {\n      assert(\n        options.auth.session,\n        'A session must be started if there is no credentials provided'\n      );\n\n      const login = await this.userDataStore?.getItem(\n        CONNECTION_BRIDGE_SESSION_STORAGE_KEYS.USER_LOGIN\n      );\n\n      if (!login) {\n        throw new Error(\n          'There is no login provided in options and no session data found to get it'\n        );\n      }\n      this.options = {\n        ...options,\n        auth: {\n          ...options.auth,\n          credentials: {\n            ...options.auth.credentials,\n            login,\n          },\n        },\n      };\n    }\n  }\n\n  protected async createSessionFromStorage(\n    sessionParams: ISensitiveDataSessionStorageOptions\n  ): Promise<ISensitiveDataSessionStorage> {\n    const session = new SensitiveDataSessionStorage();\n\n    await session.connect({\n      ...sessionParams,\n      storagePrefix: sessionParams.storagePrefix\n        ? `${sessionParams.storagePrefix}${this.options?.auth.credentials?.login}`\n        : undefined,\n    });\n    return session;\n  }\n\n  /**\n   * start session if options provided\n   *\n   * @protected\n   * @param {ISensitiveDataSessionStorageOptions} sessionParams\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected async startSession(): Promise<void> {\n    const sessionParams = this.options?.auth.session;\n\n    if (sessionParams) {\n      this.session = await this.createSessionFromStorage(sessionParams);\n    }\n  }\n\n  /**\n   *\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected async startCentralAuthorityConnection(): Promise<void> {\n    const optioinsCA = this.setOptionsCA();\n    const centralAuthority = new CentralAuthority();\n    const connectionResult = await centralAuthority.connect(optioinsCA);\n\n    if (connectionResult instanceof Error) {\n      throw connectionResult;\n    }\n    this.caConnection = centralAuthority;\n  }\n\n  /**\n   * create the default message construtor\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected async createMessageConstructor(): Promise<void> {\n    const options = this.setOptionsMessageConstructor();\n\n    if (!this.swarmMessageConstructorFabric) {\n      throw new Error(\n        'Swarm message constructor fabric must be created before'\n      );\n    }\n    this.messageConstructor = await this.swarmMessageConstructorFabric(options);\n  }\n\n  /**\n   * create connection to the swarm through the\n   * provider.\n   * TODO\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   */\n  protected async startSwarmConnection(): Promise<void> {\n    this.setOptionsSwarmConnection();\n\n    const ipfs = await ipfsUtilsConnectBasic(\n      this.options ? this.options.swarm : undefined\n    );\n\n    this.swarmConnection = {\n      getNativeConnection() {\n        return ipfs;\n      },\n    };\n  }\n\n  protected getOptionsSwarmMessageEncryptedCache() {\n    const login = this.options!.auth.credentials.login;\n\n    return {\n      login,\n      password: this.options!.auth.credentials.password!,\n      session: this.session,\n    };\n  }\n\n  protected async createSwarmMessageEncryptedCacheFabric(): Promise<void> {\n    const login = this.options!.auth.credentials.login;\n    this.swarmMessageEncryptedCacheFabric = await getSwarmMessageEncryptedCacheFabric(\n      this.getOptionsSwarmMessageEncryptedCache(),\n      `__${CONNECTION_BRIDGE_STORAGE_DATABASE_PREFIX.MESSAGE_CACHE_STORAGE}_//_${login}`\n    );\n  }\n\n  protected async createSwarmMessageConstructorFabric(): Promise<void> {\n    const login = this.options!.auth.credentials.login;\n\n    this.swarmMessageConstructorFabric = await getSwarmMessageConstructorWithCacheFabric(\n      this.getOptionsSwarmMessageEncryptedCache(),\n      {\n        caConnection: this.caConnection!,\n        instances: {},\n      },\n      `__${CONNECTION_BRIDGE_STORAGE_DATABASE_PREFIX.MESSAGE_CACHE_STORAGE}_//_${login}`\n    );\n  }\n\n  protected startEncryptedCache(\n    dbNamePrefix: string\n  ): Promise<ISwarmMessgaeEncryptedCache> {\n    const login = this.options!.auth.credentials.login;\n\n    if (!this.swarmMessageEncryptedCacheFabric) {\n      throw new Error('Encrypted cache fabric must be started before');\n    }\n    return this.swarmMessageEncryptedCacheFabric({\n      dbName: `${dbNamePrefix}_//_${login}`,\n    });\n  }\n\n  protected async startSwarmMessageEncryptedCache(): Promise<void> {\n    if (!this.swarmMessageEncryptedCacheFabric) {\n      throw new Error('Encrypted cache fabric must be started before');\n    }\n    this.swarmMessageEncryptedCache = await this.startEncryptedCache(\n      CONNECTION_BRIDGE_STORAGE_DATABASE_NAME.MESSAGE_CACHE_STORAGE\n    );\n  }\n\n  /**\n   * start connection with the SwarmMessage storage\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected async startSwarmMessageStorageConnection(): Promise<void> {\n    const swarmMessageStorageOptions = await this.setOptionsMessageStorage();\n    const swarmMessageStorage = new SwarmMessageStore<P, DbType>();\n    const result = await swarmMessageStorage.connect(\n      swarmMessageStorageOptions\n    );\n\n    if (result instanceof Error) {\n      throw result;\n    }\n    this.storage = swarmMessageStorage as ISwarmMessageStore<P, DbType>;\n  }\n\n  /**\n   * close the connection with the swarm message storage\n   * and release the instance and options;\n   *\n   * @protected\n   * @returns {Promise<void>}\n   * @memberof ConnectionBridge\n   */\n  protected async closeStorage(): Promise<void> {\n    const { storage } = this;\n\n    if (storage) {\n      try {\n        await storage.close();\n      } catch (err) {\n        console.error(\n          'Failed to close the connection to the swarm message storage',\n          err\n        );\n      }\n    } else {\n      console.warn('closeSwarmMessageStorage - there is no connection');\n    }\n    this.storage = undefined;\n    this.optionsMessageStorage = undefined;\n  }\n\n  /**\n   * close the default constructor of a swarm messages,\n   * release it's options and the instance.\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   */\n  protected async closeMessageConstructor(): Promise<void> {\n    this.messageConstructor = undefined;\n    this.optionsMessageConstructor = undefined;\n  }\n\n  /**\n   * close the connection to the swarm and release the instance\n   * and settings.\n   *\n   * @protected\n   * @returns {Promise<void>}\n   * @memberof ConnectionBridge\n   */\n  protected async closeSwarmConnection(): Promise<void> {\n    const { swarmConnection } = this;\n\n    if (swarmConnection) {\n      const ipfsConnection = swarmConnection.getNativeConnection();\n\n      try {\n        await ipfsConnection.stop();\n      } catch (error) {\n        console.error(\n          'closeSwarmConnection failed to stop the ipfs node!',\n          error\n        );\n      }\n    }\n    this.swarmConnection = undefined;\n    this.optionsSwarmConnection = undefined;\n  }\n\n  /**\n   * close the instance of the fabric\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   */\n  protected async closeSwarmMessageEncryptedCacheFabric() {\n    this.swarmMessageEncryptedCacheFabric = undefined;\n  }\n\n  /**\n   * close the instance of the fabric\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   */\n  protected async closeSwarmMessageConstructorFabric() {\n    this.swarmMessageConstructorFabric = undefined;\n  }\n\n  /**\n   * close the connection to the central authority\n   *\n   * @protected\n   * @returns {Promise<void>}\n   * @memberof ConnectionBridge\n   */\n  protected async closeCentralAuthorityConnection(): Promise<void> {\n    const { caConnection } = this;\n\n    if (caConnection) {\n      try {\n        await caConnection.disconnect();\n      } catch (err) {\n        console.error(\n          'closeCentralAuthorityConnection failed to close the connection to the central authority',\n          err\n        );\n      }\n    }\n    this.caConnection = undefined;\n    this.optionsCA = undefined;\n  }\n\n  /**\n   * set that authorized before in the session\n   * data, if it's available\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   */\n  protected async setSessionExists() {\n    await this.session?.setItem(\n      CONNECTION_BRIDGE_SESSION_STORAGE_KEYS.SESSION_DATA_AVAILABLE,\n      true\n    );\n  }\n\n  protected getSecretStorageDBOptions(): Partial<IStorageProviderOptions> {\n    return {\n      dbName: `${CONNECTION_BRIDGE_STORAGE_DATABASE_PREFIX.SECRET_STORAGE}//${this.options?.auth.credentials.login}`,\n    };\n  }\n\n  protected getSecretStorageAuthCredentials(): TSecretStorageAuthorizeCredentials {\n    if (!this.session && !this.options?.auth.credentials.password) {\n      throw new Error(\n        'Session storage or password must be provided to authorize in SecretStorage'\n      );\n    }\n    return {\n      ...this.options?.auth.credentials,\n      ...(this.session ? { session: this.session } : undefined),\n    } as TSecretStorageAuthorizeCredentials;\n  }\n\n  protected async startSecretStorage() {\n    const secretStorage = new SecretStorage();\n    const authResult = await secretStorage.authorize(\n      this.getSecretStorageAuthCredentials(),\n      this.getSecretStorageDBOptions()\n    );\n    if (authResult !== true) {\n      throw authResult === false\n        ? new Error('Conntection to the secret storage failed')\n        : authResult;\n    }\n    this._secretStorage = secretStorage;\n  }\n}\n","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.types.ts",["2346"],"import {\n  ISwarmMessageStoreOptions,\n  ISwarmMessageStore,\n} from '../swarm-message-store/swarm-message-store.types';\nimport { ESwarmStoreConnector } from '../swarm-store-class/swarm-store-class.const';\nimport { ICentralAuthority } from '../central-authority-class/central-authority-class.types';\nimport { ICentralAuthorityOptions } from '../central-authority-class/central-authority-class.types';\nimport { ISwarmMessageConstructor } from '../swarm-message/swarm-message-constructor.types';\nimport { ISensitiveDataSessionStorageOptions } from 'classes/sensitive-data-session-storage/sensitive-data-session-storage.types';\nimport { ISwarmMessageConstructorWithEncryptedCacheFabric } from '../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport { ISwarmMessageEncryptedCacheFabric } from '../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport { TSwarmStoreDatabaseType } from '../swarm-store-class/swarm-store-class.types';\n\nexport type IConnectionBridgeOptionsAuthCredentials = Omit<\n  ICentralAuthorityOptions['user']['credentials'],\n  'session'\n>;\n\nexport interface IConnectionBridgeOptionsAuth<CD extends boolean = false> {\n  /**\n   * url of an  auth provider from the auth providers pool\n   * on which the user will be authorized or registered\n   * if still had not.\n   *\n   * @type {ICentralAuthorityOptions['user']['authProviderUrl']}\n   */\n  providerUrl: ICentralAuthorityOptions['user']['authProviderUrl'];\n  /**\n   * credentials used to authorize or register on a credentials\n   * provider. If credentials are not provided, then session\n   * must be started before\n   *\n   * @type {ICentralAuthorityOptions['user']['credentials']}\n   */\n  credentials: CD extends true\n    ? IConnectionBridgeOptionsAuthCredentials\n    : IConnectionBridgeOptionsAuthCredentials | undefined | never;\n  session?: ISensitiveDataSessionStorageOptions;\n  /**\n   * this is list of auth providers will be used to authorize\n   * the user and a keys of another users connected to the\n   * swarm\n   *\n   * @type {ICentralAuthorityOptions['authProvidersPool']}\n   */\n  authProvidersPool?: ICentralAuthorityOptions['authProvidersPool'];\n}\n\nexport interface IConnectionBridgeOptions<\n  P extends ESwarmStoreConnector = ESwarmStoreConnector.OrbitDB,\n  CD extends boolean = false\n> {\n  auth: IConnectionBridgeOptionsAuth<CD>;\n  user: {\n    /**\n     * profile of the user for the central auth provider\n     *\n     * @type {ICentralAuthorityOptions['user']['profile']}\n     */\n    profile?: ICentralAuthorityOptions['user']['profile'];\n  };\n  /**\n   * this is options for a swarm databases user will be\n   * used to store a data.\n   *\n   * @type {ISwarmMessageStoreOptions<P>}\n   * @memberof IConnectionBridgeOptions\n   */\n  storage: Omit<\n    ISwarmMessageStoreOptions<P>,\n    | 'userId'\n    | 'credentials'\n    | 'messageConstructors'\n    | 'providerConnectionOptions'\n    | 'databasesListStorage'\n  >;\n  /**\n   * specify options for the swarm connection provider\n   *\n   * @memberof IConnectionBridgeOptions\n   */\n  // TODO - at now the default IPFS connection will be used\n  swarm?: any;\n}\n\nexport interface IConnectionBridge<\n  P extends ESwarmStoreConnector = ESwarmStoreConnector.OrbitDB,\n  DbType extends TSwarmStoreDatabaseType<P> = TSwarmStoreDatabaseType<P>\n> {\n  /**\n   * used to authorize the user or get\n   * a common information about the users\n   * also connected to the swarm.\n   *\n   * @type {ICentralAuthority}\n   * @memberof IConnectionBridge\n   */\n  caConnection?: ICentralAuthority;\n  /**\n   * storage allows to add or read messages from\n   * the swarm\n   *\n   * @type {ISwarmMessageStore<P>}\n   * @memberof IConnectionBridge\n   */\n  storage?: ISwarmMessageStore<P, DbType>;\n  /**\n   * allows to create messages, which can be stored in the swarm\n   *\n   * @type {ISwarmMessageConstructor}\n   * @memberof IConnectionBridge\n   */\n  messageConstructor?: ISwarmMessageConstructor;\n\n  /**\n   * Fabric which provides instances of SwarmMessageEncryptedCache,\n   * already connected to the storage and ready to use.\n   *\n   * @type {ISwarmMessageEncryptedCacheFabric}\n   * @memberof IConnectionBridge\n   */\n  swarmMessageEncryptedCacheFabric?: ISwarmMessageEncryptedCacheFabric;\n\n  /**\n   * allows to construct SwarmMessagesConstructor with support of\n   * encrypted cache storage and ready to use.\n   *\n   * @type {ISwarmMessageConstructorWithEncryptedCacheFabric}\n   * @memberof IConnectionBridge\n   */\n  swarmMessageConstructorFabric?: ISwarmMessageConstructorWithEncryptedCacheFabric;\n\n  /**\n   * Connect to central authority and swarm. If the connection\n   * will be succeed than the caConnection and storage\n   * properties will be available.\n   * If email or any other operations are necessary then\n   * the promise returned will be resolved with Error\n   * have a message with the problem description.\n   *\n   * @param {IConnectionBridgeOptions<P>} options\n   * @returns {(Promise<Error | void>)}\n   * @memberof IConnectionBridge\n   */\n  connect(options: IConnectionBridgeOptions<P>): Promise<Error | void>;\n\n  /**\n   * checks was a session started before and\n   * if it's data is available for now.\n   * If a session is availablr, the user\n   * can try to connect without credentials.\n   *\n   * @param {(ISensitiveDataSessionStorageOptions | IConnectionBridgeOptions<P>)} [options]\n   * @returns {Promise<boolean>}\n   * @memberof IConnectionBridge\n   */\n  checkSessionAvailable(\n    options?: ISensitiveDataSessionStorageOptions | IConnectionBridgeOptions<P>\n  ): Promise<boolean>;\n  /**\n   * Close all connections and release the options.\n   * The connection can't be used anymore.\n   *\n   * @returns {(Promise<Error | void>)}\n   * @memberof IConnectionBridge\n   */\n  close(): Promise<Error | void>;\n}\n","/home/paul/projects/protocol/src/classes/connection-bridge/index.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.const.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.ts",["2347"],"import {\n  FILE_STORAGE_SERVICE_STATUS,\n  FILE_STORAGE_SERVICE_TYPE,\n} from '../../filestorage-class.const';\nimport HttpRequest from 'classes/basic-classes/http-request-class-base/http-request-class-base';\nimport {\n  IFileStorageClassProviderHTTPFileGetOptions,\n  IFileStorageClassProviderHTTPFileAddOptions,\n} from './filestorage-class-provider-http.types';\nimport {\n  FILE_STORAGE_PROVIDER_HTTP_TYPE,\n  FILE_STORAGE_PROVIDER_HTTP_IDENTIFIER,\n} from './filestorage-class-provider-http.const';\nimport { HTTP_REQUEST_MODE } from 'classes/basic-classes/http-request-class-base';\nimport { downloadFileByUrl } from 'utils/files-utils/files-utils-download';\n\nimport {\n  IFileStorageService,\n  TFileStorageFileAddress,\n} from '../../filestorage-class.types';\nimport { TFileStorageFile } from '../../filestorage-class.types';\n\nexport class FileStorageClassProviderHTTP\n  implements IFileStorageService<FILE_STORAGE_SERVICE_TYPE.HTTP> {\n  public type = FILE_STORAGE_PROVIDER_HTTP_TYPE;\n\n  public readonly isSingleton = true;\n\n  public readonly identifier = FILE_STORAGE_PROVIDER_HTTP_IDENTIFIER;\n\n  public get status() {\n    return FILE_STORAGE_SERVICE_STATUS.READY;\n  }\n\n  public isFileServed(addr: TFileStorageFileAddress): boolean {\n    return addr.startsWith('/http') || this.isBlobAddr(addr);\n  }\n\n  public async connect(options: {}) {\n    return FILE_STORAGE_PROVIDER_HTTP_IDENTIFIER;\n  }\n\n  public async close() {}\n\n  public add = async (\n    filename: string,\n    file: TFileStorageFile,\n    options?: {}\n  ): Promise<TFileStorageFileAddress> => {\n    throw new Error('The HTTP provider does not supports files uploading');\n  };\n\n  public get = async (\n    addr: TFileStorageFileAddress,\n    options?: IFileStorageClassProviderHTTPFileGetOptions\n  ): Promise<File> => {\n    const urlNormalized = this.getFileURL(addr);\n    const req = new HttpRequest({\n      credentials: 'include',\n      mode: HTTP_REQUEST_MODE.CORS,\n      ...options,\n      url: urlNormalized,\n    });\n    const result = await req.send();\n\n    if (!(result instanceof File)) {\n      throw new Error('Failed to get the file from the network');\n    }\n    return result;\n  };\n\n  public download = async (\n    addr: TFileStorageFileAddress,\n    options?: IFileStorageClassProviderHTTPFileAddOptions\n  ) => {\n    const urlNormalized = this.getFileURL(addr);\n\n    downloadFileByUrl(urlNormalized);\n  };\n\n  protected isBlobAddr(addr: TFileStorageFileAddress): boolean {\n    return addr.startsWith('/data:');\n  }\n\n  protected getFileURL(addr: TFileStorageFileAddress): string {\n    if (this.isBlobAddr(addr)) {\n      return addr.slice(1);\n    }\n\n    const isHttps = addr.startsWith('/https');\n    const protocol = isHttps ? 'https://' : 'http://';\n    const addrWithoutPrefix = (isHttps ? addr.slice(6) : addr.slice(5)).replace(\n      /^\\W+/,\n      ''\n    );\n    const resultedUrl = `${protocol}${addrWithoutPrefix}`;\n\n    return String(new URL(resultedUrl));\n  }\n}\n","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.types.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/index.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.const.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.ts",["2348","2349","2350","2351"],"import {\n  IFileStorageService,\n  TFileStorageFileAddress,\n} from '../../filestorage-class.types';\nimport {\n  IFileStorageClassProviderIPFSOptions,\n  IFileStorageClassProviderIPFSFileAddOptions,\n} from './filestorage-class-provider-ipfs.types';\nimport {\n  FILE_STORAGE_PROVIDER_IPFS_IDENTIFIER,\n  FILE_STORAGE_PROVIDER_IPFS_TYPE,\n} from './filestorage-class-provider-ipfs.const';\nimport {\n  FILE_STORAGE_SERVICE_STATUS,\n  FILE_STORAGE_SERVICE_TYPE,\n} from '../../filestorage-class.const';\nimport { TFileStorageFile } from '../../filestorage-class.types';\nimport { extend } from 'utils';\nimport { getFileSize } from 'utils/files-utils';\nimport assert from 'assert';\nimport path from 'path';\nimport { FILE_STORAGE_PROVIDER_IPFS_FILE_UPLOAD_TIMEOUT_MS } from './filestorage-class-provider-ipfs.const';\nimport { IPFS, FileObject, IPFSFile } from 'types/ipfs.types';\nimport BufferList from 'bl';\nimport { FILE_STORAGE_PROVIDER_ROOT_PATH_DEFAULT } from './filestorage-class-provider-ipfs.const';\nimport { timeout } from 'utils/common-utils/common-utils-timer';\nimport { UnixTime } from 'types/ipfs.types';\nimport { downloadFile } from '../../../../utils/files-utils/files-utils-download';\nimport {\n  IFileStorageClassProviderIPFSFileGetOptions,\n  IFileStorageClassProviderIPFSFileDownloadOptions,\n} from './filestorage-class-provider-ipfs.types';\n\nexport class FileStorageClassProviderIPFS\n  implements IFileStorageService<FILE_STORAGE_SERVICE_TYPE.IPFS> {\n  public type = FILE_STORAGE_PROVIDER_IPFS_TYPE;\n\n  public readonly isSingleton = true;\n\n  public readonly identifier = FILE_STORAGE_PROVIDER_IPFS_IDENTIFIER;\n\n  public get status() {\n    const { _ipfs: ipfs } = this;\n\n    if (!ipfs || !ipfs.isOnline()) {\n      return FILE_STORAGE_SERVICE_STATUS.NOT_READY;\n    }\n    if (!ipfs.files || this._error) {\n      return FILE_STORAGE_SERVICE_STATUS.ERROR;\n    }\n    return FILE_STORAGE_SERVICE_STATUS.READY;\n  }\n\n  /**\n   * this is the prefix for path\n   * of each file uploaded\n   *\n   * @protected\n   * @type {string}\n   * @memberof FileStorageClassProviderIPFS\n   */\n  protected _rootPath: string = FILE_STORAGE_PROVIDER_ROOT_PATH_DEFAULT;\n\n  protected _ipfs?: IPFS;\n\n  protected _error?: Error;\n\n  public isFileServed(addr: TFileStorageFileAddress): boolean {\n    return addr.startsWith('/ipfs');\n  }\n\n  public async connect(options: IFileStorageClassProviderIPFSOptions) {\n    try {\n      this.setOptions(options);\n      await this._ipfs?.ready;\n    } catch (err) {\n      console.log(err);\n      throw err;\n    }\n    return FILE_STORAGE_PROVIDER_IPFS_IDENTIFIER;\n  }\n\n  public async close() {\n    this._ipfs = undefined;\n  }\n\n  public add = async (\n    filename: string,\n    file: TFileStorageFile,\n    options?: IFileStorageClassProviderIPFSFileAddOptions\n  ): Promise<TFileStorageFileAddress> => {\n    const ipfs = this._ipfs;\n    const fileSize = getFileSize(file);\n\n    assert(\n      this.status === FILE_STORAGE_SERVICE_STATUS.READY,\n      'Service is not ready to use'\n    );\n    assert(fileSize, 'Failed to get a size of the file');\n    let files: IPFSFile[] | Error | undefined;\n    const progressCallback = options?.progress;\n    let resolve: undefined | Function;\n    const pending = new Promise((res, rej) => {\n      resolve = res;\n    });\n    const opts = extend(\n      options || {},\n      {\n        pin: false,\n        cidVersion: 1,\n        progress: (bytes: number) => {\n          const percent = (bytes / fileSize!) * 100;\n\n          if (progressCallback) {\n            progressCallback(percent);\n          }\n          if (resolve && percent >= 100) {\n            resolve();\n          }\n        },\n      },\n      true\n    );\n\n    try {\n      files = await Promise.race([\n        ipfs?.add(this.getFileObject(filename, file), opts),\n        timeout(FILE_STORAGE_PROVIDER_IPFS_FILE_UPLOAD_TIMEOUT_MS),\n      ]);\n      await pending;\n    } catch (err) {\n      console.error(err);\n      throw err;\n    }\n\n    if (!files) {\n      throw new Error('Failed to upload for an unknown reason');\n    }\n    if (files instanceof Error) {\n      throw files;\n    }\n    return this.getMultiaddr(files[0]);\n  };\n\n  public get = async (\n    addr: TFileStorageFileAddress,\n    options?: IFileStorageClassProviderIPFSFileGetOptions\n  ): Promise<File> => {\n    assert(\n      this.status === FILE_STORAGE_SERVICE_STATUS.READY,\n      'Service is not ready to use'\n    );\n    assert(this.isFileServed(addr), 'The file is not supported by the service');\n\n    const ipfs = this._ipfs;\n    const fileDesc = this.getFileDescription(addr);\n    const filesOrChunks = await ipfs!.get(fileDesc.cid);\n    const content = new BufferList();\n    let lastModified = 0;\n    let fileBlob: ArrayBuffer | Blob[];\n\n    if (!filesOrChunks) {\n      throw new Error('Failed to read the file');\n    }\n    if (filesOrChunks instanceof Array) {\n      const chunksLen = filesOrChunks.length;\n      let idx = 0;\n\n      while (idx < chunksLen) {\n        const chunk = filesOrChunks[idx++];\n        content.append(chunk.content);\n        lastModified = this.getMSByUnix(chunk.mtime);\n      }\n      const buff = content.slice();\n      fileBlob = buff.buffer.slice(\n        buff.byteOffset,\n        buff.byteOffset + buff.byteLength\n      );\n    } else {\n      if (!filesOrChunks.content) {\n        throw new Error(\"Failed to read the file's content\");\n      }\n      if (filesOrChunks.content instanceof Blob) {\n        fileBlob = [filesOrChunks.content];\n        if (filesOrChunks.mtime) {\n          lastModified = this.getMSByUnix(filesOrChunks.mtime);\n        }\n      } else if (typeof filesOrChunks.content === 'string') {\n        content.append(filesOrChunks.content);\n      }\n      throw new Error('Unknown content type');\n    }\n    return new File([fileBlob], fileDesc.path, {\n      lastModified: lastModified ? lastModified : undefined,\n    });\n  };\n\n  public download = async (\n    addr: TFileStorageFileAddress,\n    options?: IFileStorageClassProviderIPFSFileDownloadOptions\n  ) => {\n    const file = await this.get(addr, options);\n\n    downloadFile(file);\n  };\n\n  protected setOptions(options: IFileStorageClassProviderIPFSOptions) {\n    assert(options.ipfs, 'An instance of IPFS must be provided in the options');\n    this._ipfs = options.ipfs;\n    this._rootPath =\n      options.rootPath || FILE_STORAGE_PROVIDER_ROOT_PATH_DEFAULT;\n  }\n\n  protected getFileObject(\n    filename: string,\n    file: TFileStorageFile\n  ): FileObject {\n    const filePath = path.join('/', this._rootPath, filename);\n\n    return {\n      path: filePath,\n      content: file,\n      mtime: file instanceof File ? new Date(file.lastModified) : undefined,\n    };\n  }\n\n  protected getMultiaddr(file: IPFSFile): TFileStorageFileAddress {\n    return path.join('/ipfs/', file.hash, file.path);\n  }\n\n  protected getFileDescription(addr: TFileStorageFileAddress) {\n    const [nothing, prefix, cid, path] = addr.split('/');\n\n    assert(cid, 'Failed to get CID by the address');\n    assert(path, 'Failed to get file path by the address');\n    return {\n      cid,\n      path,\n    };\n  }\n\n  protected getMSByUnix(unix?: UnixTime): number {\n    return unix && unix.secs ? unix.secs : Date.now();\n  }\n}\n","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.types.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/index.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/index.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class.const.ts",["2352","2353"],"import { IFileStorageService } from './filestorage-class.types';\n/**\n * status of a service\n *\n * @export\n * @enum {number}\n */\nexport enum FILE_STORAGE_SERVICE_STATUS {\n  /**\n   * ready to use\n   */\n  READY = 'READY',\n  /**\n   * connecting to the service\n   */\n  CONNECTING = 'CONNECTING',\n  /**\n   * not ready - may be disconnected or still not connected to\n   */\n  NOT_READY = 'NOT_READY',\n  /**\n   * fault on connecting or file uploading\n   * and means that the service can't be used\n   * anymore\n   */\n  ERROR = 'ERROR',\n}\n\n/**\n * service type\n *\n * @export\n * @enum {number}\n */\nexport enum FILE_STORAGE_SERVICE_TYPE {\n  IPFS = 'IPFS',\n  HTTP = 'HTTP',\n  // will be added in the feature\n  // AMAZONS3 = 'AMAZONS3',\n  // AZUREBLOB = 'AZUREBLOB',\n}\n\n// implementations of the services.\n// will be loaded only if required\nexport const FILE_STORAGE_SERVICES_IMPLEMENTATIONS: Record<\n  FILE_STORAGE_SERVICE_TYPE,\n  () => Promise<any> // Promise<new () => IFileStorageService<any>>\n> = {\n  [FILE_STORAGE_SERVICE_TYPE.IPFS]: () =>\n    import('./filestorage-class-providers/filestorage-class-provider-ipfs'),\n  [FILE_STORAGE_SERVICE_TYPE.HTTP]: () =>\n    import('./filestorage-class-providers/filestorage-class-provider-http'),\n};\n\nexport const FILE_STORAGE_SERVICE_PREFIX = '/file';\n\nexport const FILE_STORAGE_SERVICE_PREFIX_LENGTH =\n  FILE_STORAGE_SERVICE_PREFIX.length;\n","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class.types.ts",["2354"],"import { IFileStorageClassProviderIPFSOptions } from './filestorage-class-providers/filestorage-class-provider-ipfs';\nimport {\n  IFileStorageClassProviderHTTPFileDownloadOptions,\n  IFileStorageClassProviderHTTPOptions,\n} from './filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.types';\nimport { IFileStorageClassProviderIPFSFileDownloadOptions } from './filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.types';\nimport { FILE_STORAGE_SERVICE_TYPE } from './filestorage-class.const';\nimport {\n  IFileStorageClassProviderIPFSFileAddOptions,\n  IFileStorageClassProviderIPFSFileGetOptions,\n} from './filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.types';\nimport {\n  IFileStorageClassProviderHTTPFileGetOptions,\n  IFileStorageClassProviderHTTPFileAddOptions,\n} from './filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.types';\nimport {\n  FILE_STORAGE_SERVICE_TYPE as FileStorageServiceType,\n  FILE_STORAGE_SERVICE_STATUS as FileStorageServiceStatus,\n} from './filestorage-class.const';\n\nexport type TFileStorageServiceOptions<\n  T extends FILE_STORAGE_SERVICE_TYPE\n> = T extends FILE_STORAGE_SERVICE_TYPE.IPFS\n  ? IFileStorageClassProviderIPFSOptions\n  : T extends FILE_STORAGE_SERVICE_TYPE.HTTP\n  ? IFileStorageClassProviderHTTPOptions\n  : never;\n\nexport type TFileStorageServiceFileAddOptions =\n  | IFileStorageClassProviderIPFSFileAddOptions\n  | IFileStorageClassProviderHTTPFileAddOptions;\n\nexport type TFileStorageServiceFileGetOptions =\n  | IFileStorageClassProviderIPFSFileGetOptions\n  | IFileStorageClassProviderHTTPFileGetOptions;\n\nexport type TFileStorageServiceFileDownloadOptions =\n  | IFileStorageClassProviderHTTPFileDownloadOptions\n  | IFileStorageClassProviderIPFSFileDownloadOptions;\n\nexport interface IFileStorageServiceFileAddCommonOptions {\n  progress?: (progress: number) => any;\n}\n\nexport type TFileStorageFile = ArrayBuffer | Buffer | Blob | File;\n\n/**\n * multiaddr or address in the ipfs:\n * '/ipfs/QmXEmhrMpbVvTh61FNAxP9nU7ygVtyvZA8HZDUaqQCAb66',\n * '/ipfs/QmXEmhrMpbVvTh61FNAxP9nU7ygVtyvZA8HZDUaqQCAb66/a.txt'\n * or if http file:\n * '/http/server.com:3000/download/file.pdf',\n * '/https/upload.com/?d=f'\n */\nexport type TFileStorageFileAddress = string;\n\n/**\n * unique identifier of the service connected to,\n * may be an url or another string\n */\nexport type TFileStorageServiceIdentifier = string;\n\nexport interface IFileStorageService<T extends FILE_STORAGE_SERVICE_TYPE> {\n  /**\n   * the current status of the service\n   *\n   * @type {FileStorageServiceStatus}\n   * @memberof IFileStorageService\n   */\n  status: FileStorageServiceStatus;\n  /**\n   * type of the service\n   *\n   * @type {FileStorageServiceType}\n   * @memberof IFileStorageService\n   */\n  type: FileStorageServiceType;\n  /**\n   * unique name of the service, maybe url\n   *\n   * @type {TFileStorageServiceIdentifier}\n   * @memberof IFileStorageService\n   */\n  identifier: TFileStorageServiceIdentifier;\n  /**\n   * is only the one implementation is allowed\n   *\n   * @type {boolean}\n   * @memberof IFileStorageService\n   */\n  isSingleton: boolean;\n  /**\n   * initialize connection with the service\n   *\n   * @param {TFileStorageServiceOptions} options\n   * @returns {Promise<TFileStorageServiceIdentifier>}\n   * @memberof IFileStorageService\n   */\n  connect(\n    options: TFileStorageServiceOptions<T>\n  ): Promise<TFileStorageServiceIdentifier>;\n  /**\n   * close connection to the service\n   *\n   * @returns {Promise<void>}\n   * @memberof IFileStorageService\n   */\n  close(): Promise<void>;\n  /**\n   * check whether a file with the address\n   * is served by the service.\n   *\n   * @param {TFileStorageFileAddress} addr\n   * @returns {boolean}\n   * @memberof IFileStorageService\n   */\n  isFileServed(addr: TFileStorageFileAddress): boolean;\n  /**\n   * add the file to the service\n   *\n   * @param {string} filename - filename, e.g. 'file.txt'\n   * @param {TFileStorageFile} file - file content\n   * @param {object} [undefined] options - options, not required, specific for the service\n   * @returns {Promise<TFileStorageFileAddress>} - returns an address of the file added,\n   * which can be used to access the file\n   * @throws\n   * @memberof IFileStorageService\n   */\n  add(\n    filename: string,\n    file: TFileStorageFile,\n    options?: IFileStorageServiceFileAddCommonOptions\n  ): Promise<TFileStorageFileAddress>;\n  /**\n   * get the file\n   * TODO - add download progress callback\n   * @param {TFileStorageFileAddress} addr - address of the file\n   * @param {object} [undefined] options - options, not required, specific for the service\n   * @returns {Promise<File>} - returns file itself\n   * @memberof IFileStorageService\n   * @throws\n   */\n  get(\n    addr: TFileStorageFileAddress,\n    options?: TFileStorageServiceFileGetOptions\n  ): Promise<File>;\n  /**\n   * download the file, do net necessary\n   * to read it's content\n   * @param {TFileStorageFileAddress} addr\n   * @param {TFileStorageServiceFileDownloadOptions} [options]\n   * @returns {Promise<void>}\n   * @memberof IFileStorageService\n   */\n  download(\n    addr: TFileStorageFileAddress,\n    options?: TFileStorageServiceFileDownloadOptions\n  ): Promise<void>;\n}\n\nexport interface IFileStorageServiceConnectOptions<\n  T extends FILE_STORAGE_SERVICE_TYPE\n> {\n  /**\n   * type of the service provider\n   *\n   * @type {FileStorageServiceType}\n   * @memberof IFileStorageServiceConnectOptions\n   */\n  type: FileStorageServiceType;\n  /**\n   * options used be the service provider to\n   * connect to the service\n   *\n   * @type {TFileStorageServiceOptions}\n   * @memberof IFileStorageServiceConnectOptions\n   */\n  options: TFileStorageServiceOptions<T>;\n}\n\nexport interface IFileStorage<T extends FILE_STORAGE_SERVICE_TYPE> {\n  /**\n   * connect to the file upload service\n   *\n   * @param {IFileStorageServiceConnectOptions} options\n   * @returns {Promise<TFileStorageServiceIdentifier>}\n   * @memberof IFileStorage\n   */\n  connect(\n    configurations: IFileStorageServiceConnectOptions<T>[]\n  ): Promise<TFileStorageServiceIdentifier[]>;\n  /**\n   * close the existing connection with the service\n   * have the identifier provided\n   *\n   * @param {TFileStorageServiceIdentifier} service - service identifier\n   * @returns {Promise<void>}\n   * @memberof IFileStorage\n   */\n  close(serviceId: TFileStorageServiceIdentifier): Promise<void>;\n  /**\n   * add the file to the service\n   *\n   * @param {TFileStorageServiceIdentifier} service - service identifier connected to,\n   * on which to upload the file\n   * @param {string} filename - filename, e.g. 'file.txt'\n   * @param {TFileStorageFile} file - file content\n   * @param {object} [undefined] options - options, not required, specific for the service\n   * @returns {Promise<TFileStorageFileAddress>} - returns an address of the file added,\n   * which can be used to access the file\n   * @throws\n   * @memberof IFileStorage\n   */\n  add(\n    service: TFileStorageServiceIdentifier | T,\n    filename: string,\n    file: TFileStorageFile,\n    options?: TFileStorageServiceFileAddOptions\n  ): Promise<TFileStorageFileAddress>;\n  /**\n   * get the file from the service\n   *\n   * @param {TFileStorageFileAddress} addr - address of the file\n   * @param {object} [TFileStorageServiceIdentifier] service - service identifier connected to,\n   * from which to download the file. If the identifier is not provided, then\n   * it will be identified by a services connected to by the address provided.\n   * @param {object} [undefined] options - options, not required, specific for the service\n   * @returns {Promise<File>} - returns file donwloaded from the service\n   * @memberof IFileStorage\n   * @throws\n   */\n  get(\n    addr: TFileStorageFileAddress,\n    options?: TFileStorageServiceFileGetOptions\n  ): Promise<File>;\n  /**\n   * download the file, do net necessary\n   * to read it's content\n   *\n   * @param {TFileStorageFileAddress} addr - file address supported by services\n   * connected to\n   * @param {TFileStorageServiceFileDownloadOptions} [options] - options which used\n   * by the service to download the file\n   * @returns {Promise<void>}\n   * @memberof IFileStorage\n   */\n  download(\n    addr: TFileStorageFileAddress,\n    options?: TFileStorageServiceFileDownloadOptions\n  ): Promise<void>;\n}\n","/home/paul/projects/protocol/src/classes/filestorage-class/index.ts",[],"/home/paul/projects/protocol/src/classes/index.ts",[],"/home/paul/projects/protocol/src/classes/open-storage/index.ts",[],"/home/paul/projects/protocol/src/classes/open-storage/open-storage.const.ts",[],"/home/paul/projects/protocol/src/classes/open-storage/open-storage.ts",[],"/home/paul/projects/protocol/src/classes/open-storage/open-storage.types.ts",[],"/home/paul/projects/protocol/src/classes/pseudo-ntp-class/index.ts",[],"/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.const.ts",[],"/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.ts",["2355","2356","2357","2358","2359","2360"],"import { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport {\n  IPseudoNTPClassEvents,\n  IPseudoNTPClassOptions,\n  TPseudoNTPClassServersPoolOption,\n  IPseudoNTPClassServerConnection,\n  IPseudoNTPClassCommonOptionsMilliseconds,\n  TPseudoNTPClassServerResponse,\n  TPseudoNTPClassResponseWithTimesamps,\n  IPseudoNTPClassServerConnectionField,\n  IPseudoNTPClassServerConnectionCb,\n} from './pseudo-ntp-class.types';\nimport {\n  PSEUDO_NTP_CLASS_DEFAULT_OPTIONS,\n  PSEUDO_NTP_CLASS_LOGS_PREFIX,\n  PSEUDO_NTP_CLASS_EVENTS,\n  PSEUDO_NTP_CLASS_REQUEST_OPTIONS,\n} from './pseudo-ntp-class.const';\nimport {\n  getTimestampSeconds,\n  addSecondsToDate,\n  datesDifferenceSeconds,\n} from './pseudo-ntp-class.utils';\nimport HttpRequest from 'classes/basic-classes/http-request-class-base/http-request-class-base';\nimport { IHttpRequestOptions } from 'classes/basic-classes/http-request-class-base/http-request-class-base.types';\n\n/**\n * This is class for time sync with the\n * server which provides API to get\n * the current date and time in UTC.\n * This allows to sync time for all users.\n *\n * @export\n * @class PseudoNTPClass\n * @extends {EventEmitter<IPseudoNTPClassEvents>}\n */\nexport class PseudoNTPClass extends EventEmitter<IPseudoNTPClassEvents> {\n  public static Event = PSEUDO_NTP_CLASS_EVENTS;\n\n  /**\n   * true if the sync is running on\n   *\n   * @type {boolean}\n   * @memberof PseudoNTPClass\n   */\n  public isRunning: boolean = false;\n\n  /**\n   * if sync process is running at now\n   * then this flag will be set on true\n   *\n   * @protected\n   * @type {boolean}\n   * @memberof PseudoNTPClass\n   */\n  protected isSyncInProgress: boolean = false;\n\n  protected serversPool?: TPseudoNTPClassServersPoolOption;\n\n  // index of the server connected to\n  protected currentServerIndex?: number;\n\n  // options of the server connected to\n  protected currentServerOptions?: IPseudoNTPClassServerConnection;\n\n  protected currentServerRequestOptions?: IHttpRequestOptions;\n\n  // a number of fails for the current server\n  protected currentServerFails: number = 0;\n\n  /**\n   * the options used for requesting\n   *\n   * @protected\n   * @type {IPseudoNTPClassCommonOptionsMilliseconds}\n   * @memberof PseudoNTPClass\n   */\n  protected commonOptions: IPseudoNTPClassCommonOptionsMilliseconds = PSEUDO_NTP_CLASS_DEFAULT_OPTIONS;\n\n  /**\n   * the active interval for requesting\n   * the server\n   *\n   * @protected\n   * @type {NodeJS.Timer}\n   * @memberof PseudoNTPClass\n   */\n  protected intervalRunning?: NodeJS.Timeout;\n\n  constructor(options: IPseudoNTPClassOptions) {\n    super();\n    this.setOptions(options);\n  }\n\n  /**\n   * start the requesting of the servers in the pool\n   *\n   * @memberof PseudoNTPClass\n   */\n  public start() {\n    this.setCurrentServerFromPool();\n    this.startInterval();\n  }\n\n  /**\n   * stop the requesting of the servers in the pool\n   *\n   * @memberof PseudoNTPClass\n   */\n  public stop() {\n    this.stopInterval();\n  }\n\n  /**\n   * write something in console.log\n   *\n   * @protected\n   * @param {(Error | string)} message\n   * @memberof PseudoNTPClass\n   */\n  protected log = (message: Error | string) => {\n    const { currentServerOptions } = this;\n    const consoleMethod = message instanceof Error ? 'error' : 'log';\n\n    console[consoleMethod](\n      PSEUDO_NTP_CLASS_LOGS_PREFIX,\n      `server is ${\n        currentServerOptions ? currentServerOptions.server : 'not defined'\n      }`,\n      message\n    );\n  };\n\n  /**\n   * check is a server's options are valid\n   *\n   * @protected\n   * @param {*} options\n   * @returns {options is IPseudoNTPClassServerConnection}\n   * @memberof PseudoNTPClass\n   */\n  protected checkServerOptions(\n    options: any\n  ): options is IPseudoNTPClassServerConnection {\n    return (\n      !!options &&\n      typeof options === 'object' &&\n      typeof options.server === 'string' &&\n      !!options.server.length\n    );\n  }\n\n  /**\n   * set options for the instance and\n   * convert seconds in milliseconds\n   * for all the options\n   *\n   * @protected\n   * @param {IPseudoNTPClassOptions} options\n   * @memberof PseudoNTPClass\n   * @throws\n   */\n  protected setOptions(options: IPseudoNTPClassOptions) {\n    const {\n      serversPool,\n      maxFailedResponses,\n      maxOffsetErrorS,\n      responseTimeoutS,\n      retryRequestDelayS,\n      syncIntervalS,\n    } = options;\n\n    if (!(serversPool instanceof Array) || !serversPool.length) {\n      throw new Error('The \"servers pool\" option must be defined');\n    }\n    this.serversPool = serversPool;\n\n    const optionsInMs = {\n      maxFailedResponses:\n        typeof maxFailedResponses === 'number'\n          ? maxFailedResponses\n          : PSEUDO_NTP_CLASS_DEFAULT_OPTIONS.maxFailedResponses,\n      maxOffsetErrorS:\n        typeof maxOffsetErrorS === 'number'\n          ? maxOffsetErrorS\n          : PSEUDO_NTP_CLASS_DEFAULT_OPTIONS.maxOffsetErrorS,\n      responseTimeoutMs:\n        typeof responseTimeoutS === 'number'\n          ? responseTimeoutS * 1000\n          : PSEUDO_NTP_CLASS_DEFAULT_OPTIONS.responseTimeoutMs,\n      retryRequestDelayMs:\n        typeof retryRequestDelayS === 'number'\n          ? retryRequestDelayS * 1000\n          : PSEUDO_NTP_CLASS_DEFAULT_OPTIONS.retryRequestDelayMs,\n      syncIntervalMs:\n        typeof syncIntervalS === 'number'\n          ? syncIntervalS * 1000\n          : PSEUDO_NTP_CLASS_DEFAULT_OPTIONS.syncIntervalMs,\n    };\n\n    this.commonOptions = optionsInMs;\n  }\n\n  protected setCurrentServerFromPoolIndex(): void {\n    const { serversPool, currentServerIndex } = this;\n    const serversPoolLength = serversPool!.length;\n    let currentServerIndexResolved: number;\n\n    if (typeof currentServerIndex === 'number') {\n      if (currentServerIndex === serversPoolLength) {\n        currentServerIndexResolved = 0;\n      }\n      currentServerIndexResolved = currentServerIndex + 1;\n    } else {\n      currentServerIndexResolved = 0;\n    }\n    this.currentServerIndex = currentServerIndexResolved;\n  }\n\n  /**\n   * create an object to send the request\n   * to the server to request the current\n   * date and time\n   *\n   * @protected\n   * @returns {(void | Error)}\n   * @memberof PseudoNTPClass\n   */\n  protected setCurrentServerRequestOptions(): void | Error {\n    const { currentServerOptions } = this;\n    const { server: serverUrl } = currentServerOptions!;\n\n    if (!currentServerOptions) {\n      return new Error('The current server options is not defined');\n    }\n    this.currentServerRequestOptions = {\n      ...PSEUDO_NTP_CLASS_REQUEST_OPTIONS,\n      url: serverUrl,\n    };\n  }\n\n  protected setCurrentServerFromPoolOptions(): void {\n    const { serversPool, currentServerIndex } = this;\n    const currentServerOptions = serversPool![currentServerIndex || 0];\n\n    if (!this.checkServerOptions(currentServerOptions)) {\n      // if the options is not defined for the server or there is no url for it\n      // choose another server from the pool\n      this.log(\n        `Options is not defined for the server under the index ${currentServerIndex} in the pool`\n      );\n      this.setCurrentServerFromPoolIndex();\n      return this.setCurrentServerFromPoolOptions();\n    }\n    this.currentServerOptions = currentServerOptions;\n\n    const serCurrentServerRequestOptionsResult = this.setCurrentServerRequestOptions();\n\n    if (serCurrentServerRequestOptionsResult instanceof Error) {\n      return this.setCurrentServerFromPoolOptions();\n    }\n  }\n\n  protected resetCurrentServerDescription() {\n    this.currentServerFails = 0;\n    this.currentServerOptions = undefined;\n  }\n\n  /**\n   * choose the next server from the pool\n   * and set it's options to use as the\n   * current server\n   *\n   * @protected\n   * @memberof PseudoNTPClass\n   */\n  protected setCurrentServerFromPool() {\n    this.resetCurrentServerDescription();\n    this.setCurrentServerFromPoolIndex();\n    this.setCurrentServerFromPoolOptions();\n  }\n\n  /**\n   * send a request to the server\n   * and handle a response from it\n   *\n   * @protected\n   * @memberof PseudoNTPClass\n   */\n  protected sync = async (): Promise<void> => {\n    const { isSyncInProgress } = this;\n\n    if (isSyncInProgress) {\n      // if the sync process is\n      // already is running on\n      return;\n    }\n    this.isSyncInProgress = true;\n\n    const response = await this.sendRequestToCurrentServer();\n\n    if (response instanceof Error) {\n      return this.handleSyncFail(response);\n    }\n\n    const resultOfHandlig = await this.handleServerResponse(response);\n\n    if (resultOfHandlig instanceof Error) {\n      return this.handleSyncFail(resultOfHandlig);\n    }\n    this.isSyncInProgress = false;\n  };\n\n  /**\n   * starts the interval for requesting\n   * the current server from the servers\n   * pool for it's current time\n   *\n   * @protected\n   * @memberof PseudoNTPClass\n   */\n  protected startInterval(): void {\n    const { commonOptions } = this;\n    const { syncIntervalMs } = commonOptions;\n\n    if (this.isRunning) {\n      this.log('Want to start the instance already running');\n    } else {\n      this.intervalRunning = setInterval(this.sync, syncIntervalMs);\n      this.isRunning = true;\n      this.sync();\n    }\n  }\n\n  protected stopInterval() {\n    if (this.intervalRunning) {\n      clearInterval(this.intervalRunning);\n      this.intervalRunning = undefined;\n    }\n    this.isRunning = false;\n  }\n\n  /**\n   * handle failed sync attempt\n   *\n   * @param err\n   */\n  protected handleSyncFail(err?: Error) {\n    if (err instanceof Error) {\n      this.log(`Request failed ${err.message}`);\n    }\n\n    const { currentServerFails, commonOptions } = this;\n    const { maxFailedResponses } = commonOptions;\n\n    if (currentServerFails > maxFailedResponses) {\n      this.log(`There is ${currentServerFails} fail`);\n      this.setCurrentServerFromPool();\n    }\n  }\n\n  /**\n   * returns the date from the server response\n   * or an error\n   *\n   * @private\n   * @memberof PseudoNTPClass\n   */\n  protected parseServerResponse = (\n    response: TPseudoNTPClassServerResponse\n  ): Error | Date => {\n    const { currentServerOptions } = this;\n\n    if (\n      typeof (currentServerOptions as IPseudoNTPClassServerConnectionField)\n        .fieldName === 'string'\n    ) {\n      const {\n        fieldName,\n      } = currentServerOptions as IPseudoNTPClassServerConnectionField;\n\n      if (typeof response !== 'object') {\n        return new Error(\n          `Response must be an object to get the date from the field ${fieldName}`\n        );\n      }\n\n      const fieldValue = (response as any)[fieldName];\n\n      if (typeof fieldValue !== 'string') {\n        return new Error(`Response field ${fieldName} must be a string`);\n      }\n      try {\n        const resultParse = new Date(fieldValue);\n\n        if (resultParse instanceof Date) {\n          return resultParse;\n        }\n        return new Error(\n          `Failed to parse string from the server response from field ${fieldName}`\n        );\n      } catch (err) {\n        return err;\n      }\n    }\n    if (\n      typeof (currentServerOptions as IPseudoNTPClassServerConnectionCb)\n        .parseCallback === 'function'\n    ) {\n      const {\n        parseCallback,\n      } = currentServerOptions as IPseudoNTPClassServerConnectionCb;\n\n      if (!parseCallback.length) {\n        this.log('The callback seems to have no arguments accepted');\n      }\n      try {\n        const parseResponseResult = parseCallback(response);\n\n        if (parseResponseResult instanceof Error) {\n          return parseResponseResult;\n        }\n        if (parseResponseResult instanceof Date) {\n          return parseResponseResult;\n        }\n      } catch (err) {}\n      return new Error('The server response do not parse correctly');\n    }\n    if (typeof response === 'string') {\n      try {\n        const resultParse = new Date(response);\n\n        if (resultParse instanceof Date) {\n          return resultParse;\n        }\n      } catch (err) {}\n      return new Error('Failed to parse string from the server response');\n    }\n    return new Error('There is unknown response format');\n  };\n\n  protected emitClientServerTimeDifference(timeDifferenceSeconds: number) {\n    this.emit(PSEUDO_NTP_CLASS_EVENTS.TIME_SYNC, timeDifferenceSeconds);\n  }\n\n  /**\n   * handle Date received in a server response\n   * and make an adjustment based on the on the\n   * time the request was sent and\n   * the response was received.\n   * If the difference is more than the max error\n   * then emit the event.\n   *\n   * @protected\n   * @param {Date} serverDate\n   * @param {number} timestampReq - request sent in seconds\n   * @param {number} timestampRes - response received in seconds\n   * @param {Date} dateRes - Date when the responce received\n   * @memberof PseudoNTPClass\n   */\n  protected handleServerDate(\n    serverDate: Date,\n    timestampReq: number,\n    timestampRes: number,\n    dateRes: Date\n  ): void {\n    // we think that the request was received on the\n    // server at half of the request-response time\n    const adjustmentS = (timestampRes - timestampReq) / 2;\n    const clientDate = addSecondsToDate(dateRes, adjustmentS);\n    const offsetClientTimeFromServer = datesDifferenceSeconds(\n      clientDate,\n      serverDate\n    );\n\n    if (offsetClientTimeFromServer) {\n      const { commonOptions } = this;\n      const { maxOffsetErrorS } = commonOptions;\n\n      if (Math.abs(offsetClientTimeFromServer) > maxOffsetErrorS) {\n        this.log(\n          `The client-server time difference is equals to ${offsetClientTimeFromServer}`\n        );\n        this.emitClientServerTimeDifference(offsetClientTimeFromServer);\n      }\n    }\n  }\n\n  protected convertServerResponseRaw(responseRaw: {\n    [key: string]: string;\n  }): TPseudoNTPClassServerResponse | Error {\n    return responseRaw;\n  }\n\n  /**\n   * handle the responce from the server\n   *\n   * @private\n   * @memberof PseudoNTPClass\n   */\n  private handleServerResponse = async (\n    responseWithTimestamps: TPseudoNTPClassResponseWithTimesamps\n  ): Promise<void | Error> => {\n    const {\n      responseRaw,\n      timestampReq,\n      timestempRes,\n      dateRes,\n    } = responseWithTimestamps;\n    const response = this.convertServerResponseRaw(responseRaw);\n\n    if (response instanceof Error) {\n      return response;\n    }\n\n    const responseResult = this.parseServerResponse(response);\n\n    if (responseResult instanceof Error) {\n      return responseResult;\n    }\n    if (responseResult instanceof Date) {\n      return this.handleServerDate(\n        responseResult,\n        timestampReq,\n        timestempRes,\n        dateRes\n      );\n    }\n    return new Error('An unknown result of parsing the response');\n  };\n\n  /**\n   * send the HTTP request to the current\n   * server from the pool\n   *\n   * @private\n   * @memberof PseudoNTPClass\n   */\n  private async sendRequestToCurrentServer(): Promise<\n    Error | TPseudoNTPClassResponseWithTimesamps\n  > {\n    const { currentServerRequestOptions } = this;\n    // timestamp when the request sent\n    const timestampReq = getTimestampSeconds();\n    const request = new HttpRequest({\n      ...currentServerRequestOptions!,\n    });\n    let responseRaw;\n\n    try {\n      responseRaw = await request.send();\n\n      if (responseRaw instanceof Error) {\n        console.error(responseRaw);\n        return new Error('The request failed');\n      }\n    } catch (err) {\n      return err;\n    }\n    // timestamp when the response received\n    const timestempRes = getTimestampSeconds();\n    const dateRes = new Date();\n    return {\n      responseRaw,\n      timestampReq,\n      timestempRes,\n      dateRes,\n    };\n  }\n}\n\nexport default PseudoNTPClass;\n","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.types.ts",["2361","2362"],"import { PSEUDO_NTP_CLASS_EVENTS } from './pseudo-ntp-class.const';\n\nexport type TPseudoNTPClassResponseRaw = any;\n\n/**\n * @param {number} timestampReq - timestamp when the request was sent\n * @param {number} timestempRes - timestamp when the response was received\n * @param {Date} dateRes - date when the response was received\n * @param {TPseudoNTPClassResponseRaw} responseRaw - reqponse from the server\n */\nexport type TPseudoNTPClassResponseWithTimesamps = {\n  timestampReq: number;\n  timestempRes: number;\n  dateRes: Date;\n  responseRaw: TPseudoNTPClassResponseRaw;\n};\n\n/**\n *  events emitted by the pseudo ntp\n *\n * @export\n * @interface IPseudoNTPClassEvents\n */\nexport interface IPseudoNTPClassEvents {\n  /**\n   * after syncronization with the\n   * server emit the event and\n   * returns the time offset in\n   * seconds\n   */\n  [PSEUDO_NTP_CLASS_EVENTS.TIME_SYNC]: number;\n}\n\nexport type TPseudoNTPClassServerResponse = string | { [key: string]: any };\n\n/**\n *\n * @export\n * @interface IPseudoNTPClassServerConnection\n * @param {string} server - the url of the server connect to\n * @param {string} fieldName - name of the field where is\n * the server's current date as a string in ISO format\n * @param {function} parseCallback - callback which called\n * to parse the response from the server and must return\n * the Date on the server\n */\nexport interface IPseudoNTPClassServerConnectionField {\n  server: string;\n  fieldName: string;\n}\nexport interface IPseudoNTPClassServerConnectionCb {\n  server: string;\n  parseCallback: (response: TPseudoNTPClassServerResponse) => Date | Error;\n}\nexport type IPseudoNTPClassServerConnection =\n  | IPseudoNTPClassServerConnectionCb\n  | IPseudoNTPClassServerConnectionField;\n\nexport type TPseudoNTPClassServersPoolOption = IPseudoNTPClassServerConnection[];\n\n/**\n * @param {number} [1] responseTimeoutS - timeout for reponse from the\n * server in seconds\n * @param {number} [60] syncIntervalS - interval in seconds to request the server\n * to get the time on it\n * @param {number} [10] maxOffsetErrorS - the maximum offset between the client\n * and the server time which will not be suggested as error\n * @param {number} [3] maxFailedResponses - the maximum fails of the responses\n * to switch on the another server\n * @param {number} [5] retryRequestDelayS - the delay to repeat the request\n * after fail\n */\nexport interface IPseudoNTPClassCommonOptions {\n  syncIntervalS?: number;\n  maxFailedResponses?: number;\n  retryRequestDelayS?: number;\n  responseTimeoutS?: number;\n  maxOffsetErrorS?: number;\n}\n\nexport interface IPseudoNTPClassCommonOptionsMilliseconds {\n  syncIntervalMs: number;\n  maxFailedResponses: number;\n  retryRequestDelayMs: number;\n  responseTimeoutMs: number;\n  maxOffsetErrorS: number;\n}\n\n/**\n * options for pseudo ntp class\n *\n * @export\n * @interface IPseudoNTPClassOptions\n * @param {IPseudoNTPClassServerConnection[]} serversPool - this is options for\n * the pool of the servers to receive the current date and time\n */\nexport interface IPseudoNTPClassOptions extends IPseudoNTPClassCommonOptions {\n  serversPool: TPseudoNTPClassServersPoolOption;\n}\n","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.utils.ts",[],"/home/paul/projects/protocol/src/classes/safe-storage-class/index.ts",[],"/home/paul/projects/protocol/src/classes/safe-storage-class/safe-storage-class.const.ts",[],"/home/paul/projects/protocol/src/classes/safe-storage-class/safe-storage-class.ts",["2363","2364","2365"],"import {\n  ISafeStorageOptions,\n  TSafeStorageStoredDataType,\n  TSafeStorageStoredDataTypeKeyValue,\n  TSafeStorageStoredDataTypeAppendLog,\n  TSafeStorageDataTypesAvail,\n  TSafeStorageKeyType,\n  TSafeStorageDataType,\n  TSafeStorageStorageAppendLogDataType,\n} from './safe-storage-class.types';\nimport { DEFAULT_INTERVAL_MS } from 'classes/basic-classes/queue-manager-class-base/queue-manager-class-base.const';\nimport { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';\nimport {\n  SAFE_STORAGE_DUMP_PROVIDER_DEFAULT,\n  ESAFE_STORAGE_PROVIDER_STATUS,\n  SAFE_STORAGE_STORAGE_NAME_COMMON_PREFIX,\n  ESAFE_STORAGE_STORAGE_TYPE,\n  SAFE_STORAGE_MAX_ITEMS_APPEND_LOG,\n  SAFE_STORAGE_KEY_VALUE_INITIAL_VALUE,\n  SAFE_STORAGE_APPEND_LOG_INITIAL_VALUE,\n  SAFE_STORAGE_APPEND_LOG_APPEND_DATA_INITIAL_VALUE,\n  SAFE_STORAGE_KEY_VALUE_APPEND_DATA_INITIAL_VALUE,\n  SAFE_STORAGE_STORAGE_APPEND_LOG_COMMON_POSTFIX,\n  SAFE_STORAGE_ATTEMPTS_TO_SAVE_DATA_TO_STORAGE,\n  SAFE_STORAGE_DEFAULT_STORAGE_BUSY_TIMEOUT_MS,\n} from './safe-storage-class.const';\nimport {\n  getStatusClass,\n  STATUS_EVENT,\n} from 'classes/basic-classes/status-class-base/status-class-base';\n\nexport class SafeStorage<\n  TYPE extends ESAFE_STORAGE_STORAGE_TYPE\n> extends getStatusClass<typeof ESAFE_STORAGE_PROVIDER_STATUS>({\n  errorStatus: ESAFE_STORAGE_PROVIDER_STATUS.ERROR,\n  instanceName: 'SafeStorage',\n}) {\n  static storagesNames: string[] = []; // exists storages names, put it from constructor\n\n  static checkIfNameIsExists(storageName: string) {\n    const { storagesNames } = SafeStorage;\n\n    return storagesNames.includes(storageName);\n  }\n\n  static addStorageName(storageName: string) {\n    const { storagesNames } = SafeStorage;\n\n    storagesNames.push(storageName);\n  }\n\n  protected storageName: string = '';\n\n  protected storageNameAppendLog: string = '';\n\n  protected options?: ISafeStorageOptions;\n\n  protected dumpIntervalMs?: number;\n\n  protected dumpIntervalRunning?: NodeJS.Timeout | number;\n\n  protected secretStorageConnection?: InstanceType<typeof SecretStorage>;\n\n  protected tableData: TSafeStorageStoredDataType<\n    ESAFE_STORAGE_STORAGE_TYPE\n  > = [] as TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG>;\n\n  /**\n   *\n   * this is data which will be merged with the data from storage\n   * and then will be write to the storage\n   * @protected\n   * @type {TSafeStorageStoredDataType<\n   *     ESAFE_STORAGE_STORAGE_TYPE\n   *   >}\n   * @memberof SafeStorage\n   */\n  protected appendData: TSafeStorageStoredDataType<\n    ESAFE_STORAGE_STORAGE_TYPE\n  > = [] as TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG>;\n\n  /**\n   *\n   * here a data will be placed if any dumping of appendData is in progress,\n   * on a dumping will be ended up, data\n   * from this property will be merged with the appendData property\n   * @protected\n   * @type {TSafeStorageStoredDataType<\n   *     ESAFE_STORAGE_STORAGE_TYPE\n   *   >}\n   * @memberof SafeStorage\n   */\n  protected appendDataTemp: TSafeStorageStoredDataType<\n    ESAFE_STORAGE_STORAGE_TYPE\n  > = [] as TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG>;\n\n  protected storageType?: ESAFE_STORAGE_STORAGE_TYPE;\n\n  constructor(options: ISafeStorageOptions) {\n    super();\n\n    const setOptionsResult = this.setOptions(options);\n\n    if (setOptionsResult instanceof Error) {\n      throw setOptionsResult;\n    }\n    this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.NEW);\n    if (options.storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG) {\n      this.appendData = [] as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n      >;\n      this.appendDataTemp = [] as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n      >;\n    } else {\n      this.appendData = {} as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n      >;\n      this.appendDataTemp = {} as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n      >;\n    }\n  }\n\n  get secretStorageOptions() {\n    const { options } = this;\n    const { storageDumpProvider } = options as ISafeStorageOptions;\n\n    return {\n      storageProviderName:\n        storageDumpProvider || SAFE_STORAGE_DUMP_PROVIDER_DEFAULT,\n    };\n  }\n\n  get isStorageBusy(): boolean {\n    const { status } = this;\n\n    return status === ESAFE_STORAGE_PROVIDER_STATUS.WORKING_WITH_STORAGE;\n  }\n\n  /**\n   * connect to the secret storage\n   * and preload a data dumped\n   * from it\n   * @returns {boolean | Error} - true on success, false if connecting is\n   * already in progress, Error if an error has occurred\n   */\n  async connect(): Promise<boolean | Error> {\n    const { status, options } = this;\n\n    if (status !== ESAFE_STORAGE_PROVIDER_STATUS.CONNECTING_TO_STORAGE) {\n      const { credentials } = options as ISafeStorageOptions;\n      const connectionToTheSecretStorage = this.createSecretStorageInstance();\n\n      if (connectionToTheSecretStorage instanceof Error) {\n        return connectionToTheSecretStorage;\n      }\n      this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.CONNECTING_TO_STORAGE);\n\n      const connectionToSecretStorageResult = await connectionToTheSecretStorage.authorize(\n        credentials\n      );\n\n      if (connectionToSecretStorageResult instanceof Error) {\n        return this.setErrorStatus(connectionToSecretStorageResult);\n      }\n      this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.CONNECTED_TO_STORAGE);\n\n      const preloadDataResult = await this.reloadOverallTableData();\n\n      if (preloadDataResult instanceof Error) {\n        return preloadDataResult;\n      }\n\n      const startIntervalResult = this.startInterval();\n\n      if (startIntervalResult instanceof Error) {\n        return this.setErrorStatus(startIntervalResult);\n      }\n      this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.READY);\n      return true;\n    }\n    return false;\n  }\n\n  checkOptionsAreValid(options: ISafeStorageOptions): Error | true {\n    const { name, credentials } = options;\n    const { checkIfNameIsExists } = SafeStorage;\n\n    if (\n      typeof credentials !== 'object' ||\n      !credentials ||\n      !credentials.password\n    ) {\n      return this.setErrorStatus(\n        'SafeStorage: a storage with the name is already exists'\n      );\n    }\n    if (checkIfNameIsExists(name)) {\n      return this.setErrorStatus(\n        'SafeStorage: a storage with the name is already exists'\n      );\n    }\n    return true;\n  }\n\n  setOptions(options: ISafeStorageOptions): Error | true {\n    const { name, dumpIntervalMs, storageType } = options;\n    const checkOptionsResult = this.checkOptionsAreValid(options);\n    const { addStorageName } = SafeStorage;\n    const dumpInterval =\n      typeof dumpIntervalMs === 'number' ? dumpIntervalMs : DEFAULT_INTERVAL_MS;\n    const storageTypeResolved =\n      storageType &&\n      Object.values(ESAFE_STORAGE_STORAGE_TYPE).includes(storageType)\n        ? storageType\n        : ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG;\n\n    if (checkOptionsResult instanceof Error) {\n      return checkOptionsResult;\n    }\n    addStorageName(name);\n    this.options = {\n      ...options,\n      dumpIntervalMs: dumpInterval,\n      storageType: storageTypeResolved,\n    };\n    this.storageType = storageTypeResolved;\n\n    const storageName = `${SAFE_STORAGE_STORAGE_NAME_COMMON_PREFIX}${name}`;\n\n    this.storageName = storageName;\n    this.storageNameAppendLog = `${storageName}${SAFE_STORAGE_STORAGE_APPEND_LOG_COMMON_POSTFIX}`;\n    this.dumpIntervalMs = dumpInterval;\n    return true;\n  }\n\n  /**\n   * load all the data from the secret storage\n   * and put all the data to the memory table\n   */\n  async reloadOverallTableData(): Promise<boolean | Error> {\n    // load data from the storage\n    // and it's append log\n    const tableData = await this.loadOverallTable();\n\n    if (tableData instanceof Error) {\n      return this.setErrorStatus(tableData);\n    }\n    // set all data to the memory table\n    this.setTableData(tableData);\n    return true;\n  }\n\n  /**\n   * disconnect from the secret storage\n   * and dump the data before it\n   */\n  async disconnect(): Promise<Error | true> {\n    const { dumpIntervalRunning } = this;\n\n    if (typeof dumpIntervalRunning === 'number') {\n      clearInterval(dumpIntervalRunning);\n    }\n\n    // dump the data before disconnection\n    const resultDumping = await this.dumpData();\n\n    if (resultDumping === true) {\n      this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.DISCONNECTED);\n      return true;\n    }\n    return this.setErrorStatus(\n      \"Can't dump the table's data before disconnected\"\n    );\n  }\n\n  /**\n   * @returns {boolean} - returns true if the storage is freed\n   * false - on timeout\n   */\n  waitingStorageFreed(): Promise<boolean | undefined> | true {\n    if (!this.isStorageBusy) {\n      return true;\n    }\n\n    return new Promise((res) => {\n      const timeout = setTimeout(\n        res,\n        SAFE_STORAGE_DEFAULT_STORAGE_BUSY_TIMEOUT_MS\n      );\n      const { statusEmitter } = this;\n\n      statusEmitter.once(STATUS_EVENT, () => {\n        if (!this.isStorageBusy) {\n          clearTimeout(timeout);\n          res(true);\n        }\n      });\n    });\n  }\n\n  castDataToAppendLogType(\n    data?: null | TSafeStorageStoredDataType<TYPE>\n  ): TSafeStorageStoredDataTypeAppendLog | Error {\n    if (data == null) {\n      return [] as TSafeStorageStoredDataTypeAppendLog;\n    }\n    if (data instanceof Array) {\n      return data as TSafeStorageStoredDataTypeAppendLog;\n    }\n    return new Error(\n      `There is a wrong data type ${typeof data} for the append log storage`\n    );\n  }\n\n  castDataToKeyValueType(\n    data?: null | TSafeStorageStoredDataType<TYPE>\n  ): TSafeStorageStoredDataTypeKeyValue | Error {\n    if (data == null) {\n      return {} as TSafeStorageStoredDataTypeKeyValue;\n    }\n    if (!(data instanceof Array) && typeof data === 'object') {\n      return data as TSafeStorageStoredDataTypeKeyValue;\n    }\n    return new Error(\n      `There is a wrong data type ${typeof data} for a key value storage`\n    );\n  }\n\n  /**\n   * check if the data given\n   * is conformed to the\n   * storage type and\n   * return an Error if it's\n   * not conformed or data in\n   * storage type\n   * @param data\n   */\n  castDataToStorageType(\n    data?: Error | null | TSafeStorageStoredDataType<TYPE>\n  ): TSafeStorageStoredDataType<TYPE> | Error {\n    if (data instanceof Error) {\n      return data;\n    }\n\n    const { storageType } = this;\n\n    switch (storageType) {\n      case ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG:\n        return this.castDataToAppendLogType(data) as TSafeStorageStoredDataType<\n          TYPE\n        >;\n      default:\n        return this.castDataToKeyValueType(data) as TSafeStorageStoredDataType<\n          TYPE\n        >;\n    }\n  }\n\n  /**\n   * parse a data stringified\n   * before save it to the storage\n   * and read from the secret storage\n   * as a string.\n   * @param {string | Error | undefined} data\n   */\n  parseDataFromStorage<D>(\n    data: string | undefined | Error\n  ): Error | D | undefined {\n    if (data instanceof Error) {\n      return this.setErrorStatus(data);\n    }\n    if (data == null) {\n      return undefined;\n    }\n    try {\n      return JSON.parse(data) as D | undefined;\n    } catch (err) {\n      return err as Error;\n    }\n  }\n\n  /**\n   * merge the data and cast it to the\n   * storage type\n   * returns the merged data\n   * casted to the storage type\n   * @memberof SafeStorage\n   * @param { object | array } result\n   * @param { string | object | array }\n   * @returns { object | array | Error }\n   */\n  mergeData = (\n    result: TSafeStorageStoredDataType<TYPE> | Error,\n    dataToAppend: string | TSafeStorageStoredDataType<TYPE>\n  ): TSafeStorageStoredDataType<TYPE> | Error => {\n    const { storageType } = this;\n    const isAppendLogStorage =\n      storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG;\n\n    if (result instanceof Error) {\n      return result;\n    }\n\n    const dataObj =\n      typeof dataToAppend === 'string'\n        ? this.parseDataFromStorage(dataToAppend)\n        : dataToAppend;\n    const dataCastedToStorageType = this.castDataToStorageType(\n      dataObj as Error | TSafeStorageStoredDataType<TYPE>\n    );\n    if (dataCastedToStorageType instanceof Error) {\n      return this.setErrorStatus(dataCastedToStorageType);\n    }\n    return (isAppendLogStorage\n      ? [\n          ...(result as TSafeStorageStoredDataTypeAppendLog),\n          ...(dataCastedToStorageType as TSafeStorageStoredDataTypeAppendLog),\n        ]\n      : {\n          ...(result as TSafeStorageStoredDataTypeKeyValue),\n          ...(dataCastedToStorageType as TSafeStorageStoredDataTypeKeyValue),\n        }) as TSafeStorageStoredDataType<TYPE>;\n  };\n\n  /**\n   * load a data from the key\n   * named as storage name param\n   * of the secret storage connected\n   * to and return this data\n   * @param {string} storageName\n   */\n  async loadDataFromTable<D>(\n    storageName: string\n  ): Promise<D | undefined | Error> {\n    const { secretStorageConnection } = this;\n\n    if (await this.waitingStorageFreed()) {\n      const setPreviousStatus = this.setStatus(\n        ESAFE_STORAGE_PROVIDER_STATUS.WORKING_WITH_STORAGE\n      );\n      const data = await (secretStorageConnection as SecretStorage).get(\n        storageName\n      );\n\n      setPreviousStatus();\n\n      const parsedDate = this.parseDataFromStorage(data || undefined);\n\n      if (parsedDate instanceof Error) {\n        return this.setErrorStatus(parsedDate);\n      }\n      return parsedDate as D | undefined;\n    }\n    return new Error(`The storage is too busy`);\n  }\n\n  /**\n   * load data from append log key\n   * of the secret storage connected to\n   */\n  loadDataFromStorageAppendLog(): Promise<\n    TSafeStorageStorageAppendLogDataType | undefined | Error\n  > {\n    const { storageNameAppendLog } = this;\n\n    return this.loadDataFromTable<TSafeStorageStorageAppendLogDataType>(\n      storageNameAppendLog\n    );\n  }\n\n  /**\n   * load data from the append log key\n   * of the secret storage connected to\n   * parse it as an array of data append\n   * and return in a type of the storage:\n   * 1) array for an APPEND LOG type storage\n   * 2) object for an KEY VALUE type storage\n   */\n  async loadAndParseDataFromAppendLogStorage(): Promise<\n    TSafeStorageStoredDataType<TYPE> | undefined | Error\n  > {\n    const tableAppendlogsArray = await this.loadDataFromStorageAppendLog();\n    if (tableAppendlogsArray instanceof Error) {\n      return tableAppendlogsArray;\n    }\n    if (tableAppendlogsArray == null) {\n      return undefined;\n    }\n    if (tableAppendlogsArray instanceof Array) {\n      return tableAppendlogsArray\n        .map((str) => (typeof str === 'string' ? decodeURIComponent(str) : str))\n        .reduce(\n          this.mergeData,\n          this.castDataToStorageType(undefined) as TSafeStorageStoredDataType<\n            TYPE\n          >\n        );\n    }\n  }\n\n  loadDataFromMainStorage(): Promise<\n    TSafeStorageStoredDataType<TYPE> | undefined | Error\n  > {\n    const { storageName } = this;\n\n    return this.loadDataFromTable<TSafeStorageStoredDataType<TYPE>>(\n      storageName\n    );\n  }\n\n  /**\n   * loads a data from the main storage\n   * and the append log\n   * and merge it\n   */\n  async loadOverallData(): Promise<TSafeStorageStoredDataType<TYPE> | Error> {\n    const storageMainTableData = this.castDataToStorageType(\n      await this.loadDataFromMainStorage()\n    );\n    if (storageMainTableData instanceof Error) {\n      return this.setErrorStatus(storageMainTableData);\n    }\n\n    const storageDataFromAppendLogTable = this.castDataToStorageType(\n      await this.loadAndParseDataFromAppendLogStorage()\n    );\n    if (storageDataFromAppendLogTable instanceof Error) {\n      return this.setErrorStatus(storageDataFromAppendLogTable);\n    }\n    return this.mergeData(storageMainTableData, storageDataFromAppendLogTable);\n  }\n\n  /**\n   * save a data to the secret storage\n   * to the key with name\n   * storageName\n   * @param {string} storageName\n   * @param {string | null | undefined} dataStringified\n   */\n  async saveDataToStorage(\n    storageName: string,\n    dataStringified?: string | null\n  ): Promise<boolean | Error> {\n    const { secretStorageConnection, status } = this;\n\n    if (dataStringified !== null && typeof dataStringified !== 'string') {\n      const err = new Error(\n        `The table overall data must be null or string, but ${typeof dataStringified} was given`\n      );\n\n      console.error(err);\n      return err;\n    }\n\n    let attempt = 0;\n\n    if (await this.waitingStorageFreed()) {\n      const setPrevStatus = this.setStatus(\n        ESAFE_STORAGE_PROVIDER_STATUS.WORKING_WITH_STORAGE\n      );\n\n      while ((attempt += 1) < SAFE_STORAGE_ATTEMPTS_TO_SAVE_DATA_TO_STORAGE) {\n        if (\n          !(\n            (secretStorageConnection as InstanceType<typeof SecretStorage>).set(\n              storageName,\n              dataStringified || ''\n            ) instanceof Error\n          )\n        ) {\n          setPrevStatus();\n          return true;\n        }\n      }\n      setPrevStatus();\n      return new Error(`Can't save the data to the storage ${storageName}`);\n    }\n    return new Error(`The storage is too busy`);\n  }\n\n  /**\n   * stringify data for the\n   * storage\n   * @param dataAppendLog\n   * @returns {Error | string | false} - sating -stringified data, falser - no data, Error - an error has occurred\n   */\n  async stringifyDataForStorage(\n    dataAppendLog: TSafeStorageDataType[] | TSafeStorageStoredDataTypeKeyValue\n  ): Promise<string | null | Error> {\n    if (this.checkIfEmptyData(dataAppendLog)) {\n      return null;\n    }\n\n    try {\n      return JSON.stringify(dataAppendLog);\n    } catch (err) {\n      return this.setErrorStatus(err);\n    }\n  }\n\n  async writeOverallDataToMainTable(\n    data?:\n      | string\n      | null\n      | TSafeStorageDataType[]\n      | TSafeStorageStoredDataTypeKeyValue\n  ): Promise<boolean | Error> {\n    const { storageName } = this;\n    let dataStringified;\n    if (data && typeof data === 'object') {\n      dataStringified = await this.stringifyDataForStorage(data);\n    } else if (data && typeof data === 'string') {\n      dataStringified = data;\n    } else if (data) {\n      return new Error(\n        'Only an object data can be write to the main table key of the secret storage'\n      );\n    }\n    if (dataStringified instanceof Error) {\n      return dataStringified;\n    }\n    return this.saveDataToStorage(storageName, dataStringified);\n  }\n\n  /**\n   * write the data to the secret storage's\n   * key used as append log data for the\n   * main storage key\n   * @param [string[]] [undefined] data\n   */\n  async writeDataToStorageAppengLog(\n    data?: string | null | TSafeStorageStorageAppendLogDataType\n  ): Promise<Error | boolean> {\n    const { storageNameAppendLog } = this;\n    let dataStringified;\n    if (data && data instanceof Array) {\n      dataStringified = await this.stringifyDataForStorage(data);\n    } else if (data && typeof data === 'string') {\n      dataStringified = data;\n    } else if (data) {\n      return new Error(\n        'Only an array data can be write to the append log key of the secret storage'\n      );\n    }\n    if (dataStringified instanceof Error) {\n      return dataStringified;\n    }\n    return this.saveDataToStorage(storageNameAppendLog, dataStringified);\n  }\n\n  async clearAppendLogData(): Promise<boolean | Error> {\n    const { storageNameAppendLog } = this;\n\n    return this.saveDataToStorage(storageNameAppendLog, null);\n  }\n\n  async loadOverallTable(): Promise<TSafeStorageStoredDataType<TYPE> | Error> {\n    /**\n     * read data from the main storage table\n     * and storage append log table\n     * merge it\n     */\n    const overallData = await this.loadOverallData();\n    if (overallData instanceof Error) {\n      return this.setErrorStatus(overallData);\n    }\n\n    /*\n      save data from the main storage and \n      append log storage to the main storage\n      table\n    */\n    const resultSaveDataToMainStorage = await this.writeOverallDataToMainTable(\n      overallData\n    );\n    if (resultSaveDataToMainStorage instanceof Error) {\n      this.setErrorStatus(resultSaveDataToMainStorage);\n      // if an error is occurred while writing\n      // an overall data on the main storage\n      // set an error and return overall data\n      // without clearing the storage append\n      // log table\n      return overallData;\n    }\n\n    const resultClearStorageAppendLogData = await this.clearAppendLogData();\n    if (resultClearStorageAppendLogData instanceof Error) {\n      // if an error occurred while clearing the\n      // storage append log table\n      // return an error occurred as the\n      // result\n      return this.setErrorStatus(resultClearStorageAppendLogData);\n    }\n    return overallData;\n  }\n\n  setTableData(tableData?: TSafeStorageStoredDataType<TYPE>) {\n    const { storageType } = this;\n\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG) {\n      this.tableData = (tableData ||\n        SAFE_STORAGE_APPEND_LOG_INITIAL_VALUE) as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n      >;\n      this.appendData = SAFE_STORAGE_APPEND_LOG_APPEND_DATA_INITIAL_VALUE as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n      >;\n    } else {\n      this.tableData = (tableData ||\n        SAFE_STORAGE_KEY_VALUE_INITIAL_VALUE) as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n      >;\n      this.appendData = SAFE_STORAGE_KEY_VALUE_APPEND_DATA_INITIAL_VALUE as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n      >;\n    }\n  }\n\n  createSecretStorageInstance(): Error | SecretStorage {\n    const { secretStorageOptions } = this;\n    try {\n      const connectionToTheSecretStorage = new SecretStorage(\n        secretStorageOptions\n      );\n\n      this.secretStorageConnection = connectionToTheSecretStorage;\n      return connectionToTheSecretStorage;\n    } catch (err) {\n      return this.setErrorStatus(err);\n    }\n  }\n\n  startInterval(): boolean | Error {\n    const { dumpIntervalMs } = this;\n\n    try {\n      this.dumpIntervalRunning = setInterval(this.dumpData, dumpIntervalMs);\n      return true;\n    } catch (err) {\n      return this.setErrorStatus(err);\n    }\n  }\n\n  checkIfEmptyData(\n    data: TSafeStorageStoredDataType<\n      | ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n      | ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n    >\n  ): boolean {\n    if (data instanceof Array && !data.length) {\n      return true;\n    }\n    if (typeof data === 'object' && !Object.keys(data).length) {\n      return true;\n    }\n    return false;\n  }\n\n  async writeDump(\n    data:\n      | TSafeStorageStoredDataTypeAppendLog\n      | TSafeStorageStoredDataTypeKeyValue\n  ): Promise<Error | boolean> {\n    if (this.checkIfEmptyData(data)) {\n      return true;\n    }\n    let dataStringified: string;\n\n    try {\n      dataStringified = JSON.stringify(data);\n    } catch (err) {\n      return this.setErrorStatus(err);\n    }\n    return this.writeDataToStorageAppengLog(dataStringified);\n  }\n\n  async dumpAllStorageTypes(): Promise<Error | boolean> {\n    const tableOverallDataDump = await this.loadDataFromStorageAppendLog();\n    if (tableOverallDataDump instanceof Error) {\n      return this.setErrorStatus(tableOverallDataDump);\n    }\n\n    const { appendData } = this;\n    const appendDataString = await this.stringifyDataForStorage(appendData);\n    if (appendDataString instanceof Error) {\n      return this.setErrorStatus(appendDataString);\n    }\n    if (\n      tableOverallDataDump != null &&\n      !(tableOverallDataDump instanceof Array)\n    ) {\n      return this.setErrorStatus('A wrong data type was read from storage');\n    }\n\n    const tableOverallData = [\n      ...(tableOverallDataDump || []),\n      appendDataString,\n    ] as TSafeStorageStoredDataTypeAppendLog;\n    return this.writeDump(tableOverallData);\n  }\n\n  async dumpDataAppendLog(): Promise<Error | true> {\n    const writeDumpResult = await this.dumpAllStorageTypes();\n\n    if (writeDumpResult instanceof Error) {\n      const { appendData } = this;\n\n      this.appendData = [\n        ...(appendData as TSafeStorageStoredDataTypeAppendLog),\n        ...(this.appendDataTemp as TSafeStorageStoredDataTypeAppendLog),\n      ];\n      this.appendDataTemp = [];\n      return writeDumpResult;\n    }\n    this.appendData = this.appendDataTemp;\n    this.appendDataTemp = [];\n    return true;\n  }\n\n  async dumpDataKeyValueStorage(): Promise<Error | boolean> {\n    const writeDumpResult = await this.dumpAllStorageTypes();\n\n    if (writeDumpResult instanceof Error) {\n      const { appendData } = this;\n\n      this.appendData = {\n        ...(appendData as TSafeStorageStoredDataType<\n          ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n        >),\n        ...(this.appendDataTemp as TSafeStorageStoredDataType<\n          ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n        >),\n      };\n      this.appendDataTemp = {};\n      return writeDumpResult;\n    }\n    this.appendData = this.appendDataTemp;\n    this.appendDataTemp = {};\n    return true;\n  }\n\n  /**\n   * write the data from the append log\n   * in-memory table to the secret storage\n   * append log table. On error merge data\n   * from in-memory append log and\n   * in-memory temporary append log data,\n   * then clear the in-memory append log data.\n   * On success clear the in-memory\n   * append log data table and copy data\n   * from the temporary append log\n   * to the in-memory append log. And\n   * clear in-memory temporary append log\n   */\n  dumpData = async (): Promise<Error | boolean> => {\n    const { storageType, appendData, status } = this;\n\n    if (this.isStorageBusy) {\n      // if already writing a dump\n      return true;\n    }\n    if (this.checkIfEmptyData(appendData)) {\n      return true;\n    }\n\n    let resultWritingDump;\n\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE) {\n      resultWritingDump = await this.dumpDataKeyValueStorage();\n    } else {\n      resultWritingDump = await this.dumpDataAppendLog();\n    }\n    if (resultWritingDump === true) {\n      // TODO - ??reload all the data from storage\n      // to guarantee the data persistance\n      return true;\n    }\n    return this.setErrorStatus(\n      'An unknown error has occurred while writing the dump of the data to the SecretStorage'\n    );\n  };\n\n  /**\n   * check if too much data in the in-memory\n   * append log storage\n   * If it is, write a data from it\n   * to the secret storage\n   */\n  checkIfMemoryAppendLogOverflow() {\n    const { appendData } = this;\n\n    if (\n      appendData instanceof Array &&\n      appendData.length > SAFE_STORAGE_MAX_ITEMS_APPEND_LOG\n    ) {\n      this.dumpData();\n    }\n  }\n\n  getDataFromAppendLogStorage<D extends TSafeStorageDataTypesAvail>(\n    key: TSafeStorageKeyType\n  ): Error | null | undefined | D {\n    const { tableData } = this;\n    const keyType = typeof key;\n\n    if (keyType !== 'number') {\n      const err = new Error(\n        `For append log storage only a numeric keys are available but ${keyType} type key was given`\n      );\n\n      console.error(err);\n      return err;\n    }\n    return (tableData as TSafeStorageStoredDataTypeAppendLog)[key as number] as\n      | Error\n      | null\n      | undefined\n      | D;\n  }\n\n  getDataFromKeyValueStorage<D extends TSafeStorageDataTypesAvail>(\n    key: TSafeStorageKeyType\n  ): Error | null | undefined | D {\n    const { tableData } = this;\n    const keyType = typeof key;\n\n    if (keyType !== 'string') {\n      const err = new Error(\n        `For append log storage only a string keys are available but ${keyType} type key was given`\n      );\n\n      console.error(err);\n      return err;\n    }\n    return (tableData as TSafeStorageStoredDataTypeKeyValue)[key as string] as\n      | Error\n      | null\n      | undefined\n      | D;\n  }\n\n  /**\n   * get data for the key specified\n   * from the in-memory table\n   * @param key\n   */\n  get<D extends TSafeStorageDataTypesAvail>(\n    key: TSafeStorageKeyType\n  ): Error | undefined | null | D {\n    const { storageType } = this;\n\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG) {\n      return this.getDataFromAppendLogStorage<D>(key);\n    }\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE) {\n      return this.getDataFromKeyValueStorage<D>(key);\n    }\n    const err = new Error('An unknown storage type');\n\n    console.error(err);\n    return err;\n  }\n\n  /**\n   * try to stringify the data\n   * and return true if all is\n   * ok or an Error otherwise\n   * @param data\n   */\n  checkDataIsSafetyForSave(data: any): boolean | Error {\n    try {\n      JSON.stringify(data);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * encode the data to the JSON\n   * format, e.g. Date type\n   * will be normalized to\n   * a stringified date in ISO\n   * @param data\n   */\n  normilizeData(\n    data: TSafeStorageDataTypesAvail | undefined | null\n  ): string | null | undefined {\n    return data != null ? JSON.parse(JSON.stringify(data)) : undefined;\n  }\n\n  async setDataInAppendLogStorage(\n    data: TSafeStorageDataTypesAvail | undefined | null,\n    key?: TSafeStorageKeyType\n  ): Promise<Error | boolean> {\n    if (key && typeof key !== 'number') {\n      const err = new Error(\n        `For append log storage only a numeric keys are available but ${typeof key} type key was given`\n      );\n\n      console.error(err);\n      return err;\n    }\n\n    const { appendData, appendDataTemp, tableData } = this;\n    const tempStorage = this.isStorageBusy ? appendDataTemp : appendData;\n    const stringifiedData = this.normilizeData(data);\n\n    if (!key) {\n      (tempStorage as TSafeStorageStoredDataTypeAppendLog).push(\n        stringifiedData || null\n      );\n      (tableData as TSafeStorageStoredDataTypeAppendLog).push(\n        stringifiedData || null\n      );\n    } else {\n      (tempStorage as TSafeStorageStoredDataTypeAppendLog)[key as number] =\n        stringifiedData || null;\n      (tableData as TSafeStorageStoredDataTypeAppendLog)[key as number] =\n        stringifiedData || null;\n    }\n    return true;\n  }\n\n  /**\n   *\n   * @param data\n   * @param [numbder] key [undefined] - index where\n   * put the data given.\n   * If it's not specified\n   * then set the data given\n   * by the last index\n   */\n  async setDataInKeyValueStorage(\n    data: TSafeStorageDataTypesAvail | undefined | null,\n    key?: TSafeStorageKeyType\n  ): Promise<Error | boolean> {\n    if (typeof key !== 'string') {\n      const err = new Error(\n        `For key value storage only a string keys are available but ${typeof key} type key was given`\n      );\n\n      console.error(err);\n      return err;\n    }\n\n    const { appendData, appendDataTemp, tableData } = this;\n    const tempStorage = this.isStorageBusy ? appendDataTemp : appendData;\n    const stringifiedData = this.normilizeData(data);\n\n    (tableData as TSafeStorageStoredDataTypeKeyValue)[key] =\n      stringifiedData || null;\n    (tempStorage as TSafeStorageStoredDataTypeKeyValue)[key] =\n      stringifiedData || null;\n    return true;\n  }\n\n  /**\n   * set data in the in-memory\n   * table and in-memory append log\n   * table or in-memory temporary\n   * append-log table\n   * if any operations on append log\n   * in-memory table is active.\n   * Also the data set into\n   * the in-memory overall data\n   * table for the key specified\n   * @param data\n   * @param key\n   */\n  async set(\n    data: TSafeStorageDataTypesAvail | undefined | null,\n    key?: TSafeStorageKeyType\n  ): Promise<Error | boolean> {\n    const { storageType } = this;\n\n    const dataSafeResult = this.checkDataIsSafetyForSave(data);\n    if (dataSafeResult instanceof Error) {\n      return dataSafeResult;\n    }\n    this.checkIfMemoryAppendLogOverflow();\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG) {\n      return this.setDataInAppendLogStorage(data, key);\n    }\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE) {\n      return this.setDataInKeyValueStorage(data, key);\n    }\n\n    const err = new Error('An unknown storage type');\n\n    console.error(err);\n    return err;\n  }\n\n  /**\n   * remove a data by fot a key specified\n   */\n  async remove(key: TSafeStorageKeyType) {\n    if (!key) {\n      return new Error('A key must be specified to remove a data from it');\n    }\n    return this.set(null, key);\n  }\n\n  /**\n   * clear the data in the storage\n   */\n  async clear(): Promise<Error | boolean> {\n    this.appendData = this.castDataToStorageType() as TSafeStorageStoredDataType<\n      TYPE\n    >;\n    this.appendDataTemp = this.castDataToStorageType() as TSafeStorageStoredDataType<\n      TYPE\n    >;\n    this.tableData = this.castDataToStorageType() as TSafeStorageStoredDataType<\n      TYPE\n    >;\n    return this.writeDataToStorageAppengLog(null);\n  }\n}\n","/home/paul/projects/protocol/src/classes/safe-storage-class/safe-storage-class.types.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/index.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/index.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-login/index.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-login/secret-storage-class-utils-login.const.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-login/secret-storage-class-utils-login.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-main/index.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-main/secret-storage-class-utils-main.ts",["2366"],"import { ISecretStoreCredentialsCryptoKey } from './../../secret-storage-class.types';\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const checkIsStorageProviderInstance = (\n  storageProviderInstance: any\n): Error | boolean => {\n  if (!storageProviderInstance || typeof storageProviderInstance !== 'object') {\n    return new Error('Storage provider must be an object');\n  }\n\n  const { connect, get, set, disconnect } = storageProviderInstance;\n\n  if (\n    typeof connect !== 'function' ||\n    typeof get !== 'function' ||\n    typeof set !== 'function' ||\n    typeof disconnect !== 'function'\n  ) {\n    return new Error(\n      'The instance has a wrong implemntation of a StorageProvider interface'\n    );\n  }\n  return true;\n};\n\nexport const validateCryptoKeyCredentials = (\n  credentials?: ISecretStoreCredentialsCryptoKey\n): void | Error => {\n  if (!credentials) {\n    return new Error(\n      'validateCryptoKeyCredentials::Credentials must not be empty'\n    );\n  }\n  if (typeof credentials !== 'object') {\n    return new Error(\n      'validateCryptoKeyCredentials::Credentials must be an object'\n    );\n  }\n\n  const { key } = credentials;\n\n  if (!key) {\n    return new Error(\n      'validateCryptoKeyCredentials::A Key must be provided to authorize'\n    );\n  }\n  if (key instanceof CryptoKey) {\n    return;\n  }\n  return new Error(\n    'validateCryptoKeyCredentials::A Key must be ab instance of CryptoKey'\n  );\n};\n","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-password/index.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-password/secret-storage-class-utils-password.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class.const.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class.ts",["2367","2368","2369","2370","2371"],"import {\n  ISecretStoreConfiguration,\n  ISecretStorageSessionInfo,\n  ISecretStorageSessionInfoStored,\n  ISecretStoreCredentialsSession,\n} from 'classes/secret-storage-class/secret-storage-class.types';\nimport { ownValueOf } from 'types/helper.types';\nimport {\n  importPasswordKey,\n  exportPasswordKeyAsString,\n  importPasswordKeyFromString,\n  exportPasswordKey,\n} from 'utils/password-utils/derive-key.password-utils';\nimport { TPASSWORD_ENCRYPTION_KEY_IMPORT_NATIVE_SUPPORTED_TYPES } from 'utils/password-utils/password-utils.types';\nimport {\n  decryptDataWithKey,\n  decryptDataWithKeyFromUint8Array,\n} from 'utils/password-utils/decrypt.password-utils';\nimport {\n  encryptDataToString,\n  encryptDataToUInt8Array,\n} from 'utils/password-utils/encrypt.password-utils';\nimport { getStatusClass } from 'classes/basic-classes/status-class-base/status-class-base';\nimport {\n  STORAGE_PROVIDERS,\n  STORAGE_PROVIDERS_NAME,\n  STORAGE_PROVIDERS_NAMES,\n} from 'classes/storage-providers/storage-providers.const';\nimport { SecretStorageProviderLocalStorage } from 'classes/storage-providers/storage-local-storage-provider/secret-storage-local-storage-provider';\nimport { calcCryptoKeyHash } from './../../utils/encryption-keys-utils/encryption-keys-utils';\nimport {\n  checkIsStorageProviderInstance,\n  validateCryptoKeyCredentials,\n} from './secret-storage-class-utils/secret-storage-class-utils-main/secret-storage-class-utils-main';\nimport {\n  decryptValueByLogin,\n  encryptValueByLogin,\n} from './secret-storage-class-utils/secret-storage-class-utils-login/secret-storage-class-utils-login';\nimport {\n  generatePasswordKeyByPasswordSalt,\n  generateSaltForPassword,\n} from './secret-storage-class-utils/secret-storage-class-utils-password/secret-storage-class-utils-password';\nimport {\n  TInstanceofStorageProvider,\n  IStorageProvider,\n  ISecretStoreCredentials,\n  ISecretStorage,\n  ISecretStoreCredentialsCryptoKey,\n} from './secret-storage-class.types';\nimport {\n  SECRET_STORAGE_STATUS,\n  SECRET_STORAGE_PASSWORD_MIN_LENGTH,\n  SECRET_STORAGE_SESSION_KEY,\n} from './secret-storage-class.const';\nimport { getLoginHash } from './secret-storage-class-utils/secret-storage-class-utils-login';\nimport {\n  SECRET_STORAGE_LOGIN_MIN_LENGTH,\n  SECRET_STORAGE_UNSET_MAX_ATTEMPTS,\n} from './secret-storage-class.const';\nimport { IStorageProviderOptions } from 'classes/storage-providers/storage-providers.types';\nimport { ISensitiveDataSessionStorage } from 'classes/sensitive-data-session-storage/sensitive-data-session-storage.types';\nimport { isCryptoKeyDataEncryption } from '../../utils/encryption-keys-utils/encryption-keys-utils';\nimport { TSecretStorageAuthorizeCredentials } from './secret-storage-class.types';\n\n/**\n * this classed used to store value in a\n * persistent storage locally on client side\n * in encrypted format. Each key for a value is unique\n * for the user which is authorized withing database.\n * Therefore another user authorized can't to unset values\n * which were set before by another user.\n *\n * @export\n * @class SecretStorage\n * @extends {getStatusClass<typeof SECRET_STORAGE_STATUS>({\n *     errorStatus: SECRET_STORAGE_STATUS.ERROR,\n *     instanceName: 'SecretStorage',\n *   })}\n * @implements {ISecretStorage}\n */\nexport class SecretStorage\n  extends getStatusClass<typeof SECRET_STORAGE_STATUS>({\n    errorStatus: SECRET_STORAGE_STATUS.ERROR,\n    instanceName: 'SecretStorage',\n  })\n  implements ISecretStorage {\n  private static AuthStorageProvider: IStorageProvider =\n    STORAGE_PROVIDERS[STORAGE_PROVIDERS_NAME.SESSION_STORAGE];\n\n  private static PREFIX_KEY_IN_SECRET_STORAGE = '__SecretStorage__';\n\n  private static PREFIX_FOR_SALT_VALUE = '__SecretStorage__s_uk';\n\n  public static validatePassword(password: any) {\n    if (typeof password !== 'string') {\n      return new Error(\n        'validateCredentials::A password string must be provided to authorize'\n      );\n    }\n    if (!password) {\n      return new Error(\n        'validateCredentials::A password non-empty string must be provided to authorize'\n      );\n    }\n    if (password.length < SECRET_STORAGE_PASSWORD_MIN_LENGTH) {\n      return new Error(\n        `validateCredentials::The password string must be a ${SECRET_STORAGE_PASSWORD_MIN_LENGTH} characters ar least`\n      );\n    }\n  }\n\n  public static validateLogin(login: any) {\n    if (typeof login !== 'string') {\n      return new Error(\n        'validateCredentials::A login string must be provided to authorize'\n      );\n    }\n    if (!login) {\n      return new Error(\n        'validateCredentials::A login non-empty string must be provided to authorize'\n      );\n    }\n    if (login.length < SECRET_STORAGE_LOGIN_MIN_LENGTH) {\n      return new Error(\n        `validateCredentials::The login string must be a ${SECRET_STORAGE_LOGIN_MIN_LENGTH} characters ar least`\n      );\n    }\n  }\n\n  public static validateCredentials(\n    credentials?: ISecretStoreCredentials\n  ): void | Error {\n    if (!credentials) {\n      return new Error('validateCredentials::Credentials must not be empty');\n    }\n    if (typeof credentials !== 'object') {\n      return new Error('validateCredentials::Credentials must be an object');\n    }\n    return (\n      SecretStorage.validateLogin(credentials.login) ??\n      SecretStorage.validatePassword(credentials.password)\n    );\n  }\n\n  private static async saltKey(credentials: ISecretStoreCredentials) {\n    const loginHash = await getLoginHash(credentials.login);\n\n    if (loginHash instanceof Error) {\n      console.error(loginHash);\n      return new Error('Failed to calculate hash by a login string');\n    }\n    return `${SecretStorage.PREFIX_FOR_SALT_VALUE}__${loginHash}`;\n  }\n\n  private keyHash: string = '';\n\n  private k?: CryptoKey;\n\n  private storageProvider?: TInstanceofStorageProvider;\n\n  /**\n   * check whether the storage provider\n   * is support operations on\n   * UInt8Array values\n   *\n   * @private\n   * @type {boolean}\n   * @memberof SecretStorage\n   */\n  private isStorageProviderSupportUInt8Array: boolean = false;\n\n  private authStorageProvider?: TInstanceofStorageProvider;\n\n  private storageProviderName?: ownValueOf<typeof STORAGE_PROVIDERS_NAME>;\n\n  /**\n   * options for the instance\n   *\n   * @private\n   * @type {IStorageProviderOptions}\n   * @memberof SecretStorage\n   */\n  private options?: IStorageProviderOptions;\n\n  /**\n   * name of the database\n   *\n   * @private\n   * @type {string}\n   * @memberof SecretStorage\n   */\n  private dbName?: string;\n\n  /**\n   * Hash of the user login will be used as the prefix for the key\n   *\n   * @private\n   * @type {string}\n   * @memberof SecretStorage\n   */\n  private userHash?: string;\n\n  /**\n   * returns true if connected succesfully to\n   * a storage and have a vaild crypto key\n   */\n  protected get isRunning() {\n    const { status } = this;\n\n    return status === SECRET_STORAGE_STATUS.RUNNING;\n  }\n\n  public get isActive() {\n    return !!this.isRunning;\n  }\n\n  /**\n   * @param {object} configuration\n   * @param {strig} [SECRET_STORAGE_PROVIDERS_NAME.LOCAL_STORAGE] configuration.storageProviderName\n   * - provider name use to store a secret data\n   */\n  constructor(\n    protected configuration: Partial<ISecretStoreConfiguration> = {}\n  ) {\n    super();\n  }\n\n  public connect = async (\n    options?: IStorageProviderOptions\n  ): Promise<boolean | Error> => {\n    this.clearState();\n    this.setStatus(SECRET_STORAGE_STATUS.CONNECTING);\n    this.setOptions(options);\n\n    const resultRunAuthProvider = await this.runAuthStorageProvider();\n\n    if (resultRunAuthProvider instanceof Error) {\n      this.setErrorStatus(resultRunAuthProvider);\n      return resultRunAuthProvider;\n    }\n\n    const isStorageProviderStarted = await this.runStorageProvider();\n\n    if (isStorageProviderStarted instanceof Error) {\n      this.setErrorStatus(isStorageProviderStarted);\n      return isStorageProviderStarted;\n    }\n    this.setStatus(SECRET_STORAGE_STATUS.RUNNING);\n    return true;\n  };\n\n  public async disconnect(): Promise<boolean | Error> {\n    const resultDisconnectFromStorageProvider = await this.storageProviderDisconnect();\n\n    if (resultDisconnectFromStorageProvider instanceof Error) {\n      console.error(resultDisconnectFromStorageProvider);\n      return new Error('Failed to disconnect from the storage provider');\n    }\n    this.reset();\n    this.setStatus(SECRET_STORAGE_STATUS.STOPPED);\n    return true;\n  }\n\n  /**\n   * generate a new crypto key with salt provided\n   *\n   * @param {ISecretStoreCredentials} credentials\n   * @returns {(Promise<CryptoKey | Error>)}\n   * @memberof SecretStorage\n   */\n  public async generateCryptoKey(\n    credentialsOrSession:\n      | ISecretStoreCredentials\n      | ISecretStoreCredentialsSession\n  ): Promise<CryptoKey | Error> {\n    const session = (credentialsOrSession as ISecretStoreCredentialsSession)\n      .session;\n    if (session) {\n      const sessionInfo = await this.readLoginAndKeyFromSession(session);\n\n      if (sessionInfo && !(sessionInfo instanceof Error) && sessionInfo.key) {\n        return sessionInfo.key;\n      }\n    }\n\n    const credentials = credentialsOrSession as ISecretStoreCredentials;\n    const credentialsValidationResult = SecretStorage.validateCredentials(\n      credentials\n    );\n\n    if (credentialsValidationResult instanceof Error) {\n      this.setErrorStatus(credentialsValidationResult);\n      return credentialsValidationResult;\n    }\n\n    const salt = await this.getSaltValue(credentials);\n\n    if (salt instanceof Error) {\n      this.setErrorStatus(salt);\n      return new Error('Failed to generate salt value');\n    }\n\n    const cryptoKey = await generatePasswordKeyByPasswordSalt(\n      credentials.password,\n      salt\n    );\n\n    if (cryptoKey instanceof Error) {\n      this.setErrorStatus(cryptoKey);\n      return cryptoKey;\n    }\n    return cryptoKey;\n  }\n\n  public async authorize(\n    credentials: TSecretStorageAuthorizeCredentials,\n    options?: IStorageProviderOptions\n  ): Promise<boolean | Error> {\n    const credentialsWithKey = credentials as ISecretStoreCredentialsCryptoKey;\n\n    if (\n      credentialsWithKey.key &&\n      isCryptoKeyDataEncryption(credentialsWithKey.key) &&\n      isCryptoKeyDataEncryption(credentialsWithKey.key)\n    ) {\n      return this.authorizeByKey(credentialsWithKey, options);\n    }\n\n    const credentialsWithSession = credentials as ISecretStoreCredentialsSession;\n\n    if (credentialsWithSession && credentialsWithSession.session) {\n      const sessionInfo = await this.readLoginAndKeyFromSession(\n        credentialsWithSession.session\n      );\n\n      if (sessionInfo && !(sessionInfo instanceof Error)) {\n        return this.authorizeByKey(\n          {\n            key: sessionInfo.key,\n          },\n          options\n        );\n      }\n    }\n\n    const cred = credentials as ISecretStoreCredentials;\n    const cryptoKey = await this.generateCryptoKey(cred);\n\n    if (cryptoKey instanceof Error) {\n      console.error(cryptoKey);\n      return new Error('Failed to generate a crypto key to encrypt local data');\n    }\n\n    const resultRunAuthProvider = await this.runAuthStorageProvider();\n\n    if (resultRunAuthProvider instanceof Error) {\n      this.setErrorStatus(resultRunAuthProvider);\n      return resultRunAuthProvider;\n    }\n\n    const setKeyResult = await this.setEncryptionKey(cryptoKey);\n\n    if (setKeyResult instanceof Error) {\n      this.setErrorStatus(setKeyResult);\n      return setKeyResult;\n    }\n    if (credentialsWithSession.session) {\n      await this.saveLoginAndKeyToSession(\n        credentialsWithSession.session,\n        cred.login,\n        cryptoKey\n      );\n    }\n    return this.connect(options);\n  }\n\n  public async authorizeByKey(\n    credentials: ISecretStoreCredentialsCryptoKey,\n    options?: IStorageProviderOptions\n  ): Promise<boolean | Error> {\n    const credentialsValidationResult = validateCryptoKeyCredentials(\n      credentials\n    );\n\n    if (credentialsValidationResult instanceof Error) {\n      this.setErrorStatus(credentialsValidationResult);\n      return credentialsValidationResult;\n    }\n\n    const { key: cryptoKey } = credentials;\n    const resultRunAuthProvider = await this.runAuthStorageProvider();\n\n    if (resultRunAuthProvider instanceof Error) {\n      this.setErrorStatus(resultRunAuthProvider);\n      return resultRunAuthProvider;\n    }\n\n    const setKeyResult = await this.setEncryptionKey(cryptoKey);\n\n    if (setKeyResult instanceof Error) {\n      this.setErrorStatus(setKeyResult);\n      return setKeyResult;\n    }\n    return this.connect(options);\n  }\n\n  public has = async (key: string): Promise<boolean | Error> => {\n    const valueEncrypted = await this.readValueForKey(key);\n\n    if (valueEncrypted instanceof Error) {\n      return valueEncrypted;\n    }\n    return this.isValueDefined(valueEncrypted);\n  };\n\n  public get = async (\n    key: string\n  ): Promise<string | Error | undefined | null> => {\n    const valueEncrypted = await this.readValueForKey(key);\n\n    if (!valueEncrypted) {\n      return valueEncrypted;\n    }\n    if (valueEncrypted instanceof Error) {\n      return SecretStorage.error(valueEncrypted);\n    }\n    if (this.isNullishValue(valueEncrypted)) {\n      return null;\n    }\n\n    const decryptResult = await (valueEncrypted instanceof Uint8Array\n      ? this.decryptValueFromUInt8Array(valueEncrypted)\n      : this.decryptValue(valueEncrypted));\n\n    if (decryptResult instanceof Error) {\n      return decryptResult;\n    }\n    return decryptResult || undefined;\n  };\n\n  public async set(\n    keyForValue: string,\n    value: string | null\n  ): Promise<boolean | Error> {\n    let encryptedValue: Uint8Array | Error | string;\n\n    if (!this.isRunning) {\n      return SecretStorage.error(\n        'The instance of SecretStorage is not connected to the storage provider or there is no an encryption key'\n      );\n    }\n    if (value === null) {\n      encryptedValue = this.isStorageProviderSupportUInt8Array\n        ? new Uint8Array()\n        : '';\n    } else {\n      //value - must be an escaped sctring\n      encryptedValue = this.isStorageProviderSupportUInt8Array\n        ? await this.encryptValueAsInt8Array(value)\n        : await this.encryptValue(value);\n    }\n    if (encryptedValue instanceof Error) {\n      return SecretStorage.error(encryptedValue);\n    }\n\n    const key = this.storageKey(keyForValue);\n    const storeValueResult = await (encryptedValue instanceof Uint8Array\n      ? this.setWithStorageProviderUInt8Array(key, encryptedValue)\n      : this.setWithStorageProvider(key, encryptedValue));\n\n    if (storeValueResult instanceof Error) {\n      return SecretStorage.error(storeValueResult);\n    }\n    return storeValueResult;\n  }\n\n  public async insert(\n    keyForValue: string,\n    value: string | null\n  ): Promise<boolean | Error> {\n    if (await this.has(keyForValue)) {\n      return false;\n    }\n    return this.set(keyForValue, value);\n  }\n\n  public async unset(\n    key: string | string[],\n    maxAttempts: number = SECRET_STORAGE_UNSET_MAX_ATTEMPTS\n  ): Promise<Error | void> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let promisePending: Promise<any>[] = [];\n    let attempt = 1;\n    const isKeyString = typeof key === 'string';\n\n    if (key instanceof Array) {\n      promisePending = key.map(this.unsetWithStorageProvider);\n    } else if (isKeyString) {\n      promisePending = [this.unsetWithStorageProvider(key)];\n    } else {\n      return new Error('Key must be a string or an array of strings');\n    }\n    while (promisePending.length && attempt++ < maxAttempts) {\n      const results = await Promise.all(promisePending);\n      const len = results.length;\n      let idx = 0;\n\n      promisePending = [];\n      for (; idx < len; idx++) {\n        if (results[idx] instanceof Error) {\n          promisePending.push(\n            this.unsetWithStorageProvider(\n              isKeyString ? (key as string) : key[idx]\n            )\n          );\n        }\n      }\n    }\n  }\n\n  public async clearDb() {\n    if (!this.isRunning) {\n      return SecretStorage.error(\n        'The instance of SecretStorage is not connected to the storage provider or there is no an encryption key'\n      );\n    }\n    const result = await this.storageProvider?.clearDb();\n\n    if (result instanceof Error) {\n      console.error(result);\n      return SecretStorage.error(\n        'Failed to clear the database with the storage provider'\n      );\n    }\n    return true;\n  }\n\n  private setStorageProviderName(\n    storageProviderName: string = STORAGE_PROVIDERS_NAME.LOCAL_STORAGE\n  ): boolean {\n    if (STORAGE_PROVIDERS_NAMES.includes(storageProviderName)) {\n      this.storageProviderName = storageProviderName;\n      return true;\n    }\n    return false;\n  }\n\n  private createInstanceOfStorageProvider(\n    StorageProviderConstructor: IStorageProvider\n  ): TInstanceofStorageProvider | Error {\n    try {\n      const storageProvider = new StorageProviderConstructor();\n      const checkResult = checkIsStorageProviderInstance(storageProvider);\n\n      if (checkResult instanceof Error) {\n        return checkResult;\n      }\n      return storageProvider;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  private setSupportForUInt8Array(\n    StorageProviderConstructor: IStorageProvider\n  ): void {\n    this.isStorageProviderSupportUInt8Array = !!StorageProviderConstructor.isBufferSupported;\n  }\n\n  private async runAuthStorageProvider(): Promise<boolean | Error> {\n    const { authStorageProvider: runningAuthStorageProvider } = this;\n    const checkIsRunning = checkIsStorageProviderInstance(\n      runningAuthStorageProvider\n    );\n\n    /**\n     * if running already\n     */\n    if (checkIsRunning === true) {\n      return true;\n    }\n\n    const { AuthStorageProvider } = SecretStorage;\n\n    if (!AuthStorageProvider) {\n      return new Error('There is no provider for the auth storage is defined');\n    }\n\n    const authStorageProvider = this.createInstanceOfStorageProvider(\n      AuthStorageProvider\n    );\n\n    if (authStorageProvider instanceof Error) {\n      return authStorageProvider;\n    }\n\n    const { dbName } = this;\n    const connectResult = await authStorageProvider.connect({\n      dbName,\n    });\n\n    if (connectResult instanceof Error) {\n      return connectResult;\n    }\n    if (connectResult !== true) {\n      return new Error(\n        'There is a wrong result was returned by auth storage provider'\n      );\n    }\n    this.authStorageProvider = authStorageProvider;\n    return true;\n  }\n\n  protected async runStorageProvider(): Promise<Error | boolean> {\n    const { configuration } = this;\n\n    if (configuration) {\n      const { storageProviderName } = configuration;\n\n      if (this.setStorageProviderName(storageProviderName)) {\n        const { storageProviderName: storageProviderChosenName } = this;\n\n        if (!storageProviderChosenName) {\n          return new Error('There is no storage provider was choosed');\n        }\n\n        const storageProviderConstructor =\n          STORAGE_PROVIDERS[storageProviderChosenName];\n\n        this.setSupportForUInt8Array(storageProviderConstructor);\n        if (storageProviderConstructor) {\n          const storageProvider = this.createInstanceOfStorageProvider(\n            storageProviderConstructor\n          );\n\n          if (storageProvider instanceof Error) {\n            return storageProvider;\n          }\n\n          const { dbName } = this;\n          const storageProviderIsRunning = await storageProvider.connect({\n            dbName,\n          });\n\n          if (storageProviderIsRunning instanceof Error) {\n            return storageProviderIsRunning;\n          }\n          this.storageProvider = storageProvider;\n          return true;\n        }\n      }\n      throw new Error('Failed to set the name of the storage provider');\n    }\n    throw new Error('There is no storage provider configuration was defined');\n  }\n\n  protected storageKey(key: string) {\n    return `${SecretStorage.PREFIX_KEY_IN_SECRET_STORAGE}_${this.keyHash}_${key}`;\n  }\n\n  protected async setEncryptionKey(\n    key: TPASSWORD_ENCRYPTION_KEY_IMPORT_NATIVE_SUPPORTED_TYPES | CryptoKey\n  ): Promise<boolean | Error> {\n    let k;\n\n    if (key instanceof CryptoKey) {\n      k = key;\n    } else {\n      const importedKey = await importPasswordKey(key);\n\n      if (importedKey instanceof Error) {\n        return importedKey;\n      }\n    }\n    if (!(k instanceof CryptoKey)) {\n      return new Error('Unknown type of the key');\n    }\n\n    const keyString = await exportPasswordKeyAsString(k);\n\n    if (keyString instanceof Error) {\n      return new Error(\"Can't convert the key to exported format\");\n    }\n\n    const keyHash = await calcCryptoKeyHash(k);\n\n    if (keyHash instanceof Error) {\n      console.error(keyHash);\n      return new Error('Failed to calculate hash value for the CryptoKey');\n    }\n    this.k = k;\n    this.keyHash = keyHash;\n    return true;\n  }\n\n  protected setOptions(options?: IStorageProviderOptions): void {\n    if (options && typeof options === 'object') {\n      this.options = options;\n\n      const { dbName } = options;\n\n      if (dbName && typeof dbName === 'string') {\n        this.dbName = dbName;\n      }\n    }\n  }\n\n  protected isNullishValue(value: any): boolean {\n    return (\n      (typeof value === 'string' && value === '') ||\n      (value instanceof Uint8Array && value.byteLength === 0)\n    );\n  }\n\n  protected reset() {\n    this.clearError();\n    this.clearStatus();\n    this.clearState();\n    this.k = undefined;\n    this.authStorageProvider = undefined;\n  }\n\n  protected storageProviderDisconnect = async (): Promise<boolean | Error> => {\n    const { authStorageProvider } = this;\n\n    if (authStorageProvider) {\n      return authStorageProvider.disconnect();\n    }\n    return new Error('There is no Auth storage provider defined');\n  };\n\n  protected async getSaltValue(\n    credentials: ISecretStoreCredentials\n  ): Promise<Error | string> {\n    const key = await SecretStorage.saltKey(credentials);\n\n    if (key instanceof Error) {\n      console.error(key);\n      return new Error('Failed to get key for a salt value');\n    }\n\n    const saltStorageProvider = new SecretStorageProviderLocalStorage();\n    const saltStorageProviderConnectResult = await saltStorageProvider.connect();\n\n    if (saltStorageProviderConnectResult instanceof Error) {\n      console.error(saltStorageProviderConnectResult);\n      return new Error('Failed to connect to the salt storage provider');\n    }\n\n    const saltEncrypted = await saltStorageProvider.get(key);\n\n    if (saltEncrypted instanceof Error) {\n      console.error(saltEncrypted);\n      return new Error('Failed to read salt value');\n    }\n    if (!saltEncrypted) {\n      console.log('A salt value was not found a new one will be generated');\n\n      const newSalt = generateSaltForPassword();\n\n      if (newSalt instanceof Error) {\n        console.error(newSalt);\n        return new Error('Failed to generate a new salt value');\n      }\n\n      const newSaltEncrypted = await encryptValueByLogin(\n        credentials.login,\n        newSalt\n      );\n\n      if (newSaltEncrypted instanceof Error) {\n        console.error(newSaltEncrypted);\n        return new Error('Failed to encrypt the salt value');\n      }\n\n      const saltValueSetInStorageResult = await saltStorageProvider.set(\n        key,\n        newSaltEncrypted\n      );\n\n      if (saltValueSetInStorageResult instanceof Error) {\n        console.error(saltValueSetInStorageResult);\n        return new Error(\n          'Failed to store the salt value in the persistant storage'\n        );\n      }\n      return newSalt;\n    }\n    return decryptValueByLogin(credentials.login, saltEncrypted);\n  }\n\n  protected async getWithStorageProvider(\n    key: string\n  ): Promise<string | Error | undefined> {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error('There is no connection with a storage provider');\n    }\n\n    const value = await storageProvider.get(key);\n\n    if (value instanceof Error) {\n      return SecretStorage.error(value);\n    }\n    if (!value) {\n      return value;\n    }\n    if (typeof value !== 'string' || !value.length) {\n      return SecretStorage.error(\n        'There is a wrong value type returned by the storage provider. A string must be returned'\n      );\n    }\n    return value;\n  }\n\n  protected async getWithStorageProviderUint8Array(\n    key: string\n  ): Promise<Uint8Array | Error | undefined> {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error('There is no connection with a storage provider');\n    }\n\n    if (typeof storageProvider.getUInt8Array !== 'function') {\n      return new Error(\n        'The storage provider which support Uint8Array must provide the method called getUInt8Array'\n      );\n    }\n\n    const value = await storageProvider.getUInt8Array(key);\n\n    if (!value) {\n      return undefined;\n    }\n    if (value instanceof Error) {\n      return SecretStorage.error(value);\n    }\n    if (!(value instanceof Uint8Array) || !value.length) {\n      return SecretStorage.error(\n        'There is a wrong value type returned by the storage provider. An instance of Uint8Array must be returned'\n      );\n    }\n    return value;\n  }\n\n  protected async decryptValue(value: string): Promise<string | Error> {\n    const { k } = this;\n\n    if (!(k instanceof CryptoKey)) {\n      return SecretStorage.error(\n        'There is no a valid key to decrypt the value'\n      );\n    }\n\n    const decryptedValue = await decryptDataWithKey(k, value);\n\n    if (decryptedValue instanceof Error) {\n      return SecretStorage.error(decryptedValue);\n    }\n    if (typeof decryptedValue !== 'string') {\n      return SecretStorage.error('A wrong value decrypted');\n    }\n    return decryptedValue;\n  }\n\n  protected async decryptValueFromUInt8Array(\n    value: Uint8Array\n  ): Promise<string | Error> {\n    const { k } = this;\n\n    if (!(k instanceof CryptoKey)) {\n      return SecretStorage.error(\n        'There is no a valid key to decrypt the value'\n      );\n    }\n    if (!value.length) {\n      return SecretStorage.error('The value must not be empty');\n    }\n\n    const decryptedValue = await decryptDataWithKeyFromUint8Array(k, value);\n\n    if (decryptedValue instanceof Error) {\n      return SecretStorage.error(decryptedValue);\n    }\n    if (typeof decryptedValue !== 'string') {\n      return SecretStorage.error('A wrong value decrypted');\n    }\n    return decryptedValue;\n  }\n\n  protected async setWithStorageProvider(\n    key: string,\n    value: string\n  ): Promise<boolean | Error> {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error(\n        'There is no an active connection with storage provider'\n      );\n    }\n\n    const result = await storageProvider.set(key, value);\n\n    if (result instanceof Error) {\n      return result;\n    }\n    if (result !== true) {\n      return new Error(\n        'A wrong result on set the value into the storage provider'\n      );\n    }\n    return true;\n  }\n\n  protected unsetWithStorageProvider = async (\n    key: string\n  ): Promise<boolean | Error> => {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error(\n        'There is no an active connection with storage provider'\n      );\n    }\n\n    const result = await storageProvider.set(this.storageKey(key), undefined);\n\n    if (result instanceof Error) {\n      return result;\n    }\n    return true;\n  };\n\n  protected async setWithStorageProviderUInt8Array(\n    key: string,\n    value: Uint8Array\n  ): Promise<boolean | Error> {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error(\n        'There is no an active connection with storage provider'\n      );\n    }\n    if (typeof storageProvider.setUInt8Array !== 'function') {\n      return new Error(\n        \"The storage provider doesn't have the method setUInt8Array\"\n      );\n    }\n\n    const result = await storageProvider.setUInt8Array(key, value);\n\n    if (result instanceof Error) {\n      return result;\n    }\n    if (result !== true) {\n      return new Error(\n        'A wrong result on set the value into the storage provider'\n      );\n    }\n    return true;\n  }\n\n  protected async encryptValue(value: string): Promise<string | Error> {\n    const { k } = this;\n\n    if (!(k instanceof CryptoKey)) {\n      return new Error('There is no key to encrypt the value');\n    }\n\n    const encryptedValue = await encryptDataToString(k, value);\n\n    if (encryptedValue instanceof Error) {\n      return encryptedValue;\n    }\n    if (typeof encryptedValue !== 'string' || !encryptedValue.length) {\n      return new Error('A wrong encryption result for the value');\n    }\n    return encryptedValue;\n  }\n\n  /**\n   * encrypts string to the UInt8Array\n   *\n   * @protected\n   * @param {string} value\n   * @returns {(Promise<Uint8Array | Error>)}\n   * @memberof SecretStorage\n   */\n  protected async encryptValueAsInt8Array(\n    value: string | Uint8Array\n  ): Promise<Uint8Array | Error> {\n    const { k } = this;\n\n    if (!(k instanceof CryptoKey)) {\n      return new Error('There is no key to encrypt the value');\n    }\n\n    const encryptedValue = await encryptDataToUInt8Array(k, value);\n\n    if (encryptedValue instanceof Error) {\n      return encryptedValue;\n    }\n    if (!(encryptedValue instanceof Uint8Array) || !encryptedValue.length) {\n      return new Error('A wrong encryption result for the value');\n    }\n    return encryptedValue;\n  }\n\n  protected async readLoginAndKeyFromSession(\n    session: ISensitiveDataSessionStorage\n  ): Promise<ISecretStorageSessionInfo | Error | undefined> {\n    try {\n      const sessionInfo:\n        | ISecretStorageSessionInfoStored\n        | undefined = await session.getItem(SECRET_STORAGE_SESSION_KEY);\n\n      if (sessionInfo) {\n        const cryptoKey = await importPasswordKeyFromString(sessionInfo.key);\n\n        if (cryptoKey instanceof Error) {\n          return cryptoKey;\n        }\n        return {\n          key: cryptoKey,\n          login: sessionInfo.login,\n        };\n      }\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  protected async saveLoginAndKeyToSession(\n    session: ISensitiveDataSessionStorage,\n    login: string,\n    key: CryptoKey\n  ): Promise<Error | undefined> {\n    const keyExported = await exportPasswordKeyAsString(key);\n\n    if (keyExported instanceof Error) {\n      return keyExported;\n    }\n\n    const sessionInfo: ISecretStorageSessionInfoStored = {\n      login,\n      key: keyExported,\n    };\n\n    try {\n      await session.setItem(SECRET_STORAGE_SESSION_KEY, sessionInfo);\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  protected readValueForKey = async (key: string) => {\n    if (!this.isRunning) {\n      return new Error('There is no connection with storage or not authorized');\n    }\n\n    const k = this.storageKey(key);\n    const { isStorageProviderSupportUInt8Array } = this;\n\n    return isStorageProviderSupportUInt8Array\n      ? this.getWithStorageProviderUint8Array(k)\n      : this.getWithStorageProvider(k);\n  };\n\n  protected isValueDefined(valueEncrypted: any): boolean {\n    if (this.isNullishValue(valueEncrypted)) {\n      return true;\n    }\n    if (!valueEncrypted) {\n      return false;\n    }\n    return true;\n  }\n}\n","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class.types.ts",[],"/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/index.ts",[],"/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/sensitive-data-session-storage.const.ts",[],"/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/sensitive-data-session-storage.ts",["2372","2373"],"import {\n  ISensitiveDataSessionStorage,\n  ISensitiveDataSessionStorageOptions,\n} from './sensitive-data-session-storage.types';\nimport {\n  SENSITIVE_DATA_SESSION_STORAGE_STORAGE_KEY,\n  SENSITIVE_DATA_SESSION_STORAGE_STORAGE_KEY_SALT,\n} from './sensitive-data-session-storage.const';\nimport assert from 'assert';\nimport {\n  generatePasswordKeyByPasswordSalt,\n  generateSaltForPassword,\n} from 'classes/secret-storage-class';\nimport { encryptDataToString, decryptDataByPassword } from 'utils';\n\nexport class SensitiveDataSessionStorage\n  implements ISensitiveDataSessionStorage {\n  protected isConnected: boolean = false;\n\n  protected connectingPromise: undefined | Promise<void> = undefined;\n\n  protected _temp: Record<string, any> = {};\n\n  private _tempStringified: string | undefined = undefined;\n\n  private k?: CryptoKey;\n\n  private storagePrefix: string = '';\n\n  private get storageKeyValue() {\n    return `${this.storagePrefix}//${SENSITIVE_DATA_SESSION_STORAGE_STORAGE_KEY}`;\n  }\n\n  private get storageKeySalt() {\n    return `${this.storagePrefix}//${SENSITIVE_DATA_SESSION_STORAGE_STORAGE_KEY_SALT}`;\n  }\n\n  public async connect(options?: ISensitiveDataSessionStorageOptions) {\n    if (this.isConnected) {\n      return;\n    }\n    if (options) {\n      const { storagePrefix } = options;\n\n      if (storagePrefix) {\n        this.storagePrefix = storagePrefix;\n      }\n    }\n    if (!this.connectingPromise) {\n      this.connectingPromise = this.connectToStorage(options);\n    }\n    await this.connectingPromise;\n  }\n\n  public getItem = async (key: string) => {\n    assert(typeof key === 'string', 'Key must be a string');\n    return this._temp[key];\n  };\n\n  public setItem = async (key: string, v: any) => {\n    assert(typeof key === 'string', 'Key must be a string');\n    if (v == null) {\n      delete this._temp[key];\n    } else {\n      this._temp[key] = v;\n    }\n    this.stringifyTemp();\n  };\n\n  private async connectToStorage(\n    options?: ISensitiveDataSessionStorageOptions\n  ) {\n    let error: Error | undefined;\n    try {\n      let k: CryptoKey | undefined;\n      const pinCode = options?.pinCode;\n\n      try {\n        this._temp = (await this.readFromStorage(pinCode)) ?? {};\n      } catch (err) {\n        error = err;\n      }\n      this.subscribeOnWindowUnload();\n      if (pinCode) {\n        assert(typeof pinCode === 'string', 'Pin code must be a string');\n        const pinCodeNewCryptoKey = await generatePasswordKeyByPasswordSalt(\n          pinCode,\n          this.generateSalt()\n        );\n\n        if (pinCodeNewCryptoKey instanceof Error) {\n          throw pinCodeNewCryptoKey;\n        }\n        k = pinCodeNewCryptoKey;\n      }\n      this.k = k;\n      this.stringifyTemp();\n    } catch (err) {\n      this.reset();\n      console.error(err);\n      throw err;\n    } finally {\n      if (options?.clearStorageAfterConnect !== false) {\n        this.clearValueStorage();\n      }\n      this.isConnected = true;\n    }\n    if (error) {\n      throw error;\n    }\n  }\n\n  private readSalt() {\n    const salt = sessionStorage.getItem(this.storageKeySalt);\n\n    return salt;\n  }\n\n  private generateSalt() {\n    const newSalt = generateSaltForPassword();\n\n    if (typeof newSalt !== 'string') {\n      throw new Error('Failed to generate a salt value');\n    }\n    sessionStorage.setItem(this.storageKeySalt, newSalt);\n    return newSalt;\n  }\n\n  public toString() {\n    return this._tempStringified ?? '';\n  }\n\n  private subscribeOnWindowUnload() {\n    window.addEventListener('beforeunload', () => {\n      const v = this._tempStringified;\n      if (v && typeof v === 'string') {\n        sessionStorage.setItem(this.storageKeyValue, v);\n      }\n    });\n  }\n\n  private async readFromStorage(pinCode?: string) {\n    const v = sessionStorage.getItem(this.storageKeyValue);\n\n    if (!v) {\n      return;\n    }\n    const salt = !!pinCode && this.readSalt();\n    const decrypted =\n      salt && pinCode ? await decryptDataByPassword(pinCode, salt, v) : v;\n\n    if (decrypted instanceof Error) {\n      throw decrypted;\n    }\n    return JSON.parse(decrypted);\n  }\n\n  protected clearSaltStorage() {\n    sessionStorage.removeItem(this.storageKeySalt);\n  }\n\n  protected clearValueStorage() {\n    sessionStorage.removeItem(this.storageKeyValue);\n  }\n\n  protected reset() {\n    this.clearSaltStorage();\n    this.clearValueStorage();\n    this.k = undefined;\n    this._temp = {};\n    this._tempStringified = undefined;\n  }\n\n  private stringifyTemp = async () => {\n    const k = this.k;\n    const v = this._temp;\n    let stringified = undefined as string | undefined;\n\n    if (!Object.keys(v).length) {\n      stringified = undefined;\n    } else if (k) {\n      const encrypted = await encryptDataToString(k, v);\n\n      if (encrypted instanceof Error) {\n        return;\n      }\n      stringified = encrypted;\n    } else {\n      stringified = JSON.stringify(v);\n    }\n    this._tempStringified = stringified;\n  };\n}\n","/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/sensitive-data-session-storage.types.ts",["2374","2375"],"export interface ISensitiveDataSessionStorageOptions {\n  /**\n   * pincode value used to encrypt and decrypt a sensitive information\n   *\n   * @type {string}\n   * @memberof ISensitiveDataSessionStorageOptions\n   */\n  pinCode?: string;\n  storagePrefix?: string;\n  /**\n   * clear values in the session storage\n   * after connection to it.\n   *\n   * @type {boolean}\n   * @memberof ISensitiveDataSessionStorageOptions\n   */\n  clearStorageAfterConnect?: boolean;\n}\n/**\n * used to store data in the session storage.\n * A data may be secured with a pin code value.\n *\n * @export\n * @interface ISensitiveDataSessionStorage\n */\nexport interface ISensitiveDataSessionStorage {\n  /**\n   * connect to the storage\n   *\n   * @param {ISensitiveDataSessionStorageOptions} options\n   * @returns {Promise<void>}\n   * @memberof ISensitiveDataSessionStorage\n   * @throws\n   */\n  connect(options: ISensitiveDataSessionStorageOptions): Promise<void>;\n  /**\n   * add item to the storage\n   *\n   * @param {string} key\n   * @param {*} value\n   * @returns {Promise<void>}\n   * @memberof ISensitiveDataSessionStorage\n   */\n  setItem(key: string, value: any): Promise<void>;\n  getItem(key: string): Promise<any>;\n}\n","/home/paul/projects/protocol/src/classes/storage-providers/index.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-level-js-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-level-js-provider/secret-storage-level-js-provider.const.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-level-js-provider/secret-storage-level-js-provider.ts",["2376","2377","2378","2379"],"import levelup, { LevelUp } from 'levelup';\nimport leveljs from 'level-js';\nimport {\n  StorageProvider,\n  IStorageProviderOptions,\n} from '../storage-providers.types';\nimport { SECRET_STORAGE_LEVELJS_PROVIDER_DEFAULTS_DB_NAME } from './secret-storage-level-js-provider.const';\n\nexport class SecretStorageProviderLevelJS implements StorageProvider {\n  public static isBufferSupported = true;\n\n  private levelStorage?: LevelUp;\n\n  private dbName: string = SECRET_STORAGE_LEVELJS_PROVIDER_DEFAULTS_DB_NAME;\n\n  private options?: IStorageProviderOptions;\n\n  private isDisconnected: boolean = false;\n\n  public async connect(\n    options?: IStorageProviderOptions\n  ): Promise<true | Error> {\n    try {\n      const { isDisconnected } = this;\n\n      if (isDisconnected) {\n        return new Error(\n          'The instance of the SecretStorageProvider was closed before'\n        );\n      }\n\n      this.setOptions(options);\n\n      const res = await this.createInstanceOfLevelDB();\n\n      if (res instanceof Error) {\n        console.error('SecretStorageProviderLevelJS', res);\n        return res;\n      }\n      return true;\n    } catch (err) {\n      console.error('SecretStorageProviderLevelJS', err);\n      return err;\n    }\n  }\n\n  public async disconnect(): Promise<true | Error> {\n    try {\n      const { levelStorage, isDisconnected } = this;\n\n      if (isDisconnected) {\n        return true;\n      }\n      this.setIsDisconnected();\n      if (levelStorage) {\n        await levelStorage.close();\n      }\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n    return true;\n  }\n\n  /**\n   * WARNING! If the value is empty\n   * it will be removed with the leveljs.del\n   *\n   * @param {string} key\n   * @param {string} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public async set(key: string, value?: string): Promise<Error | true> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n\n      if (!levelStorage) {\n        return new Error('There is no storage connected');\n      }\n      if (!value) {\n        return this.unset(key);\n      } else {\n        await levelStorage.put(key, value);\n      }\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async unset(key: string): Promise<Error | true> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n\n      if (!levelStorage) {\n        return new Error('There is no storage connected');\n      }\n      await levelStorage.del(key);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async clearDb(): Promise<Error | boolean> {\n    try {\n      const isDisconnected = this.checkIsReady();\n      const { levelStorage } = this;\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n      if (!levelStorage) {\n        return new Error('There is no connection to the local forage');\n      }\n      if (this.dbName === SECRET_STORAGE_LEVELJS_PROVIDER_DEFAULTS_DB_NAME) {\n        return new Error(\"The DEFAULT database can't be removed\");\n      }\n      if (!(levelStorage as any).clear) {\n        return new Error(\n          'The version of the library does not supports for a db clearing'\n        );\n      }\n      await (levelStorage as any).clear();\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * WARNING! If the value is empty\n   * it will be removed with the leveljs.del\n   *\n   * @param {string} key\n   * @param {string} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public async setUInt8Array(\n    key: string,\n    value?: Uint8Array\n  ): Promise<Error | true> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n\n      if (!levelStorage) {\n        return new Error('There is no storage connected');\n      }\n      if (!value) {\n        return this.unset(key);\n      }\n      await levelStorage.put(key, value);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async get(key: string): Promise<Error | string | undefined> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n      const item = await levelStorage!.get(key, { asBuffer: false });\n\n      if (typeof item !== 'string') {\n        return undefined;\n      }\n      return item;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async getUInt8Array(\n    key: string\n  ): Promise<Error | Uint8Array | undefined> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n      // TODO - the custom patch used to return\n      // Uint8Array instead of Buffer\n      const item = await levelStorage!.get(key, { asBuffer: true });\n\n      return new Uint8Array(item);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected setOptions(options?: IStorageProviderOptions): void {\n    if (options && typeof options === 'object') {\n      this.options = options;\n\n      const { dbName } = options;\n\n      if (dbName && typeof dbName === 'string') {\n        this.dbName = dbName;\n      }\n    }\n  }\n\n  protected setIsDisconnected() {\n    this.isDisconnected = true;\n  }\n\n  protected checkIsReady(): void | Error {\n    const { isDisconnected, levelStorage } = this;\n\n    if (isDisconnected) {\n      return new Error('The StorageProvider instance is disconnected');\n    }\n    if (!levelStorage) {\n      return new Error('There is no storage connected');\n    }\n  }\n\n  protected async createInstanceOfLevelDB(): Promise<void | Error> {\n    const { dbName } = this;\n    const levelStorage = levelup(leveljs(dbName));\n\n    try {\n      await levelStorage.open();\n    } catch (err) {\n      return err;\n    }\n    this.levelStorage = levelStorage;\n  }\n}\n","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-forage-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-local-forage-provider/secret-storage-local-forage-provider.const.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-local-forage-provider/secret-storage-local-forage-provider.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-local-storage-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-local-storage-provider/secret-storage-local-storage-provider.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-providers.const.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-providers.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-providers.types.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-session-storage-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-session-storage-provider/secret-storage-session-storage-provider.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-constructor.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-constructor.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-constructor.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-parser/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-parser/swarm-message-subclass-parser.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-parser/swarm-message-subclass-parser.types.ts",["2380"],"import { ISwarmMessageSubclassValidator } from '../swarm-message-subclass-validators/swarm-message-subclass-validator.types';\nimport { ISwarmMessageUtilsMessageParser } from '../../swarm-message-utils/swarm-message-utils-message-parser/swarm-message-utils-message-parser.types';\nimport { ISwarmMessageUtilsBodyParser } from '../../swarm-message-utils/swarm-message-utils-body-parser';\nimport { IQueuedEncrypyionClassBaseOptions } from '../../../basic-classes/queued-encryption-class-base/queued-encryption-class-base.types';\nimport { ISwarmMessgaeEncryptedCache } from '../../../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport {\n  TSwarmMessageSerialized,\n  TSwarmMessageInstance,\n} from '../../swarm-message-constructor.types';\n\nexport interface ISwarmMessageSubclassParserUtils {\n  messageParser: ISwarmMessageUtilsMessageParser;\n  messageBodyRawParser: ISwarmMessageUtilsBodyParser;\n}\n\nexport interface ISwarmMessageSubclassParserOptions {\n  validator: ISwarmMessageSubclassValidator;\n  utils: ISwarmMessageSubclassParserUtils;\n  queueOptions?: IQueuedEncrypyionClassBaseOptions['queueOptions'];\n  /**\n   * this is a key used to decrypt private messages\n   */\n  decryptionKey?: CryptoKey;\n  /**\n   * if provided, then:\n   * 1) For private messages, before decrypt it's body, parser will try to\n   * read it's body from the cache provided before;\n   * 2) For all messages, parser will try to read sign mark before\n   * validation of a message signature. If there is no mark stored,\n   * then it will be validated.\n   *\n   * @type {ISwarmMessgaeEncryptedCache}\n   * @memberof ISwarmMessageSubclassParserOptions\n   */\n  encryptedCache?: ISwarmMessgaeEncryptedCache;\n}\n\n/**\n * parses and validates swarm message serizlized\n *\n * @export\n * @interface ISwarmMessageSubclassParser\n */\nexport interface ISwarmMessageSubclassParser {\n  /**\n   * deserialize and validate the swarm message\n   *\n   * @param {TSwarmMessageSerialized} message - swarm message serialized\n   * @returns {Promise<ISwarmMessage>}\n   * @memberof ISwarmMessageSubclassParser\n   * @throws\n   */\n  parse(message: TSwarmMessageSerialized): Promise<TSwarmMessageInstance>;\n}\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.types.ts",["2381"],"import { ISwarmMessageSubclassFieldsValidator } from '../swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { ISwarmMessageUtilSignatureGetStringForSignByMessageRaw } from '../../swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.types';\nimport { ICentralAuthority } from '../../../central-authority-class/central-authority-class.types';\nimport { IQueuedEncrypyionClassBaseOptions } from '../../../basic-classes/queued-encryption-class-base/queued-encryption-class-base.types';\nimport { ISwarmMessageUtilsBodySerializer } from '../../swarm-message-utils/swarm-message-utils-body-serializer/swarm-message-utils-body-serializer.types';\nimport { ISwarmMessageUtilsMessageSerializer } from '../../swarm-message-utils/swarm-message-utils-message-serializer/swarm-message-utils-message-serializer.types';\nimport { ISwarmMessageSubclassValidator } from '../swarm-message-subclass-validators/swarm-message-subclass-validator.types';\nimport { TSwarmMessageInstance } from '../../swarm-message-constructor.types';\nimport { TSwarmMessageSignatureAlgorithm } from '../../swarm-message-constructor.types';\nimport { ISwarmMessageBodyDeserialized } from '../../swarm-message-constructor.types';\n\nexport interface ISwarmMessageSerializerUtils {\n  getDataToSignBySwarmMsg: ISwarmMessageUtilSignatureGetStringForSignByMessageRaw;\n  swarmMessageBodySerializer: ISwarmMessageUtilsBodySerializer;\n  swarmMessageSerializer: ISwarmMessageUtilsMessageSerializer;\n}\n\n/**\n * data about the user who will create\n * messages.\n *\n * @export\n * @interface ISwarmMessageSerializerUser\n */\nexport interface ISwarmMessageSerializerUser {\n  /**\n   * identity of the user who will be a creator of\n   * swarm messages.\n   *\n   * @type {TSwarmMessageUserIdentifierSerialized}\n   * @memberof ISwarmMessageSerializerUser\n   */\n  userId: TSwarmMessageUserIdentifierSerialized;\n  /**\n   * A crypto key which will be used for\n   * messages signing.\n   *\n   * @type {CryptoKey}\n   * @memberof ISwarmMessageSerializerUser\n   */\n  dataSignKey: CryptoKey;\n}\n\n/**\n * User for messages creation\n *\n * @export\n * @interface ISwarmMessageSerializerConstructorOptions\n */\nexport interface ISwarmMessageSerializerConstructorOptions {\n  /**\n   * options used for the message signing queue\n   *\n   * @type {Required<IQueuedEncrypyionClassBaseOptions['queueOptions']>}\n   * @memberof ISwarmMessageSerializerConstructorOptions\n   */\n  queueOptions?: Required<IQueuedEncrypyionClassBaseOptions['queueOptions']>;\n  /**\n   * instance implemented connection to the CentralAuthority\n   * to get information described in ISwarmMessageSerializerUser\n   *\n   * @type {ICentralAuthority}\n   * @memberof ISwarmMessageSerializerConstructorOptions\n   */\n  caConnection: ICentralAuthority;\n  /**\n   * utils used for a message signing\n   *\n   * @type {ISwarmMessageSerializerUtils}\n   * @memberof ISwarmMessageSerializerConstructorOptions\n   */\n  utils: ISwarmMessageSerializerUtils;\n  /**\n   * instance of the SwarmMessageFieldsValidator subclass\n   *\n   * @type {ISwarmMessageSubclassFieldsValidator}\n   * @memberof ISwarmMessageSerializerConstructorOptions\n   */\n  messageValidator: ISwarmMessageSubclassValidator;\n  /**\n   * the algorithm used for messages signing\n   *\n   * @type {ESwarmMessageSignatureAlgorithmsDescription}\n   * @memberof ISwarmMessageSerializerConstructorOptions\n   */\n  alg: TSwarmMessageSignatureAlgorithm;\n}\n\n/**\n * this class used for messages serizlization\n * before sending it to the swarm users.\n *\n * @export\n * @interface ISwarmMessageSerializer\n */\nexport interface ISwarmMessageSerializer {\n  /**\n   * serialize the message into a type\n   * which can be used for sending of\n   * a message into the swarm.\n   * If a message's data is not valid\n   * the method throws.\n   *\n   * @param {ISwarmMessageBodyDeserialized} msgBody\n   * @returns {TSwarmMessageSerialized}\n   * @memberof ISwarmMessageSerializer\n   * @throws\n   */\n  serialize(\n    msgBody: ISwarmMessageBodyDeserialized\n  ): Promise<TSwarmMessageInstance>;\n  /**\n   * serialize the message as a private and\n   * encrypt it's body with the key provided.\n   *\n   * @param {ISwarmMessageBodyDeserialized} msgBody\n   * @param {CryptoKey} encryptWithKey - user's public key to encrypt\n   * the message as a private\n   * @returns {Promise<TSwarmMessageInstance>}\n   * @memberof ISwarmMessageSerializer\n   */\n  serialize(\n    msgBody: ISwarmMessageBodyDeserialized,\n    encryptWithKey?: CryptoKey\n  ): Promise<TSwarmMessageInstance>;\n}\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/swarm-message-subclass-validator-fields-validator-body-raw.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/swarm-message-subclass-validator-fields-validator-body-raw.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/swarm-message-subclass-validator-fields-validator-signature.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/swarm-message-subclass-validator-fields-validator-signature.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/swarm-message-subclass-validator-fields-validator-validator-type.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/swarm-message-subclass-validator-fields-validator-validator-type.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator.ts",["2382","2383"],"import assert from 'assert';\nimport {\n  commonUtilsArrayDeleteFromArray,\n  commonUtilsArrayDoCallbackTillNoError,\n} from 'utils/common-utils/common-utils';\nimport { TSwarmMessageUserIdentifierVersion } from '../swarm-message-subclass-validator.types';\nimport { validateIssuerDesirizlizedFormat } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied';\nimport validateIssuerSerializedFormat from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized';\nimport { TSwarmMessageIssuerDeserialized } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied.types';\nimport validateTypeFormat from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/swarm-message-subclass-validator-fields-validator-validator-type';\nimport { validateUserIdentifier } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier';\nimport { createValidatePayload } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload';\nimport { createValidateTimestamp } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp';\nimport { TSwarmMessageType } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/swarm-message-subclass-validator-fields-validator-validator-type.types';\nimport { ISwarmMessagePayloadValidationOptions } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.types';\nimport { ISwarmMessageTimestampValidationOptions } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.types';\nimport { TSwarmMessageUserIdentifierSerialized } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { CA_USER_IDENTITY_VERSIONS_LIST } from '../../../../central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport {\n  TSwarmMessage,\n  TSwarmMessageBodyEncrypted,\n} from '../../../swarm-message-constructor.types';\nimport { validateMessageBodyRawFormat } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/swarm-message-subclass-validator-fields-validator-body-raw';\nimport { validateMessageSignatureFormat } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/swarm-message-subclass-validator-fields-validator-signature';\nimport {\n  IMessageFieldsValidatorOptions,\n  ISwarmMessageSubclassFieldsValidator,\n} from './swarm-message-subclass-validator-fields-validator.types';\nimport {\n  ISwarmMessageBodyDeserialized,\n  ISwarmMessageRaw,\n} from '../../../swarm-message-constructor.types';\nimport {\n  SWARM_MESSAGE_SUBCLASS_VALIDATOR_BODY_ENCRYPTED_MAX_LENGTH_BYTES,\n  SWARM_MESSAGE_SUBCLASS_VALIDATOR_BODY_ENCRYPTED_MIN_LENGTH_BYTES,\n} from '../swarm-message-subclass-validator.const';\n\nexport class SwarmMessageSubclassFieldsValidator\n  implements ISwarmMessageSubclassFieldsValidator {\n  /**\n   * list of a valid issuers.\n   * If it is empty then any issuer will\n   * be considered correct.\n   *\n   * @protected\n   * @static\n   * @type {string[]}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected issuersList: TSwarmMessageIssuerDeserialized[] = [];\n\n  /**\n   * list of a valid user identifier versions.\n   *\n   * @protected\n   * @static\n   * @type {string[]}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected supportedUserIdentifierVer: TSwarmMessageUserIdentifierVersion[] = CA_USER_IDENTITY_VERSIONS_LIST;\n\n  /**\n   * list of a valid message types.\n   * If it is empty then any type will\n   * be considered correct.\n   *\n   * @protected\n   * @static\n   * @type {Array<string | number>}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected typesList: TSwarmMessageType[] = [];\n\n  protected payloadValidationOptions?: ISwarmMessagePayloadValidationOptions;\n\n  protected timestampValidationOptions?: ISwarmMessageTimestampValidationOptions;\n\n  protected validatePayload = createValidatePayload(\n    this.payloadValidationOptions\n  );\n\n  protected validateTimestamp = createValidateTimestamp(\n    this.timestampValidationOptions\n  );\n\n  /**\n   * Creates an instance of SwarmMessageSubclassValidator.\n   * @param {IMessageFieldsValidatorOptions} options\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  constructor(options?: IMessageFieldsValidatorOptions) {\n    this.setOptions(options);\n  }\n\n  /**\n   * validate message's deserialized body object\n   *\n   * @param {ISwarmMessageBodyDeserialized} messageBody\n   * @memberof SwarmMessageSubclassFieldsValidator\n   * @throws\n   */\n  public validateMessageBody(messageBody: ISwarmMessageBodyDeserialized): void {\n    assert(!!messageBody, 'Message body must be defined');\n    assert(typeof messageBody === 'object', 'Message body must be an object');\n    const { iss, pld, ts, typ } = messageBody;\n\n    this.validateType(typ);\n    this.validateIssuer(iss);\n    this.validatePayload(pld);\n    this.validateTimestamp(ts);\n  }\n\n  public validateMessageBodyEncrypted(\n    messsageBodyEncrypted: TSwarmMessageBodyEncrypted\n  ): void {\n    assert(!!messsageBodyEncrypted, 'Message body must be specefied');\n    assert(\n      typeof messsageBodyEncrypted === 'string',\n      'Message body must be a string for a private messages'\n    );\n    assert(\n      messsageBodyEncrypted.length <\n        SWARM_MESSAGE_SUBCLASS_VALIDATOR_BODY_ENCRYPTED_MAX_LENGTH_BYTES,\n      'Private message body is increased the maximum length'\n    );\n    assert(\n      messsageBodyEncrypted.length >\n        SWARM_MESSAGE_SUBCLASS_VALIDATOR_BODY_ENCRYPTED_MIN_LENGTH_BYTES,\n      'Private message body is less then the minimal length'\n    );\n  }\n\n  /**\n   * validate swarm message object\n   * throw an error if the message\n   * is not valid\n   *\n   * @param {TSwarmMessage} message\n   * @memberof SwarmMessageSubclassFieldsValidator\n   * @throws\n   */\n  public validateMessage(message: TSwarmMessage): void {\n    assert(!!message, 'Message must be defined');\n    assert(typeof message === 'object', 'Message must be an object');\n\n    const { bdy, uid, sig, isPrivate } = message;\n\n    validateMessageSignatureFormat(sig);\n    this.validateUserIdentifier(uid);\n    this.validateIsPrivateField(isPrivate);\n    this.validateMessageBody(bdy as ISwarmMessageBodyDeserialized);\n  }\n\n  /**\n   * validate the message's in format\n   * when the body is serizlized\n   *\n   * @param {ISwarmMessageRaw} messageRaw\n   * @memberof SwarmMessageSubclassFieldsValidator\n   */\n  public validateMessageRaw(messageRaw: ISwarmMessageRaw): void {\n    assert(!!messageRaw, 'Message must be defined');\n    assert(typeof messageRaw === 'object', 'Message must be an object');\n\n    const { bdy, uid, sig } = messageRaw;\n\n    validateMessageBodyRawFormat(bdy);\n    validateMessageSignatureFormat(sig);\n    this.validateUserIdentifier(uid);\n  }\n\n  /**\n   * add an issuer string in the list\n   * as a valid issuer.\n   *\n   * @param {string} issuer\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  public addIssuerToValidList = (issuer: string): void => {\n    const { issuersList } = this;\n\n    validateIssuerDesirizlizedFormat(issuer);\n    if (!issuersList.includes(issuer)) {\n      issuersList.push(issuer);\n    }\n  };\n\n  /**\n   * remove an issuer from the list of the\n   * valid issuers. If there is no\n   * issuer in the list returns true.\n   *\n   * @param {string} issuer\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public removeIssuerFromValidList(issuer: string): boolean | Error {\n    const { issuersList } = this;\n\n    if (typeof issuer !== 'string') {\n      return new Error('The issuer must be a string');\n    }\n    commonUtilsArrayDeleteFromArray(issuersList, issuer);\n    return true;\n  }\n\n  /**\n   * checks whether the issuer is in the\n   * list of the valid issuers. If the\n   * list of the valid issuers is empty\n   * then returns true\n   *\n   * @param {string} issuer\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected checkIssuerIsInList(issuer: string): void {\n    const { issuersList } = this;\n\n    assert(\n      !issuersList.length || issuersList.includes(issuer),\n      'The issuer is not into the list of the valid issuers'\n    );\n  }\n\n  protected validateIsPrivateField(isPrivateField?: any) {\n    if (isPrivateField != null) {\n      assert(isPrivateField === true, 'Is private value must be a \"true\"');\n    }\n  }\n\n  /**\n   * validate the Issuer format and\n   * if it is in the list of the valid\n   * issuers\n   *\n   * @param {string} issuer\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected validateIssuer(issuer: string): void {\n    validateIssuerSerializedFormat(issuer);\n    this.checkIssuerIsInList(issuer);\n  }\n\n  /**\n   * add an type string in the list\n   * as a valid types.\n   *\n   * @param {string | number} type\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected addType = (type: TSwarmMessageType): void => {\n    const { typesList } = this;\n\n    validateTypeFormat(type, typesList);\n  };\n\n  /**\n   * remove an issuer from the list of the\n   * valid issuers. If there is no\n   * issuer in the list returns true.\n   *\n   * @param {string | number} type\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected removeType(type: TSwarmMessageType): void {\n    const { typesList } = this;\n\n    commonUtilsArrayDeleteFromArray(typesList, type);\n  }\n\n  /**\n   * Checks whether the list of valid types is defined and not empty.\n   * If it is then checks if the type is into the list.\n   *\n   * @param {string| number} type\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected checkTypeInList(type: TSwarmMessageType): void {\n    const { typesList } = this;\n\n    assert(\n      !typesList.length || typesList.includes(type),\n      'The type is not into the list of the valid types'\n    );\n  }\n\n  /**\n   * check the Type value format and\n   * if the type is in the list of the\n   * valid types\n   *\n   * @param {string | number} type\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected validateType(type: TSwarmMessageType): void {\n    validateTypeFormat(type);\n    this.checkTypeInList(type);\n  }\n\n  protected validateUserIdentifier = (\n    userId: TSwarmMessageUserIdentifierSerialized\n  ): void => {\n    validateUserIdentifier(userId, this.supportedUserIdentifierVer);\n  };\n\n  /**\n   * set the options\n   *\n   * @protected\n   * @param {IMessageFieldsValidatorOptions} options\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected setOptions(options?: IMessageFieldsValidatorOptions) {\n    if (options != null) {\n      assert(typeof options === 'object', 'The options must be an object');\n\n      const {\n        supportedUserIdentifierVer,\n        payloadValidationOptions,\n        issuersList,\n        typesList,\n        timestampValidationOptions,\n      } = options;\n\n      if (timestampValidationOptions) {\n        this.timestampValidationOptions = timestampValidationOptions; // set time to live in milliseconds\n        this.validateTimestamp = createValidateTimestamp(\n          timestampValidationOptions\n        );\n      }\n      if (payloadValidationOptions) {\n        this.payloadValidationOptions = payloadValidationOptions;\n        this.validatePayload = createValidatePayload(payloadValidationOptions);\n      }\n      if (supportedUserIdentifierVer instanceof Array) {\n        this.supportedUserIdentifierVer = supportedUserIdentifierVer.map(\n          (userIdentifierVersion) => {\n            if (typeof userIdentifierVersion === 'string') {\n              return userIdentifierVersion;\n            }\n            assert.fail(\n              `The version ${userIdentifierVersion} must be a string`\n            );\n          }\n        );\n      }\n      if (issuersList) {\n        if (issuersList instanceof Array) {\n          const setIssuersListResult = commonUtilsArrayDoCallbackTillNoError<\n            string\n          >(issuersList, this.addIssuerToValidList);\n\n          if (setIssuersListResult instanceof Error) {\n            assert.fail(setIssuersListResult);\n          }\n        } else {\n          assert.fail('The value of the \"issuersList\" option must be an Array');\n        }\n      }\n      if (typesList) {\n        if (typesList instanceof Array) {\n          const setTypesListResult = commonUtilsArrayDoCallbackTillNoError<\n            TSwarmMessageType\n          >(typesList, this.addType);\n\n          if (setTypesListResult instanceof Error) {\n            throw setTypesListResult;\n          }\n        } else {\n          assert.fail('The value of the \"typesList\" option must be an Array');\n        }\n      }\n    }\n  }\n}\n\nexport default SwarmMessageSubclassFieldsValidator;\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/swarm-message-subclass-validator-signature-validator.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/swarm-message-subclass-validator-signature-validator.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-parser/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-parser/swarm-message-utils-body-parser.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-parser/swarm-message-utils-body-parser.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-serializer/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-serializer/swarm-message-utils-body-serializer.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-serializer/swarm-message-utils-body-serializer.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-parser/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-parser/swarm-message-utils-message-parser.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-parser/swarm-message-utils-message-parser.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-serializer/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-serializer/swarm-message-utils-message-serializer.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-serializer/swarm-message-utils-message-serializer.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.ts",["2384"],"import {\n  ISwarmMessageRaw,\n  TSwarmMessageSignatureAlgorithm,\n} from '../../swarm-message-constructor.types';\nimport { ISwarmMessageUtilSignatureGetStringForSignByMessageRaw } from './swarm-message-utils-signature.types';\nimport { SWARM_MESSAGE_UTIL_SIGNATURE_GET_STRING_FOR_SIGN_BY_MESSAGE_RAW_DELIMETER } from './swarm-message-utils-signature.const';\n\nexport const swarmMessageUtilSignatureGetStringForSignByMessageRaw: ISwarmMessageUtilSignatureGetStringForSignByMessageRaw = (\n  msg: Omit<ISwarmMessageRaw, 'sig'>\n) =>\n  `${msg.alg}${SWARM_MESSAGE_UTIL_SIGNATURE_GET_STRING_FOR_SIGN_BY_MESSAGE_RAW_DELIMETER}${msg.uid}${SWARM_MESSAGE_UTIL_SIGNATURE_GET_STRING_FOR_SIGN_BY_MESSAGE_RAW_DELIMETER}${msg.bdy}`;\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-common/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-common/swarm-message-store-utils-common.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-connector-options-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-connector-options-provider/swarm-message-store-utils-connector-options-provider.ts",["2385","2386","2387"],"import assert from 'assert';\nimport { ESwarmStoreConnector } from '../../../swarm-store-class/swarm-store-class.const';\nimport {\n  ISwarmMessageStoreOptions,\n  TSwarmMessageStoreAccessControlGrantAccessCallback,\n} from '../../swarm-message-store.types';\nimport { TSwarmMessageSerialized } from '../../../swarm-message/swarm-message-constructor.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../../../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { ISwarmStoreConnectorOrbitDBConnectionOptions } from '../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types';\nimport { ipfsUtilsConnectBasic } from '../../../../utils/ipfs-utils/ipfs-utils';\nimport { getMessageValidator } from '../swarm-message-store-utils-common/swarm-message-store-utils-common';\nimport { ISwarmStoreConnectorOrbitDBOptions } from '../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types';\nimport { ISwarmStoreConnectorOrbitDbDatabaseOptions } from '../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { TSwarmStoreValueTypes } from '../../../swarm-store-class/swarm-store-class.types';\nimport { TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback } from '../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.types';\nimport {\n  ISwarmStoreDatabaseBaseOptions,\n  TSwarmStoreDatabaseOptions,\n} from '../../../swarm-store-class/swarm-store-class.types';\n\n/**\n * Add access control options for OrbitDB provided\n * databases.\n *\n * @template T\n * @param {ISwarmMessageStoreOptions<ESwarmStoreConnector.OrbitDB>} options\n * @param {(ISwarmStoreConnectorOrbitDbDatabaseOptions<T> &\n *     ISwarmStoreDatabaseBaseOptions)} dbOptions\n * @param {string[]} [allowAccessForUsers]\n * @param {TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback<ESwarmStoreConnector, T>} [grantAccessCallback]\n * @returns {(TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, T> &\n *   ISwarmStoreDatabaseBaseOptions & { provider: ESwarmStoreConnector.OrbitDB })}\n */\nfunction swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControlOrbitDB<\n  T extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>\n>(\n  options: ISwarmMessageStoreOptions<ESwarmStoreConnector.OrbitDB>,\n  dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<T> &\n    ISwarmStoreDatabaseBaseOptions,\n  allowAccessForUsers?: string[],\n  grantAccessCallback?: TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback<\n    ESwarmStoreConnector,\n    T\n  >\n): TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, T> &\n  ISwarmStoreDatabaseBaseOptions & { provider: ESwarmStoreConnector.OrbitDB } {\n  const grantAccess = getMessageValidator(\n    dbOptions,\n    options.messageConstructors,\n    // TODO - TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback<string, P>\n    (grantAccessCallback || dbOptions.grantAccess) as any,\n    options.userId\n  );\n\n  return {\n    write: allowAccessForUsers,\n    ...dbOptions,\n    grantAccess,\n    provider: ESwarmStoreConnector.OrbitDB,\n  };\n}\n\n/**\n * Return a function which extends a database options with\n * access control\n *\n * @param {ISwarmMessageStoreOptions<ESwarmStoreConnector.OrbitDB>} options\n * @throw\n * @exports\n */\nexport const swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControl = <\n  P extends ESwarmStoreConnector,\n  T extends TSwarmStoreValueTypes<P>\n>(\n  options: ISwarmMessageStoreOptions<P>\n) => (\n  dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<T> &\n    ISwarmStoreDatabaseBaseOptions\n): TSwarmStoreDatabaseOptions<P, T> &\n  ISwarmStoreDatabaseBaseOptions & { provider: P } => {\n  const { accessControl } = options;\n  let grantAccessCallback:\n    | TSwarmMessageStoreAccessControlGrantAccessCallback<P>\n    | undefined;\n  let allowAccessForUsers: TSwarmMessageUserIdentifierSerialized[] | undefined;\n\n  // validate options first\n  if (accessControl) {\n    const { grantAccess, allowAccessFor } = accessControl;\n\n    if (!grantAccess) {\n      throw new Error('\"Grant access\" callback function must be provided');\n    }\n    assert(\n      typeof grantAccess === 'function' && grantAccess.length === 3,\n      '\"Grant access\" callback must be a function which accepts a 3 arguments'\n    );\n    if (allowAccessFor) {\n      assert(\n        allowAccessFor instanceof Array,\n        'Users list for which access is uncinditionally granted for must be a function'\n      );\n      allowAccessFor.forEach((userId) =>\n        assert(typeof userId === 'string', 'The user identity must be a string')\n      );\n      allowAccessForUsers = allowAccessFor;\n    }\n    grantAccessCallback = grantAccess;\n  }\n  return swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControlOrbitDB<T>(\n    options,\n    dbOptions,\n    allowAccessForUsers,\n    grantAccessCallback as any\n  ) as any; // TODO - on added another DB provider than the OrbitDB, any type must be removed\n};\n\n/**\n * Extends options for connector to a databases of the OrbitDB type\n *\n * @param {ISwarmMessageStoreOptions<ESwarmStoreConnector.OrbitDB>} options - options for the connector\n * @param {ReturnType<typeof swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControl>} extendWithAccessControlOptions - get access options for a database\n * @returns {(Promise<\n *   ISwarmStoreConnectorOrbitDBOptions<TSwarmMessageSerialized> & {\n *     providerConnectionOptions: ISwarmStoreConnectorOrbitDBConnectionOptions;\n *     provider: typeof ESwarmStoreConnector.OrbitDB;\n *   }\n * >)}\n */\nasync function swarmMessageStoreUtilsConnectorOptionsProviderForOrbitDB(\n  options: ISwarmMessageStoreOptions<ESwarmStoreConnector.OrbitDB>,\n  extendWithAccessControlOptions: ReturnType<\n    typeof swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControl\n  >\n): Promise<\n  ISwarmStoreConnectorOrbitDBOptions<TSwarmMessageSerialized> & {\n    providerConnectionOptions: ISwarmStoreConnectorOrbitDBConnectionOptions;\n    provider: typeof ESwarmStoreConnector.OrbitDB;\n  }\n> {\n  const ipfsConnection =\n    options.providerConnectionOptions && options.providerConnectionOptions.ipfs\n      ? options.providerConnectionOptions.ipfs\n      : await ipfsUtilsConnectBasic();\n  const databases = options.databases.map(extendWithAccessControlOptions);\n\n  return {\n    ...options,\n    providerConnectionOptions: {\n      ...options.providerConnectionOptions,\n      ipfs: ipfsConnection,\n    },\n    databases,\n  };\n}\n\n/**\n * transform options from options simplified\n * interface for the SwarmMessageStore to the\n * full options for the SwarmStore.\n *\n * @export\n * @template P\n * @param {ISwarmMessageStoreOptions<P>} options\n * @returns {ISwarmStoreOptions<P>}\n * @throws if the options can not be transformed then throws\n */\nexport async function swarmMessageStoreUtilsConnectorOptionsProvider<\n  P extends ESwarmStoreConnector\n>(\n  options: ISwarmMessageStoreOptions<P>,\n  extendWithAccessControlOptions: ReturnType<\n    typeof swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControl\n  >\n): Promise<ISwarmMessageStoreOptions<P>> {\n  const { provider } = options;\n\n  switch (provider) {\n    case ESwarmStoreConnector.OrbitDB:\n      return swarmMessageStoreUtilsConnectorOptionsProviderForOrbitDB(\n        options,\n        extendWithAccessControlOptions\n      ) as Promise<ISwarmMessageStoreOptions<P>>;\n    default:\n      throw new Error(\n        `Failed to transform options cause the provider \"${provider}\" is unknown`\n      );\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store.ts",["2388","2389"],"import assert from 'assert';\nimport { SwarmStore } from '../swarm-store-class/swarm-store-class';\nimport {\n  ESwarmStoreConnector,\n  ESwarmStoreEventNames,\n} from '../swarm-store-class/swarm-store-class.const';\nimport {\n  ISwarmMessageStoreAccessControlOptions,\n  ISwarmMessageDatabaseConstructors,\n} from './swarm-message-store.types';\nimport {\n  ISwarmMessageConstructor,\n  TSwarmMessageInstance,\n} from '../swarm-message/swarm-message-constructor.types';\nimport {\n  ESwarmMessageStoreEventNames,\n  SWARM_MESSAGE_STORE_CONNECTOR_ORBIT_DB_ITERATOR_OPTIONS_DEFAULT,\n} from './swarm-message-store.const';\nimport { extend } from '../../utils/common-utils/common-utils-objects';\nimport {\n  TSwarmStoreDatabaseIteratorMethodAnswer,\n  TSwarmStoreDatabaseMethodAnswer,\n  TSwarmStoreDatabaseEntityAddress,\n} from '../swarm-store-class/swarm-store-class.types';\nimport {\n  TSwarmStoreDatabaseMethodArgument,\n  TSwarmStoreDatabaseIteratorMethodArgument,\n} from '../swarm-store-class/swarm-store-class.types';\nimport {\n  ESwarmStoreConnectorOrbitDbDatabaseMethodNames,\n  TSwarmStoreConnectorOrbitDbDatabaseMethodNames,\n} from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport {\n  TSwarmStoreValueTypes,\n  TSwarmStoreDatabaseMethod,\n} from '../swarm-store-class/swarm-store-class.types';\nimport {\n  TSwarmMessageStoreConnectReturnType,\n  ISwarmMessageStoreOptions,\n} from './swarm-message-store.types';\nimport {\n  ISwarmMessageStoreEvents,\n  ISwarmMessageStore,\n} from './swarm-message-store.types';\nimport { swarmMessageStoreUtilsConnectorOptionsProvider } from './swarm-message-store-utils/swarm-message-store-utils-connector-options-provider';\nimport { getMessageConstructorForDatabase } from './swarm-message-store-utils/swarm-message-store-utils-common/swarm-message-store-utils-common';\nimport {\n  TSwarmMessageStoreMessageId,\n  ISwarmMessageStoreDeleteMessageArg,\n} from './swarm-message-store.types';\nimport {\n  TSwarmMessageSerialized,\n  ISwarmMessageInstanceDecrypted,\n  ISwarmMessageInstanceEncrypted,\n  TSwarmMessageConstructorBodyMessage,\n} from '../swarm-message/swarm-message-constructor.types';\nimport { ISwarmMessageConstructorWithEncryptedCacheFabric } from '../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport {\n  TSwarmStoreDatabaseOptions,\n  TSwarmStoreDatabaseType,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControl } from './swarm-message-store-utils/swarm-message-store-utils-connector-options-provider/swarm-message-store-utils-connector-options-provider';\n\nimport {\n  ISwarmMessageStoreMessagingRequestWithMetaResult,\n  ISwarmMessageStoreSwarmMessageMetadata,\n  TSwarmMessageStoreEntryRaw,\n  ISwarmMessageStoreDatabaseType,\n} from './swarm-message-store.types';\nimport {\n  TSwarmStoreDatabaseRequestMethodReturnType,\n  TSwarmStoreDatabaseEntityKey,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { StorageProviderInMemory } from '../storage-providers/storage-in-memory-provider/storage-in-memory-provider';\nimport { StorageProvider } from '../storage-providers/storage-providers.types';\nimport {\n  ISwarmMessageStoreUtilsMessagesCache,\n  ISwarmMessageStoreUtilsMessagesCacheOptions,\n} from './swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.types';\nimport { SwarmMessageStoreUtilsMessagesCache } from './swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache';\nimport {\n  EOrbitDbFeedStoreOperation,\n  ESwarmStoreConnectorOrbitDbDatabaseType,\n} from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\n\nexport class SwarmMessageStore<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>\n>\n  extends SwarmStore<\n    P,\n    TSwarmMessageSerialized,\n    DbType,\n    ISwarmMessageStoreEvents\n  >\n  implements ISwarmMessageStore<P, DbType> {\n  protected connectorType: P | undefined;\n\n  protected accessControl?: ISwarmMessageStoreAccessControlOptions<P>;\n\n  protected messageConstructors?: ISwarmMessageDatabaseConstructors;\n\n  protected swarmMessageConstructorFabric?: ISwarmMessageConstructorWithEncryptedCacheFabric;\n\n  protected extendsWithAccessControl?: ReturnType<\n    typeof swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControl\n  >;\n\n  protected _dbTypes: Record<\n    string,\n    ESwarmStoreConnectorOrbitDbDatabaseType\n  > = {};\n\n  protected _cache?: StorageProvider<\n    TSwarmMessageInstance\n  > = new StorageProviderInMemory<TSwarmMessageInstance>();\n\n  protected _databasesMessagesCaches: Record<\n    string,\n    ISwarmMessageStoreUtilsMessagesCache\n  > = {};\n\n  protected get dbMethodAddMessage(): TSwarmStoreDatabaseMethod<P> {\n    const { connectorType } = this;\n\n    switch (connectorType as P) {\n      case ESwarmStoreConnector.OrbitDB:\n        return (ESwarmStoreConnectorOrbitDbDatabaseMethodNames.add as TSwarmStoreConnectorOrbitDbDatabaseMethodNames) as TSwarmStoreDatabaseMethod<\n          P\n        >;\n      default:\n        throw new Error('Failed to define the method for adding message');\n    }\n  }\n\n  protected get dbMethodRemoveMessage(): TSwarmStoreDatabaseMethod<P> {\n    const { connectorType } = this;\n\n    switch (connectorType as P) {\n      case ESwarmStoreConnector.OrbitDB:\n        return (ESwarmStoreConnectorOrbitDbDatabaseMethodNames.remove as TSwarmStoreConnectorOrbitDbDatabaseMethodNames) as TSwarmStoreDatabaseMethod<\n          P\n        >;\n      default:\n        throw new Error('Failed to define the method for adding message');\n    }\n  }\n\n  protected get dbMethodIterator(): TSwarmStoreDatabaseMethod<P> {\n    const { connectorType } = this;\n\n    switch (connectorType as P) {\n      case ESwarmStoreConnector.OrbitDB:\n        return (ESwarmStoreConnectorOrbitDbDatabaseMethodNames.iterator as TSwarmStoreConnectorOrbitDbDatabaseMethodNames) as TSwarmStoreDatabaseMethod<\n          P\n        >;\n      default:\n        throw new Error('Failed to define the method for adding message');\n    }\n  }\n\n  public async connect(\n    options: ISwarmMessageStoreOptions<P>\n  ): TSwarmMessageStoreConnectReturnType<P, DbType> {\n    const extendsWithAccessControl = swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControl(\n      options\n    );\n    const optionsSwarmStore = await swarmMessageStoreUtilsConnectorOptionsProvider(\n      options,\n      extendsWithAccessControl\n    );\n\n    this.extendsWithAccessControl = extendsWithAccessControl;\n    this.setOptions(optionsSwarmStore);\n\n    const connectionResult = await super.connect(\n      optionsSwarmStore,\n      optionsSwarmStore.databasesListStorage\n    );\n\n    if (connectionResult instanceof Error) {\n      throw connectionResult;\n    }\n    await this._startCacheStore();\n    this.setListeners();\n  }\n\n  /**\n   * open a new connection to the database specified\n   *\n   * @param {TSwarmStoreDatabaseOptions} dbOptions\n   * @returns {(Promise<void | Error>)}\n   * @memberof SwarmStore\n   */\n  public async openDatabase(\n    dbOptions: TSwarmStoreDatabaseOptions<P, TSwarmMessageSerialized>\n  ): Promise<void | Error> {\n    try {\n      const optionsWithAcessControl = (this.extendsWithAccessControl?.(\n        dbOptions\n      ) || dbOptions) as TSwarmStoreDatabaseOptions<P, TSwarmMessageSerialized>;\n      const dbOpenResult = await super.openDatabase(optionsWithAcessControl);\n\n      if (!(dbOpenResult instanceof Error)) {\n        await this.openDatabaseMessagesCache(dbOptions.dbName);\n      }\n\n      const dbType = this.getDatabaseTypeByOptions(dbOptions);\n\n      this._setDatabaseType(dbOptions.dbName, dbType);\n    } catch (err) {\n      console.error(err);\n      return new Error(\n        `Swarm message store:failed to open the database ${dbOptions.dbName}: ${err.message}`\n      );\n    }\n  }\n\n  /**\n   * Remove the database, clean it's messages cache if exists,\n   * unset settings.\n   *\n   * @param {string} dbName\n   * @returns {(Promise<void | Error>)}\n   * @memberof SwarmMessageStore\n   */\n  public async dropDatabase(dbName: string): Promise<void | Error> {\n    const dropDbResult = await super.dropDatabase(dbName);\n\n    if (dropDbResult instanceof Error) {\n      return dropDbResult;\n    }\n    const messageConstructor = await this.getMessageConstructor(dbName);\n\n    try {\n      if (messageConstructor?.encryptedCache) {\n        await messageConstructor.encryptedCache.clearDb();\n      }\n      await this.unsetDatabaseMessagesCache(dbName);\n      this._unsetDatabaseType(dbName);\n    } catch (err) {\n      console.error(\n        `Failed to clear messages encrypted cache for the database ${dbName}`\n      );\n      return err;\n    }\n  }\n\n  public async addMessage<\n    T extends TSwarmStoreValueTypes<P>,\n    DT extends DbType\n  >(\n    dbName: string,\n    msg: TSwarmMessageInstance | TSwarmMessageConstructorBodyMessage | string,\n    key?: TSwarmStoreDatabaseEntityAddress<P>\n  ): Promise<TSwarmMessageStoreMessageId> {\n    const message: TSwarmMessageInstance | string =\n      typeof msg === 'string' ? msg : await this.constructMessage(dbName, msg);\n\n    assert(dbName, 'Database name must be provided');\n    this.validateMessageFormat(message);\n\n    const requestAddArgument = {\n      value: this.serializeMessage(message),\n      key,\n    } as TSwarmStoreDatabaseMethodArgument<P, TSwarmStoreValueTypes<P>, DT>;\n    const response = (await this.request<TSwarmStoreValueTypes<P>, DT>(\n      dbName,\n      this.dbMethodAddMessage,\n      requestAddArgument\n    )) as TSwarmStoreDatabaseMethodAnswer<P, T> | Error;\n\n    if (response instanceof Error) {\n      throw response;\n    }\n    return this.deserializeAddMessageResponse(response);\n  }\n\n  public async deleteMessage(\n    dbName: string,\n    messageAddressOrDbKey: ISwarmMessageStoreDeleteMessageArg<P>\n  ): Promise<void> {\n    assert(dbName, 'Database name must be provided');\n    assert(\n      messageAddressOrDbKey && typeof messageAddressOrDbKey === 'string',\n      'Message address must be a non empty string'\n    );\n\n    const result = await this.request(\n      dbName,\n      this.dbMethodRemoveMessage,\n      this.getArgRemoveMessage(messageAddressOrDbKey)\n    );\n\n    if (result instanceof Error) {\n      throw result;\n    }\n    try {\n      await this.removeSwarmMessageFromCacheByAddressOrKey(\n        dbName,\n        messageAddressOrDbKey\n      );\n    } catch (err) {\n      console.error(\n        new Error(\n          `Failed to remove a message by address or key \"${messageAddressOrDbKey}\" from cache for database \"${dbName}\"`\n        ),\n        err\n      );\n    }\n  }\n\n  public async collect<T extends TSwarmStoreValueTypes<P>, DT extends DbType>(\n    dbName: string,\n    options: TSwarmStoreDatabaseIteratorMethodArgument<P, DT>\n  ): Promise<\n    (ISwarmMessageInstanceDecrypted | ISwarmMessageInstanceEncrypted | Error)[]\n  > {\n    assert(typeof dbName === 'string', '');\n\n    const iterator = await this.request<T, DT>(\n      dbName,\n      this.dbMethodIterator,\n      this.getArgIterateDb<T, DT>(dbName, options)\n    );\n\n    if (iterator instanceof Error) {\n      throw iterator;\n    }\n    return this.collectMessages(\n      dbName,\n      iterator as TSwarmStoreDatabaseIteratorMethodAnswer<P, T>,\n      this._getDatabaseType(dbName) as ISwarmMessageStoreDatabaseType<P>\n    );\n  }\n\n  public async collectWithMeta<\n    T extends TSwarmStoreValueTypes<P>,\n    DT extends DbType\n  >(\n    dbName: string,\n    options: TSwarmStoreDatabaseIteratorMethodArgument<P, DbType>\n  ): Promise<\n    Array<ISwarmMessageStoreMessagingRequestWithMetaResult<P> | undefined>\n  > {\n    assert(typeof dbName === 'string', '');\n\n    const rawEntries = await this.request(\n      dbName,\n      this.dbMethodIterator,\n      this.getArgIterateDb<T, DT>(dbName, options)\n    );\n\n    if (rawEntries instanceof Error) {\n      throw rawEntries;\n    }\n\n    const collectMessagesResult = await this.collectMessages(\n      dbName,\n      rawEntries as TSwarmStoreDatabaseIteratorMethodAnswer<\n        P,\n        TSwarmStoreValueTypes<P>\n      >,\n      this._getDatabaseType(dbName) as ISwarmMessageStoreDatabaseType<P>\n    );\n    debugger;\n    return this.getMessagesWithMeta(\n      collectMessagesResult,\n      rawEntries as Exclude<\n        TSwarmStoreDatabaseRequestMethodReturnType<P, TSwarmStoreValueTypes<P>>,\n        Error\n      >,\n      dbName,\n      this._getDatabaseType(dbName) as ISwarmMessageStoreDatabaseType<P>\n    );\n  }\n\n  protected validateOpts(options: ISwarmMessageStoreOptions<P>): void {\n    super.validateOptions(options);\n\n    const { messageConstructors } = options;\n\n    assert(messageConstructors, 'messages constructors must be specified');\n    assert(\n      typeof messageConstructors === 'object',\n      'messages constructors must an object'\n    );\n\n    const validateMessageConstructor = (mc: any) => {\n      assert(\n        typeof mc === 'object',\n        'the message constructor must be specified'\n      );\n      assert(\n        typeof mc.construct === 'function',\n        'the message constructor must have the \"construct\" method'\n      );\n    };\n\n    assert(\n      typeof messageConstructors.default === 'object',\n      'the default message constructor must be cpecified'\n    );\n    validateMessageConstructor(messageConstructors.default);\n    Object.values(messageConstructors).forEach(validateMessageConstructor);\n    if (options.cache) {\n      assert(\n        typeof options.cache === 'object',\n        'Cache option must be an object'\n      );\n      assert(\n        typeof options.cache.get === 'function',\n        'Cache option must implements StorageProvider and have a \"get\" method'\n      );\n      assert(\n        typeof options.cache.set === 'function',\n        'Cache option must implements StorageProvider and have a \"set\" method'\n      );\n      assert(\n        typeof options.cache.clearDb === 'function',\n        'Cache option must implements StorageProvider and have a \"clearDb\" method'\n      );\n    }\n  }\n\n  protected setOptions(options: ISwarmMessageStoreOptions<P>): void {\n    this.validateOpts(options);\n    this.connectorType = options.provider;\n    this.accessControl = options.accessControl;\n    this.messageConstructors = options.messageConstructors;\n\n    if (options.cache) {\n      this._cache = options.cache;\n    }\n    this.swarmMessageConstructorFabric = options.swarmMessageConstructorFabric;\n  }\n\n  /**\n   * Return database type specifically for OrbitDB databases\n   *\n   * @protected\n   * @param {TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB>} dbOptions\n   * @returns {ESwarmStoreConnectorOrbitDbDatabaseType}\n   * @memberof SwarmMessageStore\n   */\n  protected getOrbitDBDatabaseTypeByOptions<T extends TSwarmStoreValueTypes<P>>(\n    dbOptions: TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, T>\n  ): ESwarmStoreConnectorOrbitDbDatabaseType {\n    return dbOptions.dbType || ESwarmStoreConnectorOrbitDbDatabaseType.FEED;\n  }\n\n  /**\n   * Return type of the database by it's options.\n   *\n   * @protected\n   * @param {TSwarmStoreDatabaseOptions<P>} dbOptions\n   * @returns {ESwarmStoreConnectorOrbitDbDatabaseType}\n   * @memberof SwarmMessageStore\n   */\n  protected getDatabaseTypeByOptions<T extends TSwarmStoreValueTypes<P>>(\n    dbOptions: TSwarmStoreDatabaseOptions<P, T>\n  ): ISwarmMessageStoreDatabaseType<P> {\n    const { connectorType } = this;\n\n    switch (connectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        return this.getOrbitDBDatabaseTypeByOptions(\n          dbOptions\n        ) as ISwarmMessageStoreDatabaseType<P>;\n      default:\n        return undefined as ISwarmMessageStoreDatabaseType<P>;\n    }\n  }\n\n  /**\n   * return the message constructor specified\n   * for the database\n   *\n   * @protected\n   * @param {string} dbName\n   * @returns {(ISwarmMessageConstructor | undefined)}\n   * @memberof SwarmMessageStore\n   */\n  protected async getMessageConstructor(\n    dbName: string\n  ): Promise<ISwarmMessageConstructor | undefined> {\n    if (!dbName) {\n      return;\n    }\n    const messageConstructor =\n      this.messageConstructors &&\n      getMessageConstructorForDatabase(dbName, this.messageConstructors);\n\n    if (!messageConstructor) {\n      return this.createMessageConstructorForDb(dbName);\n    }\n    return messageConstructor;\n  }\n\n  protected getMessagesWithMeta(\n    messages: Array<\n      Error | ISwarmMessageInstanceDecrypted | ISwarmMessageInstanceEncrypted\n    >,\n    rawEntriesIterator: Exclude<\n      TSwarmStoreDatabaseRequestMethodReturnType<P, TSwarmStoreValueTypes<P>>,\n      Error\n    >,\n    dbName: string,\n    dbType: ISwarmMessageStoreDatabaseType<P>\n  ): Array<ISwarmMessageStoreMessagingRequestWithMetaResult<P> | undefined> {\n    if (this.connectorType === ESwarmStoreConnector.OrbitDB) {\n      debugger;\n      return this.joinMessagesWithRawOrbitDBEntries(\n        messages,\n        rawEntriesIterator as Exclude<\n          TSwarmStoreDatabaseIteratorMethodAnswer<\n            ESwarmStoreConnector.OrbitDB,\n            TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>\n          >,\n          Error\n        >,\n        dbName,\n        dbType\n      );\n    }\n    return [];\n  }\n\n  protected joinMessagesWithRawOrbitDBEntries(\n    messages: Array<\n      Error | ISwarmMessageInstanceDecrypted | ISwarmMessageInstanceEncrypted\n    >,\n    rawEntriesIterator: Exclude<\n      TSwarmStoreDatabaseIteratorMethodAnswer<\n        ESwarmStoreConnector.OrbitDB,\n        TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>\n      >,\n      Error\n    >,\n    dbName: string,\n    dbType: ISwarmMessageStoreDatabaseType<P>\n  ): Array<\n    | ISwarmMessageStoreMessagingRequestWithMetaResult<\n        ESwarmStoreConnector.OrbitDB\n      >\n    | undefined\n  > {\n    debugger;\n    return messages.map((messageInstance, idx) => {\n      const logEntry = rawEntriesIterator[idx];\n      const messageMetadata = this.getSwarmMessageMetadata<\n        TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>\n      >(\n        logEntry as TSwarmMessageStoreEntryRaw<\n          P,\n          TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>\n        >,\n        dbType\n      );\n\n      if (!messageMetadata) {\n        return undefined;\n      }\n      return {\n        dbName,\n        message: messageInstance,\n        messageAddress: messageMetadata.messageAddress,\n        key: messageMetadata.key,\n      };\n    });\n  }\n\n  /**\n   * emits error occurred on a message creation\n   *\n   * @protected\n   * @memberof SwarmMessageStore\n   */\n  protected emitMessageConstructionFails = (\n    dbName: string,\n    message: string,\n    messageAddr: string,\n    key: string | undefined, // message key\n    error: Error\n  ) => {\n    this.emit(\n      ESwarmMessageStoreEventNames.NEW_MESSAGE_ERROR,\n      dbName,\n      message,\n      error,\n      messageAddr,\n      key\n    );\n  };\n\n  /**\n   * new message incoming\n   *\n   * @protected\n   * @memberof SwarmMessageStore\n   */\n  protected emitMessageNew = (\n    dbName: string,\n    message: TSwarmMessageInstance,\n    messageAddr: string,\n    messageKey?: string\n  ) => {\n    console.log('SwarmMessageStore::emitMessageNew', {\n      dbName,\n      message,\n      messageAddr,\n      messageKey,\n    });\n    this.emit(\n      ESwarmMessageStoreEventNames.NEW_MESSAGE,\n      dbName,\n      message,\n      messageAddr,\n      messageKey\n    );\n  };\n\n  /**\n   * Message or key was deleted\n   *\n   * @protected\n   * @memberof SwarmMessageStore\n   */\n  protected emitMessageDelete = (\n    dbName: string,\n    userId: string,\n    messageHash: TSwarmStoreDatabaseEntityAddress<P>,\n    messageDeletedHash: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n      : TSwarmStoreDatabaseEntityAddress<P>,\n    messageKey: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityKey<P>\n      : undefined\n  ) => {\n    console.log('SwarmMessageStore::emitMessageDelete', {\n      dbName,\n      userId,\n      messageHash,\n      messageKey,\n    });\n    this.emit(\n      ESwarmMessageStoreEventNames.DELETE_MESSAGE,\n      dbName,\n      userId,\n      messageHash,\n      messageDeletedHash,\n      messageKey\n    );\n  };\n\n  /**\n   * Check whether the message has a valid format\n   *\n   * @protected\n   * @param {*} message\n   * @param {ESwarmStoreConnectorOrbitDbDatabaseType} dbType\n   * @returns {message is (\n   *     P extends ESwarmStoreConnector.OrbitDB\n   *     ? LogEntry<TSwarmMessageSerialized>\n   *     : any\n   *   )}\n   * @memberof SwarmMessageStore\n   */\n  protected isValidDataMessageFormat<T extends TSwarmStoreValueTypes<P>>(\n    message: TSwarmMessageStoreEntryRaw<P, T>,\n    dbType: ISwarmMessageStoreDatabaseType<P>\n  ): message is TSwarmMessageStoreEntryRaw<P, T> {\n    return (\n      typeof message === 'object' &&\n      typeof message.payload === 'object' &&\n      typeof message.hash === 'string' &&\n      typeof message.payload.value === 'string' &&\n      (dbType !== ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE ||\n        typeof message.payload.key === 'string')\n    );\n  }\n\n  protected getSwarmMessageMetadataOrbitDb<T extends TSwarmStoreValueTypes<P>>(\n    message:\n      | TSwarmMessageStoreEntryRaw<ESwarmStoreConnector.OrbitDB, T>\n      | undefined,\n    dbType: ISwarmMessageStoreDatabaseType<P>\n  ): ISwarmMessageStoreSwarmMessageMetadata | undefined {\n    if (!message) {\n      return message;\n    }\n    return {\n      messageAddress: message.hash,\n      key:\n        dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n          ? message.payload.key\n          : undefined,\n    };\n  }\n\n  protected getSwarmMessageMetadata<T extends TSwarmStoreValueTypes<P>>(\n    message: TSwarmMessageStoreEntryRaw<P, T> | undefined,\n    dbType: ISwarmMessageStoreDatabaseType<P>\n  ): ISwarmMessageStoreSwarmMessageMetadata | undefined {\n    const { connectorType } = this;\n\n    switch (connectorType as P) {\n      case ESwarmStoreConnector.OrbitDB:\n        return this.getSwarmMessageMetadataOrbitDb(message, dbType);\n      default:\n        throw new Error('Unsupported database connector');\n    }\n  }\n\n  /**\n   * Constructs new swarm message from the raw database entry.\n   *\n   * @template T\n   * @param {string} dbName\n   * @param {TSwarmMessageStoreEntryRaw<P, T>} message\n   * @param {ISwarmMessageStoreDatabaseType<P>} dbType\n   * @returns {(Promise<TSwarmMessageInstance>)}\n   * @throw\n   */\n  protected constructNewSwarmMessageFromRawEntry = async <\n    T extends TSwarmStoreValueTypes<P>\n  >(\n    dbName: string,\n    dbType: ISwarmMessageStoreDatabaseType<P>,\n    message: TSwarmMessageStoreEntryRaw<P, T>\n  ): Promise<TSwarmMessageInstance> => {\n    if (!this.isValidDataMessageFormat(message, dbType)) {\n      throw new Error('There is unknown message format');\n    }\n\n    const messageMetadata = this.getSwarmMessageMetadata<T>(message, dbType);\n    const swarmMessageInstance = await this.constructMessage(\n      dbName,\n      message.payload.value,\n      messageMetadata\n    );\n\n    if (swarmMessageInstance instanceof Error) {\n      throw swarmMessageInstance;\n    }\n    return swarmMessageInstance;\n  };\n\n  /**\n   * Handle message with some information\n   *\n   * @protected\n   * @memberof SwarmMessageStore\n   */\n  protected handleNewDataMessage = async <T extends TSwarmStoreValueTypes<P>>(\n    dbName: string,\n    dbType: ISwarmMessageStoreDatabaseType<P>,\n    message: TSwarmMessageStoreEntryRaw<P, T>\n  ): Promise<void> => {\n    let messageRawType: T | undefined;\n    let key: string | undefined;\n    let swarmMessageInstance: TSwarmMessageInstance | undefined;\n\n    try {\n      swarmMessageInstance = await this.getSwarmMessageFromCacheByRawEntry<T>(\n        dbName,\n        dbType,\n        message\n      );\n    } catch (err) {\n      console.error(\n        new Error(\n          `Failed to read a swarm message because the error: ${err.message}`\n        )\n      );\n    }\n\n    if (!swarmMessageInstance) {\n      try {\n        swarmMessageInstance = await this.constructNewSwarmMessageFromRawEntry(\n          dbName,\n          dbType,\n          message\n        );\n      } catch (err) {\n        return this.emitMessageConstructionFails(\n          dbName,\n          messageRawType ? String(messageRawType) : '',\n          message?.hash || '',\n          key,\n          err\n        );\n      }\n    }\n    if (swarmMessageInstance) {\n      const messageWithMeta = this.getSwarmMessageMetadata<T>(message, dbType);\n\n      if (!messageWithMeta) {\n        return;\n      }\n      const { messageAddress, key } = messageWithMeta;\n      return this.emitMessageNew(\n        dbName,\n        swarmMessageInstance,\n        messageAddress,\n        key\n      );\n    }\n  };\n\n  /**\n   * handle a new message stored in the local database\n   *\n   * @memberof SwarmMessageStore\n   */\n  protected handleNewMessage = async <T extends TSwarmStoreValueTypes<P>>([\n    dbName,\n    message,\n    messageAddress,\n    heads,\n    dbType,\n  ]: [\n    string,\n    TSwarmMessageStoreEntryRaw<P, T>,\n    TSwarmStoreDatabaseEntityAddress<P>,\n    any,\n    ISwarmMessageStoreDatabaseType<P>\n  ]): Promise<void> => {\n    console.log('SwarmMessageStore::handleNewMessage', {\n      dbName,\n      message,\n      messageAddress,\n    });\n    if (message?.payload?.op === EOrbitDbFeedStoreOperation.DELETE) {\n      // TODO - remove the message from the cache\n      debugger;\n      return this.emitMessageDelete(\n        dbName,\n        message.identity.id,\n        message.hash as TSwarmStoreDatabaseEntityAddress<P>,\n        (message.payload\n          .value as unknown) as DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n          ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n          : TSwarmStoreDatabaseEntityAddress<P>,\n        (dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n          ? message.payload.key\n          : undefined) as DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n          ? TSwarmStoreDatabaseEntityKey<P>\n          : undefined\n      );\n    }\n    debugger;\n    return this.handleNewDataMessage<T>(dbName, dbType, message);\n  };\n\n  protected setListeners() {\n    this.addListener(ESwarmStoreEventNames.NEW_ENTRY, this.handleNewMessage);\n  }\n\n  /**\n   * validate format of a message to send\n   *\n   * @protected\n   * @param {(TSwarmMessageInstance | string)} message\n   * @memberof SwarmMessageStore\n   */\n  protected validateMessageFormat(message: TSwarmMessageInstance | string) {\n    assert(message, 'Message must be provided');\n    assert(\n      typeof message === 'string' || typeof message === 'object',\n      'Message must be a string or an object'\n    );\n    assert(\n      typeof (message as TSwarmMessageInstance).bdy === 'object' &&\n        typeof (message as TSwarmMessageInstance).uid === 'string' &&\n        typeof (message as TSwarmMessageInstance).sig === 'string',\n      'Message must be a string or an object'\n    );\n  }\n\n  /**\n   * serizlize the message to a fromat\n   * to store it in the store with\n   * a type specified in the options\n   *\n   * @protected\n   * @returns {TSwarmStoreValueTypes<P>}\n   * @memberof SwarmMessageStore\n   */\n  protected serializeMessage(\n    message: TSwarmMessageInstance | string\n  ): TSwarmStoreValueTypes<P> {\n    const { connectorType } = this;\n\n    switch (connectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        return String(message) as TSwarmStoreValueTypes<\n          ESwarmStoreConnector.OrbitDB\n        >;\n      default:\n        throw new Error(\n          'Failed to serizlize the message to the store connector compatible format'\n        );\n    }\n  }\n\n  /**\n   * returns the argument for a message removing request\n   * accepted by the connector type provided\n   *\n   * @protected\n   * @param {string} messageAddress\n   * @param {(TSwarmMessageInstance | string)} message\n   * @returns {TSwarmStoreDatabaseMethodArgument<P, TSwarmStoreValueTypes<P>>}\n   * @memberof SwarmMessageStore\n   */\n  protected getArgRemoveMessage<DbType extends TSwarmStoreDatabaseType<P>>(\n    messageAddress: string\n  ): TSwarmStoreDatabaseMethodArgument<P, TSwarmStoreValueTypes<P>, DbType> {\n    const { connectorType } = this;\n\n    switch (connectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        return messageAddress as TSwarmStoreDatabaseMethodArgument<\n          P,\n          TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>,\n          DbType\n        >;\n      default:\n        throw new Error(\n          'Failed to define argument value for a swarm message removing'\n        );\n    }\n  }\n\n  /**\n   * returns argment for a database values iterator\n   *\n   * @protected\n   * @param {string} dbName\n   * @returns {TSwarmStoreDatabaseMethodArgument<P, TSwarmStoreValueTypes<P>>}\n   * @memberof SwarmMessageStore\n   */\n  protected getArgIterateDb<\n    V extends TSwarmStoreValueTypes<P>,\n    DbType extends TSwarmStoreDatabaseType<P>\n  >(\n    dbName: string,\n    options: TSwarmStoreDatabaseIteratorMethodArgument<P, DbType>\n  ): TSwarmStoreDatabaseMethodArgument<P, V, DbType> {\n    const { connectorType } = this;\n\n    switch (connectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        assert(options, 'The iteratro opti');\n        return (options\n          ? (extend(\n              options,\n              SWARM_MESSAGE_STORE_CONNECTOR_ORBIT_DB_ITERATOR_OPTIONS_DEFAULT\n            ) as TSwarmStoreDatabaseIteratorMethodArgument<P, DbType>)\n          : (SWARM_MESSAGE_STORE_CONNECTOR_ORBIT_DB_ITERATOR_OPTIONS_DEFAULT as TSwarmStoreDatabaseIteratorMethodArgument<\n              P,\n              DbType\n            >)) as TSwarmStoreDatabaseMethodArgument<P, V, DbType>;\n      default:\n        throw new Error(\n          'Failed to define argument value for a swarm message collecting'\n        );\n    }\n  }\n\n  protected async collectMessagesFromOrbitDBIterator<\n    T extends TSwarmStoreValueTypes<P>\n  >(\n    dbName: string,\n    rawEnties: TSwarmStoreDatabaseIteratorMethodAnswer<\n      ESwarmStoreConnector.OrbitDB,\n      T\n    >, // TODO - may be not a string,\n    dbType: ESwarmStoreConnectorOrbitDbDatabaseType\n  ): Promise<(TSwarmMessageInstance | Error)[]> {\n    if (rawEnties instanceof Error) {\n      throw rawEnties;\n    }\n    return Promise.all(\n      rawEnties.map(async (logEntry) => {\n        if (logEntry instanceof Error) {\n          return logEntry;\n        }\n        if (!logEntry) {\n          return logEntry;\n        }\n        try {\n          debugger;\n          const messageMetadata = this.getSwarmMessageMetadata<T>(\n            logEntry as TSwarmMessageStoreEntryRaw<P, T>,\n            dbType as ISwarmMessageStoreDatabaseType<P>\n          );\n          const message = await this.constructMessage(\n            dbName,\n            logEntry.payload.value,\n            messageMetadata\n          );\n\n          return message;\n        } catch (err) {\n          return err;\n        }\n      })\n    );\n  }\n\n  /**\n   * collect messages from iterator\n   *\n   * @protected\n   * @param {string} dbName\n   * @param {TSwarmStoreDatabaseIteratorMethodAnswer<P, any>} rawEntries\n   * @param {any} d\n   * @returns {TSwarmMessageInstance[]}\n   * @memberof SwarmMessageStore\n   */\n  protected collectMessages<T extends TSwarmStoreValueTypes<P>>(\n    dbName: string,\n    rawEntries: TSwarmStoreDatabaseIteratorMethodAnswer<P, T>,\n    dbType: ISwarmMessageStoreDatabaseType<P>\n  ): Promise<(TSwarmMessageInstance | Error)[]> {\n    const { connectorType } = this;\n\n    switch (connectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        return this.collectMessagesFromOrbitDBIterator<T>(\n          dbName,\n          rawEntries,\n          dbType\n        );\n      default:\n        throw new Error(\n          'Failed to define argument value for a swarm message collecting'\n        );\n    }\n  }\n\n  /**\n   * transforms the result of a query for adding a message\n   * to the unique message's identifier in the database\n   *\n   * @protected\n   * @param {TSwarmStoreDatabaseMethodAnswer<\n   *       P,\n   TSwarmMessageSerialized\n   *     >} addMessageResponse\n   * @returns {TSwarmMessageStoreMessageId}\n   * @memberof SwarmMessageStore\n   */\n  protected deserializeAddMessageResponse<T extends TSwarmStoreValueTypes<P>>(\n    addMessageResponse: TSwarmStoreDatabaseMethodAnswer<P, T>\n  ): TSwarmMessageStoreMessageId {\n    const { connectorType } = this;\n\n    switch (connectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        if (typeof addMessageResponse !== 'string') {\n          throw new Error('There is a wrong responce on add message request');\n        }\n        return addMessageResponse;\n      default:\n        return String(addMessageResponse);\n    }\n  }\n\n  protected async createMessageConstructorForDb(\n    dbName: string\n  ): Promise<ISwarmMessageConstructor | undefined> {\n    if (!this.swarmMessageConstructorFabric) {\n      return;\n    }\n    return this.swarmMessageConstructorFabric({}, { dbName });\n  }\n\n  /**\n   * construct message for the database by a constructor,\n   * specified for the database,\n   * or return itself if a SwarmMessageInstance\n   * given.\n   *\n   * @protected\n   * @param {string} dbName\n   * @param {(TSwarmMessageInstance | TSwarmMessageConstructorBodyMessage)} message\n   * @returns {Promise<TSwarmMessageInstance>}\n   * @memberof SwarmMessageStore\n   */\n  protected async constructMessage(\n    dbName: string,\n    message:\n      | TSwarmMessageInstance\n      | TSwarmMessageConstructorBodyMessage\n      | TSwarmMessageSerialized,\n    metadata?: ISwarmMessageStoreSwarmMessageMetadata\n  ): Promise<TSwarmMessageInstance> {\n    if (metadata) {\n      // try to read message from the cache at first\n      // by it's unique address\n      const { messageAddress } = metadata;\n      const messageCached = await this.getSwarmMessageInstanceFromCacheByAddress(\n        dbName,\n        messageAddress\n      );\n\n      if (messageCached) {\n        return messageCached;\n      }\n    }\n\n    let swarmMessageInstance: TSwarmMessageInstance;\n\n    if (\n      (message as TSwarmMessageInstance).bdy &&\n      (message as TSwarmMessageInstance).sig\n    ) {\n      // if the message argument is already instance of a swarm message\n      swarmMessageInstance = message as TSwarmMessageInstance;\n    } else {\n      // construct swarm message instance if it's not in the cache and\n      // the message argument is not an instance by itself\n      const messageConsturctor = await this.getMessageConstructor(dbName);\n\n      if (!messageConsturctor) {\n        throw new Error(\n          `A message consturctor is not specified for the database ${dbName}`\n        );\n      }\n      swarmMessageInstance = await messageConsturctor.construct(\n        message as TSwarmMessageConstructorBodyMessage\n      );\n    }\n    if (swarmMessageInstance && metadata) {\n      await this.addMessageToCacheByMetadata(\n        dbName,\n        metadata,\n        swarmMessageInstance\n      );\n    }\n    return swarmMessageInstance;\n  }\n\n  protected getOptionsForDatabaseMessagesCache(\n    dbName: string\n  ): ISwarmMessageStoreUtilsMessagesCacheOptions {\n    if (!this._cache) {\n      throw new Error(\n        'Instance of storage used as messages cache is not defined'\n      );\n    }\n    return {\n      dbName,\n      cache: this._cache,\n    };\n  }\n\n  /**\n   * set messages cache for the database\n   *\n   * @protected\n   * @memberof SwarmMessageStore\n   * @throws\n   */\n  protected openDatabaseMessagesCache = async (\n    dbName: string\n  ): Promise<void> => {\n    const messagesCache = new SwarmMessageStoreUtilsMessagesCache();\n    const options = this.getOptionsForDatabaseMessagesCache(dbName);\n\n    await messagesCache.connect(options);\n    this._databasesMessagesCaches[dbName] = messagesCache;\n  };\n\n  /**\n   * Unset messages cache for the database\n   *\n   * @param {string} dbName\n   * @returns {Promise<void>}\n   * @throws\n   */\n  protected unsetDatabaseMessagesCache = async (\n    dbName: string\n  ): Promise<void> => {\n    const messagesCache = this._databasesMessagesCaches[dbName];\n\n    if (messagesCache) {\n      await messagesCache.clear();\n    }\n  };\n\n  /**\n   * Returns messages cache or undefined.\n   *\n   * @protected\n   * @param {string} dbName\n   * @returns {(ISwarmMessageStoreUtilsMessagesCache | undefined)}\n   * @memberof SwarmMessageStore\n   */\n  protected getMessagesCacheForDb(\n    dbName: string\n  ): ISwarmMessageStoreUtilsMessagesCache | undefined {\n    return this._databasesMessagesCaches[dbName];\n  }\n\n  /**\n   * Add message to a cache storage defined for the database.\n   * If cache is not exists for the database do notrhing\n   *\n   * @protected\n   * @param {string} dbName\n   * @param {ISwarmMessageStoreSwarmMessageMetadata} messageMetadata\n   * @param {TSwarmMessageInstance} messageInstance\n   * @returns {Promise<void>}\n   * @memberof SwarmMessageStore\n   */\n  protected async addMessageToCacheByMetadata(\n    dbName: string,\n    messageMetadata: ISwarmMessageStoreSwarmMessageMetadata,\n    messageInstance: TSwarmMessageInstance\n  ): Promise<void> {\n    const cache = this.getMessagesCacheForDb(dbName);\n\n    if (cache) {\n      const { messageAddress, key } = messageMetadata;\n      const pending = [\n        cache.setMessageByAddress(messageAddress, messageInstance),\n      ];\n\n      if (key) {\n        pending.push(cache.setMessageAddressForKey(key, messageAddress));\n      }\n      await Promise.all(pending);\n    }\n  }\n\n  protected async removeSwarmMessageFromCacheByKey(\n    dbName: string,\n    key: string\n  ): Promise<void> {\n    const cache = this.getMessagesCacheForDb(dbName);\n\n    if (cache) {\n      await cache.unsetMessageAddressForKey(key);\n    }\n  }\n\n  protected async removeSwarmMessageFromCacheByAddress(\n    dbName: string,\n    messageAddress: string\n  ): Promise<void> {\n    const cache = this.getMessagesCacheForDb(dbName);\n\n    if (cache) {\n      await cache.unsetMessageByAddress(messageAddress);\n    }\n  }\n\n  /**\n   * Remove the message from the swarm messages cache for\n   * the database by it's metadata.\n   *\n   * @protected\n   * @param {string} dbName\n   * @param {ISwarmMessageStoreSwarmMessageMetadata} messageMetadata\n   * @memberof SwarmMessageStore\n   */\n  protected async removeSwarmMessageFromCacheByAddressOrKey(\n    dbName: string,\n    messageAddressOrKey: ISwarmMessageStoreDeleteMessageArg<P>\n  ) {\n    const databaseType = this._getDatabaseType(dbName);\n\n    if (\n      messageAddressOrKey &&\n      databaseType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n    ) {\n      return this.removeSwarmMessageFromCacheByKey(dbName, messageAddressOrKey);\n    }\n    if (messageAddressOrKey) {\n      return this.removeSwarmMessageFromCacheByAddress(\n        dbName,\n        messageAddressOrKey\n      );\n    }\n    console.warn(\n      'The message address or key is not provided',\n      dbName,\n      messageAddressOrKey\n    );\n  }\n\n  protected async getSwarmMessageInstanceFromCacheByAddress(\n    dbName: string,\n    messageAddress: ISwarmMessageStoreSwarmMessageMetadata['messageAddress']\n  ): Promise<TSwarmMessageInstance | undefined> {\n    const cache = this.getMessagesCacheForDb(dbName);\n\n    if (cache) {\n      return cache.getMessageByAddress(messageAddress);\n    }\n  }\n\n  protected async getSwarmMessageFromCacheByRawEntry<\n    T extends TSwarmStoreValueTypes<P>\n  >(\n    dbName: string,\n    dbType: ISwarmMessageStoreDatabaseType<P>,\n    message: TSwarmMessageStoreEntryRaw<P, T> | undefined\n  ): Promise<TSwarmMessageInstance | undefined> {\n    debugger;\n    const messageMetadata = this.getSwarmMessageMetadata<T>(message, dbType);\n    if (!messageMetadata) {\n      return;\n    }\n    return await this.getSwarmMessageInstanceFromCacheByAddress(\n      dbName,\n      messageMetadata.messageAddress\n    );\n  }\n\n  /**\n   * Set type for database with the name\n   *\n   * @protected\n   * @param {string} dbName\n   * @param {ESwarmStoreConnectorOrbitDbDatabaseType} dbType\n   * @memberof SwarmMessageStore\n   */\n  protected _setDatabaseType(\n    dbName: string,\n    dbType: ISwarmMessageStoreDatabaseType<P>\n  ): void {\n    this._dbTypes[dbName] = dbType;\n  }\n\n  protected _unsetDatabaseType(dbName: string): void {\n    delete this._dbTypes[dbName];\n  }\n\n  /**\n   * Returns a database's type by it's name\n   *\n   * @param {string} dbName\n   * @returns {(ESwarmStoreConnectorOrbitDbDatabaseType | undefined)}\n   */\n  protected _getDatabaseType = (\n    dbName: string\n  ): ESwarmStoreConnectorOrbitDbDatabaseType | undefined =>\n    this._dbTypes[dbName];\n\n  /**\n   * Connect to the cache store\n   *\n   * @returns {Promise<void>}\n   * @throws - throws if failed to connect\n   */\n  protected _startCacheStore = async (): Promise<void> => {\n    const { _cache: cacheStore } = this;\n\n    if (!cacheStore) {\n      throw new Error('There is no cache store');\n    }\n\n    const connectToCacheResult = await cacheStore.connect();\n    debugger;\n    if (connectToCacheResult instanceof Error) {\n      throw new Error(\n        `Failed to connect to cache store: ${connectToCacheResult.message}`\n      );\n    }\n  };\n}\n","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store.types.ts",["2390","2391"],"import {\n  ISwarmStore,\n  ISwarmStoreEvents,\n  ISwarmStoreOptions,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { ESwarmStoreConnector } from '../swarm-store-class/swarm-store-class.const';\nimport {\n  TSwarmMessageInstance,\n  ISwarmMessageConstructor,\n} from '../swarm-message/swarm-message-constructor.types';\nimport { EventEmitter } from '../basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport { ESwarmMessageStoreEventNames } from './swarm-message-store.const';\nimport { TSwarmMessageUserIdentifierSerialized } from '../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport {\n  TSwarmStoreDatabaseIteratorMethodArgument,\n  TSwarmStoreDatabaseType,\n} from '../swarm-store-class/swarm-store-class.types';\nimport {\n  TSwarmMessageSerialized,\n  TSwarmMessageConstructorBodyMessage,\n} from '../swarm-message/swarm-message-constructor.types';\nimport { TCentralAuthorityUserIdentity } from '../central-authority-class/central-authority-class-types/central-authority-class-types-common';\nimport { ISwarmMessageConstructorWithEncryptedCacheFabric } from '../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport { IStorageCommon } from 'types/storage.types';\nimport {\n  TSwarmStoreDatabaseEntryOperation,\n  TSwarmStoreValueTypes,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { StorageProvider } from '../storage-providers/storage-providers.types';\nimport { ISwarmStoreConnectorOrbitDbDatabaseValue } from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { ISwarmMessageInstanceDecrypted } from '../swarm-message/swarm-message-constructor.types';\nimport {\n  TSwarmStoreDatabaseEntityAddress,\n  TSwarmStoreDatabaseEntityKey,\n} from '../swarm-store-class/swarm-store-class.types';\n\n/**\n * message unique identifier in the database\n */\nexport type TSwarmMessageStoreMessageId = string;\n\nexport interface ISwarmMessageStoreSwarmMessageMetadata {\n  /**\n   * Message uniq address in the swarm\n   *\n   * @type {TSwarmMessageStoreMessageId}\n   * @memberof ISwarmMessageStoreSwarmMessageMetadata\n   */\n  messageAddress: TSwarmMessageStoreMessageId;\n  /**\n   * Message key in Key-Value databse\n   *\n   * @type {string}\n   * @memberof ISwarmMessageStoreSwarmMessageMetadata\n   */\n  key?: string;\n}\n\nexport interface ISwarmMessageStoreEvents extends ISwarmStoreEvents {\n  /**\n   * new message stored in the local database\n   * 1) the first argument - database name where the message was added\n   * 2) the second argument - swarm message instance\n   * 3) the third argument - the global unique address of the message in the swarm\n   *\n   * @type {[\n   *     string,\n   TSwarmMessageInstance,\n   *     string\n   *   ]}\n   * @memberof ISwarmMessageStoreEvents\n   */\n  [ESwarmMessageStoreEventNames.NEW_MESSAGE]: [\n    string,\n    TSwarmMessageInstance,\n    string\n  ];\n  /**\n   * failed to deserialize a new message stored\n   *\n   * @type {[\n   *     string,\n   *     string,\n   *     Error,\n   *     string\n   *   ]}\n   * @memberof ISwarmMessageStoreEvents\n   */\n  [ESwarmMessageStoreEventNames.NEW_MESSAGE_ERROR]: [\n    string,\n    string,\n    Error,\n    string\n  ];\n}\n\nexport type TSwarmMessageStoreAccessControlGrantAccessCallback<\n  P extends ESwarmStoreConnector\n> = (\n  // swarm message\n  message: TSwarmMessageInstance,\n  // identifier of the user sender of the message\n  userId: TCentralAuthorityUserIdentity,\n  // a name of the database from where the message is comming from\n  // TODO - can it be gotten from the database entry??\n  dbName: string,\n  // key for the value in the database\n  key?: TSwarmStoreDatabaseEntityKey<P>,\n  // operation on the database\n  op?: TSwarmStoreDatabaseEntryOperation<P>\n) => Promise<boolean>;\n\n/**\n * grant the write access options to define access options\n * for the databases connected to\n *\n * @export\n * @interface ISwarmMessageStoreAccessControlOptions\n */\nexport interface ISwarmMessageStoreAccessControlOptions<\n  P extends ESwarmStoreConnector\n> {\n  // async callback which is called each time before a new message will be wrote to the database\n  grantAccess?: TSwarmMessageStoreAccessControlGrantAccessCallback<P>;\n  // a list of the user identifiers for whom an unconditional write access will be given\n  allowAccessFor?: TSwarmMessageUserIdentifierSerialized[];\n}\n\n/**\n * Swarm message constructors,specified for a databases\n * and the default constructor for a messages.\n * Each private database must have it's own\n * message constructor with it's own instance of the swarm message\n * swarm message encrypted cache.\n *\n * @export\n * @interface ISwarmMessageDatabaseConstructors\n */\nexport interface ISwarmMessageDatabaseConstructors {\n  [dbName: string]: ISwarmMessageConstructor;\n  default: ISwarmMessageConstructor;\n}\n\nexport interface ISwarmMessageStoreOptions<P extends ESwarmStoreConnector>\n  extends ISwarmStoreOptions<P, TSwarmMessageSerialized> {\n  accessControl?: ISwarmMessageStoreAccessControlOptions<P>;\n  messageConstructors: ISwarmMessageDatabaseConstructors;\n  providerConnectionOptions: any;\n  databasesListStorage: IStorageCommon;\n  /**\n   * Used for caching messages constructed\n   * for keys and addresses.\n   *\n   * @type {IStorageCommon}\n   * @memberof ISwarmMessageStoreOptions\n   */\n  cache?: StorageProvider<TSwarmMessageInstance>;\n  swarmMessageConstructorFabric?: ISwarmMessageConstructorWithEncryptedCacheFabric;\n}\n\nexport type TSwarmMessageStoreConnectReturnType<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>\n> = ReturnType<\n  ISwarmStore<\n    P,\n    TSwarmMessageSerialized,\n    DbType,\n    ISwarmMessageStoreOptions<P>\n  >['connect']\n>;\n\nexport type TSwarmMessageStoreEntryRaw<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmStoreValueTypes<P>\n> = P extends ESwarmStoreConnector\n  ? ISwarmStoreConnectorOrbitDbDatabaseValue<T>\n  : any;\n\nexport type ISwarmMessageStoreDeleteMessageArg<\n  P extends ESwarmStoreConnector\n> = P extends ESwarmStoreConnector.OrbitDB\n  ? TSwarmStoreDatabaseEntityAddress<P> // swarm message address\n  : TSwarmMessageInstance; // instance of the message to remove\n\nexport type ISwarmMessageStoreDatabaseType<\n  P extends ESwarmStoreConnector\n> = P extends ESwarmStoreConnector.OrbitDB\n  ? ESwarmStoreConnectorOrbitDbDatabaseType\n  : undefined;\n\nexport interface ISwarmMessageStoreMessageMeta<P extends ESwarmStoreConnector> {\n  /**\n   * A name of a database where the name is from\n   *\n   * @type {string}\n   * @memberof ISwarmMessageStoreMessageMeta\n   */\n  dbName: string;\n  /**\n   * The global unique address (hash) of the message in the swarm\n   *\n   * @type {TSwarmStoreDatabaseEntityUniqueAddress<P>}\n   */\n  messageAddress: Error | undefined | TSwarmStoreDatabaseEntityAddress<P>;\n  /**\n   * for key-value store it will be the key\n   *\n   * @type {string}\n   * @memberof ISwarmMessageStoreMessageMeta\n   */\n  key?: Error | TSwarmStoreDatabaseEntityKey<P> | undefined;\n}\n\nexport interface ISwarmMessageStoreMessagingRequestWithMetaResult<\n  P extends ESwarmStoreConnector\n> extends ISwarmMessageStoreMessageMeta<P> {\n  /**\n   * Message parsed.\n   * Error if failed to parse the message.\n   *\n   * @type {(Error | TSwarmMessageInstance)}\n   */\n  message: Error | TSwarmMessageInstance;\n}\n\nexport interface ISwarmMessageStoreMessageWithMeta<\n  P extends ESwarmStoreConnector\n> {\n  /**\n   * A name of a database where the name is from\n   *\n   * @type {string}\n   * @memberof ISwarmMessageStoreMessageMeta\n   */\n  dbName: string;\n  /**\n   * The global unique address (hash) of the message in the swarm\n   *\n   * @type {TSwarmStoreDatabaseEntityUniqueAddress<P>}\n   */\n  messageAddress: TSwarmStoreDatabaseEntityAddress<P>;\n  /**\n   * for key-value store it will be the key\n   *\n   * @type {string}\n   * @memberof ISwarmMessageStoreMessageMeta\n   */\n  key: TSwarmStoreDatabaseEntityKey<P> | undefined;\n  /**\n   * Message parsed.\n   * Error if failed to parse the message.\n   *\n   * @type {(Error | TSwarmMessageInstance)}\n   */\n  message: ISwarmMessageInstanceDecrypted;\n}\n\n/**\n * Methods for messaging between swarm users.\n *\n * @export\n * @interface ISwarmMessageStoreMessagingMethods\n * @template P\n */\nexport interface ISwarmMessageStoreMessagingMethods<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>\n> {\n  /**\n   * add message to a database with the given name\n   *\n   * @param {string} dbName - name of the database\n   * @param {ISwarmMessageStoreOptions<P>} message - message to add\n   * @param {TSwarmStoreDatabaseEntityUniqueAddress<P>} key - key for the message under which the message will be stored\n   * @returns {Promise<TSwarmMessageStoreMessageId>} - unique message's identifier in the database\n   * @memberof ISwarmMessageStore\n   * @throws\n   */\n  addMessage(\n    dbName: string,\n    message: TSwarmMessageInstance,\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ): Promise<TSwarmMessageStoreMessageId>;\n\n  /**\n   * add message serialized to a database with the given name\n   *\n   * @param {string} dbName - name of the database\n   * @param {ISwarmMessageStoreOptions<P>} message - message to add\n   * @returns {Promise<TSwarmMessageStoreMessageId>} - unique message's identifier in the database\n   * @memberof ISwarmMessageStore\n   * @throws\n   */\n  addMessage(\n    dbName: string,\n    message: string,\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ): Promise<TSwarmMessageStoreMessageId>;\n\n  /**\n   * construct and add message to a database with the given name.\n   *\n   * @param {string} dbName - name of the database\n   * @param {ISwarmMessageStoreOptions<P>} message - message to add\n   * @returns {Promise<TSwarmMessageStoreMessageId>} - unique message's identifier in the database\n   * @memberof ISwarmMessageStore\n   * @throws\n   */\n  addMessage(\n    dbName: string,\n    message: TSwarmMessageConstructorBodyMessage,\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ): Promise<TSwarmMessageStoreMessageId>;\n\n  /**\n   * Message removed from the database\n   * or marked as removed, It will not\n   * be accessed with iterator.\n   *\n   * @param dbName\n   * @param messageAddressOrKey - a message's key for a key value store.\n   * A message's address in the swarm for a non key value store.\n   * @returns {Promise<void>}\n   * @memberof ISwarmMessageStore\n   * @throws\n   */\n  deleteMessage(\n    dbName: string,\n    messageAddressOrKey: ISwarmMessageStoreDeleteMessageArg<P>\n  ): Promise<void>;\n  /**\n   * read all messages existing (not removed) in the database\n   * with the name provided.\n   *\n   * @param dbName\n   * @param messageAddress\n   * @returns {Promise<void>}\n   * @memberof ISwarmMessageStore\n   * @throws\n   */\n  collect(\n    dbName: string,\n    options: TSwarmStoreDatabaseIteratorMethodArgument<P, DbType>\n  ): Promise<(TSwarmMessageInstance | Error)[]>;\n\n  /**\n   * Collect messages with some metadata info.\n   *\n   * @param {string} dbName\n   * @param {TSwarmStoreDatabaseIteratorMethodArgument<P>} options\n   * @returns {Promise<(ISwarmMessageStoreMessagingRequestWithMetaResult<P> | undefined)[]>}\n   * @memberof ISwarmMessageStoreMessagingMethods\n   */\n  collectWithMeta(\n    dbName: string,\n    options: TSwarmStoreDatabaseIteratorMethodArgument<P, DbType>\n  ): Promise<\n    Array<ISwarmMessageStoreMessagingRequestWithMetaResult<P> | undefined>\n  >;\n}\n\n/**\n * Allows to write messages to the swarm storage\n * and creating a new swarm databases.\n *\n * @export\n * @interface ISwarmMessageStore\n * @extends {Omit<ISwarmStore<P>, 'connect'>}\n * @extends {EventEmitter<ISwarmMessageStoreEvents>}\n * @template P\n */\nexport interface ISwarmMessageStore<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>\n>\n  extends ISwarmStore<\n      P,\n      TSwarmMessageSerialized,\n      DbType,\n      ISwarmMessageStoreOptions<P>\n    >,\n    EventEmitter<ISwarmMessageStoreEvents>,\n    ISwarmMessageStoreMessagingMethods<P, DbType> {\n  /**\n   * connect to the swarm storage\n   *\n   * @param {ISwarmMessageStoreOptions<P>} options\n   * @returns {TSwarmMessageStoreConnectReturnType<P>}\n   * @memberof ISwarmMessageStore\n   * @throws\n   */\n  connect(\n    options: ISwarmMessageStoreOptions<P>\n  ): TSwarmMessageStoreConnectReturnType<P, DbType>;\n}\n","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-message-encrypted-cache.utils.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.ts",["2392","2393","2394","2395"],"import {\n  TSwarmMessgaeEncryptedCacheOptions,\n  ISwarmMessgaeEncryptedCache,\n} from './swarm-messgae-encrypted-cache.types';\nimport assert from 'assert';\nimport { ISecretStorage } from '../secret-storage-class/secret-storage-class.types';\nimport { SecretStorage } from '../secret-storage-class/secret-storage-class';\nimport { TSwarmMessageBodyRaw } from '../swarm-message/swarm-message-constructor.types';\nimport {\n  ISwarmMessgaeEncryptedCacheOptionsStorageProvider,\n  ISwarmMessgaeEncryptedCacheOptionsForStorageProvider,\n} from './swarm-messgae-encrypted-cache.types';\nimport {\n  SWARM_MESSGAE_ENCRYPTED_CACHE_DEFAULT_STORAGE_DATABASE_NAME,\n  SWARM_MESSGAE_ENCRYPTED_CACHE_DEFAULT_STORAGE_DATABASE_NAME_HASH,\n} from './swarm-messgae-encrypted-cache.const';\nimport { calculateHash } from '../../utils/hash-calculation-utils/hash-calculation-utils';\n\nexport class SwarmMessageEncryptedCache implements ISwarmMessgaeEncryptedCache {\n  public isRunning: boolean = false;\n\n  protected options?: TSwarmMessgaeEncryptedCacheOptions = undefined;\n\n  protected storageProvider?: ISecretStorage = undefined;\n\n  protected get dbNamePrefix() {\n    return (\n      (this.options as ISwarmMessgaeEncryptedCacheOptionsForStorageProvider)\n        ?.dbNamePrefix || ''\n    );\n  }\n\n  protected get dbName() {\n    return `${(this\n      .options as ISwarmMessgaeEncryptedCacheOptionsForStorageProvider)\n      ?.storageProviderOptions?.dbName ||\n      SWARM_MESSGAE_ENCRYPTED_CACHE_DEFAULT_STORAGE_DATABASE_NAME}`;\n  }\n\n  public async connect(options: TSwarmMessgaeEncryptedCacheOptions) {\n    this.setOptions(options);\n    await this.runStorageConnection();\n    this.setIsRunning();\n  }\n\n  /**\n   * Add value only if not exists in the storage\n   *\n   * @memberof SwarmMessageEncryptedCache\n   */\n  public add = async (sig: string, message: TSwarmMessageBodyRaw) => {\n    this.checkIsActive();\n\n    const value = message || null;\n    const result = await this.storageProvider!.insert(sig, value);\n\n    if (result instanceof Error) {\n      throw result;\n    }\n    return result;\n  };\n  public get = async (sig: string) => {\n    const result = await this.readValue(sig);\n\n    if (!result) {\n      return undefined;\n    }\n    return result;\n  };\n\n  public unset = async (sig: string) => {\n    this.checkIsActive();\n\n    const resutl = await this.storageProvider!.unset(sig);\n\n    if (resutl instanceof Error) {\n      throw resutl;\n    }\n  };\n\n  public async clearDb() {\n    const clearDbResult = await this.storageProvider?.clearDb();\n\n    if (clearDbResult instanceof Error) {\n      throw clearDbResult;\n    }\n  }\n\n  /**\n   * Set value INDEPENDENTLY whether it's exists or not.\n   * WARNING!. The 'add' method should be used for storing messages.\n   * This method may be used if the instance is used not for the messages.\n   * TODO - It's added only to the instance be capatible with IStorageCommon interface\n   *\n   * @memberof SwarmMessageEncryptedCache\n   */\n  public set = async (sig: string, message: TSwarmMessageBodyRaw) => {\n    this.checkIsActive();\n\n    const value = message || null;\n    const result = await this.storageProvider!.set(sig, value);\n\n    if (result instanceof Error) {\n      throw result;\n    }\n  };\n\n  protected setOptions(options: TSwarmMessgaeEncryptedCacheOptions) {\n    assert(options, 'Options must be provided');\n    assert(typeof options === 'object', 'Options must be an object');\n\n    const optsWithStorageProvider = options as ISwarmMessgaeEncryptedCacheOptionsStorageProvider;\n\n    if (optsWithStorageProvider.storageProvider) {\n      assert(\n        typeof optsWithStorageProvider.storageProvider === 'object',\n        'Storage provider must be an object'\n      );\n      assert(\n        typeof optsWithStorageProvider.storageProvider.connect === 'function' &&\n          typeof optsWithStorageProvider.storageProvider.get === 'function' &&\n          typeof optsWithStorageProvider.storageProvider.get === 'function',\n        'Storage provider provided is not valid'\n      );\n    } else {\n      const optsWithConfForStorageProviderConnection = options as ISwarmMessgaeEncryptedCacheOptionsForStorageProvider;\n\n      assert(\n        optsWithConfForStorageProviderConnection.storageProviderAuthOptions,\n        'Options for authorization to the storage provider must be provided'\n      );\n    }\n\n    this.options = options;\n  }\n\n  protected setStorageProvider(provider: ISecretStorage) {\n    this.storageProvider = provider;\n  }\n\n  protected async runStorageConnection() {\n    const { options } = this;\n    const optsWithStorageProvider = options as ISwarmMessgaeEncryptedCacheOptionsStorageProvider;\n\n    if (optsWithStorageProvider.storageProvider) {\n      this.setStorageProvider(optsWithStorageProvider.storageProvider);\n      return;\n    }\n\n    const optsWithConfForStorageProviderConnection = options as ISwarmMessgaeEncryptedCacheOptionsForStorageProvider;\n\n    if (!optsWithConfForStorageProviderConnection.storageProviderAuthOptions) {\n      throw new Error(\n        'Auth options was not provided to connect with the secret storage provider'\n      );\n    }\n\n    const {\n      storageProviderOptions,\n      storageProviderAuthOptions,\n    } = optsWithConfForStorageProviderConnection;\n\n    const storageProvider = new SecretStorage();\n    const dbName = await calculateHash(\n      this.dbName,\n      SWARM_MESSGAE_ENCRYPTED_CACHE_DEFAULT_STORAGE_DATABASE_NAME_HASH\n    );\n\n    if (dbName instanceof Error) {\n      console.error(\n        `Failed to calculate hash for the database name ${this.dbName}`\n      );\n      throw dbName;\n    }\n    await storageProvider.authorize(storageProviderAuthOptions, {\n      ...storageProviderOptions,\n      dbName,\n    });\n    this.setStorageProvider(storageProvider);\n  }\n\n  protected setIsRunning() {\n    this.isRunning = true;\n  }\n\n  protected checkIsActive() {\n    if (!this.isRunning) {\n      throw new Error('The instance is not running');\n    }\n    if (!this.storageProvider || !this.storageProvider.isActive) {\n      throw new Error('There is no running storage provider');\n    }\n    return true;\n  }\n\n  protected async readValue(\n    sig: string\n  ): Promise<TSwarmMessageBodyRaw | undefined | null> {\n    this.checkIsActive();\n\n    const result = await this.storageProvider!.get(sig);\n\n    if (result instanceof Error) {\n      throw result;\n    }\n    if (result === null) {\n      return undefined;\n    }\n    if (!result) {\n      return undefined;\n    }\n    if (typeof result !== 'string') {\n      throw new Error('There is a wrong result');\n    }\n    return result;\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class.types.ts",["2396","2397","2398"],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.ts",["2399"],"import OrbitDB from 'orbit-db';\nimport AccessController from 'orbit-db-access-controllers/src/access-controller-interface';\nimport {\n  SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_TYPE,\n  SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_LOG_PREFIX,\n} from './swarm-store-connector-orbit-db-subclass-access-controller.const';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions,\n  TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback,\n  ISwarmStoreConnectorOrbitDbDatabaseAccessControllerManifest,\n} from './swarm-store-connector-orbit-db-subclass-access-controller.types';\nimport { IdentityProvider } from 'orbit-db-identity-provider';\nimport { ESwarmStoreConnector } from '../../../../swarm-store-class.const';\nimport { EOrbitDbFeedStoreOperation } from '../swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { TSwarmStoreValueTypes } from '../../../../swarm-store-class.types';\n\nexport class SwarmStoreConnectorOrbitDBSubclassAccessController<\n  T extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>\n> extends AccessController {\n  // Returns the type of the access controller\n  public static get type(): string {\n    return SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_TYPE;\n  }\n  /**\n   * create and preload an instance\n   * of the SwarmStoreConnectorOrbitDBSubclassAccessController\n   *\n   * @static\n   * @template T\n   * @param {OrbitDB} orbitdb\n   * @param {ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T>} [options={}]\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  public static async create<\n    T extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>\n  >(\n    orbitdb: OrbitDB,\n    options: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T> = {}\n  ): Promise<SwarmStoreConnectorOrbitDBSubclassAccessController<T>> {\n    return new SwarmStoreConnectorOrbitDBSubclassAccessController<T>(\n      orbitdb,\n      options\n    );\n  }\n\n  // if true then anyone have access\n  // to the database\n  protected _isPublic: boolean = false;\n\n  protected _grantAccessCallback?: TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback<\n    ESwarmStoreConnector.OrbitDB,\n    T\n  >;\n\n  protected _orbitdb?: OrbitDB;\n\n  protected _options?: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<\n    T\n  >;\n\n  constructor(\n    orbitdb: OrbitDB,\n    options: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T> = {}\n  ) {\n    super();\n    this._orbitdb = orbitdb;\n    this.setOptions(options);\n  }\n\n  /**\n   * Called by the databases (the log) to see if entry should\n   * be allowed in the database. Return true if the entry is allowed,\n   * false is not allowed.\n   *\n   * @param {LogEntry<T>} entry\n   * @param {IdentityProvider} identityProvider\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  public async canAppend(\n    entry: LogEntry<T>,\n    identityProvider: IdentityProvider\n  ): Promise<boolean> {\n    if (!this.verifyEntryFormat(entry)) {\n      console.warn(\n        `${SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_LOG_PREFIX}::entry have an unknown format`\n      );\n      return false;\n    }\n\n    // Write keys and admins keys are allowed\n    const { _options, _isPublic } = this;\n\n    if (_isPublic) {\n      return this.checkAccess(entry, identityProvider);\n    }\n\n    if (!_options) {\n      return false;\n    }\n\n    const { identity } = entry;\n    const { id: userPerformedActionOnEntryId } = identity;\n    const { write: accessListForUsers } = _options;\n\n    // If the ACL contains the writer's public key or it contains '*'\n    if (\n      accessListForUsers &&\n      accessListForUsers.includes(userPerformedActionOnEntryId)\n    ) {\n      return this.checkAccess(entry, identityProvider);\n    }\n    return false;\n  }\n\n  /**\n   *  return manifest params\n   *\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  public async save(): Promise<\n    ISwarmStoreConnectorOrbitDbDatabaseAccessControllerManifest\n  > {\n    return {};\n  }\n\n  /**\n   * check if the entry have the common fields\n   * used to verfy the access on it\n   *\n   * @protected\n   * @param {LogEntry<T>} entry\n   * @returns {entry is LogEntry<T>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  protected verifyEntryFormat(entry: LogEntry<T>): entry is LogEntry<T> {\n    if (!entry || typeof entry !== 'object') {\n      return false;\n    }\n\n    const { identity, payload } = entry;\n    const { id } = identity;\n\n    if (!id) {\n      return false;\n    }\n    if (payload === undefined) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * validate the identiry provided by the entity\n   *\n   * @protected\n   * @param {IdentityJson} identity\n   * @returns {Promise<boolean>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  protected verifyIdentity(\n    identity: IdentityJson,\n    identityProvider: IdentityProvider\n  ): Promise<boolean> {\n    return (identityProvider as any).verifyIdentity(identity);\n  }\n\n  /**\n   * validate the entity format and\n   * check the access on it for the\n   * identity provided\n   *\n   * @protected\n   * @param {LogEntry<T>} entry\n   * @returns {Promise<boolean>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  protected async verifyEntity(entry: LogEntry<T>): Promise<boolean> {\n    if (!this.verifyEntryFormat(entry)) {\n      return false;\n    }\n\n    const { identity, payload } = entry;\n    const { value, key, op } = payload;\n    const { id } = identity;\n    const { _grantAccessCallback } = this;\n\n    if (typeof _grantAccessCallback === 'function') {\n      return _grantAccessCallback(\n        value,\n        id,\n        key,\n        op as EOrbitDbFeedStoreOperation | undefined\n      );\n    }\n    return true;\n  }\n\n  /**\n   * validates the enetry and verify the user have\n   * the access on it\n   *\n   * @protected\n   * @param {LogEntry<T>} entry\n   * @param {IdentityProvider} identityProvider\n   * @returns {Promise<boolean>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  protected async checkAccess(\n    entry: LogEntry<T>,\n    identityProvider: IdentityProvider\n  ): Promise<boolean> {\n    try {\n      if (!this.verifyEntryFormat(entry)) {\n        return false;\n      }\n\n      const { identity } = entry;\n      const validateIdentityResult = await this.verifyIdentity(\n        identity,\n        identityProvider\n      );\n\n      if (validateIdentityResult !== true) {\n        return false;\n      }\n      return this.verifyEntity(entry);\n    } catch (err) {\n      console.error(err);\n      return false;\n    }\n  }\n\n  protected setOptions(\n    options: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T>\n  ) {\n    if (options) {\n      const { write, grantAccess } = options;\n\n      if (write instanceof Array) {\n        if (write.includes('*')) {\n          this._isPublic = true;\n        }\n      } else {\n        console.warn(\n          `${SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_LOG_PREFIX}::Noone have access on the database`\n        );\n      }\n      if (typeof grantAccess === 'function') {\n        if (grantAccess.length !== 2) {\n          console.warn(\n            `${SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_LOG_PREFIX}::A grant access callback must receives 2 arguments generally, but receives ${grantAccess.length}`\n          );\n        }\n        this._grantAccessCallback = grantAccess;\n      }\n      this._options = options;\n    }\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.ts",["2400","2401","2402","2403","2404","2405","2406","2407"],"import * as orbitDbModule from 'orbit-db';\nimport OrbitDbFeedStore from 'orbit-db-feedstore';\nimport OrbitDbKeyValueStore from 'orbit-db-kvstore';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseOptions,\n  ISwarmStoreConnectorOrbitDbDatabaseEvents,\n  ISwarmStoreConnectorOrbitDbDatabaseValue,\n  ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions,\n  TSwarmStoreConnectorOrbitDbDatabaseEntityIndex,\n} from './swarm-store-connector-orbit-db-subclass-database.types';\nimport { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport {\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_LOG_PREFIX,\n  EOrbidDBFeedSoreEvents,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONFIGURATION,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_ENTITIES_LOAD_COUNT_DEFAULT,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_ITERATOR_OPTIONS_DEFAULT,\n} from './swarm-store-connector-orbit-db-subclass-database.const';\nimport {\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON,\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_OFF,\n} from 'const/common-values/common-values';\nimport { SwarmStoreConnectorOrbitDBSubclassAccessController } from '../swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller';\nimport { ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions } from '../swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.types';\nimport {\n  ESwarmStoreConnectorOrbitDbDatabaseIteratorOption,\n  TSwarmStoreConnectorOrbitDbDatabase,\n} from './swarm-store-connector-orbit-db-subclass-database.types';\nimport {\n  EOrbitDbFeedStoreOperation,\n  ESwarmStoreConnectorOrbitDbDatabaseType,\n} from './swarm-store-connector-orbit-db-subclass-database.const';\nimport {\n  ESwarmStoreEventNames,\n  ESwarmStoreConnector,\n} from '../../../../swarm-store-class.const';\nimport {\n  TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbLoad,\n  ISwarmStoreConnectorOrbitDbDatabaseIteratorOptionsRequired,\n} from './swarm-store-connector-orbit-db-subclass-database.types';\nimport {\n  ISwarmStoreConnectorRequestLoadAnswer,\n  TSwarmStoreDatabaseType,\n  TSwarmStoreValueTypes,\n} from '../../../../swarm-store-class.types';\nimport {\n  TSwarmStoreDatabaseEntityAddress,\n  TSwarmStoreDatabaseEntityKey,\n} from '../../../../swarm-store-class.types';\nimport { TSwarmStoreConnectorOrbitDbDatabaseStoreHash } from './swarm-store-connector-orbit-db-subclass-database.types';\nimport { SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_PRELOAD_COUNT_MIN } from './swarm-store-connector-orbit-db-subclass-database.const';\nimport {\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_EMIT_BATCH_INT_MS,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_EMIT_BATCH_SIZE,\n} from './swarm-store-connector-orbit-db-subclass-database.const';\nimport {\n  TSwarmStoreConnectorOrbitDbDatabaseAddMethodArgument,\n  TSwarmStoreConnectorOrbitDbDatabaseStoreKey,\n} from './swarm-store-connector-orbit-db-subclass-database.types';\n\nexport class SwarmStoreConnectorOrbitDBDatabase<\n  TStoreValue extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>,\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>\n> extends EventEmitter<\n  ISwarmStoreConnectorOrbitDbDatabaseEvents<\n    SwarmStoreConnectorOrbitDBDatabase<TStoreValue, DbType>,\n    TStoreValue\n  >\n> {\n  // is loaded fully and ready to use\n  public isReady: boolean = false;\n\n  // whether is closed\n  public isClosed: boolean = false;\n\n  // a name of the database\n  public dbName: string = '';\n\n  private isFullyLoaded: boolean = false;\n\n  private options?: ISwarmStoreConnectorOrbitDbDatabaseOptions<TStoreValue>;\n\n  protected orbitDb?: orbitDbModule.OrbitDB;\n\n  protected database?: TSwarmStoreConnectorOrbitDbDatabase<TStoreValue>;\n\n  protected preloadCount: number = SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_ENTITIES_LOAD_COUNT_DEFAULT;\n\n  protected newEntriesPending: [string, LogEntry<TStoreValue>, any][] = [];\n\n  /**\n   * set items overall count\n   *\n   * @protected\n   * @type {number}\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   */\n  protected itemsOverallCountInStorage: number = 0;\n\n  /**\n   * entries already received and emitted.\n   * { hash: signature }\n   *\n   * @protected\n   * @type {Record<string, string>}\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   */\n  protected entriesReceived: Record<string, string> = {};\n\n  protected get itemsCurrentlyLoaded() {\n    return Object.keys(this.entriesReceived).length;\n  }\n\n  protected get itemsOverallCount() {\n    return Math.max(this.itemsOverallCountInStorage, this.itemsCurrentlyLoaded);\n  }\n\n  protected dbType: ESwarmStoreConnectorOrbitDbDatabaseType =\n    ESwarmStoreConnectorOrbitDbDatabaseType.FEED;\n\n  protected emitBatchesInterval?: NodeJS.Timer;\n\n  protected get isKVStore() {\n    return this.dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE;\n  }\n\n  constructor(\n    options: ISwarmStoreConnectorOrbitDbDatabaseOptions<TStoreValue>,\n    orbitDb: orbitDbModule.OrbitDB\n  ) {\n    super();\n    this.setOptions(options);\n    this.setOrbitDbInstance(orbitDb);\n  }\n\n  public connect = async (): Promise<Error | void> => {\n    const dbStore = await this.createDb();\n\n    if (dbStore instanceof Error) {\n      console.error(dbStore);\n      return new Error('Failed to create a new database instance');\n    }\n\n    const loadDbResult = await dbStore.load(this.preloadCount);\n\n    if ((loadDbResult as unknown) instanceof Error) {\n      console.error(loadDbResult);\n      return this.onFatalError(\n        'The fatal error has occurred on databse loading',\n        'connect'\n      );\n    }\n  };\n\n  public close = async (opt?: any): Promise<Error | void> => {\n    this.unsetAllListenersForEvents();\n    this.unsetReadyState();\n    this.resetEntriesPending();\n    this.resetEntriesReceived();\n    this.unsetEmithBatchInterval();\n    this.resetItemsOverall();\n    this.isClosed = true;\n\n    let result: undefined | Error;\n\n    try {\n      const closeCurrentStoreResult = await this.closeCurrentStore();\n\n      if (closeCurrentStoreResult instanceof Error) {\n        result = closeCurrentStoreResult;\n      }\n    } catch (err) {\n      result = err;\n    }\n    this.emitEvent(ESwarmStoreEventNames.CLOSE, this);\n    return result;\n  };\n\n  public add = async (\n    addArg: TSwarmStoreConnectorOrbitDbDatabaseAddMethodArgument<TStoreValue>\n  ): Promise<string | Error> => {\n    const { value, key } = addArg;\n    const database = this.getDbStoreInstance();\n\n    if (database instanceof Error) {\n      return database;\n    }\n    try {\n      let hash: TSwarmStoreConnectorOrbitDbDatabaseStoreHash;\n      if (this.isKVStore) {\n        if (!key) {\n          return new Error('Key must be provided for the key-value storage');\n        }\n        /*\n         TODO - https://github.com/orbitdb/orbit-db/blob/master/API.md#setkey-value.\n         the 'set' method returns hash of entry added\n        */\n        hash = ((await (database as OrbitDbKeyValueStore<TStoreValue>).set(\n          key,\n          value\n        )) as unknown) as TSwarmStoreConnectorOrbitDbDatabaseStoreHash;\n      } else {\n        hash = await (database as OrbitDbFeedStore<TStoreValue>).add(value);\n      }\n      console.log(`ADDED DATA WITH HASH -- ${hash}`);\n      if (typeof hash !== 'string') {\n        return new Error(\n          'An unknown type of hash was returned for the value stored'\n        );\n      }\n      return hash;\n    } catch (err) {\n      console.trace(err);\n      return err;\n    }\n  };\n\n  /**\n   * for the key value store a key must be used.\n   * for the feed store a hash of the value\n   * must be used.\n   *\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   */\n  public get = async (\n    keyOrHash: TSwarmStoreConnectorOrbitDbDatabaseEntityIndex\n  ): Promise<\n    Error | ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValue> | undefined\n  > => {\n    const entryRaw = this.readRawEntry(keyOrHash);\n\n    if (!entryRaw || entryRaw instanceof Error) {\n      return entryRaw;\n    }\n    try {\n      if (this.isKVStore) {\n        if (entryRaw.payload.key !== keyOrHash) {\n          return undefined;\n        }\n      } else if (entryRaw.hash !== keyOrHash) {\n        return undefined;\n      }\n      return entryRaw;\n    } catch (err) {\n      return err;\n    }\n    return undefined;\n  };\n\n  /**\n   * Remove a value located in the key provided if it is a key value\n   * database.\n   * Remove an entry by it's address for a non key-value database.\n   *\n   * @param {TSwarmStoreConnectorOrbitDbDatabaseEntityIndex} keyOrEntryAddress - key of a value for key-value store or entry address.\n   * @returns {(Promise<Error | void>)}\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   */\n  public async remove(\n    keyOrEntryAddress: TSwarmStoreConnectorOrbitDbDatabaseEntityIndex\n  ): Promise<Error | void> {\n    try {\n      await (this.isKVStore\n        ? this.removeKeyKVStore(keyOrEntryAddress)\n        : this.removeEntry(keyOrEntryAddress));\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public iterator = async (\n    options?: ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<DbType>\n  ): Promise<\n    | Error\n    | Array<\n        | ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValue>\n        | Error\n        | undefined\n      >\n  > => {\n    return this.isKVStore\n      ? this.iteratorKeyValueStore(options)\n      : this.iteratorFeedStore(options);\n  };\n\n  public drop = async () => {\n    const database = this.getDbStoreInstance();\n\n    if (database instanceof Error) {\n      return database;\n    }\n    this.unsetAllListenersForEvents();\n    try {\n      await database.drop();\n    } catch (err) {\n      return err;\n    }\n  };\n\n  /**\n   * returns a count of an items loaded or Error\n   *\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   */\n  public load = async (\n    count: TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbLoad\n  ): Promise<ISwarmStoreConnectorRequestLoadAnswer | Error> => {\n    return this._load(this.itemsCurrentlyLoaded + count);\n  };\n\n  public parseValueStored = (\n    e: LogEntry<TStoreValue>\n  ):\n    | {\n        id: LogEntry<TStoreValue>['identity']['id'];\n        value: LogEntry<TStoreValue>['payload']['value'];\n        key: LogEntry<TStoreValue>['payload']['key'];\n        hash: LogEntry<TStoreValue>['hash'];\n      }\n    | Error\n    | undefined => {\n    const { payload, identity, hash } = e;\n\n    if (payload) {\n      if (payload.op === EOrbitDbFeedStoreOperation.DELETE) {\n        return undefined;\n      }\n      return {\n        id: identity.id,\n        value: payload.value,\n        hash,\n        key: this.isKVStore ? payload.key : undefined,\n      };\n    } else {\n      return new Error('An unknown fromat of the data stored');\n    }\n  };\n\n  protected createDb(): Promise<\n    Error | TSwarmStoreConnectorOrbitDbDatabase<TStoreValue>\n  > {\n    this.unsetReadyState();\n    return this.createDbInstance();\n  }\n\n  protected async restartDbInstanceSilent(): Promise<\n    Error | TSwarmStoreConnectorOrbitDbDatabase<TStoreValue>\n  > {\n    const db = this.getDbStoreInstance();\n\n    if (!db) {\n      return new Error('There is no an active database instance');\n    }\n    if (db instanceof Error) {\n      return db;\n    }\n    this.unsetAllListenersForEvents();\n\n    const result = await this.closeInstanceOfStore(db);\n\n    if (result instanceof Error) {\n      console.error('Failed to close the instance of store');\n      return result;\n    }\n    return this.createDbInstance();\n  }\n\n  protected setItemsOverallCount(total: number) {\n    this.itemsOverallCountInStorage = Math.max(\n      this.itemsOverallCountInStorage,\n      total\n    );\n    console.log('total number of entries', total);\n  }\n\n  /**\n   * increment the overall count by 1\n   *\n   * @protected\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   */\n  protected incItemsOverallCount() {\n    this.itemsOverallCountInStorage++;\n  }\n\n  protected resetItemsOverall() {\n    this.itemsOverallCountInStorage = 0;\n  }\n\n  /**\n   * returns a count of an items loaded or Error\n   *\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   */\n  protected _load = async (\n    count: TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbLoad\n  ): Promise<ISwarmStoreConnectorRequestLoadAnswer | Error> => {\n    const itemsLoaded = this.itemsCurrentlyLoaded;\n\n    if (count) {\n      const dbInstance = await this.restartDbInstanceSilent();\n\n      if (dbInstance instanceof Error) {\n        console.error('Failed to restart the database');\n        return dbInstance;\n      }\n      await dbInstance.load(count);\n      debugger;\n    }\n    return {\n      count: this.itemsCurrentlyLoaded - itemsLoaded,\n      loadedCount: this.itemsCurrentlyLoaded,\n      overallCount: this.itemsOverallCount,\n    };\n  };\n\n  protected getLodEntryHash(\n    logEntry: LogEntry<TStoreValue>\n  ): TSwarmStoreDatabaseEntityAddress<ESwarmStoreConnector.OrbitDB> {\n    return logEntry.hash;\n  }\n\n  /**\n   * Read a value stored in the database storage\n   * by key or value unique hash\n   *\n   * @protected\n   * @param {TSwarmStoreConnectorOrbitDbDatabaseEntityIndex} keyOrHash\n   * @returns {(TStoreValue\n   *     | LogEntry<TStoreValue>\n   *     | Error\n   *     | undefined)}\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   */\n  protected readRawValueFromStorage = (\n    keyOrHash: TSwarmStoreConnectorOrbitDbDatabaseEntityIndex\n  ): TStoreValue | LogEntry<TStoreValue> | Error | undefined => {\n    const database = this.getDbStoreInstance();\n\n    if (database instanceof Error) {\n      return new Error(`Failed to get database insatane: ${database.message}`);\n    }\n\n    const entryRawOrStoreValue = database.get(keyOrHash) as\n      | TStoreValue\n      | LogEntry<TStoreValue>\n      | Error\n      | undefined;\n\n    return entryRawOrStoreValue;\n  };\n\n  /**\n   * Read the raw entry from the database\n   *\n   * @protected\n   * @param {TSwarmStoreConnectorOrbitDbDatabaseEntityIndex} keyOrHash\n   * @returns {(TStoreValue\n   *     | LogEntry<TStoreValue>\n   *     | Error\n   *     | undefined)}\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   */\n  protected readRawEntry = (\n    keyOrHash: TSwarmStoreConnectorOrbitDbDatabaseEntityIndex\n  ): LogEntry<TStoreValue> | Error | undefined => {\n    try {\n      const entryRawOrStoreValue = this.readRawValueFromStorage(keyOrHash);\n      const entryRaw = (entryRawOrStoreValue && this.isKVStore\n        ? this.findInOplog(keyOrHash, entryRawOrStoreValue as TStoreValue)\n        : entryRawOrStoreValue) as LogEntry<TStoreValue> | Error | undefined;\n\n      if (entryRaw instanceof Error) {\n        return new Error('An error has occurred on get the data from the key');\n      }\n      return entryRaw;\n    } catch (err) {\n      return new Error(\n        `Failed to read a raw entry from the databse: ${err.message}`\n      );\n    }\n  };\n\n  protected findInOplog(\n    key: TSwarmStoreConnectorOrbitDbDatabaseStoreKey,\n    value: TStoreValue\n  ): LogEntry<TStoreValue> | undefined | Error {\n    const db = this.getDbStoreInstance();\n\n    if (db instanceof Error) {\n      return db;\n    }\n\n    return ((db as any)._oplog.values as LogEntry<TStoreValue>[]).find(\n      (entry) => {\n        const pld = entry?.payload;\n        return (\n          pld?.op === EOrbitDbFeedStoreOperation.PUT && pld?.value === value\n        );\n      }\n    );\n  }\n\n  protected filterRequltsFeedStore = (\n    logEntriesList: Array<LogEntry<TStoreValue>>,\n    filterOptions: ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<DbType>\n  ): Array<LogEntry<TStoreValue>> => {\n    const { gt, gte, lt, lte, neq } = filterOptions;\n\n    if (!gt && !gte && !lt && !lte && !neq) {\n      return logEntriesList;\n    }\n    return logEntriesList.filter((logEntry) => {\n      const logEntryHash = this.getLodEntryHash(logEntry);\n\n      if (neq) {\n        if (neq instanceof Array) {\n          return !(neq as TSwarmStoreDatabaseEntityAddress<\n            ESwarmStoreConnector.OrbitDB\n          >[]).includes(logEntryHash);\n        }\n        return neq !== logEntryHash;\n      } else if (gte && logEntryHash >= gte) {\n        return true;\n      } else if (gt && logEntryHash > gt) {\n        return true;\n      } else if (lte && logEntryHash <= lte) {\n        return true;\n      } else if (lt && logEntryHash < lt) {\n        return true;\n      }\n      return false;\n    });\n  };\n\n  protected async preloadEntitiesBeforeIterate(count: number): Promise<void> {\n    if (count && Number(count) > this.itemsCurrentlyLoaded) {\n      // before to query the database entities must be preloaded in memory\n      await this._load(count);\n    }\n  }\n\n  protected async iteratorFeedStore(\n    options?: ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<DbType>\n  ): Promise<\n    | Error\n    | Array<\n        | ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValue>\n        | Error\n        | undefined\n      >\n  > {\n    const iteratorOptionsRes =\n      options ||\n      SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_ITERATOR_OPTIONS_DEFAULT;\n    let limit = iteratorOptionsRes.limit;\n\n    if (typeof limit !== 'number' || limit < 0) {\n      limit = undefined;\n    }\n    // before to query the database entities must be preloaded in memory\n    limit && (await this.preloadEntitiesBeforeIterate(limit));\n    debugger;\n    const eqOperand =\n      options?.[ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.eq];\n    // database instance can become another one after load() method call\n    const database = this.getDbStoreInstance() as OrbitDbFeedStore<TStoreValue>;\n\n    if (database instanceof Error) {\n      return database;\n    }\n    if (eqOperand) {\n      // if the equal operand passed within the argument\n      // return just values queried by it and\n      // ignore all other operators.\n      return this.getValues(eqOperand, database);\n    }\n\n    let result = database.iterator(iteratorOptionsRes).collect();\n\n    if (options) {\n      result = this.filterRequltsFeedStore(result, options);\n      debugger;\n    }\n    debugger;\n    return result;\n  }\n\n  protected async iteratorKeyValueStore(\n    options?: ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<DbType>\n  ): Promise<\n    | Error\n    | Array<\n        | ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValue>\n        | Error\n        | undefined\n      >\n  > {\n    // TODO - check it works\n    const iteratorOptionsRes =\n      options ||\n      SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_ITERATOR_OPTIONS_DEFAULT;\n    let limit = iteratorOptionsRes.limit;\n\n    if (typeof limit !== 'number' || limit < 0) {\n      limit = undefined;\n    }\n    // before to query the database entities must be preloaded in memory\n    limit && (await this.preloadEntitiesBeforeIterate(limit));\n    debugger;\n    const eqOperand =\n      options?.[ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.eq];\n\n    if (eqOperand) {\n      // if the equal operand passed within the argument\n      // return just values queried by it and\n      // ignore all other operators.\n      return this.getEqual(eqOperand);\n    }\n    // database instance can become another one after the load() method call\n    const database = this.getDbStoreInstance() as OrbitDbKeyValueStore<\n      TStoreValue\n    >;\n    if (database instanceof Error) {\n      return database;\n    }\n    const keys = Object.keys(database.all);\n\n    const {\n      reverse,\n    } = iteratorOptionsRes as ISwarmStoreConnectorOrbitDbDatabaseIteratorOptionsRequired<\n      DbType\n    >;\n    let keysList = (reverse ? keys.reverse() : keys).slice(0, limit);\n\n    keysList = this.filterKeys(keysList, iteratorOptionsRes);\n    return this.getValuesForKeys(keysList);\n  }\n\n  protected getEqual = async (\n    eqOperand: string | string[]\n  ): Promise<\n    | Error\n    | Array<\n        | ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValue>\n        | Error\n        | undefined\n      >\n  > => {\n    if (eqOperand instanceof Array) {\n      return Promise.all(eqOperand.map(this.get));\n    }\n    return [await this.get(eqOperand)];\n  };\n\n  protected filterKeys = (\n    keysList: string[],\n    filterOptions: ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<DbType>\n  ): string[] => {\n    const { gt, gte, lt, lte, neq } = filterOptions;\n\n    if (!gt && !gte && !lt && !lte && !neq) {\n      return keysList;\n    }\n    return keysList.filter((key) => {\n      if (neq) {\n        if (neq instanceof Array) {\n          return !(neq as TSwarmStoreDatabaseEntityKey<\n            ESwarmStoreConnector.OrbitDB\n          >[]).includes(key);\n        }\n        return neq !== key;\n      } else if (gte && key >= gte) {\n        return true;\n      } else if (gt && key > gt) {\n        return true;\n      } else if (lte && key <= lte) {\n        return true;\n      } else if (lt && key < lt) {\n        return true;\n      }\n      return false;\n    });\n  };\n\n  protected getValuesForKeys = (\n    keys: string[]\n  ): Promise<\n    | Error\n    | Array<\n        | ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValue>\n        | Error\n        | undefined\n      >\n  > => Promise.all(keys.map(this.readRawEntry)) as any;\n\n  protected getValues(\n    hash: string | string[],\n    database: OrbitDbFeedStore<TStoreValue>\n  ): Promise<\n    Array<\n      ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValue> | Error | undefined\n    >\n  > {\n    const pending =\n      typeof hash === 'string'\n        ? [this.get(hash)]\n        : hash.map((h) => this.get(h));\n\n    return Promise.all(pending);\n  }\n\n  private getDbStoreInstance():\n    | Error\n    | TSwarmStoreConnectorOrbitDbDatabase<TStoreValue> {\n    const { isReady, database } = this;\n\n    if (!isReady) {\n      return new Error('The store is not ready to use');\n    }\n    if (!database) {\n      return this.emitError('The database store instance is empty');\n    }\n    return database;\n  }\n\n  private setReadyState(isReady: boolean = true) {\n    this.isReady = isReady;\n  }\n\n  private unsetReadyState() {\n    this.setReadyState(false);\n  }\n\n  protected unsetAllListenersForEvents = () => {\n    if (this.database) {\n      this.unsetStoreEventListeners(this.database);\n    }\n  };\n\n  protected emitError(\n    error: Error | string,\n    mehodName?: string,\n    isFatal: boolean = false\n  ): Error {\n    const err = typeof error === 'string' ? new Error() : error;\n    const eventName = isFatal\n      ? ESwarmStoreEventNames.FATAL\n      : ESwarmStoreEventNames.ERROR;\n\n    console.error(\n      `${SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_LOG_PREFIX}::error${\n        mehodName ? `::${mehodName}` : ''\n      }`,\n      err\n    );\n    this.emit(eventName, err);\n    return err;\n  }\n\n  protected onFatalError(error: Error | string, methodName: string) {\n    this.unsetReadyState();\n    this.emitError(error, methodName, true);\n\n    const { isClosed } = this;\n\n    if (!isClosed) {\n      this.close();\n    }\n    return this.emitError(\n      'The database closed cause a fatal error',\n      methodName,\n      true\n    );\n  }\n\n  protected emitEvent(event: ESwarmStoreEventNames, ...args: any[]) {\n    const { options } = this;\n\n    if (!options) {\n      throw new Error('Options are not exists');\n    }\n\n    const { dbName } = options;\n\n    this.emit(event, dbName, ...args);\n  }\n\n  private getStoreOptions(): IStoreOptions | undefined | Error {\n    return SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONFIGURATION;\n  }\n\n  private emitFullyLoaded() {\n    if (!this.isFullyLoaded) {\n      this.isFullyLoaded = true;\n      this.emitEvent(ESwarmStoreEventNames.LOADING, 100);\n    }\n  }\n\n  /**\n   * Deletes the Object associated with key.\n   * Returns a Promise that resolves to a String that is the multihash of the deleted entry.\n   *\n   * @protected\n   * @param {TSwarmStoreConnectorOrbitDbDatabaseEntityIndex} key - key of a value\n   * @returns {(Promise<Error | void>)}\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   * @throws\n   */\n  protected async removeKeyKVStore(\n    key: TSwarmStoreConnectorOrbitDbDatabaseEntityIndex\n  ): Promise<void> {\n    const database = this.getDbStoreInstance() as OrbitDbKeyValueStore<\n      TStoreValue\n    >;\n\n    if (database instanceof Error) {\n      throw database;\n    }\n    try {\n      const hashRemoved = await database.del(key);\n\n      if (typeof hashRemoved !== 'string') {\n        throw new Error(\n          'An unknown type of hash was returned for the value removed'\n        );\n      }\n    } catch (err) {\n      console.error(err);\n      throw new Error(\n        `Failed to remove an object by the key ${key}: ${err.message}`\n      );\n    }\n  }\n\n  /**\n   * Remove an entry by it's address provided\n   *\n   * @param {TSwarmStoreConnectorOrbitDbDatabaseEntityIndex} entryAddress\n   * @returns {(Promise<Error | void>)}\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   * @throws\n   */\n  public async removeEntry(\n    entryAddress: TSwarmStoreConnectorOrbitDbDatabaseEntityIndex\n  ): Promise<Error | void> {\n    const database = this.getDbStoreInstance() as OrbitDbFeedStore<TStoreValue>;\n\n    if (database instanceof Error) {\n      throw database;\n    }\n    try {\n      await database.remove(entryAddress);\n    } catch (err) {\n      console.error(err);\n      return new Error(\n        `Failed to remove an entry by the address ${entryAddress}: ${err.message}`\n      );\n    }\n  }\n\n  protected logStore = () => {\n    // TODO\n    // const database = this.getDbStoreInstance();\n    // const posts = database!.iterator({ limit: -1 }).collect();\n    // console.log('STORE::READY--');\n    // posts.forEach((post: any) => {\n    //   if (post && post.identity) {\n    //     console.log(post.identity.id);\n    //   }\n    // });\n    // console.log('--STORE::READY');\n  };\n\n  private emitNewEntry = (\n    address: string,\n    entry: LogEntry<TStoreValue>,\n    heads: any\n  ) => {\n    console.log('emit new entry', {\n      address,\n      entry,\n      heads,\n      itemsCurrentlyLoaded: this.itemsCurrentlyLoaded,\n      itemsOverallCount: this.itemsOverallCount,\n    });\n    this.emit(ESwarmStoreEventNames.NEW_ENTRY, [\n      this.dbName,\n      entry,\n      address,\n      heads,\n      this.dbType,\n      this,\n    ]);\n  };\n\n  private emitEmtriesPending() {\n    this.startEmitBatchesInterval();\n  }\n\n  /**\n   * check was the message received\n   *\n   * @private\n   * @param {LogEntry<TStoreValue>} entry\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   */\n  private checkWasEntryReceived(entry: LogEntry<TStoreValue>) {\n    return this.entriesReceived[entry.hash] === entry.sig;\n  }\n\n  private addMessageToReceivedMessages(entry: LogEntry<TStoreValue>) {\n    if (!this.checkWasEntryReceived(entry)) {\n      this.entriesReceived[entry.hash] = entry.sig;\n    }\n  }\n\n  private resetEntriesReceived() {\n    this.entriesReceived = {};\n  }\n\n  private resetEntriesPending() {\n    this.newEntriesPending = [];\n  }\n\n  private handleNewEntry = (\n    address: string,\n    entry: LogEntry<TStoreValue>,\n    heads: any\n  ) => {\n    if (!this.checkWasEntryReceived(entry)) {\n      this.newEntriesPending.push([address, entry, heads]);\n      this.addMessageToReceivedMessages(entry);\n    }\n  };\n\n  private handleFeedStoreReady = () => {\n    this.emitFullyLoaded();\n    this.setReadyState();\n    this.emitEvent(ESwarmStoreEventNames.READY);\n    this.logStore();\n    this.emitEmtriesPending();\n  };\n\n  private handleFeedStoreLoaded = () => {\n    // emit event that the database local copy was fully loaded\n    // this.emitFullyLoaded();\n  };\n\n  private handleFeedStoreLoadProgress = (\n    address: string,\n    hash: string,\n    entry: LogEntry<TStoreValue>,\n    progress: number,\n    total: number\n  ) => {\n    this.setItemsOverallCount(total);\n    this.handleNewEntry(address, entry, {});\n    // emit event database local copy loading progress\n    this.emitEvent(\n      ESwarmStoreEventNames.LOADING,\n      (progress / (this.preloadCount <= 0 ? total : this.preloadCount)) * 100\n    );\n  };\n\n  private handleFeedStoreReplicated = () => {\n    // emit event that the db updated, cause it\n    // was replicated with another peer db copy\n    const { dbName } = this;\n    console.log('REPLICATED', { dbName });\n    this.emitEvent(ESwarmStoreEventNames.UPDATE, dbName);\n    this.logStore();\n    this.emitEmtriesPending();\n  };\n\n  private handleFeedStoreClosed = () => {\n    const { isClosed } = this;\n\n    if (!isClosed) {\n      this.unsetReadyState();\n      this.emitError(\n        'The instance was closed unexpected',\n        'handleFeedStoreClosed'\n      );\n      this.restartStore();\n    }\n  };\n\n  private async closeInstanceOfStore(\n    storeInstance: TSwarmStoreConnectorOrbitDbDatabase<TStoreValue>\n  ): Promise<Error | void> {\n    if (!storeInstance) {\n      return new Error('An instance of the store must be specified');\n    }\n    this.unsetStoreEventListeners(storeInstance);\n    try {\n      await storeInstance.close();\n    } catch (err) {\n      console.error(err);\n      return new Error(\n        'Fatal error has occurred on close the instance of the Feed store'\n      );\n    }\n  }\n\n  private async closeCurrentStore(): Promise<Error | void> {\n    const { database } = this;\n\n    if (database) {\n      const closeStoreResult = await this.closeInstanceOfStore(database);\n\n      if (closeStoreResult instanceof Error) {\n        console.error(closeStoreResult);\n        return new Error(\n          'Failed to close the current instance of the Database store'\n        );\n      }\n      this.database = undefined;\n    }\n  }\n\n  // restart the store\n  private async restartStore(): Promise<Error | void> {\n    const { isClosed } = this;\n\n    if (isClosed) {\n      return new Error('The store was closed previousely');\n    }\n\n    const currentStoreStopResult = await this.closeCurrentStore();\n\n    if (currentStoreStopResult instanceof Error) {\n      console.error(currentStoreStopResult);\n      return this.onFatalError(\n        'Failed to restart the Database cause failed to close the store instance',\n        'restartStore'\n      );\n    }\n    return this.connect();\n  }\n\n  private handleFeedStoreReplicateInProgress = (\n    address: string,\n    hash: string,\n    entry: LogEntry<TStoreValue>,\n    progress: number,\n    have: unknown\n  ) => {\n    console.warn(`handleFeedStoreReplicateInProgress::\n      addr: ${address}\n      hash: ${hash}\n      progress: ${progress}\n    `);\n    this.logStore();\n    this.handleNewEntry(address, entry, {});\n  };\n\n  private handleWrite = (\n    address: string,\n    entry: LogEntry<TStoreValue>,\n    heads: any\n  ) => {\n    this.incItemsOverallCount(); // this must be called before the handleNewEntry,\n    // otherwise doubling of the overall count will be caused\n    this.handleNewEntry(address, entry, heads);\n  };\n\n  private setFeedStoreEventListeners(\n    feedStore: TSwarmStoreConnectorOrbitDbDatabase<TStoreValue>,\n    isSet = true\n  ): Error | void {\n    if (!feedStore) {\n      return new Error('An instance of the FeedStore must be specified');\n    }\n    if (!feedStore.events) {\n      return new Error('An unknown API of the FeedStore');\n    }\n    if (\n      typeof feedStore.events.addListener !== 'function' ||\n      typeof feedStore.events.removeListener !== 'function'\n    ) {\n      return new Error('An unknown API of the FeedStore events');\n    }\n\n    const methodName = isSet\n      ? COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON\n      : COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_OFF;\n\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.READY,\n      this.handleFeedStoreReady\n    );\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.LOAD,\n      this.handleFeedStoreLoaded\n    );\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.LOAD_PROGRESS,\n      this.handleFeedStoreLoadProgress\n    );\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.REPLICATED,\n      this.handleFeedStoreReplicated\n    );\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.CLOSE,\n      this.handleFeedStoreClosed\n    );\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.REPLICATE_PROGRESS,\n      this.handleFeedStoreReplicateInProgress\n    );\n    feedStore.events[methodName](\n      EOrbidDBFeedSoreEvents.WRITE,\n      this.handleWrite\n    );\n  }\n\n  private unsetStoreEventListeners(\n    feedStore: TSwarmStoreConnectorOrbitDbDatabase<TStoreValue>\n  ) {\n    this.setFeedStoreEventListeners(feedStore, false);\n  }\n\n  private getAccessControllerOptions(): ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<\n    TStoreValue\n  > {\n    const { options } = this;\n    const resultedOptions: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<TStoreValue> = {\n      type: SwarmStoreConnectorOrbitDBSubclassAccessController.type,\n    };\n\n    if (!options) {\n      return resultedOptions;\n    }\n\n    const { isPublic, write, grantAccess } = options;\n\n    if (isPublic) {\n      resultedOptions.write = ['*'];\n    } else if (write instanceof Array) {\n      resultedOptions.write = write.filter(\n        (identity) => identity && typeof identity === 'string'\n      );\n    }\n    if (typeof grantAccess === 'function') {\n      if (grantAccess.length !== 2) {\n        console.warn(\n          'The grant access callback function must have 2 arguments'\n        );\n      }\n      resultedOptions.grantAccess = grantAccess;\n    }\n    return resultedOptions;\n  }\n\n  private async createDbInstance(): Promise<\n    Error | TSwarmStoreConnectorOrbitDbDatabase<TStoreValue>\n  > {\n    try {\n      const { orbitDb, options } = this;\n\n      if (!orbitDb) {\n        return this.onFatalError(\n          'There is no intance of the OrbitDb is specified',\n          'createDbInstance'\n        );\n      }\n\n      if (!options) {\n        throw new Error('Options are not defined');\n      }\n\n      const { dbName } = options;\n\n      if (!dbName) {\n        return this.onFatalError(\n          'A name of the database must be specified',\n          'createDbInstance'\n        );\n      }\n\n      const dbStoreOptions = this.getStoreOptions();\n\n      if (dbStoreOptions instanceof Error) {\n        return this.onFatalError(\n          dbStoreOptions,\n          'createDbInstance::getStoreOptions'\n        );\n      }\n\n      const storeOptions = {\n        ...SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONFIGURATION,\n        accessController: this.getAccessControllerOptions(),\n      };\n      const db: Error | TSwarmStoreConnectorOrbitDbDatabase<TStoreValue> = this\n        .isKVStore\n        ? await orbitDb.keyvalue(dbName, storeOptions)\n        : await orbitDb.feed(dbName, storeOptions);\n\n      if (db instanceof Error) {\n        return this.onFatalError(db, 'createDbInstance::feed store creation');\n      }\n\n      const setStoreListenersResult = this.setFeedStoreEventListeners(db);\n\n      if (setStoreListenersResult instanceof Error) {\n        return this.onFatalError(\n          setStoreListenersResult,\n          'createDbInstance::set feed store listeners'\n        );\n      }\n      this.database = db;\n      return db;\n    } catch (err) {\n      return this.onFatalError(err, 'createDbInstance');\n    }\n  }\n\n  private setOptions(\n    options: ISwarmStoreConnectorOrbitDbDatabaseOptions<TStoreValue>\n  ): void | Error {\n    if (!options) {\n      return this.onFatalError('Options must be specified', 'setOptions');\n    }\n\n    const { dbName, preloadCount, dbType } = options;\n\n    if (typeof dbName !== 'string') {\n      return this.onFatalError(\n        'A name of the database must be specified',\n        'setOptions'\n      );\n    }\n    if (preloadCount && typeof preloadCount !== 'number') {\n      return this.onFatalError('Preload count must be number', 'setOptions');\n    }\n    // preloadCount must not be 0.\n    // If it's equals to 0, the database not firing events which\n    // are necessary for the application to continue the work with\n    // the database.\n    this.preloadCount =\n      (preloadCount ? preloadCount : undefined) ||\n      SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_PRELOAD_COUNT_MIN;\n    if (dbType) {\n      if (\n        !Object.values(ESwarmStoreConnectorOrbitDbDatabaseType).includes(dbType)\n      ) {\n        return this.onFatalError('An unknown db store type', 'setOptions');\n      }\n      this.dbType = dbType;\n    }\n    this.options = options;\n    this.dbName = dbName;\n  }\n\n  private setOrbitDbInstance(orbitDb: orbitDbModule.OrbitDB): void | Error {\n    if (!orbitDb) {\n      return this.onFatalError(\n        'An instance of orbit db must be specified',\n        'setOrbitDbInstance'\n      );\n    }\n    this.orbitDb = orbitDb;\n  }\n\n  private emitEntries = (\n    batchSize: number = SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_EMIT_BATCH_SIZE\n  ) => {\n    console.log('newEntriesPending count', this.newEntriesPending.length, {\n      itemsCurrentlyLoaded: this.itemsCurrentlyLoaded,\n      itemsOverallCount: this.itemsOverallCount,\n    });\n    if (this.newEntriesPending.length) {\n      this.newEntriesPending\n        .splice(0, batchSize)\n        .forEach((newEntry) => newEntry && this.emitNewEntry(...newEntry));\n    }\n  };\n\n  private emitBatch = () => {\n    this.emitEntries();\n  };\n\n  private startEmitBatchesInterval() {\n    this.emitBatchesInterval = setInterval(\n      this.emitBatch,\n      SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_EMIT_BATCH_INT_MS\n    );\n  }\n\n  private unsetEmithBatchInterval() {\n    if (this.emitBatchesInterval) {\n      clearInterval(this.emitBatchesInterval);\n    }\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types.ts",["2408","2409"],"import {\n  ISwarmStoreDatabaseBaseOptions,\n  TSwarmStoreValueTypes,\n} from '../../../../swarm-store-class.types';\nimport {\n  ESwarmStoreEventNames,\n  ESwarmStoreConnector,\n} from '../../../../swarm-store-class.const';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from './swarm-store-connector-orbit-db-subclass-database.const';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseAccessControlleGrantCallback,\n  ISwarmStoreConnectorOrbitDbAccessConrotllerOrbitDBStandardOptionsWriteAccess,\n} from '../swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.types';\nimport OrbitDbFeedStore from 'orbit-db-feedstore';\nimport OrbitDbKeyValueStore from 'orbit-db-kvstore';\nimport {\n  TSwarmStoreDatabaseEntityUniqueIndex,\n  TSwarmStoreDatabaseType,\n} from '../../../../swarm-store-class.types';\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseStoreHash = string;\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseStoreKey = string;\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseEntityIndex =\n  | TSwarmStoreConnectorOrbitDbDatabaseStoreHash\n  | TSwarmStoreConnectorOrbitDbDatabaseStoreKey;\n\nexport type TSwarmStoreConnectorOrbitDbDatabase<V> =\n  | OrbitDbFeedStore<V>\n  | OrbitDbKeyValueStore<V>;\n\nexport interface ISwarmStoreConnectorOrbitDbDatabaseOptions<\n  TStoreValueType extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>\n>\n  extends ISwarmStoreConnectorOrbitDbDatabaseAccessControlleGrantCallback<\n      TStoreValueType\n    >,\n    ISwarmStoreConnectorOrbitDbAccessConrotllerOrbitDBStandardOptionsWriteAccess,\n    ISwarmStoreDatabaseBaseOptions {\n  /**\n   * Datatbase type, may be feed store or key-value store.\n   * By default the feed store type is used.\n   *\n   * @type {ESwarmStoreConnectorOrbitDbDatabaseType}\n   * @memberof ISwarmStoreConnectorOrbitDbDatabaseOptions\n   */\n  dbType?: ESwarmStoreConnectorOrbitDbDatabaseType;\n}\n\nexport interface ISwarmStoreConnectorOrbitDbDatabaseEvents<\n  TSwarmStoreConnectorOrbitDBDatabase,\n  TFeedStoreType\n> {\n  [ESwarmStoreEventNames.FATAL]: [\n    string,\n    Error,\n    TSwarmStoreConnectorOrbitDBDatabase\n  ];\n\n  [ESwarmStoreEventNames.ERROR]: [\n    string,\n    Error,\n    TSwarmStoreConnectorOrbitDBDatabase\n  ];\n  // Database name and percents loaded\n  [ESwarmStoreEventNames.LOADING]: [\n    string,\n    number,\n    TSwarmStoreConnectorOrbitDBDatabase\n  ];\n  [ESwarmStoreEventNames.UPDATE]: [string, TSwarmStoreConnectorOrbitDBDatabase];\n  [ESwarmStoreEventNames.CLOSE]: [string, TSwarmStoreConnectorOrbitDBDatabase];\n  [ESwarmStoreEventNames.READY]: [string, TSwarmStoreConnectorOrbitDBDatabase];\n  [ESwarmStoreEventNames.NEW_ENTRY]: [\n    string, // database name\n    any, // entry added\n    string, // address of the entry,\n    any, // heads\n    ESwarmStoreConnectorOrbitDbDatabaseType,\n    TSwarmStoreConnectorOrbitDBDatabase\n  ];\n}\n\nexport type ISwarmStoreConnectorOrbitDbDatabaseKey = string;\n\nexport interface ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValueType>\n  extends LogEntry<TStoreValueType> {}\n\nexport enum ESwarmStoreConnectorOrbitDbDatabaseIteratorOption {\n  /**\n   * not equals to address or key\n   */\n  neq = 'neq',\n  /**\n   * equals to address or key\n   */\n  eq = 'eq',\n  /**\n   * greater than\n   */\n  gt = 'gt',\n  /**\n   * greater than or equals\n   */\n  gte = 'gte',\n  /**\n   * less than\n   */\n  lt = 'lt',\n  /**\n   * less than or equal\n   */\n  lte = 'lte',\n  /**\n   * limit messages count to read\n   */\n  limit = 'limit',\n  /**\n   * in reverse order\n   */\n  reverse = 'reverse',\n}\n\nexport interface ISwarmStoreConnectorOrbitDbDatabaseIteratorOptionsRequired<\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>\n> {\n  // if the equal operator applyied all other will not be applied\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.eq]:\n    | TSwarmStoreDatabaseEntityUniqueIndex<ESwarmStoreConnector.OrbitDB, DbType>\n    | TSwarmStoreDatabaseEntityUniqueIndex<\n        ESwarmStoreConnector.OrbitDB,\n        DbType\n      >[];\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.neq]:\n    | TSwarmStoreDatabaseEntityUniqueIndex<ESwarmStoreConnector.OrbitDB, DbType>\n    | TSwarmStoreDatabaseEntityUniqueIndex<\n        ESwarmStoreConnector.OrbitDB,\n        DbType\n      >[];\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.gt]: TSwarmStoreDatabaseEntityUniqueIndex<\n    ESwarmStoreConnector.OrbitDB,\n    DbType\n  >;\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.gte]: TSwarmStoreDatabaseEntityUniqueIndex<\n    ESwarmStoreConnector.OrbitDB,\n    DbType\n  >;\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.lt]: TSwarmStoreDatabaseEntityUniqueIndex<\n    ESwarmStoreConnector.OrbitDB,\n    DbType\n  >;\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.lte]: TSwarmStoreDatabaseEntityUniqueIndex<\n    ESwarmStoreConnector.OrbitDB,\n    DbType\n  >;\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.limit]: number;\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.reverse]: boolean;\n}\n\nexport interface ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>\n>\n  extends Partial<\n    ISwarmStoreConnectorOrbitDbDatabaseIteratorOptionsRequired<DbType>\n  > {}\n\nexport interface ISwarmStoreConnectorOrbitDbDatabaseIteratorAnswer<T> {\n  collect(): T[];\n}\n\nexport enum ESwarmStoreConnectorOrbitDbDatabaseMethodNames {\n  'get' = 'get',\n  'add' = 'add',\n  'remove' = 'remove',\n  'iterator' = 'iterator',\n  'close' = 'close',\n  'load' = 'load',\n}\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseMethodNames = ESwarmStoreConnectorOrbitDbDatabaseMethodNames;\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseAddMethodArgument<\n  TStoreValue\n> = {\n  value: TStoreValue;\n  /**\n   * Key of the value for Key-Value database store type.\n   *\n   * @type {TSwarmStoreConnectorOrbitDbDatabaseStoreKey}\n   */\n  key?: TSwarmStoreConnectorOrbitDbDatabaseStoreKey;\n};\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbClose = void;\n\n// how many items to load\nexport type TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbLoad = number;\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseMethodArgument<\n  TStoreValue,\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>\n> =\n  | TSwarmStoreConnectorOrbitDbDatabaseStoreHash\n  | TStoreValue\n  | TSwarmStoreConnectorOrbitDbDatabaseAddMethodArgument<TStoreValue>\n  | ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<DbType>\n  | TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbClose\n  | TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbLoad;\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider.ts",["2410","2411","2412","2413"],"import KeystoreClass, { Keystore } from 'orbit-db-keystore';\nimport {\n  IdentityProvider,\n  IdentityProviderOptions,\n  IdentityAsJson,\n} from 'orbit-db-identity-provider';\nimport { IOrbitDBKeystoreStoreCustom } from 'types';\nimport { SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_IDENTITY_PROVIDER_TYPE } from './swarm-store-connector-orbit-db-subclass-identity-provider.const';\n\nexport class SwarmStoreConnectorOrbitDBSubclassIdentityProvider extends IdentityProvider {\n  /**\n   * return name of the identity provider\n   *\n   * @readonly\n   * @static\n   * @type {string}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n   */\n  public static get type(): string {\n    return SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_IDENTITY_PROVIDER_TYPE;\n  }\n\n  /**\n   * Verify that identity was signed by the ID\n   *\n   * @static\n   * @param {IdentityAsJson} identity\n   * @returns {Promise<boolean>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n   */\n  public static async verifyIdentity(\n    identity: IdentityAsJson\n  ): Promise<boolean> {\n    // TODO - may be verify the identity with central authority\n    const verifyResult = await (KeystoreClass as unknown as IOrbitDBKeystoreStoreCustom).verify(\n      identity.signatures.publicKey,\n      identity.publicKey,\n      identity.publicKey + identity.signatures.id\n    );\n\n    return verifyResult;\n  }\n\n  protected _keystore?: Keystore;\n\n  constructor(options: IdentityProviderOptions = {}) {\n    super(options);\n    if (!options.keystore) {\n      throw new Error(\n        'IdentityProvider.createIdentity requires options.keystore'\n      );\n    }\n    if (!options.signingKeystore) {\n      options.signingKeystore = options.keystore;\n    }\n    this._keystore = options.signingKeystore;\n  }\n\n  /**\n   * return identifier of external id (eg. a public key)\n   *\n   * @param {IdentityProviderOptions} [options={}]\n   * @returns {Promise<string>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n   * @throws Error\n   */\n  async getId(options: IdentityProviderOptions = {}): Promise<string> {\n    const id = options.id;\n\n    if (!id) {\n      throw new Error('id is required');\n    }\n    return id;\n  }\n\n  /**\n   * return a signature of data (signature of the OrbtiDB public key)\n   *\n   * @param {*} data\n   * @param {IdentityProviderOptions} [options={}]\n   * @returns {Promise<any>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n   * @throws Error\n   */\n  async signIdentity(\n    data: any,\n    options: IdentityProviderOptions = {}\n  ): Promise<string> {\n    const id = options.id;\n\n    if (!id) {\n      throw new Error('id is required');\n    }\n\n    const { _keystore: keystore } = this;\n    const key = await keystore!.getKey(id);\n\n    if (!key) {\n      throw new Error(`Signing key for '${id}' not found`);\n    }\n\n    const result = await (keystore! as any).sign(key, data);\n\n    return result;\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.utils.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-cache/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-cache/swarm-store-connector-orbit-db-subclass-storage-cache.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.ts",["2414","2415"],"import { IStore } from 'orbit-db-cache';\nimport { ISecretStoreCredentials } from 'classes/secret-storage-class/secret-storage-class.types';\nimport { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';\nimport { ISwarmStoreConnectorOrbitDBSubclassStorageFabric } from './swarm-store-connector-orbit-db-subclass-storage-fabric.types';\nimport { SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter } from '../swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter';\nimport Storage from 'orbit-db-storage-adapter';\nimport OrbitDB from 'orbit-db';\n\nexport class SwarmStoreConnectorOrbitDBSubclassStorageFabric\n  implements ISwarmStoreConnectorOrbitDBSubclassStorageFabric {\n  private key?: CryptoKey;\n\n  private ready?: Promise<void>;\n\n  // names of databases which must be encrypted\n  protected secretDatabasesNames: string[] = [];\n\n  protected storage: any;\n\n  constructor(credentials: ISecretStoreCredentials) {\n    this.applyCredentials(credentials);\n    this.storage = Storage();\n  }\n\n  public addSecretDatabaseName = (dbName: string) => {\n    if (!this.secretDatabasesNames.includes(dbName)) {\n      this.secretDatabasesNames.push(dbName);\n    }\n  };\n\n  /**\n   * create an instance of OrbitDB Cache\n   * for a path provided\n   *\n   * @param {string} path\n   * @returns {Cache}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStorageFabric\n   * @throws\n   */\n  public async createStore(path: string): Promise<IStore> {\n    await this.ready;\n    if (!this.isSecretPath(path)) {\n      return this.storage.createStore(path);\n    }\n\n    const { key } = this;\n\n    if (!key) {\n      throw new Error('A CryptoKey is not exists');\n    }\n    if (!(key instanceof CryptoKey)) {\n      throw new Error('The key must be an instance of CryptoKey');\n    }\n\n    const cache = new SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter(\n      { key },\n      { dbName: path }\n    );\n\n    await cache.open();\n    return cache;\n  }\n\n  protected getValidPath(path: string): string {\n    return path.startsWith('/') ? path : `/${path}`;\n  }\n\n  protected getDBNameByAddress(path: string): undefined | string {\n    try {\n      return (OrbitDB as any).parseAddress(this.getValidPath(path)).path;\n    } catch (err) {\n      console.error('Cant parse the path', err);\n    }\n  }\n\n  protected getDBNameByPath(path: string): undefined | string {\n    const dbName = this.getDBNameByAddress(path);\n\n    if (dbName) {\n      return dbName;\n    }\n\n    let idx = 0;\n    let matches = 0;\n    while (matches < 2 && idx < path.length) {\n      if (path[idx++] === '/') {\n        matches++;\n      }\n      if (matches === 2) {\n        return path.slice(idx);\n      }\n    }\n  }\n\n  protected isSecretPath(path: string): boolean {\n    const dbName = this.getDBNameByPath(path);\n    return !!dbName && this.secretDatabasesNames.includes(dbName);\n  }\n\n  protected applyCredentials(credentials: ISecretStoreCredentials): void {\n    this.ready = this.createKey(credentials);\n  }\n\n  /**\n   *\n   *\n   * @protected\n   * @param {ISecretStoreCredentials} credentials\n   * @returns {Promise<void>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStorageFabric\n   * @throws\n   */\n  protected async createKey(\n    credentials: ISecretStoreCredentials\n  ): Promise<void> {\n    const secretStorage = new SecretStorage();\n    const cryptoKey = await secretStorage.generateCryptoKey(credentials);\n\n    if (cryptoKey instanceof Error) {\n      console.error(`createKey::${cryptoKey}`);\n      throw new Error('Failed to generate a key');\n    }\n    if (!(cryptoKey instanceof CryptoKey)) {\n      throw new Error(\n        'createKey::the key generated by a password string must be a CryptoKey'\n      );\n    }\n    this.key = cryptoKey;\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.ts",["2416"],"import { IStorageProviderOptions } from 'classes/storage-providers/storage-providers.types';\nimport { validateCryptoKeyCredentials } from './../../../../../secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-main/secret-storage-class-utils-main';\nimport {\n  ISecretStoreCredentials,\n  ISecretStoreCredentialsCryptoKey,\n} from 'classes/secret-storage-class/secret-storage-class.types';\nimport { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';\nimport {\n  IOrbitDbCacheStore,\n  IOrbitDbKeystoreStore,\n} from './swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.types';\nimport {\n  SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_DEFAULT_OPTIONS_SECRET_STORAGE,\n  SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS,\n} from './swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.const';\nimport { TCallbackError, TCallbackErrorValue } from 'orbit-db-cache';\nimport { ISecretStorage } from '../../../../../secret-storage-class/secret-storage-class.types';\n\nexport class SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter\n  implements IOrbitDbKeystoreStore, IOrbitDbCacheStore {\n  public get status(): SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS {\n    const { isClose } = this;\n\n    if (isClose) {\n      return SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.CLOSE;\n    }\n    return SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS.OPEN;\n  }\n\n  /**\n   * this is used in the Cache(orbit-db-cache) in status\n   * ` get status () { return this._store.db.status } `\n   *\n   * @readonly\n   * @type {{ status: SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_STATUS }}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter\n   */\n  public get db() {\n    return {\n      status: this.status,\n    };\n  }\n\n  protected options?: IStorageProviderOptions;\n\n  protected secretStorage?: ISecretStorage;\n\n  private credentials?: ISecretStoreCredentials;\n\n  private credentialsCryptoKey?: ISecretStoreCredentialsCryptoKey;\n\n  protected isOpen: boolean = false;\n\n  protected isClose: boolean = false;\n\n  constructor(\n    credentials: ISecretStoreCredentials | ISecretStoreCredentialsCryptoKey,\n    options: Required<IStorageProviderOptions>\n  ) {\n    this.setOptions(options);\n    this.setCredentials(credentials);\n    this.createSecretStorage();\n  }\n\n  public async open(cb?: TCallbackError): Promise<void> {\n    const { isClose, isOpen } = this;\n\n    if (!isClose && isOpen) {\n      return;\n    }\n\n    const result = await this.startSecretStorage();\n\n    if (result instanceof Error) {\n      throw result;\n    }\n    this.setIsOpen();\n    this.unsetIsClose();\n    if (typeof cb === 'function') {\n      cb(undefined);\n    }\n  }\n\n  public close = async (cb?: TCallbackError): Promise<void> => {\n    if (!this.isOpen || this.isClose) {\n      return;\n    }\n    this.setIsClose();\n    this.unsetIsOpen();\n    const result = await this.disconnectSecretStorage();\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw result;\n    }\n    if (typeof cb === 'function') {\n      cb(undefined);\n    }\n  };\n\n  public async get(\n    k: string,\n    cb?: TCallbackErrorValue\n  ): Promise<string | undefined> {\n    // open connection to the secret storage\n    // before any operations\n    await this.openIfNecessary();\n\n    const secretStorage = this.getSecretStorage();\n\n    if (secretStorage instanceof Error) {\n      console.error(secretStorage);\n      throw secretStorage;\n    }\n\n    const result = await secretStorage.get(k);\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw result;\n    }\n    const resulted = result ? result : undefined;\n    if (typeof cb === 'function') {\n      cb(undefined, resulted);\n    }\n    return resulted;\n  }\n\n  public async put(\n    k: string,\n    v: string | Buffer,\n    cb?: TCallbackError\n  ): Promise<void> {\n    if (this.isClose) {\n      console.error('CLOSED');\n    }\n    await this.openIfNecessary();\n\n    const secretStorage = this.getSecretStorage();\n\n    if (secretStorage instanceof Error) {\n      console.error(secretStorage);\n      throw secretStorage;\n    }\n\n    const value = v instanceof Buffer ? v.toString() : v;\n    const result = await secretStorage.set(k, value);\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw result;\n    }\n    if (typeof cb === 'function') {\n      cb(undefined);\n    }\n  }\n\n  public del = async (key: string, cb?: TCallbackError) => {\n    await this.openIfNecessary();\n\n    const secretStorage = this.getSecretStorage();\n\n    if (secretStorage instanceof Error) {\n      console.error(secretStorage);\n      throw secretStorage;\n    }\n\n    const result = await secretStorage.unset(key);\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw result;\n    }\n    if (typeof cb === 'function') {\n      cb(undefined);\n    }\n  };\n\n  public dropDb = async () => {\n    await this.openIfNecessary();\n\n    const secretStorage = this.getSecretStorage();\n\n    if (secretStorage instanceof Error) {\n      console.error(secretStorage);\n      throw secretStorage;\n    }\n\n    const result = await secretStorage.clearDb();\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw new Error('Failed to drop the database');\n    }\n  };\n\n  // TODO - not implemented in ocrbit-db-cache\n  public async load() {}\n\n  // TODO - not implemented in ocrbit-db-cache\n  public async destroy() {\n    await this.dropDb();\n    await this.close();\n    this.unsetSecretStorage();\n  }\n\n  protected setIsOpen() {\n    this.isOpen = true;\n  }\n\n  protected unsetIsOpen() {\n    this.isOpen = false;\n  }\n\n  protected setIsClose() {\n    this.isClose = true;\n  }\n\n  protected unsetIsClose() {\n    this.isClose = false;\n  }\n\n  protected getSecretStorage(): Error | ISecretStorage {\n    const { secretStorage } = this;\n\n    if (secretStorage) {\n      return secretStorage;\n    }\n    return new Error('There is no connection to the SecretStorage');\n  }\n\n  protected setOptions(options: Required<IStorageProviderOptions>): void {\n    if (!options) {\n      throw new Error('Options must be provided');\n    }\n    if (typeof options !== 'object') {\n      throw new Error('Options must be an object');\n    }\n\n    const { dbName } = options;\n\n    if (!dbName) {\n      throw new Error('A database name must be specified in the options');\n    }\n    if (typeof dbName !== 'string') {\n      throw new Error('A database name must be a string');\n    }\n    this.options = options;\n  }\n\n  /**\n   * validate and set credentials with password or crypto key\n   *\n   * @protected\n   * @param {(ISecretStoreCredentials | ISecretStoreCredentialsCryptoKey)} credentials\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter\n   * @throws\n   */\n  protected setCredentials(\n    credentials: ISecretStoreCredentials | ISecretStoreCredentialsCryptoKey\n  ) {\n    if (!credentials) {\n      throw new Error('Credentials must be specified');\n    }\n    if (typeof credentials !== 'object') {\n      throw new Error('Credentials must be an object');\n    }\n\n    if ((credentials as ISecretStoreCredentialsCryptoKey).key) {\n      const credentialsValidationResult = validateCryptoKeyCredentials(\n        credentials as ISecretStoreCredentialsCryptoKey\n      );\n\n      if (credentialsValidationResult instanceof Error) {\n        console.error(credentialsValidationResult);\n        throw new Error('setCredentials::crypto credentials not valid');\n      }\n      this.credentialsCryptoKey = credentials as ISecretStoreCredentialsCryptoKey;\n    }\n    this.credentials = credentials as ISecretStoreCredentials;\n  }\n\n  protected unsetCredentials() {\n    this.credentials = undefined;\n  }\n\n  private createSecretStorage() {\n    const secretStorage = new SecretStorage(\n      SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_SECRET_STORAGE_ADAPTER_DEFAULT_OPTIONS_SECRET_STORAGE\n    );\n\n    this.secretStorage = secretStorage;\n  }\n\n  private unsetSecretStorage() {\n    this.secretStorage = undefined;\n  }\n\n  private startSecretStorage(): Promise<Error | boolean> | Error {\n    const { options, credentials, secretStorage, credentialsCryptoKey } = this;\n\n    if (secretStorage) {\n      if (credentialsCryptoKey) {\n        return secretStorage.authorizeByKey(credentialsCryptoKey, options);\n      } else if (credentials) {\n        return secretStorage.authorize(credentials, options);\n      }\n      return new Error('Credentials was not provided');\n    }\n    return new Error('Secret storage is not defined');\n  }\n\n  private async disconnectSecretStorage(): Promise<Error | void> {\n    const { secretStorage } = this;\n\n    if (!secretStorage) {\n      return new Error(\n        'There is no instance of the SecretStorage connected to'\n      );\n    }\n    try {\n      const result = await secretStorage.disconnect();\n\n      if (result instanceof Error) {\n        return result;\n      }\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected async openIfNecessary(): Promise<void> {\n    const { isOpen } = this;\n\n    if (isOpen) {\n      return;\n    }\n    await this.open();\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.ts",["2417","2418","2419","2420","2421","2422","2423"],"import OrbitDB from 'orbit-db';\nimport Identities from 'orbit-db-identity-provider';\nimport AccessControllers from 'orbit-db-access-controllers';\nimport { Keystore } from 'orbit-db-keystore';\nimport { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport {\n  SWARM_STORE_CONNECTOR_ORBITDB_CONNECTION_TIMEOUT_MS,\n  SWARM_STORE_CONNECTOR_ORBITDB_LOG_PREFIX,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONNECTION_TIMEOUT_MS,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_RECONNECTION_ATTEMPTS_MAX,\n  SWARM_STORE_CONNECTOR_ORBITDB_IDENTITY_TYPE,\n  SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DBNAME,\n  SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DIRECTORY,\n} from './swarm-store-connector-orbit-db.const';\nimport { IPFS } from 'types/ipfs.types';\nimport { SwarmStoreConnectorOrbitDBSubclassIdentityProvider } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider';\nimport { SwarmStoreConnectorOrbitDBSubclassAccessController } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller';\nimport {\n  ISwarmStoreConnectorOrbitDBOptions,\n  ISwarmStoreConnectorOrbitDBConnectionOptions,\n  ISwarmStoreConnectorOrbitDBEvents,\n} from './swarm-store-connector-orbit-db.types';\nimport { timeout, delay } from 'utils/common-utils/common-utils-timer';\nimport { SwarmStoreConnectorOrbitDBDatabase } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseOptions,\n  TSwarmStoreConnectorOrbitDbDatabaseMethodNames,\n  TSwarmStoreConnectorOrbitDbDatabaseMethodArgument,\n} from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { commonUtilsArrayDeleteFromArray } from 'utils/common-utils/common-utils';\nimport {\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON,\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_OFF,\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_UNSET_ALL_LISTENERS,\n} from 'const/common-values/common-values';\nimport { SwarmStorageConnectorOrbitDBSublassKeyStore } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore';\nimport { ISwarmStoreConnectorOrbitDBSubclassStorageFabric } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.types';\nimport { SwarmStoreConnectorOrbitDBSubclassStorageFabric } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { TSwarmStoreDatabaseType } from '../../swarm-store-class.types';\nimport {\n  ISwarmStoreConnector,\n  TSwarmStoreValueTypes,\n} from '../../swarm-store-class.types';\nimport {\n  ESwarmStoreConnector,\n  ESwarmStoreEventNames,\n} from '../../swarm-store-class.const';\n\nexport class SwarmStoreConnectorOrbitDB<\n  ISwarmDatabaseValueTypes extends TSwarmStoreValueTypes<\n    ESwarmStoreConnector.OrbitDB\n  >,\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>\n> extends EventEmitter<ISwarmStoreConnectorOrbitDBEvents>\n  implements\n    ISwarmStoreConnector<\n      ESwarmStoreConnector.OrbitDB,\n      ISwarmDatabaseValueTypes,\n      DbType\n    > {\n  private static isLoadedCustomIdentityProvider: boolean = false;\n\n  private static isLoadedCustomAccessController: boolean = false;\n\n  private static loadCustomIdentityProvider() {\n    if (!SwarmStoreConnectorOrbitDB.isLoadedCustomIdentityProvider) {\n      Identities.addIdentityProvider(\n        SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n      );\n      SwarmStoreConnectorOrbitDB.isLoadedCustomIdentityProvider = true;\n    }\n  }\n\n  private static loadCustomAccessController() {\n    if (!SwarmStoreConnectorOrbitDB.isLoadedCustomAccessController) {\n      AccessControllers.addAccessController({\n        AccessController: SwarmStoreConnectorOrbitDBSubclassAccessController,\n      });\n      SwarmStoreConnectorOrbitDB.isLoadedCustomAccessController = true;\n    }\n  }\n\n  public isReady: boolean = false;\n\n  public isClosed: boolean = false;\n\n  protected userId: string = '';\n\n  protected directory: string = SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DIRECTORY;\n\n  protected identity?: any;\n\n  protected connectionOptions?: ISwarmStoreConnectorOrbitDBConnectionOptions;\n\n  protected options?: ISwarmStoreConnectorOrbitDBOptions<\n    ISwarmDatabaseValueTypes\n  >;\n\n  protected ipfs?: IPFS; // instance of the IPFS connected through\n\n  protected orbitDb?: OrbitDB; // instance of the OrbitDB\n\n  protected databases: SwarmStoreConnectorOrbitDBDatabase<\n    ISwarmDatabaseValueTypes,\n    DbType\n  >[] = [];\n\n  protected identityKeystore?: Keystore;\n\n  protected storage?: ISwarmStoreConnectorOrbitDBSubclassStorageFabric;\n\n  private dbCloseListeners: ((...args: any[]) => any)[] = [];\n\n  public constructor(\n    options: ISwarmStoreConnectorOrbitDBOptions<ISwarmDatabaseValueTypes>\n  ) {\n    super();\n    SwarmStoreConnectorOrbitDB.loadCustomIdentityProvider();\n    SwarmStoreConnectorOrbitDB.loadCustomAccessController();\n    this.applyOptions(options);\n  }\n\n  /**\n     * waiting for the connection to the swarm, load the database locally\n     * and ready to use it\n    /**\n     *\n     *\n     * @param {ISwarmStoreConnectorOrbitDBConnectionOptions} connectionOptions\n     * @returns {(Promise<void | Error>)}\n     * @memberof SwarmStoreConnectorOrbitDB\n     */\n  public connect = async (\n    connectionOptions: ISwarmStoreConnectorOrbitDBConnectionOptions\n  ): Promise<void | Error> => {\n    const resultCreateIdentity = await this.createIdentity();\n\n    if (resultCreateIdentity instanceof Error) {\n      console.error(resultCreateIdentity);\n      return this.emitError('Failed to create an identity');\n    }\n\n    const disconnectFromSwarmResult = await this.disconnectFromSwarm();\n\n    if (disconnectFromSwarmResult instanceof Error) {\n      return disconnectFromSwarmResult;\n    }\n\n    const setConnectionOptionsResult = this.setConnectionOptions(\n      connectionOptions\n    );\n\n    if (setConnectionOptionsResult instanceof Error) {\n      return setConnectionOptionsResult;\n    }\n\n    const connectToSwarmResult = await this.connectToSwarm();\n\n    if (connectToSwarmResult instanceof Error) {\n      return connectToSwarmResult;\n    }\n\n    // close the current connections to the databases if exists\n    const closeExistingDatabaseesOpened = await this.closeDatabases();\n\n    if (closeExistingDatabaseesOpened instanceof Error) {\n      return this.emitError(closeExistingDatabaseesOpened, 'openDatabases');\n    }\n\n    // stop the current instance of OrbitDB\n    // if it exists\n    const stopOrbitDBResult = await this.stopOrbitDBInsance();\n\n    if (stopOrbitDBResult instanceof Error) {\n      return stopOrbitDBResult;\n    }\n\n    // create a new OrbitDB instance\n    const createOrbitDbResult = await this.createOrbitDBInstance();\n\n    if (createOrbitDbResult instanceof Error) {\n      return createOrbitDbResult;\n    }\n\n    // create OrbitDB databases\n    const createDatabases = await this.openDatabases();\n\n    if (createDatabases instanceof Error) {\n      return createDatabases;\n    }\n    // set the database is ready to query\n    this.setReady();\n  };\n\n  public openDatabase = async (\n    dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<\n      ISwarmDatabaseValueTypes\n    >,\n    openAttempt: number = 0,\n    checkOptionsIsExists: boolean = true\n  ): Promise<void | Error> => {\n    const { orbitDb, isClosed } = this;\n\n    if (!orbitDb) {\n      return new Error('There is no instance of OrbitDB');\n    }\n    if (isClosed) {\n      return new Error(\"Can't open a database for the connection opened\");\n    }\n\n    // add options in the main setting only\n    // if options are not exists already\n    // in the list. If options are exists\n    // this may mean that the database was\n    // opened but still not ready to use and\n    // waiting when it will be ready to use.\n    const checkDbOptionsResult = checkOptionsIsExists\n      ? this.setDbOptionsIfNotExists(dbOptions)\n      : this.setDbOptions(dbOptions);\n\n    // options checked and set for valid\n    // calculation of the progress percent\n    if (checkDbOptionsResult instanceof Error) {\n      return checkDbOptionsResult;\n    }\n\n    const { dbName, useEncryptedStorage } = dbOptions;\n    const db = this.getDbConnectionExists(dbName);\n\n    if (db) {\n      this.unsetOptionsForDatabase(dbName);\n      return new Error(`A database named as ${dbName} is already exists`);\n    }\n\n    if (useEncryptedStorage) {\n      // Add the database name in the Storage fabric\n      // as the enctypted db. The storage fabric\n      // will create the encrypted storage\n      // for this database\n      this.storage?.addSecretDatabaseName(dbName);\n    }\n\n    const database = new SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >(dbOptions, orbitDb);\n\n    this.setListenersDatabaseEvents(database);\n\n    const databaseOpenResult = await this.waitDatabaseOpened(database);\n\n    if (databaseOpenResult instanceof Error) {\n      await this.closeDb(database, false); // close the connection to the database\n      await delay(300);\n      if (\n        openAttempt >\n        SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_RECONNECTION_ATTEMPTS_MAX\n      ) {\n        return this.handleErrorOnDbOpen(\n          database,\n          'The max nunmber of connection attempts has reached'\n        );\n      }\n\n      const openDatabaseResult = await this.openDatabase(\n        dbOptions,\n        (openAttempt += 1)\n      );\n\n      if (openDatabaseResult instanceof Error) {\n        return this.handleErrorOnDbOpen(database, openDatabaseResult);\n      }\n    }\n    console.log('openDatabase', dbName);\n    this.databases.push(database);\n    this.emit(ESwarmStoreEventNames.READY, dbOptions.dbName);\n  };\n\n  public async dropDatabase(dbName: string) {\n    const db = this.getDbConnection(dbName);\n\n    if (!db) {\n      return new Error(`The database named ${dbName} was not found`);\n    }\n    try {\n      this.unsetListenersDatabaseEvents(db);\n      await db.drop();\n      await this.closeDb(db);\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  public async closeDatabase(dbName: string): Promise<Error | void> {\n    const db = this.getDbConnection(dbName);\n\n    if (db) {\n      return this.closeDb(db);\n    }\n    return new Error(`The database named ${dbName} was not found`);\n  }\n\n  /**\n   * make a request to a database by it's name\n   * and a method to execute\n   * @memberof SwarmStoreConnctotOrbitDB\n   */\n  public request = async <ISwarmDatabaseValueTypes>(\n    dbName: string,\n    dbMethod: TSwarmStoreConnectorOrbitDbDatabaseMethodNames,\n    arg: TSwarmStoreConnectorOrbitDbDatabaseMethodArgument<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >\n  ): Promise<Error | any> => {\n    const { isClosed } = this;\n\n    if (isClosed) {\n      return new Error('The Swarm connection was closed');\n    }\n\n    const dbConnection = await this.waitingDbOpened(dbName);\n\n    if (dbConnection instanceof Error) {\n      console.error(dbConnection);\n      return this.emitError(\n        new Error('Failed to get an opened connection to the database')\n      );\n    }\n    return dbConnection[dbMethod](arg as any);\n  };\n\n  /**\n   * close all connections with databases\n   * and the Swarm store\n   * @memberof SwarmStoreConnctotOrbitDB\n   */\n  public close = async (): Promise<Error | void> => {\n    this.setIsClosed();\n\n    const closeAllDatabasesResult = await this.closeDatabases();\n    const stopOrbitDBResult = await this.stopOrbitDBInsance();\n    let err;\n\n    if (closeAllDatabasesResult instanceof Error) {\n      err = true;\n      console.error(closeAllDatabasesResult);\n      this.emitError('Failed to close all databases connections');\n    }\n    if (stopOrbitDBResult instanceof Error) {\n      err = true;\n      console.error(closeAllDatabasesResult);\n      this.emitError('Failed to close the current instanceof OrbitDB');\n    }\n    this.unsetAllListenersForEvents();\n    if (err) {\n      return this.emitError(\n        'Failed to close normally the connection to the swarm store'\n      );\n    }\n  };\n\n  protected setIsClosed = () => {\n    this.setNotReady();\n    this.isClosed = true;\n    this.emit(ESwarmStoreEventNames.CLOSE, true);\n  };\n\n  /**\n   * return an opened connection with the database by it's name\n   * if exists and undefined if it is not exists\n   * @readonly\n   * @protected\n   * @type {(SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes> | void)}\n   * @memberof SwarmStoreConnctotOrbitDB\n   */\n  protected getDbConnection = (\n    dbName: string,\n    checkIsOpen: boolean = true\n  ): SwarmStoreConnectorOrbitDBDatabase<\n    ISwarmDatabaseValueTypes,\n    DbType\n  > | void => {\n    const { databases } = this;\n\n    return databases.find((db) => {\n      return (\n        db &&\n        db.dbName === dbName &&\n        (!checkIsOpen || (!db.isClosed && !!db.isReady))\n      );\n    });\n  };\n\n  /**\n   * returns a database if exists into the list\n   * of the databases which were opened.\n   * This method do not check whether db\n   * closed and ready.\n   * @protected\n   * @param {string} dbName\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected getDbConnectionExists(dbName: string) {\n    return this.getDbConnection(dbName, false);\n  }\n\n  protected handleDbClose(\n    database: SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >\n  ): void {\n    if (database) {\n      const { dbName } = database;\n\n      this.unsetListenersDatabaseEvents(database);\n      this.unsetOptionsForDatabase(dbName);\n      this.deleteDatabaseFromList(database);\n    }\n  }\n\n  protected handleErrorOnDbOpen(\n    database: SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >,\n    error: Error | string\n  ): Error {\n    if (database) {\n      const { dbName } = database;\n\n      this.handleDbClose(database);\n      console.error(\n        `An error has occurred while database named ${dbName} opening`\n      );\n      console.error(error);\n    }\n    return this.emitError(error);\n  }\n\n  /**\n   * waiting till connection to the database\n   * will be opened or failed. If a db will\n   * not be ready during a timeout return error.\n   * @protected\n   * @param {string} dbName\n   * @returns {(Promise<Error | SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>>)}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected async waitingDbOpened(\n    dbName: string\n  ): Promise<\n    Error | SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes, DbType>\n  > {\n    const { getDbConnection } = this;\n    const db = getDbConnection(dbName);\n    const dbOptsIdx = this.getIdxDbOptions(dbName);\n\n    if (db) {\n      return db;\n    } else if (dbOptsIdx === -1) {\n      return new Error(`A database with the name ${dbName} was not found`);\n    } else {\n      const removeListener = this.removeListener.bind(this);\n\n      return new Promise((res) => {\n        let timeout: undefined | NodeJS.Timer;\n        function removeListners() {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = undefined;\n          }\n          removeListener(ESwarmStoreEventNames.READY, onReady);\n          removeListener(ESwarmStoreEventNames.CLOSE, onClose);\n        }\n        function onReady(dbNameReady: string) {\n          if (dbNameReady === dbName) {\n            const db = getDbConnection(dbName);\n\n            if (db) {\n              removeListners();\n              res(db);\n            }\n          }\n        }\n        function onClose() {\n          removeListners();\n          res(new Error('The Swarm store was closed'));\n        }\n\n        timeout = setTimeout(() => {\n          removeListners();\n          res(new Error());\n        }, SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONNECTION_TIMEOUT_MS);\n        this.once(ESwarmStoreEventNames.READY, onReady);\n        this.once(ESwarmStoreEventNames.CLOSE, onClose);\n      });\n    }\n  }\n\n  protected unsetAllListenersForEvents = () => {\n    Object.values(ESwarmStoreEventNames).forEach(\n      this[COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_UNSET_ALL_LISTENERS].bind(\n        this\n      )\n    );\n  };\n\n  protected emitDatabaseClose(\n    database: SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >\n  ) {\n    if (database) {\n      const { dbName } = database;\n\n      console.warn(`Database named ${dbName} was closed`);\n      this.emit(ESwarmStoreEventNames.CLOSE_DATABASE, dbName, database);\n    }\n  }\n\n  protected emitError(error: Error | string, mehodName?: string): Error {\n    const err = typeof error === 'string' ? new Error(error) : error;\n\n    console.error(\n      `${SWARM_STORE_CONNECTOR_ORBITDB_LOG_PREFIX}::error${\n        mehodName ? `::${mehodName}` : ''\n      }`,\n      err\n    );\n    this.emit(ESwarmStoreEventNames.ERROR, err);\n    return err;\n  }\n\n  private setIsReady(isReady: boolean = false) {\n    this.isReady = isReady;\n    this.emit(ESwarmStoreEventNames.STATE_CHANGE, isReady);\n  }\n\n  /**\n   * set the flag this instance\n   * is not ready to make a\n   * request to databases\n   * @protected\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected setReady() {\n    this.setIsReady(true);\n  }\n\n  protected setNotReady() {\n    this.setIsReady(false);\n  }\n\n  /**\n   * delete the database from the list\n   * of opened databases\n   * @protected\n   * @param {SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>} database\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected deleteDatabaseFromList(\n    database: SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >\n  ) {\n    const { databases } = this;\n\n    if (databases && databases instanceof Array) {\n      commonUtilsArrayDeleteFromArray<\n        SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes, DbType>\n      >(databases, database);\n    }\n  }\n\n  protected checkDbOptions(\n    options: unknown\n  ): options is ISwarmStoreConnectorOrbitDbDatabaseOptions<\n    ISwarmDatabaseValueTypes\n  > {\n    if (options != null && typeof options === 'object') {\n      const { dbName } = options as { dbName: string };\n\n      return !!dbName && typeof dbName === 'string';\n    }\n    return false;\n  }\n\n  /**\n   * apply options provided for the\n   * instance\n   *\n   * @private\n   * @param {ISwarmStoreConnectorOrbitDBOptions} options\n   * @memberof SwarmStoreConnectorOrbitDB\n   * @throws Error - throw an error if the options are not valid\n   */\n  private applyOptions(\n    options: ISwarmStoreConnectorOrbitDBOptions<ISwarmDatabaseValueTypes>\n  ) {\n    if (!options || typeof options !== 'object') {\n      throw new Error('The options must be an object');\n    }\n    this.options = options;\n\n    const { userId, credentials, directory } = options;\n\n    if (!userId) {\n      console.warn(new Error('The user id is not provided'));\n    } else {\n      this.userId = userId;\n    }\n    if (typeof directory === 'string') {\n      this.directory = directory;\n    }\n    if (credentials) {\n      // if credentials provided, then\n      // create the secret keystorage\n      this.createIdentityKeystores(credentials);\n      // create secret storage fabric\n      this.createStorage(credentials);\n    }\n  }\n\n  /**\n   * create keystores for identity provider\n   * throw an error if not valid\n   *\n   * @private\n   * @param {(ISwarmStoreConnectorOrbitDBOptions<ISwarmDatabaseValueTypes>)['credentials']} credentials\n   * @returns {void}\n   * @memberof SwarmStoreConnectorOrbitDB\n   * @throws Error\n   */\n  private createIdentityKeystores(\n    credentials: ISwarmStoreConnectorOrbitDBOptions<\n      ISwarmDatabaseValueTypes\n    >['credentials']\n  ): void {\n    const { directory, userId } = this;\n    const identityKeystorePrefix = `${directory}/${userId}`;\n    const identityKeystore = this.createKeystore(\n      credentials,\n      identityKeystorePrefix\n    );\n\n    if (identityKeystore instanceof Error) {\n      console.error(identityKeystore);\n      throw new Error('Failed on create identity keystore');\n    }\n    this.identityKeystore = identityKeystore;\n  }\n\n  /**\n   * create a Storage fabric which is\n   * used by the OrbitDB instance\n   * to generate Cache for a\n   * Keystore and various databases\n   * to read/write values from the\n   * local persistent Cache\n   *\n   * @private\n   * @param {(ISwarmStoreConnectorOrbitDBOptions<ISwarmDatabaseValueTypes>)['credentials']} credentials\n   * @memberof SwarmStoreConnectorOrbitDB\n   * @throws\n   */\n  private createStorage(\n    credentials: ISwarmStoreConnectorOrbitDBOptions<\n      ISwarmDatabaseValueTypes\n    >['credentials']\n  ): void {\n    if (!credentials) {\n      throw new Error('createIdentityKeystores::credentials must be provided');\n    }\n    this.storage = new SwarmStoreConnectorOrbitDBSubclassStorageFabric(\n      credentials\n    );\n  }\n\n  protected createKeystore(\n    credentials: ISwarmStoreConnectorOrbitDBOptions<\n      ISwarmDatabaseValueTypes\n    >['credentials'],\n    keystoreNamePrefix?: string\n  ): Keystore | Error {\n    const keystoreName = `${keystoreNamePrefix ||\n      ''}${SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DBNAME}`;\n\n    if (!credentials) {\n      return this.emitError('createKeystore::A Credentials must be provided');\n    }\n    return new SwarmStorageConnectorOrbitDBSublassKeyStore({\n      credentials, // TODO - why does the credentials without login\n      store: keystoreName,\n    }) as Keystore;\n  }\n\n  /**\n   * create identity for the user. If the userid\n   * is provided then the identity will be created\n   * by the value of the user id.\n   *\n   * @private\n   * @returns {(Promise<Error | void>)}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  private async createIdentity(): Promise<Error | void> {\n    const { userId } = this;\n\n    try {\n      const identity = await Identities.createIdentity({\n        type: SWARM_STORE_CONNECTOR_ORBITDB_IDENTITY_TYPE,\n        id: userId ? userId : undefined,\n        keystore: this.identityKeystore,\n      });\n\n      if (!userId) {\n        this.userId = identity.id;\n        console.warn(`The user id created automatically is ${userId}`);\n      }\n      if (identity instanceof Error) {\n        return identity;\n      }\n      this.identity = identity;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * return index of the options\n   * for a database name is exists\n   * in the main databases options\n   * (in this.options.databases)\n   * @protected\n   * @param {string} dbName\n   * @returns {number | -1}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected getIdxDbOptions(dbName: string): number {\n    const { options } = this;\n\n    if (options) {\n      const { databases } = options;\n\n      if (databases instanceof Array) {\n        return databases.findIndex(\n          (db) => !!db && typeof db === 'object' && db.dbName === dbName\n        );\n      }\n    }\n    return -1;\n  }\n\n  protected unsetOptionsForDatabase(dbName: string) {\n    const { options } = this;\n\n    if (options) {\n      const { databases } = options;\n\n      if (databases instanceof Array) {\n        const idx = this.getIdxDbOptions(dbName);\n\n        databases.splice(idx, 1);\n      }\n    }\n  }\n\n  /**\n   * set the Database store options in\n   * the main options (this.options.databases)\n   * of all databases\n   * @protected\n   * @param {ISwarmStoreConnectorOrbitDbDatabaseOptions} dbOptions\n   * @param {boolean} [checkIfExists=false]\n   * @returns {(void | Error)}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected setDbOptions(\n    dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<\n      ISwarmDatabaseValueTypes\n    >,\n    checkIfExists: boolean = false\n  ): void | Error {\n    if (!this.checkDbOptions(dbOptions)) {\n      return new Error('The database options have a wrong format');\n    }\n\n    if (checkIfExists) {\n      const { dbName } = dbOptions;\n      const idxExisting = this.getIdxDbOptions(dbName);\n\n      if (idxExisting !== -1) {\n        return new Error(`\n          Options for the database ${dbName} is already exists.\n          May be the database was opened but still not be in ready state\n        `);\n      }\n    }\n\n    const { options } = this;\n\n    if (!options) {\n      this.applyOptions({\n        ...this.options,\n        userId: '',\n        databases: [dbOptions],\n      } as ISwarmStoreConnectorOrbitDBOptions<ISwarmDatabaseValueTypes>);\n      return;\n    }\n\n    const { databases } = options;\n\n    if (databases instanceof Array) {\n      const { dbName } = dbOptions;\n\n      this.unsetOptionsForDatabase(dbName);\n      databases.push(dbOptions);\n    } else {\n      options.databases = [dbOptions];\n    }\n  }\n\n  protected setDbOptionsIfNotExists(\n    dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<\n      ISwarmDatabaseValueTypes\n    >\n  ): void | Error {\n    return this.setDbOptions(dbOptions, true);\n  }\n\n  /**\n   *\n   *\n   * @private\n   * @param {SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes>} database - db to close\n   * @param {boolean} [flEmit=true] - whether to emit an events during execution\n   * @returns {(Promise<Error | void>)}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  private async closeDb(\n    database: SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >,\n    flEmit: boolean = true\n  ): Promise<Error | void> {\n    this.unsetListenersDatabaseEvents(database);\n\n    const { dbName } = database;\n\n    this.unsetOptionsForDatabase(dbName);\n    this.deleteDatabaseFromList(database);\n\n    const closeDatabaseResult = await database.close();\n\n    if (closeDatabaseResult instanceof Error) {\n      if (flEmit) {\n        return this.emitError(closeDatabaseResult);\n      }\n      return closeDatabaseResult;\n    }\n    if (flEmit) {\n      this.emitDatabaseClose(database);\n    }\n  }\n\n  private setConnectionOptions(\n    connectionOptions: ISwarmStoreConnectorOrbitDBConnectionOptions\n  ): void | Error {\n    if (!connectionOptions) {\n      return this.emitError('Connection options must be specified');\n    }\n\n    const { ipfs } = connectionOptions;\n\n    if (!ipfs) {\n      return this.emitError(\n        'An instance of ipfs must be specified in the connection options'\n      );\n    }\n    this.ipfs = ipfs;\n  }\n\n  private unsetSwarmConnectionOptions() {\n    this.ipfs = undefined;\n    this.connectionOptions = undefined;\n  }\n\n  private async disconnectFromSwarm(): Promise<Error | void> {\n    console.warn(\n      `${SWARM_STORE_CONNECTOR_ORBITDB_LOG_PREFIX}::disconnectFromTheSwarm`\n    );\n    this.unsetSwarmConnectionOptions();\n    this.setNotReady();\n  }\n\n  private async connectToSwarm(): Promise<Error | void> {\n    const { ipfs } = this;\n\n    if (!ipfs) {\n      return this.emitError('An instance of the IPFS must be specified');\n    }\n    try {\n      // wait when the ipfs will be ready to use\n      await Promise.race([\n        ipfs.ready,\n        timeout(SWARM_STORE_CONNECTOR_ORBITDB_CONNECTION_TIMEOUT_MS),\n      ]);\n    } catch (err) {\n      return this.emitError(err);\n    }\n  }\n\n  private async stopOrbitDBInsance(): Promise<Error | void> {\n    const { orbitDb } = this;\n\n    if (orbitDb) {\n      try {\n        await orbitDb.stop();\n        this.setNotReady();\n        this.orbitDb = undefined;\n      } catch (err) {\n        return this.emitError(err, 'stopOrbitDBInsance');\n      }\n    }\n  }\n\n  private async createOrbitDBInstance(): Promise<Error | void> {\n    const { ipfs, identity, storage } = this;\n\n    if (!ipfs) {\n      return this.emitError(\n        'An instance of IPFS must exists',\n        'createOrbitDBInstance'\n      );\n    }\n    try {\n      if (!OrbitDB) {\n        return this.emitError('A constructor of the OrbitDb is not provided');\n      }\n      if (!identity) {\n        return this.emitError('An identity must be specified');\n      }\n\n      const instanceOfOrbitDB = await OrbitDB.createInstance(ipfs, {\n        identity,\n        storage,\n      } as any); // TODO - correct typing must be specified\n\n      if (instanceOfOrbitDB instanceof Error) {\n        return this.emitError(\n          instanceOfOrbitDB,\n          'createOrbitDBInstance::error has occurred in the \"createInstance\" method'\n        );\n      }\n      this.orbitDb = instanceOfOrbitDB;\n    } catch (err) {\n      return this.emitError(\n        err,\n        'createOrbitDBInstance::failed to create the instance of OrbitDB'\n      );\n    }\n  }\n\n  protected getDbOptions(\n    dbName: string\n  ):\n    | ISwarmStoreConnectorOrbitDbDatabaseOptions<ISwarmDatabaseValueTypes>\n    | void\n    | Error {\n    const { options } = this;\n\n    if (!options) {\n      return this.emitError(\n        'An options is not specified for the database',\n        `getDbOptions::${dbName}`\n      );\n    }\n\n    const { databases } = options;\n\n    return databases.find((option) => option && option.dbName === dbName);\n  }\n\n  protected stop(): Promise<Error | void> {\n    this.setNotReady();\n    return this.closeDatabases();\n  }\n\n  /**\n   * open database and not check if an options are\n   * exists for the database (replace if exists)\n   * @private\n   * @param {ISwarmStoreConnectorOrbitDbDatabaseOptions} optionsForDb\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  private openDatabaseNotCheckOptionsExists(\n    optionsForDb: ISwarmStoreConnectorOrbitDbDatabaseOptions<\n      ISwarmDatabaseValueTypes\n    >\n  ): Promise<void | Error> {\n    return this.openDatabase(optionsForDb, 0, false);\n  }\n\n  private async restartDbConnection(\n    dbName: string,\n    database: SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >\n  ): Promise<void | Error> {\n    //try to restart the database\n    const optionsForDb = this.getDbOptions(dbName);\n\n    this.unsetListenersDatabaseEvents(database);\n    if (optionsForDb instanceof Error || !optionsForDb) {\n      this.emitError(\n        'Failed to get options to open a new db store',\n        `restartDbConnection::${dbName}`\n      );\n      return this.stop();\n    }\n\n    const startDbResult = await this.openDatabaseNotCheckOptionsExists(\n      optionsForDb\n    );\n\n    if (startDbResult instanceof Error) {\n      this.emitError(\n        'Failed to open a new db store',\n        `restartDbConnection::${dbName}`\n      );\n      return this.stop();\n    }\n  }\n\n  protected removeDbFromList(\n    database: SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >\n  ) {\n    if (this.databases instanceof Array) {\n      commonUtilsArrayDeleteFromArray<\n        SwarmStoreConnectorOrbitDBDatabase<ISwarmDatabaseValueTypes, DbType>\n      >(this.databases, database);\n    }\n  }\n\n  private handleDatabaseStoreClosed = (\n    database: SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >,\n    error: Error\n  ) => {\n    if (database) {\n      const { dbName } = database;\n\n      this.emitError(\n        `Database closed unexpected: ${error.message}`,\n        `handleDatabaseStoreClosed::${dbName}`\n      );\n      this.handleDbClose(database);\n      this.restartDbConnection(dbName, database);\n    }\n  };\n\n  private handleLoadingProgress = (dbName: string, progress: number): void => {\n    /* \n            databases - is a list of the databases opened already\n            it means that the loading progress for this databases\n            is 100%\n        */\n    const { databases, options } = this;\n    let currentProgressInPercent = 0;\n\n    if (options) {\n      /* \n                overallDatabases - is a list of all databases\n                which are must be opened\n            */\n      const { databases: overallDatabases } = options;\n      // the progress which will be reached\n      // on all the databases will be opened\n      const overallProgressToReach = overallDatabases.length * 100;\n      // progress reached at this time\n      const currentProgress =\n        (databases ? databases.length : 0) * 100 + progress;\n      // the progress reached at this time in a percentage\n      currentProgressInPercent = currentProgress\n        ? (overallProgressToReach / currentProgress) * 100\n        : 0;\n    }\n    console.log(\n      `Swarm store connector::handleLoadingProgress::${dbName}::progress::${progress}`\n    );\n    this.emit(ESwarmStoreEventNames.LOADING, currentProgressInPercent);\n    this.emit(ESwarmStoreEventNames.DB_LOADING, [dbName, progress]);\n  };\n\n  private handleDatabaseUpdated = (dbName: string) => {\n    this.emit(ESwarmStoreEventNames.UPDATE, dbName);\n  };\n\n  /**\n   * write\n   * db.events.on('write', (address, entry, heads) => ... )\n   * Emitted after an entry was added locally to the database. hash is the IPFS hash of the latest state of the database.\n   * entry is the added database op.\n   *\n   * @private\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  private handleNewEntryAddedToDatabase = ([\n    dbName,\n    entry,\n    address,\n    heads,\n    dbType,\n  ]: [\n    string,\n    LogEntry<ISwarmDatabaseValueTypes>,\n    string,\n    any,\n    ESwarmStoreConnectorOrbitDbDatabaseType\n  ]) => {\n    // TODO - FOR KEY VALUE STOE. If added two different values for the same key,\n    // then two messages related to this values will be emitted anyway\n    // not just one, which is the latest one, but both messages.\n    // Both two messages will be emitted after the instance was preloaded\n    console.log(\n      `SwarmStoreConnectorOrbitDB::handleNewEntryAddedToDatabase:emit NEW_ENTRY`,\n      {\n        dbName,\n        entry,\n        address,\n        heads,\n      }\n    );\n    this.emit(ESwarmStoreEventNames.NEW_ENTRY, [\n      dbName,\n      entry,\n      address,\n      heads,\n      dbType,\n    ]);\n  };\n\n  private async setListenersDatabaseEvents(\n    database: SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >,\n    isSet: boolean = true\n  ): Promise<Error | void> {\n    const methodName = isSet\n      ? COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON\n      : COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_OFF;\n\n    if (isSet) {\n      const dbCloseHandler = (err: Error) => {\n        this.handleDatabaseStoreClosed(database, err);\n      };\n\n      database[methodName](ESwarmStoreEventNames.CLOSE, dbCloseHandler);\n      database[methodName](ESwarmStoreEventNames.FATAL, dbCloseHandler);\n      this.dbCloseListeners.push(dbCloseHandler);\n    } else {\n      this.dbCloseListeners.forEach((dbCloseHandler) => {\n        database[methodName](ESwarmStoreEventNames.CLOSE, dbCloseHandler);\n        database[methodName](ESwarmStoreEventNames.FATAL, dbCloseHandler);\n      });\n    }\n    database[methodName](\n      ESwarmStoreEventNames.LOADING,\n      this.handleLoadingProgress\n    );\n    database[methodName](\n      ESwarmStoreEventNames.UPDATE,\n      this.handleDatabaseUpdated\n    );\n    database[methodName](\n      ESwarmStoreEventNames.NEW_ENTRY,\n      this.handleNewEntryAddedToDatabase\n    );\n  }\n\n  private async unsetListenersDatabaseEvents(\n    database: SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >\n  ): Promise<Error | void> {\n    this.setListenersDatabaseEvents(database, false);\n  }\n\n  private async closeDatabases(): Promise<Error | void> {\n    const { databases } = this;\n\n    // set that the orbit db is not ready to use\n    this.setNotReady();\n    if (!databases || !databases.length) {\n      return;\n    }\n\n    try {\n      let idx = 0;\n      const databasesToClose = [...databases];\n      const len = databasesToClose.length;\n\n      for (; idx < len; idx += 1) {\n        const db = databasesToClose[idx];\n        const dbCloseResult = await this.closeDb(db);\n\n        if (dbCloseResult instanceof Error) {\n          console.error(this.emitError(dbCloseResult));\n          this.emitError(\n            'An error has occurred on closing the database',\n            'closeDatabases'\n          );\n        }\n      }\n      this.databases = [];\n    } catch (err) {\n      return err;\n    }\n  }\n\n  private waitDatabaseOpened(\n    database: SwarmStoreConnectorOrbitDBDatabase<\n      ISwarmDatabaseValueTypes,\n      DbType\n    >\n  ): Promise<Error | boolean> {\n    return new Promise<Error | boolean>(async (res) => {\n      let timeout: NodeJS.Timer | undefined = undefined;\n\n      function usetListeners() {\n        database.removeListener(ESwarmStoreEventNames.READY, res);\n        database.removeListener(ESwarmStoreEventNames.CLOSE, res);\n        database.removeListener(ESwarmStoreEventNames.FATAL, res);\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        timeout = undefined;\n      }\n\n      timeout = setTimeout(async () => {\n        usetListeners();\n        res(\n          new Error('Failed to open the database cause the timeout has reached')\n        );\n      }, SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONNECTION_TIMEOUT_MS);\n      try {\n        database.once(ESwarmStoreEventNames.CLOSE, () => {\n          usetListeners();\n          res(new Error('Database was closed'));\n        });\n        database.once(ESwarmStoreEventNames.FATAL, () => {\n          usetListeners();\n          res(new Error('A fatal error has occurred while open the database'));\n        });\n        database.once(ESwarmStoreEventNames.READY, () => {\n          usetListeners();\n          console.log('dbReady', database.dbName);\n          res(true);\n        });\n\n        //connect to the database\n        // and wait for an events from it\n        const connectResult = await database.connect();\n\n        if (connectResult instanceof Error) {\n          usetListeners();\n          console.error(connectResult);\n          return this.emitError('The database.connect method was failed');\n        }\n      } catch (err) {\n        console.error(err);\n        usetListeners();\n        res(err);\n      }\n    });\n  }\n\n  private async openDatabases(): Promise<Error | void> {\n    const { options } = this;\n\n    if (!options) {\n      return this.emitError(\n        'The options must be specified to open the databases'\n      );\n    }\n\n    const { databases } = options;\n    const databasesOptions = [...databases];\n\n    if (!(databasesOptions instanceof Array)) {\n      return this.emitError('The options for databases must be specified');\n    }\n    if (!databasesOptions.length) {\n      return;\n    }\n    try {\n      let idx = 0;\n      const len = databasesOptions.length;\n\n      for (; idx < len; idx += 1) {\n        const options = databasesOptions[idx];\n        const startResultStatus = await this.openDatabaseNotCheckOptionsExists(\n          options\n        );\n\n        if (startResultStatus instanceof Error) {\n          console.error(startResultStatus);\n          await this.closeDatabases();\n          return new Error('Failed to open the database');\n        }\n      }\n    } catch (err) {\n      await this.closeDatabases();\n      return this.emitError(err);\n    }\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types.ts",[],"/home/paul/projects/protocol/src/components/app-render.tsx",[],"/home/paul/projects/protocol/src/components/app.tsx",["2424","2425","2426"],"import React from 'react';\nimport { FileStoreAddFile } from 'components/filestore-add-file/filestore-add-file';\nimport { ConnectToSwarm } from 'components/connect-to-swarm';\nimport { SensitiveDataStorage } from 'components/sensitive-data-storage';\nimport { ConnectToSwarmImmediate } from './connect-to-swarm-immediate/connect-to-swarm-immediate';\n\nexport class App extends React.Component {\n  render() {\n    // return <FileStoreAddFile />;\n    // return <SensitiveDataStorage />;\n    // return <ConnectToSwarm />;\n    return <ConnectToSwarmImmediate />;\n  }\n}\n\nexport default App;\n","/home/paul/projects/protocol/src/components/connect-to-swarm/connect-to-swarm.const.ts",[],"/home/paul/projects/protocol/src/components/connect-to-swarm/connect-to-swarm.tsx",["2427","2428","2429"],"import React from 'react';\nimport { connectToSwarmUtil } from './connect-to-swarm.utils';\nimport { IConnectionBridge } from 'classes/connection-bridge/connection-bridge.types';\nimport {\n  CONNECT_TO_SWARM_DATABASE_MAIN,\n  CONNECT_TO_SWARM_DATABASE_MAIN_2,\n} from './connect-to-swarm.const';\nimport {\n  CONNECT_TO_SWARM_AUTH_CREDENTIALS_USEDID_1,\n  CONNECT_TO_SWARM_AUTH_CREDENTIALS_USEDID_2,\n} from './connect-to-swarm.const';\nimport {\n  CONNECT_TO_SWARM_DATABASE_MAIN_NAME,\n  CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY,\n} from './connect-to-swarm.const';\nimport {\n  CONNECT_TO_SWARM_AUTH_CREDENTIALS_SESSION_STORAGE_KEY,\n  CONNECT_TO_SWARM_AUTH_CREDENTIALS_1,\n  CONNECT_TO_SWARM_AUTH_CREDENTIALS_2,\n} from './connect-to-swarm.const';\nimport {\n  ESwarmStoreConnectorOrbitDbDatabaseMethodNames,\n  ISwarmStoreDatabasesCommonStatusList,\n  ESwarmStoreEventNames,\n} from 'classes';\nimport { SwarmStoreDbComponent } from '../swarm-store-db-component/swarm-store-db-component';\nimport { ESwarmMessageStoreEventNames } from '../../classes/swarm-message-store/swarm-message-store.const';\nimport { ConnectionBridge } from '../../classes/connection-bridge/connection-bridge';\nimport { ESwarmStoreConnector } from '../../classes/swarm-store-class/swarm-store-class.const';\nimport { TSwarmMessageInstance } from '../../classes/swarm-message/swarm-message-constructor.types';\nimport { ISwarmMessageInstanceDecrypted } from '../../classes/swarm-message/swarm-message-constructor.types';\nimport { ISecretStorage } from '../../classes/secret-storage-class/secret-storage-class.types';\nimport { ICentralAuthorityUserProfile } from '../../classes/central-authority-class/central-authority-class-types/central-authority-class-types-common';\nimport { UserProfile } from '../userProfile/userProfile';\nimport { ISwarmStoreDatabaseBaseOptions } from '../../classes/swarm-store-class/swarm-store-class.types';\nimport { SwarmMessagesDatabaseComponent } from '../swarm-messages-database-component/swarm-messages-database-component';\n\nexport interface IMessageDescription {\n  id: string;\n  key?: string;\n  message: ISwarmMessageInstanceDecrypted;\n}\n\nexport interface IConnectToSwarmProps {\n  connectImmediateWithCredentials?: 1 | 2;\n  dbOptionsToConnectImmediate?: Partial<ISwarmStoreDatabaseBaseOptions> & {\n    dbName: ISwarmStoreDatabaseBaseOptions['dbName'];\n  };\n}\n\nexport class ConnectToSwarm extends React.PureComponent<IConnectToSwarmProps> {\n  public state = {\n    isConnecting: false,\n    messagingSending: undefined as NodeJS.Timeout | undefined,\n    error: undefined as Error | undefined,\n    connectionBridge: undefined as IConnectionBridge | undefined,\n    userId: undefined as string | undefined,\n    // was the database main removed by the user\n    dbRemoved: false,\n    dbRemoving: false,\n    messages: [] as any[],\n    messagesReceived: new Map() as Map<\n      string,\n      Map<string, IMessageDescription>\n    >,\n    databasesList: undefined as\n      | ISwarmStoreDatabasesCommonStatusList\n      | undefined,\n    swarmStoreMessagesDbOptionsList: [] as ISwarmStoreDatabaseBaseOptions[],\n    databaseOpeningStatus: false as boolean,\n    credentialsVariant: undefined as undefined | number,\n    secretStorage: undefined as undefined | ISecretStorage,\n    userProfileData: undefined as\n      | undefined\n      | Partial<ICentralAuthorityUserProfile>,\n  };\n\n  protected get defaultDbOptions() {\n    return this.state.credentialsVariant === 1\n      ? CONNECT_TO_SWARM_DATABASE_MAIN\n      : CONNECT_TO_SWARM_DATABASE_MAIN_2;\n  }\n\n  protected sendSwarmMessage = async () => {\n    try {\n      const key = 'test_message';\n\n      await this.state.connectionBridge?.storage?.addMessage(\n        CONNECT_TO_SWARM_DATABASE_MAIN_NAME,\n        {\n          ...CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY,\n        },\n        key\n      );\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\n  protected sendPrivateSwarmMessage = async () => {\n    try {\n      await this.state.connectionBridge?.storage?.addMessage(\n        CONNECT_TO_SWARM_DATABASE_MAIN_NAME,\n        {\n          ...CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY,\n          receiverId:\n            this.state.userId === CONNECT_TO_SWARM_AUTH_CREDENTIALS_USEDID_1\n              ? CONNECT_TO_SWARM_AUTH_CREDENTIALS_USEDID_2\n              : CONNECT_TO_SWARM_AUTH_CREDENTIALS_USEDID_1,\n        }\n      );\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\n  protected toggleMessagesSending = (isPrivate: boolean = false) => {\n    this.setState((state: any) => {\n      if (state.messagingSending) {\n        clearInterval(state.messagingSending);\n        return {\n          messagingSending: undefined,\n        };\n      }\n\n      const method = isPrivate\n        ? this.sendPrivateSwarmMessage\n        : this.sendSwarmMessage;\n\n      method();\n      return {\n        messagingSending: setInterval(method, 1000),\n      };\n    });\n  };\n\n  public handleDatabaseRemove = async () => {\n    const { connectionBridge } = this.state;\n\n    if (connectionBridge) {\n      this.setState({\n        dbRemoving: true,\n      });\n      await connectionBridge.storage?.dropDatabase(\n        CONNECT_TO_SWARM_DATABASE_MAIN_NAME\n      );\n      this.setState({\n        dbRemoved: true,\n        dbRemoving: false,\n      });\n    }\n  };\n\n  protected renderConnectToDatabase() {\n    return (\n      <div>\n        <h2>Database connection</h2>\n        <button onClick={this.handleDatabaseRemove}>Remove the database</button>\n      </div>\n    );\n  }\n\n  public connectToDb = async () => {\n    const { connectionBridge } = this.state;\n\n    if (connectionBridge && connectionBridge.storage) {\n      await connectionBridge.storage?.openDatabase(\n        CONNECT_TO_SWARM_DATABASE_MAIN\n      );\n      this.setState({\n        dbRemoved: false,\n      });\n    }\n  };\n\n  public loadNextMessages = async () => {\n    const { connectionBridge } = this.state;\n\n    if (connectionBridge) {\n      const result = await connectionBridge.storage?.request(\n        CONNECT_TO_SWARM_DATABASE_MAIN_NAME,\n        ESwarmStoreConnectorOrbitDbDatabaseMethodNames.load,\n        10\n      );\n      console.log(result);\n    }\n  };\n\n  public renderLoadMessages() {\n    return (\n      <div>\n        <button onClick={this.loadNextMessages}>Load next 10 messages</button>\n      </div>\n    );\n  }\n  public renderConnectedState() {\n    const { messagingSending, userId, dbRemoved, dbRemoving } = this.state;\n\n    if (dbRemoved) {\n      return <div onClick={this.connectToDb}>Connect to database</div>;\n    }\n    if (dbRemoving) {\n      return <span>Database removing...</span>;\n    }\n    return (\n      <div>\n        <div>Is connected with user identity ${userId}</div>\n        <button onClick={() => this.toggleMessagesSending()}>\n          {messagingSending ? 'Stop' : 'Start'} messages sending\n        </button>\n        <button onClick={() => this.toggleMessagesSending(true)}>\n          {messagingSending ? 'Stop' : 'Start'} private messages sending\n        </button>\n        {this.renderUserProfile()}\n        {this.renderDatabasesList()}\n        {this.renderSwarmMessagesDatabasesList()}\n        {this.renderConnectToDatabase()}\n        {this.renderLoadMessages()}\n      </div>\n    );\n  }\n\n  public componentDidMount() {\n    const { connectImmediateWithCredentials } = this.props;\n\n    if (connectImmediateWithCredentials != null) {\n      this.connectToSwarm(connectImmediateWithCredentials);\n    }\n  }\n\n  public render() {\n    const { connectionBridge, isConnecting, error } = this.state;\n\n    if (error) {\n      return <span>Error: {error.message}</span>;\n    }\n    if (connectionBridge) {\n      return this.renderConnectedState();\n    }\n    if (!connectionBridge && !isConnecting) {\n      return (\n        <div>\n          <button onClick={() => this.connectToSwarm()}>Connect cred 1</button>\n          <button onClick={() => this.connectToSwarm(2)}>Connect cred 2</button>\n        </div>\n      );\n    }\n    return <span>Connecting...</span>;\n  }\n\n  protected handleDatabasesListUpdate = (\n    databasesList: ISwarmStoreDatabasesCommonStatusList\n  ) => {\n    this.setState({\n      databasesList: { ...databasesList },\n    });\n  };\n\n  protected handleMessage = (\n    dbName: string,\n    message: TSwarmMessageInstance,\n    id: string,\n    key: string\n  ) => {\n    const { messagesReceived } = this.state;\n    const messagesMap = messagesReceived.get(dbName) || new Map();\n    // TODO - to get all of actual values for KV-store it is necessary\n    // to iterate overall database. Cause for a KV store implemented\n    // by the OrbitDB only the \"db.all\" method returns all keys, so\n    // in this implementation only thught the iterate method of a db\n    // this is able to iterate over all items(db.all)\n\n    if (!messagesMap.get(id)) {\n      messagesMap.set(id, {\n        message,\n        id,\n        key,\n      });\n      messagesReceived.set(dbName, messagesMap);\n      this.forceUpdate();\n    }\n  };\n\n  protected setListenersConnectionBridge(\n    connectionBridge: ConnectionBridge<ESwarmStoreConnector>\n  ) {\n    connectionBridge.storage?.addListener(\n      ESwarmStoreEventNames.DATABASES_LIST_UPDATED,\n      this.handleDatabasesListUpdate\n    );\n    connectionBridge.storage?.addListener(\n      ESwarmMessageStoreEventNames.NEW_MESSAGE,\n      this.handleMessage\n    );\n  }\n\n  protected connectToSwarm = async (credentialsVariant: 1 | 2 = 1) => {\n    this.setState({\n      isConnecting: true,\n      credentialsVariant,\n    });\n    try {\n      const connectionBridge = await connectToSwarmUtil(\n        credentialsVariant === 1\n          ? CONNECT_TO_SWARM_AUTH_CREDENTIALS_1\n          : CONNECT_TO_SWARM_AUTH_CREDENTIALS_2\n      );\n\n      sessionStorage.setItem(\n        CONNECT_TO_SWARM_AUTH_CREDENTIALS_SESSION_STORAGE_KEY,\n        'true'\n      );\n\n      const userId = connectionBridge?.caConnection?.getUserIdentity();\n      const userProfileData = await connectionBridge?.caConnection?.getCAUserProfile();\n\n      this.setState({\n        connectionBridge,\n        userId,\n        databasesList: connectionBridge.storage?.databases,\n        secretStorage: connectionBridge.secretStorage,\n        userProfileData,\n      });\n      this.setListenersConnectionBridge(connectionBridge);\n\n      const { dbOptionsToConnectImmediate } = this.props;\n\n      if (dbOptionsToConnectImmediate) {\n        await this.handleOpenNewSwarmStoreMessagesDatabase(\n          dbOptionsToConnectImmediate\n        );\n      }\n    } catch (error) {\n      this.setState({\n        error,\n      });\n    }\n  };\n\n  public handleOpenDatabase = async (dbName?: string) => {\n    try {\n      this.setState({\n        databaseOpeningStatus: true,\n      });\n      await this.state.connectionBridge?.storage?.openDatabase({\n        ...this.defaultDbOptions,\n        dbName: dbName || this.defaultDbOptions.dbName,\n      });\n    } catch (err) {\n      console.error(err);\n    } finally {\n      this.setState({\n        databaseOpeningStatus: false,\n      });\n    }\n  };\n\n  public handleClickOpenNewSwarmStoreMessagesDatabase = () => {\n    this.handleOpenNewSwarmStoreMessagesDatabase();\n  };\n\n  public handleOpenNewDatabase = async () => {\n    const dbName = window.prompt('Enter database name', '');\n\n    if (dbName) {\n      await this.handleOpenDatabase(dbName);\n    }\n  };\n\n  protected handleOpenNewSwarmStoreMessagesDatabase = async (\n    dbOptionsToConnectImmediate?: Partial<ISwarmStoreDatabaseBaseOptions>\n  ) => {\n    const dbNameToOpen = dbOptionsToConnectImmediate?.dbName;\n    const dbName = dbNameToOpen || window.prompt('Enter database name', '');\n\n    if (dbName) {\n      const dbOptions = {\n        ...this.defaultDbOptions,\n        ...dbOptionsToConnectImmediate,\n        dbName: dbName || this.defaultDbOptions.dbName,\n      };\n      this.setState(({ swarmStoreMessagesDbOptionsList }: any) => ({\n        swarmStoreMessagesDbOptionsList: [\n          ...swarmStoreMessagesDbOptionsList,\n          dbOptions,\n        ],\n      }));\n    }\n  };\n\n  protected renderUserProfile() {\n    const { userId, userProfileData } = this.state;\n    return <UserProfile id={userId} profile={userProfileData} />;\n  }\n\n  protected renderDatabasesList() {\n    const {\n      databasesList,\n      connectionBridge,\n      databaseOpeningStatus,\n    } = this.state;\n    const dbsOptions = databasesList?.options;\n    const isDefaultDatabaseWasOpenedBeforeOrOpening =\n      !databaseOpeningStatus && !dbsOptions?.[this.defaultDbOptions.dbName];\n\n    return (\n      <div>\n        <div>\n          <h4>List of databases:</h4>\n          {!!databasesList &&\n            !!dbsOptions &&\n            Object.keys(dbsOptions).map((databaseName) => {\n              const databaseOptions = dbsOptions[databaseName];\n              const isOpened = databasesList.opened[databaseName];\n              const dbMessages = this.state.messagesReceived.get(databaseName);\n\n              return (\n                <SwarmStoreDbComponent\n                  key={databaseName}\n                  databaseOptions={databaseOptions}\n                  isOpened={isOpened}\n                  connectionBridge={connectionBridge}\n                  messages={Array.from(dbMessages?.values() || [])}\n                />\n              );\n            })}\n        </div>\n        {!!isDefaultDatabaseWasOpenedBeforeOrOpening ? (\n          <button onClick={() => this.handleOpenDatabase()}>\n            Open default database\n          </button>\n        ) : (\n          <button onClick={this.handleOpenNewDatabase}>\n            Open new database\n          </button>\n        )}\n      </div>\n    );\n  }\n\n  protected renderSwarmMessagesDatabasesList() {\n    const { swarmStoreMessagesDbOptionsList, connectionBridge } = this.state;\n    const { dbOptionsToConnectImmediate } = this.props;\n\n    return (\n      <div>\n        <div>\n          <h4>List of swarm messages databases:</h4>\n          {swarmStoreMessagesDbOptionsList.map((dbsOptions) => {\n            const { userId } = this.state;\n            if (!userId) {\n              throw new Error('User identity should not be empty');\n            }\n            return (\n              <SwarmMessagesDatabaseComponent\n                key={dbsOptions.dbName}\n                userId={userId}\n                databaseOptions={dbsOptions}\n                connectionBridge={connectionBridge}\n                isOpenImmediate={\n                  dbsOptions.dbName === dbOptionsToConnectImmediate?.dbName\n                }\n              />\n            );\n          })}\n        </div>\n        <button onClick={this.handleClickOpenNewSwarmStoreMessagesDatabase}>\n          Open new swarm store database\n        </button>\n      </div>\n    );\n  }\n}\n","/home/paul/projects/protocol/src/components/connect-to-swarm/connect-to-swarm.utils.ts",["2430"],"import { ConnectionBridge } from 'classes';\nimport { CONNECT_TO_SWARM_CONNECTION_OPTIONS } from './connect-to-swarm.const';\n\nexport const connectToSwarmUtil = async (credentials: any) => {\n  const connectionBridge = new ConnectionBridge();\n  const useSessionAuth = await connectionBridge.checkSessionAvailable({\n    ...CONNECT_TO_SWARM_CONNECTION_OPTIONS,\n    auth: {\n      ...CONNECT_TO_SWARM_CONNECTION_OPTIONS.auth,\n      credentials: undefined,\n    },\n  });\n\n  await connectionBridge.connect({\n    ...CONNECT_TO_SWARM_CONNECTION_OPTIONS,\n    auth: {\n      ...CONNECT_TO_SWARM_CONNECTION_OPTIONS.auth,\n      credentials: useSessionAuth ? undefined : credentials,\n    },\n  });\n  return connectionBridge;\n};\n","/home/paul/projects/protocol/src/components/connect-to-swarm/index.ts",[],"/home/paul/projects/protocol/src/components/filestore-add-file/filestore-add-file.tsx",["2431"],"import React, { MouseEvent } from 'react';\nimport { downloadFile } from '../../utils/files-utils/files-utils-download';\nimport { IFileStorage } from '../../classes/filestorage-class/filestorage-class.types';\nimport { FILE_STORAGE_SERVICE_TYPE } from '../../classes/filestorage-class/filestorage-class.const';\nimport { connectToFileStorage } from './filestore-add-file.utils';\n\nexport class FileStoreAddFile extends React.Component {\n  protected fileStorage:\n    | IFileStorage<\n        FILE_STORAGE_SERVICE_TYPE.HTTP | FILE_STORAGE_SERVICE_TYPE.IPFS\n      >\n    | undefined;\n\n  protected loadingProgress: number | undefined = undefined;\n\n  protected uploadedFiles: string[] = [];\n\n  protected styles = {\n    filesLoadedContainer: {\n      paddingBottom: '10px',\n    },\n  };\n\n  public componentDidMount() {\n    this.createFilestoreInstance();\n  }\n\n  public render() {\n    const { fileStorage: fileStore } = this;\n\n    if (!fileStore) {\n      return <div>Not ready</div>;\n    }\n    return (\n      <>\n        {this.renderFileDownload()}\n        {this.renderFileUpload()}\n      </>\n    );\n  }\n\n  protected async createFilestoreInstance() {\n    this.fileStorage = await connectToFileStorage();\n    this.forceUpdate();\n  }\n\n  protected handleFileChosen = async (\n    ev: React.ChangeEvent<HTMLInputElement>\n  ) => {\n    if (this.loadingProgress != null) {\n      return;\n    }\n\n    const { target } = ev;\n    const { fileStorage: fileStore } = this;\n\n    if (fileStore && target.files) {\n      const file = target.files[0];\n\n      this.loadingProgress = 0;\n      try {\n        console.dir(file);\n        const [loadedAddr] = await Promise.all([\n          fileStore.add(FILE_STORAGE_SERVICE_TYPE.IPFS, file.name, file, {\n            progress: (progress: number) => {\n              this.loadingProgress = progress;\n              this.forceUpdate();\n            },\n          }),\n          Promise.resolve().then(() => {\n            this.forceUpdate();\n          }),\n        ]);\n        this.uploadedFiles.push(loadedAddr);\n      } catch (err) {\n        console.error(err);\n      } finally {\n        this.loadingProgress = undefined;\n        this.forceUpdate();\n      }\n    }\n  };\n\n  private handleFileDownload = async (ev: MouseEvent<HTMLAnchorElement>) => {\n    const { target } = ev;\n    const { textContent } = target as HTMLAnchorElement;\n\n    ev.preventDefault();\n    if (textContent) {\n      await this.fileStorage?.download(textContent);\n    }\n  };\n\n  protected handleFileDownloadByURL = async () => {\n    const inpEl = document.getElementById('fileDownload');\n    const url = (inpEl as HTMLInputElement)?.value;\n\n    if (url) {\n      try {\n        const result = await this.fileStorage?.get(`/file/${url}`);\n\n        if (!(result instanceof File)) {\n          throw new Error('Failed to get the file');\n        }\n        downloadFile(result);\n      } catch (err) {\n        console.error(err);\n      }\n    }\n  };\n\n  protected renderFilesLoadedList() {\n    const { uploadedFiles } = this;\n\n    return uploadedFiles.map((fileAddr, idx) => (\n      <div key={fileAddr}>\n        <pre>{idx}. </pre>\n        <a\n          href=\"#\"\n          role=\"button\"\n          data-name={fileAddr}\n          onClick={this.handleFileDownload}\n        >\n          {fileAddr}\n        </a>\n      </div>\n    ));\n  }\n\n  protected renderFileUpload() {\n    if (this.loadingProgress != null) {\n      return <div>Upload progress: {this.loadingProgress}</div>;\n    }\n    return (\n      <div>\n        <div style={this.styles.filesLoadedContainer}>\n          {this.renderFilesLoadedList()}\n        </div>\n        <label htmlFor=\"fileUpload\">File: </label>\n        <input id=\"fileUpload\" type=\"file\" onChange={this.handleFileChosen} />\n      </div>\n    );\n  }\n\n  protected renderFileDownload() {\n    return (\n      <div>\n        <label htmlFor=\"fileUpload\">Url: </label>\n        <input id=\"fileDownload\" type=\"text\" />\n        <button onClick={this.handleFileDownloadByURL}>Download</button>\n      </div>\n    );\n  }\n}\n","/home/paul/projects/protocol/src/components/filestore-add-file/filestore-add-file.utils.ts",["2432","2433","2434"],"import { FileStorageClassProviderIPFS } from 'classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs';\nimport { ipfsUtilsConnectBasic } from 'utils/ipfs-utils/ipfs-utils';\nimport { IFileStorageService } from '../../classes/filestorage-class/filestorage-class.types';\nimport { FileStorageClassProviderHTTP } from '../../classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http';\nimport {\n  FileStorage,\n  FILE_STORAGE_SERVICE_TYPE,\n} from 'classes/filestorage-class';\n\nexport const connectToFileStorage = async () => {\n  const ipfs = await ipfsUtilsConnectBasic();\n  const optionsIpfs = {\n    ipfs,\n  };\n  const optionsHTTP = {};\n  const fileStoreProvider = new FileStorage();\n\n  await fileStoreProvider.connect([\n    {\n      type: FILE_STORAGE_SERVICE_TYPE.IPFS,\n      options: optionsIpfs,\n    },\n    {\n      type: FILE_STORAGE_SERVICE_TYPE.HTTP,\n      options: optionsHTTP,\n    },\n  ]);\n  return fileStoreProvider;\n};\n","/home/paul/projects/protocol/src/components/filestore-add-file/index.ts",[],"/home/paul/projects/protocol/src/components/sensitive-data-storage/index.ts",[],"/home/paul/projects/protocol/src/components/sensitive-data-storage/sensitive-data-storage.tsx",[],"/home/paul/projects/protocol/src/const/common-date-time/common-date-time-main.ts",[],"/home/paul/projects/protocol/src/const/common-date-time/common-date-time-ntp-servers.const.ts",[],"/home/paul/projects/protocol/src/const/common-date-time/common-date-time-timezone.const.ts",[],"/home/paul/projects/protocol/src/const/common-date-time/index.ts",[],"/home/paul/projects/protocol/src/const/common-values/common-values-env.ts",[],"/home/paul/projects/protocol/src/const/common-values/common-values.ts",[],"/home/paul/projects/protocol/src/const/common-values/index.ts",[],"/home/paul/projects/protocol/src/const/const-api-conf.ts",[],"/home/paul/projects/protocol/src/const/const-crypto-keys/const-crypto-keys.ts",[],"/home/paul/projects/protocol/src/const/const-crypto-keys/index.ts",[],"/home/paul/projects/protocol/src/const/const-validation-regex/const-validation-regex-common.ts",[],"/home/paul/projects/protocol/src/const/const-validation-regex/index.ts",[],"/home/paul/projects/protocol/src/const/const-validation-schemes/const-validation-schemes-common.ts",[],"/home/paul/projects/protocol/src/const/const-validation-schemes/const-validation-schemes-credentials.ts",[],"/home/paul/projects/protocol/src/const/const-validation-schemes/const-validation-schemes.ts",[],"/home/paul/projects/protocol/src/const/const-validation-schemes/index.ts",[],"/home/paul/projects/protocol/src/const/const-validation-values/const-validation-values-messaging-date.ts",[],"/home/paul/projects/protocol/src/const/const-validation-values/index.ts",[],"/home/paul/projects/protocol/src/const/const-values-restrictions-common.ts",[],"/home/paul/projects/protocol/src/dev.ts",[],"/home/paul/projects/protocol/src/index.ts",[],"/home/paul/projects/protocol/src/prod.ts",[],"/home/paul/projects/protocol/src/react-app-env.d.ts",[],"/home/paul/projects/protocol/src/types/channels.types.ts",[],"/home/paul/projects/protocol/src/types/common.types.ts",[],"/home/paul/projects/protocol/src/types/encryption-keys.types.ts",[],"/home/paul/projects/protocol/src/types/helper.types.ts",["2435","2436","2437","2438","2439","2440","2441","2442","2443"],"// eslint-disable-next-line @typescript-eslint/ban-types\nexport type TPrototypeKeys = keyof Object;\n\nexport type ownKeyOf<T extends object> = keyof T extends TPrototypeKeys\n  ? never\n  : keyof T;\n\n// onlye own properties values\nexport type ownValueOf<T extends object> = keyof T extends ownKeyOf<T>\n  ? T[keyof T]\n  : never;\n\nexport type ArgumentTypes<F extends Function> = F extends (\n  ...args: infer A\n) => any\n  ? A\n  : never;\n\nexport type FirstPrameter<F extends (arg: any) => any> = Parameters<\n  F\n> extends Array<infer FirstArg>\n  ? FirstArg\n  : never;\ntype FirstPrameter<F extends (arg: any) => any> = Parameters<F> extends Array<\n  infer FirstArg\n>\n  ? FirstArg\n  : never;\n\nexport type OmitTypeProp<T extends {}, E> = {\n  [k in keyof T]: T[k] extends E ? never : T[k];\n};\n\nexport type OmitType<T, O> = T extends O ? never : T;\n\nexport type ConstructorType<R, A extends Array<any> = any[]> = new (\n  ...args: A\n) => R;\n\nexport type ArrayFirst<T extends any[]> = T extends Array<infer F> ? F : never;\n\nexport type Defined<T extends {}> = {\n  [k in keyof T]: T[k] extends undefined ? NonNullable<T[k]> : T[k];\n};\n\nexport type OmitFirstArg<F extends Function> = F extends (\n  x: any,\n  ...args: infer P\n) => infer R\n  ? (...args: P) => R\n  : never;\n\nexport type ArrayElement<\n  ArrayType extends readonly unknown[]\n> = ArrayType[number];\n","/home/paul/projects/protocol/src/types/index.d.ts",[],"/home/paul/projects/protocol/src/types/ipfs.d.ts",[],"/home/paul/projects/protocol/src/types/ipfs.types.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-bootstrap.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-delegated-content-routing.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-delegated-peer-routing.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-gossipsub.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-kad-dht.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-mdns.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-secio.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-spdy.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-stardust.d.ts",["2444","2445","2446"],"/** Declaration file generated by dts-gen */\r\n\r\ndeclare module 'libp2p-stardust' {\r\n  export = libp2p_stardust;\r\n\r\n  function libp2p_stardust(...args: any[]): any;\r\n\r\n  function isstardust(obj: any): void;\r\n\r\n  libp2p_stardust.isstardust = isstardust;\r\n}\r\n","/home/paul/projects/protocol/src/types/libp2p-tcp.d.ts",["2447","2448","2449"],"/** Declaration file generated by dts-gen */\r\ndeclare module 'libp2p-tcp' {\r\n  export = libp2p_tcp;\r\n\r\n  declare function libp2p_tcp(...args: any[]): any;\r\n\r\n  declare namespace libp2p_tcp {\r\n    function isTCP(obj: any): void;\r\n  }\r\n}\r\n","/home/paul/projects/protocol/src/types/libp2p-webrtc-direct.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-webrtc-star.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-websocket-star.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-websockets.d.ts",["2450","2451","2452"],"/** Declaration file generated by dts-gen */\r\n\r\ndeclare module 'libp2p-websockets' {\r\n  export = libp2p_websockets;\r\n\r\n  declare function libp2p_websockets(...args: any[]): any;\r\n\r\n  declare namespace libp2p_websockets {\r\n    function isWebSockets(obj: any): void;\r\n  }\r\n}\r\n","/home/paul/projects/protocol/src/types/libp2p.d.ts",[],"/home/paul/projects/protocol/src/types/main.types.ts",[],"/home/paul/projects/protocol/src/types/multiaddr.d.ts",[],"/home/paul/projects/protocol/src/types/orbit-db-cache.d.ts",[],"/home/paul/projects/protocol/src/types/orbit-db-identity-provider-ext.d.ts",[],"/home/paul/projects/protocol/src/types/orbit-db-keystore.d.ts",["2453","2454","2455","2456","2457","2458"],"import 'orbit-db-keystore';\n\nexport interface IOrbitDBKeystoreStoreCustom {\n  status: string;\n  open(): Promise<void>;\n  close(): Promise<void>;\n  put(k: string, v: any): Promise<void>;\n  get(k: string): string | Uint8Array;\n  verify(\n    publicKeySignature: string,\n    publicKey: string,\n    publicKeyAndId: string\n  ): Promise<boolen>;\n}\n\ndeclare module 'orbit-db-keystore' {\n  export interface IOrbitDBKeystoreStore extends IOrbitDBKeystoreStoreCustom {\n  }\n\n  export interface IOrbitDBKeystoreCache {\n    length: number;\n    keys: string[];\n    set(k: string, v: any): void;\n    get(k: string): any;\n    remove(k: string): void;\n    clear(): void;\n  }\n\n  /**\n   *\n   *\n   * @export\n   * @interface IOrbitDBKeystoreOptionsForSecretStorage\n   * @property {string} path - the custom name of the storage\n   */\n  export interface IOrbitDBKeystoreOptionsForSecretStorage {\n    store?: string | IOrbitDBKeystoreStoreCustom;\n    cache?: IOrbitDBKeystoreCache;\n    path?: string;\n    credentials: {\n      password: string;\n    };\n  }\n\n  export type TOrbitDBKeystoreOptions =\n    | IOrbitDBKeystoreOptionsForSecretStorage\n    | string;\n\n  export = class Keystore implements IOrbitDBKeystoreStore {\n    constructor(options: any) { }\n  }\n}\n","/home/paul/projects/protocol/src/types/orbit-db-storage-adapter.d.ts",[],"/home/paul/projects/protocol/src/types/pull-mplex.d.ts",[],"/home/paul/projects/protocol/src/types/storage.types.ts",[],"/home/paul/projects/protocol/src/types/users.types.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/common-utils-array.ts",["2459","2460","2461","2462","2463","2464","2465","2466","2467","2468","2469","2470"],"import { bytesInInteger } from './common-utils-number';\nimport { isDefined } from './common-utils-main';\n\nexport const commonUtilsIsInstanceOfArray = (a: any): a is Array<any> =>\n  !a || typeof a !== 'object' || a instanceof Array;\n\n/**\n * Checks whether two array items are equal\n *\n * @param {Array<any>} firstArray\n * @param {Array<any>} secondArray\n * @returns {boolean}\n */\nexport const commonUtilsIsTwoArraysEquals = (\n  firstArray: Array<any>,\n  secondArray: Array<any>\n): boolean => {\n  if (firstArray === secondArray) {\n    return true;\n  }\n  if (firstArray.length !== secondArray.length) {\n    return false;\n  }\n  return !firstArray.some((firstArrayItem, firstArrayItemIndex) => {\n    return firstArrayItem !== secondArray[firstArrayItemIndex];\n  }, true);\n};\n/**\n * Checks whether two items are arrays and the two array items are equal and return the second\n * one if equals.\n * Returns the second array if two arrays are equal or returns false otherwise.\n *\n * @template S\n * @template F\n * @param {F} firstArray\n * @param {S} secondArray\n * @returns {S | false}\n */\nexport const commonUtilsReturnArrayIfTwoArraysEquals = <S>(\n  firstArray: any,\n  secondArray: S\n): S extends Array<any> ? S : false =>\n  (commonUtilsIsInstanceOfArray(firstArray) &&\n  commonUtilsIsInstanceOfArray(secondArray) &&\n  commonUtilsIsTwoArraysEquals(firstArray, secondArray)\n    ? secondArray\n    : false) as S extends Array<any> ? S : false;\n\n/**\n * Checks whether all arrays has the same items in the same order\n *\n * @param {...Array<Array<any>>} arrays\n * @returns {boolean}\n */\nexport const commonUtilsAreAllArraysEqual = (\n  ...arrays: Array<Array<any>>\n): boolean => {\n  if (!arrays.length) {\n    return true;\n  }\n  if (arrays.length === 1) {\n    return commonUtilsIsInstanceOfArray(arrays[0]);\n  }\n  return !!arrays.reduce(commonUtilsReturnArrayIfTwoArraysEquals, arrays[0]);\n};\n\nexport const commonUtilsArrayOrderByDecComparationFunction = <T>(\n  a: T,\n  b: T\n): number => Number(b) - Number(a);\n\n/**\n * sort array by decreasing\n * value on increased index\n * @param {any[]} arr\n */\nexport const commonUtilsArrayOrderByDec = <T>(arr: T[]): T[] =>\n  arr.sort(commonUtilsArrayOrderByDecComparationFunction);\n\n/**\n * delete an item from the array\n * @param {Array} arr\n * @param {any} item\n */\n\nexport const commonUtilsArrayDeleteFromArray = <T>(arr: T[], item: T) => {\n  if (arr instanceof Array && arr.length) {\n    const idxOfItem = arr.findIndex((el: T) => el === item);\n\n    if (idxOfItem !== -1) {\n      arr.splice(idxOfItem, 1);\n    }\n  }\n};\n\n/**\n * call a callback function for an each item in the\n * array till the result is not an intstance of the\n * Error. If any callback resulted with an Error\n * then the execution will break.\n */\nexport const commonUtilsArrayDoCallbackTillNoError = <T>(\n  arr: T[],\n  cb: (v: T) => Error | any\n): Error | void => {\n  if (!(arr instanceof Array)) {\n    return new Error('The array value must be an instance of Array');\n  }\n\n  const len = arr.length;\n  let idx = 0;\n  let r: Error | any;\n\n  for (; idx < len; idx += 1) {\n    r = cb(arr[idx]);\n\n    if (r instanceof Error) {\n      return r;\n    }\n  }\n};\n\n/**\n * calculate the overall lenght\n * of the numeric array in bytes\n * @param {number[]} arr\n * @param {number} [maxNumber] - maximum value of the valid number\n * @param {number} [minNumber] - minimum value of the valid number\n * @returns {number | Error} - return a length of the array or an Error\n * if a non-finite or an unsafe number will be met\n */\nexport const commonUtilsArrayCalculateLengthOfIntegerArray = (\n  arr: number[],\n  maxNumber?: number,\n  minNumber?: number\n): number | Error => {\n  if (!(arr instanceof Array)) {\n    return new Error('The array value must be an instance of Array');\n  }\n\n  const maxNumberRes =\n    typeof maxNumber === 'number' ? maxNumber : Number.MAX_SAFE_INTEGER;\n  const minNumberRes = typeof minNumber === 'number' ? minNumber : 0;\n  const len = arr.length;\n  let idx = 0;\n  let item;\n  let result = 0;\n  let bytesInIntem;\n\n  for (; idx < len; idx += 1) {\n    item = arr[idx];\n\n    if (typeof item !== 'number') {\n      return new Error('The value is not a number');\n    }\n    if (!Number.isInteger(item)) {\n      return new Error('The value is not an integer number');\n    }\n    if (item < 0) {\n      return new Error('The number must be greater than 0');\n    }\n    if (!Number.isFinite(item)) {\n      return new Error('The value is not a finite number');\n    }\n    if (item > maxNumberRes) {\n      return new Error('The number is too big');\n    }\n    if (item < minNumberRes) {\n      return new Error('The number is too small');\n    }\n    bytesInIntem = bytesInInteger(item);\n    if (bytesInIntem instanceof Error) {\n      return bytesInIntem;\n    }\n    result += bytesInIntem;\n  }\n  return result;\n};\n\n/**\n * check wherether the array\n * includes all items\n * @param testedArray\n * @param requiredItems\n */\nexport const commonUtilsArrayIncludesAll = (\n  testedArray: any[],\n  requiredItems: any[]\n): boolean => {\n  const len = requiredItems.length;\n  let idx = 0;\n\n  while (idx < len) {\n    if (!testedArray.includes(requiredItems[idx])) {\n      return false;\n    }\n    idx++;\n  }\n  return true;\n};\n\n/**\n * Returns only defined items of an array\n *\n * @template T\n * @param {T[]} arr\n * @returns {T[]}\n */\nexport const commonUtilsArrayDefinedOnly = <T>(arr: T[]): NonNullable<T>[] =>\n  arr.filter(isDefined);\n\n/**\n * Returns uniq items of an array\n *\n * @template T\n * @param {T[]} arr\n * @returns {T[]}\n */\nexport const commonUtilsArrayUniq = <T>(arr: T[]): T[] =>\n  Array.from(new Set(arr));\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-check-value.ts",["2471"],"export const checkIsError = (v: any): v is Error => v instanceof Error;\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-date-time-synced.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/common-utils-date-time.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/common-utils-main.ts",["2472","2473","2474","2475"],"import { isTypedArray } from '../typed-array-utils';\nimport { TTypedArrays } from '../../types/main.types';\n\nexport const isDefined = <T>(v: T): v is NonNullable<T> => v != null;\n\n/**\n * Count of items\n *\n * @template T\n * @param {T} arg - argument which is able to count it's items number\n * @returns {number} - chars in string, bytes in typed arrays, keys in object, members in map, items in set, items in array\n */\nexport const getItemsCount = <\n  T extends Map<any, any> | Set<any> | Array<any> | {} | string | TTypedArrays\n>(\n  arg: T\n): number => {\n  if (arg instanceof Map || arg instanceof Set) {\n    return arg.size;\n  } else if (Array.isArray(arg)) {\n    return arg.length;\n  } else if (arg && typeof arg === 'object') {\n    return Object.keys(arg).length;\n  } else if (typeof arg === 'string') {\n    return arg.length;\n  } else if (isTypedArray(arg)) {\n    return arg.byteLength;\n  }\n  throw new Error('Unsupported type');\n};\n\n/**\n * Return a Promise which will be resolved\n * when the callback returns any value\n * which is defined(not null, ubdefined, NaN).\n *\n * @template R - resolved type return by the callback function\n * @param {() => R | undefined} cb - callback function called each interval till not trow or return somethind\n * @param {number} [checkIntervalMs=100] - interval when the callback will be called\n * @param {number} [timeoutMs = 360000] - timeout when the promise will be rejected if not resolved before\n * @returns {Promise<R>}\n * @throw - rejects on timeout or if the callback thrown an error\n */\nexport const waitFor = <R>(\n  cb: () => NonNullable<R> | undefined,\n  checkIntervalMs: number = 100,\n  timeoutMs: number = 360000\n): Promise<R> => {\n  return new Promise((res, rej) => {\n    let timeout: NodeJS.Timer | undefined;\n    let checkInterval: NodeJS.Timeout | undefined;\n    const clearTimers = () => {\n      checkInterval && clearInterval(checkInterval);\n      timeout && clearTimeout(timeout);\n      checkInterval = undefined;\n      timeout = undefined;\n    };\n\n    if (timeoutMs) {\n      timeout = setTimeout(() => {\n        clearTimers();\n        rej(new Error('Timeout'));\n      }, timeoutMs);\n    }\n    checkInterval = setInterval(() => {\n      let result;\n      try {\n        result = cb();\n      } catch (err) {\n        clearTimers();\n        rej(err);\n        return;\n      }\n      if (isDefined(result)) {\n        clearTimers();\n        res(result);\n      }\n    }, checkIntervalMs);\n  });\n};\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-number.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/common-utils-objects.ts",["2476","2477","2478","2479","2480"],"import { TObjectKeys, TDictionary } from 'types/common.types';\nimport { isDefined } from './common-utils-main';\n\nexport const isNotEmptyObject = (o: any): o is object => {\n  return !!o && typeof o === 'object' && !!Object.keys(o).length;\n};\n\nexport const isEmptyObject = (o: any): boolean => {\n  return !isNotEmptyObject(o);\n};\n\nexport const getObjectKeys = (o: object): Array<TObjectKeys> =>\n  (Object.keys(o) as Array<TObjectKeys>).concat(\n    Object.getOwnPropertySymbols(o)\n  );\n\nexport const isSimpleObject = (o: any): o is object =>\n  typeof o === 'object' && Object.getPrototypeOf(o) === Object.prototype;\n\n/**\n * extends object with another object if the object\n * have no properties\n *\n * @export\n * @template T\n * @template E\n * @param {T} o\n * @param {E} ext\n * @returns {T}\n */\nexport function extend<T extends TDictionary<any>, E extends TDictionary<any>>(\n  o: T | undefined,\n  ext: E,\n  replaceExisting?: boolean\n): T & E {\n  if (!o) {\n    return ext;\n  }\n  if (!isSimpleObject(o) || !isSimpleObject(ext)) {\n    if (replaceExisting && ext) {\n      return ext;\n    }\n    return (!o || isEmptyObject(o)) && ext ? ext : o;\n  }\n\n  const keys = getObjectKeys(ext);\n  let idx = 0;\n  let k: keyof E;\n  const len = keys.length;\n\n  while (idx < len) {\n    k = keys[idx];\n    idx++;\n    if (!isDefined(ext[k])) {\n      continue;\n    }\n    if (replaceExisting || !isDefined(o[k])) {\n      o[k] = ext[k];\n    } else if (typeof o[k] === 'object' && typeof ext[k] === 'object') {\n      o[k] = extend(o[k], ext[k]);\n    }\n  }\n  return o;\n}\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-timer.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/common-utils-url.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/common-utils.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.const.ts",[],"/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.ts",[],"/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.types.ts",[],"/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/index.ts",[],"/home/paul/projects/protocol/src/utils/data-cache-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/data-compression-utils/data-compression-utils-strings.ts",[],"/home/paul/projects/protocol/src/utils/data-compression-utils/data-compression-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/data-compression-utils/data-compression-utils.ts",[],"/home/paul/projects/protocol/src/utils/data-compression-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/data-sign-utils/data-sign-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/data-sign-utils/data-sign-utils.ts",[],"/home/paul/projects/protocol/src/utils/data-sign-utils/data-sign-utils.types.ts",[],"/home/paul/projects/protocol/src/utils/data-sign-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/data-sign-utils/keys.data-sign-utils.ts",["2481","2482","2483"],"import {\n  DATA_SIGN_CRYPTO_UTIL_GENERATE_KEYPAIR_OPTIONS,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_USAGES,\n  DATA_SIGN_CRYPTO_UTIL_PUBLIC_KEY_USAGE,\n  DATA_SIGN_CRYPTO_UTIL_PRIVATE_KEY_USAGE,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n  DATA_SIGN_CRYPTO_UTIL_KEY_DESC,\n  DATA_SIGN_CRYPTO_UTIL_KEYS_EXTRACTABLE,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME,\n  KEY_NOT_FOUND_ERROR_MESSAGE,\n} from './data-sign-utils.const';\nimport { cryptoModuleDataSign } from './main.data-sign-utils.const';\nimport {\n  TDATA_SIGN_UTIL_KEY_EXPORT_FORMAT_TYPE,\n  TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE,\n  TDATA_SIGN_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE,\n  TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n  TDATA_SIGN_UTIL_IMPORT_KEY_TYPES,\n} from './data-sign-utils.types';\nimport {\n  isCryptoKeyPair,\n  getJWKOrBool,\n} from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport { TEncryptionKeyStoreFormatType } from 'types/encryption-keys.types';\nimport { isTypedArray } from 'utils/typed-array-utils';\nimport { stringify } from 'utils/main-utils';\nimport { decryptDataByPassword } from '../password-utils/decrypt.password-utils';\nimport { DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME } from './data-sign-utils.const';\nimport { generateSalt } from '../encryption-utils/salt-utils';\nimport { encryptDataWithPassword } from '../password-utils/encrypt.password-utils';\nimport { TDATA_SIGN_UTIL_KEYPAIR_IMPORT_TYPE } from './data-sign-utils.types';\nimport { typedArrayToString } from '../typed-array-utils';\n\nexport const dataSignIsCryptoKeyPairImported = (\n  key: any,\n  checkPrivateKey: boolean = true\n): key is TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE => {\n  return (\n    typeof key === 'object' &&\n    !!key[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME] &&\n    (!checkPrivateKey || !!key[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME])\n  );\n};\n\nexport const dataSignGenerateKeyPair = (): PromiseLike<CryptoKeyPair> =>\n  cryptoModuleDataSign.generateKey(\n    DATA_SIGN_CRYPTO_UTIL_GENERATE_KEYPAIR_OPTIONS,\n    DATA_SIGN_CRYPTO_UTIL_KEYS_EXTRACTABLE,\n    DATA_SIGN_CRYPTO_UTIL_KEYPAIR_USAGES\n  );\n\nexport const dataSignExportKey = async (\n  key: CryptoKey\n): Promise<TDATA_SIGN_UTIL_KEY_EXPORT_FORMAT_TYPE | Error> => {\n  try {\n    return cryptoModuleDataSign.exportKey(\n      DATA_SIGN_CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n      key\n    );\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignExportKeyAsString = async (\n  key: CryptoKey\n): Promise<string | Error> => {\n  const keyExported = await dataSignExportKey(key);\n\n  if (keyExported instanceof Error) {\n    return keyExported;\n  }\n  try {\n    return stringify(keyExported);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignExportPublicKey = async (\n  keyPair: CryptoKeyPair\n): Promise<TDATA_SIGN_UTIL_KEY_EXPORT_FORMAT_TYPE | Error> => {\n  if (isCryptoKeyPair(keyPair)) {\n    return dataSignExportKey(keyPair.publicKey);\n  }\n  return new Error('Argument must be a CryptoKeyPair');\n};\n\nexport const dataSignExportPublicKeyAsString = async (\n  keyPair: CryptoKeyPair\n): Promise<Error | string> => {\n  try {\n    const keyPublicExported = await dataSignExportPublicKey(keyPair);\n\n    if (keyPublicExported instanceof Error) {\n      return keyPublicExported;\n    }\n    return stringify(keyPublicExported);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignExportKeyPair = async (\n  keyPair: CryptoKeyPair,\n  password?: string\n): Promise<TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (isCryptoKeyPair(keyPair, !!password)) {\n      // do it in parallel\n      const [privateKey, publicKey] = await Promise.all([\n        password || keyPair.privateKey\n          ? dataSignExportKey(keyPair.privateKey)\n          : Promise.resolve(undefined),\n        dataSignExportKey(keyPair.publicKey),\n      ]).catch((err) => [err, err]);\n\n      if (privateKey instanceof Error) {\n        return privateKey;\n      }\n      if (publicKey instanceof Error) {\n        return publicKey;\n      }\n\n      const result: TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE = {\n        [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: publicKey,\n        [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: privateKey,\n      };\n\n      if (password) {\n        const salt = generateSalt();\n\n        if (salt instanceof Error) {\n          return new Error('Failed to generate a unique salt value');\n        }\n\n        const encryptedPrivateKey = await encryptDataWithPassword(\n          password,\n          salt,\n          privateKey\n        );\n\n        if (encryptedPrivateKey instanceof Error) {\n          return new Error(\n            'Failed to encrypt private key with password provided'\n          );\n        }\n\n        const saltStringified = typedArrayToString(salt);\n\n        if (saltStringified instanceof Error) {\n          return new Error(\n            'Failed to stringify the salt value for the private data sign key'\n          );\n        }\n\n        const decryptedPrivateKey = await decryptDataByPassword(\n          password,\n          saltStringified,\n          encryptedPrivateKey\n        );\n\n        if (decryptedPrivateKey instanceof Error) {\n          return new Error('Failed to decrypt private key for data encryption');\n        }\n        result[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME] = saltStringified;\n        result[\n          DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME\n        ] = encryptedPrivateKey;\n      }\n      return result;\n    }\n    return new Error('Argument given must be a CryptoKeyPair');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignExportKeyPairAsString = async (\n  keyPair: CryptoKeyPair,\n  password?: string\n): Promise<string | Error> => {\n  try {\n    const res = await dataSignExportKeyPair(keyPair, password);\n\n    if (res instanceof Error) {\n      return res;\n    }\n    return stringify(res);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignImportKey = async (\n  key: TDATA_SIGN_UTIL_IMPORT_KEY_TYPES,\n  isPublic: boolean = true\n): Promise<CryptoKey | Error> => {\n  try {\n    if (typeof key !== 'object') {\n      return new Error('Unsupported argument type');\n    }\n    const res = await cryptoModuleDataSign.importKey(\n      DATA_SIGN_CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n      key,\n      DATA_SIGN_CRYPTO_UTIL_KEY_DESC,\n      DATA_SIGN_CRYPTO_UTIL_KEYS_EXTRACTABLE,\n      [\n        isPublic\n          ? DATA_SIGN_CRYPTO_UTIL_PUBLIC_KEY_USAGE\n          : DATA_SIGN_CRYPTO_UTIL_PRIVATE_KEY_USAGE,\n      ]\n    );\n\n    if (!(res instanceof CryptoKey)) {\n      return new Error(\"Can't import the key\");\n    }\n    return res;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignImportPublicKey = (\n  key: TDATA_SIGN_UTIL_IMPORT_KEY_TYPES\n): PromiseLike<CryptoKey | Error> => dataSignImportKey(key, true);\n\nexport const dataSignImportPrivateKey = (\n  key: TDATA_SIGN_UTIL_IMPORT_KEY_TYPES\n): PromiseLike<CryptoKey | Error> => dataSignImportKey(key, false);\n\nexport const dataSignImportKeyPair = async (\n  keyPair: TDATA_SIGN_UTIL_KEYPAIR_IMPORT_TYPE,\n  checkPrivateKey: boolean = true\n): Promise<TDATA_SIGN_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (dataSignIsCryptoKeyPairImported(keyPair, checkPrivateKey)) {\n      const privateKeyToImport =\n        keyPair[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME];\n      if (checkPrivateKey && !privateKeyToImport) {\n        return new Error('The private key is empty');\n      }\n      const importResult = await Promise.all([\n        dataSignImportPublicKey(\n          keyPair[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]\n        ),\n        checkPrivateKey || privateKeyToImport\n          ? dataSignImportPrivateKey(privateKeyToImport!)\n          : (Promise.resolve(undefined) as any),\n      ]).catch((err) => [err, err]);\n      const publicKey = importResult[0];\n      let privateKey = importResult[1];\n\n      if (publicKey instanceof Error) {\n        return publicKey;\n      }\n      if (privateKey instanceof Error) {\n        if (checkPrivateKey) {\n          return privateKey;\n        }\n        privateKey = undefined;\n      }\n      return {\n        [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: publicKey,\n        [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: privateKey,\n      };\n    }\n    return new Error('The argument must be an instance of CryptoKeyPair');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignImportKeyPairFromString = async (\n  keyPairString: string,\n  password?: string\n): Promise<TDATA_SIGN_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (typeof keyPairString === 'string') {\n      const keyPairObject = JSON.parse(keyPairString);\n\n      if (\n        password &&\n        keyPairObject[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME]\n      ) {\n        if (\n          typeof keyPairObject[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME] !==\n          'string'\n        ) {\n          return new Error('A salt value must be a string');\n        }\n\n        const decryptedPrivateKey = await decryptDataByPassword(\n          password,\n          keyPairObject[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME],\n          keyPairObject[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]\n        );\n\n        if (decryptedPrivateKey instanceof Error) {\n          console.error('Failed to decrypt the data sign private key');\n          return decryptedPrivateKey;\n        }\n        try {\n          keyPairObject[\n            DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME\n          ] = JSON.parse(decryptedPrivateKey);\n        } catch (err) {\n          console.error(err);\n          return new Error(\n            'Failed to parse datasign Private key from the string decrypted'\n          );\n        }\n      }\n      if (dataSignIsCryptoKeyPairImported(keyPairObject, !!password)) {\n        return dataSignImportKeyPair(\n          keyPairObject as TDATA_SIGN_UTIL_KEYPAIR_IMPORT_TYPE,\n          !!password\n        );\n      }\n      return new Error('There is a wrong format for the imported key pair');\n    }\n    return new Error('The key must be a string');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignImportKeyFromString = (\n  keyString: string,\n  isPublic: boolean = true\n): PromiseLike<CryptoKey | Error> | Error => {\n  try {\n    if (typeof keyString !== 'string') {\n      return new Error('The key must be a string');\n    }\n\n    const parsedKey = JSON.parse(keyString);\n\n    return dataSignImportKey(parsedKey, isPublic);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignImportPublicKeyFromString = (\n  key: string\n): PromiseLike<CryptoKey | Error> | Error =>\n  dataSignImportKeyFromString(key, true);\n\nexport const dataSignImportPrivateKeyFromString = (\n  key: string\n): PromiseLike<CryptoKey | Error> | Error =>\n  dataSignImportKeyFromString(key, false);\n\nexport const dataSignCheckIfStringIsKeyPair = (keyString: string): boolean => {\n  return (\n    keyString.includes(DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME) &&\n    keyString.includes(DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME)\n  );\n};\n\nexport const dataSignGetKeyOfType = async (\n  key: TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n  type: KeyType\n): Promise<CryptoKey | Error> => {\n  if (typeof key === 'string') {\n    if (dataSignCheckIfStringIsKeyPair(key)) {\n      const keyPair = await dataSignImportKeyPairFromString(key);\n\n      if (keyPair instanceof Error) {\n        return keyPair;\n      }\n      return dataSignGetKeyOfType(keyPair, type);\n    } else {\n      const keyFromString = await dataSignImportKeyFromString(\n        key,\n        type === 'public'\n      );\n\n      if (keyFromString instanceof Error) {\n        return keyFromString;\n      }\n      return dataSignGetKeyOfType(keyFromString, type);\n    }\n  }\n  if (key instanceof CryptoKey) {\n    return key.type === type ? key : new Error(KEY_NOT_FOUND_ERROR_MESSAGE);\n  }\n  if (typeof key === 'object') {\n    const keys = Object.values(key);\n    const keyResulted = keys.find(\n      (k: CryptoKey) => k && k.type && k.type === type\n    );\n\n    return keyResulted || new Error(KEY_NOT_FOUND_ERROR_MESSAGE);\n  }\n  return new Error('There is an unsupported type of the key given');\n};\n\n/**\n * import an encryption key from a\n * supported format of an exported key\n * and returns a crypto key in native\n * format\n * @param {} key\n */\nexport const dataSignImportEncryptionKey = async (\n  key: TEncryptionKeyStoreFormatType\n): Promise<CryptoKey | Error> => {\n  if (isTypedArray(key)) {\n    return dataSignImportKey(key);\n  } else {\n    const jwk = getJWKOrBool(key);\n\n    if (typeof jwk === 'object') {\n      return dataSignImportKey(jwk);\n    } else if (typeof key === 'string') {\n      return dataSignImportKeyFromString(key);\n    }\n  }\n  return new Error('There is an unknown key format');\n};\n\n/**\n * import an encryption key from a\n * supported format of an exported key\n * and returns a crypto key as a string\n * @param {} key\n */\nexport const dataSignConvertAndExportKeyAsString = async (\n  key: TEncryptionKeyStoreFormatType\n): Promise<string | Error> => {\n  const cryptoKeyImported = await dataSignImportEncryptionKey(key);\n\n  if (cryptoKeyImported instanceof Error) {\n    return cryptoKeyImported;\n  }\n  return dataSignExportKeyAsString(cryptoKeyImported);\n};\n","/home/paul/projects/protocol/src/utils/data-sign-utils/main.data-sign-utils.const.ts",["2484"],"if (!window.crypto) {\n  window.CryptoKey = require('@trust/webcrypto/src/keys/CryptoKey');\n  window.CryptoKeyPair = require('@trust/webcrypto/src/keys/CryptoKeyPair');\n  (window as any).JsonWebKey = require('@trust/webcrypto/src/keys/JsonWebKey');\n}\n\nexport const ENCRYPTION_FORMAT_SUPPORTED = !window.crypto ? 'SHA-1' : undefined;\n// TODO - check isomorphic-webcrypto to use\n\nexport const crypto = window.crypto || require('@trust/webcrypto');\n\nexport const cryptoModuleDataSign = crypto.subtle;\n","/home/paul/projects/protocol/src/utils/data-sign-utils/sign-data.encryption-utils.ts",["2485"],"import { cryptoModuleDataSign } from './main.data-sign-utils.const';\nimport {\n  DATA_SIGN_CRYPTO_UTIL_DATA_SIGN_AND_VERIFY_PARAMS,\n  DATA_SIGN_CRYPTO_UTIL_SIGN_KEY_TYPE,\n} from './data-sign-utils.const';\nimport {\n  TDATA_SIGN_UTIL_SIGN_DATA_TYPES,\n  TDATA_SIGN_UTIL_SIGN_DATA_TYPES_NATIVE,\n  TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n} from './data-sign-utils.types';\nimport {\n  dataSignGetKeyOfType,\n  dataSignExportKey,\n} from './keys.data-sign-utils';\nimport {\n  convertToTypedArray,\n  typedArrayToString,\n} from 'utils/typed-array-utils';\n\nexport const signNative = async (\n  key: CryptoKey,\n  data: TDATA_SIGN_UTIL_SIGN_DATA_TYPES_NATIVE\n): Promise<ArrayBuffer | Error> => {\n  if (key.type !== DATA_SIGN_CRYPTO_UTIL_SIGN_KEY_TYPE) {\n    return new Error(\n      `The type of the key ${key.type} may not be used for data signing`\n    );\n  }\n  try {\n    const res = await cryptoModuleDataSign.sign(\n      { ...DATA_SIGN_CRYPTO_UTIL_DATA_SIGN_AND_VERIFY_PARAMS },\n      key,\n      data\n    );\n\n    return res;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const signToTypedArray = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n  data: TDATA_SIGN_UTIL_SIGN_DATA_TYPES\n): Promise<ArrayBuffer | Error> => {\n  const k = await dataSignGetKeyOfType(\n    key,\n    DATA_SIGN_CRYPTO_UTIL_SIGN_KEY_TYPE\n  );\n\n  if (k instanceof Error) {\n    return k;\n  }\n\n  const d = convertToTypedArray(data);\n\n  if (d instanceof Error) {\n    return d;\n  }\n\n  return signNative(k, d);\n};\n\nexport const signToString = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n  data: TDATA_SIGN_UTIL_SIGN_DATA_TYPES\n): Promise<string | Error> => {\n  const signedHashData = await signToTypedArray(key, data);\n\n  if (signedHashData instanceof Error) {\n    return signedHashData;\n  }\n\n  return typedArrayToString(signedHashData);\n};\n","/home/paul/projects/protocol/src/utils/data-sign-utils/verify-data.encryption-utils.ts",["2486"],"import {\n  isTypedArray,\n  stringToTypedArray,\n  typedArrayToString,\n} from 'utils/typed-array-utils';\nimport { stringify } from 'utils/main-utils';\nimport { cryptoModuleDataSign } from './main.data-sign-utils.const';\nimport {\n  DATA_SIGN_CRYPTO_UTIL_VERIFY_KEY_TYPE,\n  DATA_SIGN_CRYPTO_UTIL_DATA_SIGN_AND_VERIFY_PARAMS,\n} from './data-sign-utils.const';\nimport {\n  TDATA_SIGN_UTIL_VERIFY_DATA_TYPES,\n  TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_EXTENDED,\n  TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_NATIVE,\n  TDATA_SIGN_UTIL_VERIFY_KEY_TYPES,\n} from './data-sign-utils.types';\nimport { dataSignGetKeyOfType } from './keys.data-sign-utils';\n\nexport const verifyNative = async (\n  key: CryptoKey,\n  data: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_NATIVE,\n  signature: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_NATIVE\n): Promise<true | Error> => {\n  if (key.type !== DATA_SIGN_CRYPTO_UTIL_VERIFY_KEY_TYPE) {\n    return new Error(\n      `The type of the key ${key.type} may not be used for data decryption`\n    );\n  }\n  if (!isTypedArray(data)) {\n    return new Error('The data type is not supported');\n  }\n  try {\n    const res = await cryptoModuleDataSign.verify(\n      { ...DATA_SIGN_CRYPTO_UTIL_DATA_SIGN_AND_VERIFY_PARAMS },\n      key,\n      signature,\n      data\n    );\n\n    return res !== true\n      ? new Error('The signature for the data is not valid')\n      : true;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const verifyData = async (\n  key: TDATA_SIGN_UTIL_VERIFY_KEY_TYPES,\n  data: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_EXTENDED,\n  signature: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES\n): Promise<true | Error> => {\n  const k = await dataSignGetKeyOfType(\n    key,\n    DATA_SIGN_CRYPTO_UTIL_VERIFY_KEY_TYPE\n  );\n\n  if (k instanceof Error) {\n    return k;\n  }\n\n  let d;\n\n  if (isTypedArray(data)) {\n    d = data;\n  } else if (typeof data === 'object' && !(data instanceof Error)) {\n    d = stringify(data);\n\n    if (d instanceof Error) {\n      return d;\n    }\n    d = stringToTypedArray(d);\n  } else if (typeof data === 'string') {\n    d = stringToTypedArray(data);\n  } else {\n    return new Error('Unsupported data type');\n  }\n  if (d instanceof Error) {\n    return d;\n  }\n\n  const s =\n    typeof signature === 'string' ? stringToTypedArray(signature) : signature;\n\n  if (s instanceof Error) {\n    return s;\n  }\n  return verifyNative(k, d, s);\n};\n","/home/paul/projects/protocol/src/utils/data-validators-utils/data-validators-utils-common.ts",["2487","2488","2489","2490","2491"],"import {\n  CONST_VALIDATION_SCHEMES_URI,\n  CONST_VALIDATION_SCHEMES_URL,\n  CONST_VALIDATION_SCHEMES_UUID_V4,\n  CONST_VALIDATION_SCHEMES_EMAIL,\n  CONST_VALIDATION_SCHEMES_LOGIN,\n} from 'const/const-validation-schemes/const-validation-schemes-common';\nimport { validateBySchema } from 'utils/validation-utils/validation-utils';\n\nexport const dataValidatorUtilURI = (v: any): boolean => {\n  return validateBySchema(CONST_VALIDATION_SCHEMES_URI, v);\n};\n\nexport const dataValidatorUtilURL = (v: any): boolean => {\n  const result = validateBySchema(CONST_VALIDATION_SCHEMES_URL, v);\n\n  return result;\n};\n\nexport const dataValidatorUtilUUIDV4 = (v: any): boolean => {\n  return validateBySchema(CONST_VALIDATION_SCHEMES_UUID_V4, v);\n};\n\nexport const dataValidatorUtilEmail = (v: any): boolean => {\n  return validateBySchema(CONST_VALIDATION_SCHEMES_EMAIL, v);\n};\n\nexport const dataValidatorUtilSafeLogin = (v: any): boolean => {\n  return validateBySchema(CONST_VALIDATION_SCHEMES_LOGIN, v);\n};\n","/home/paul/projects/protocol/src/utils/data-validators-utils/data-validators-utils.ts",[],"/home/paul/projects/protocol/src/utils/data-validators-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/encryption-keys-utils/encryption-keys-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/encryption-keys-utils/encryption-keys-utils.ts",["2492","2493","2494","2495","2496","2497","2498","2499","2500","2501"],"import {\n  CONST_CRYPTO_KEYS_TYPES,\n  CONST_CRYPTO_KEYS_TYPES_EXPORT_FORMATS,\n} from 'const/const-crypto-keys/const-crypto-keys';\nimport {\n  HASH_CALCULATION_UTILS_DEFAULT_HASH_ALHORITHM,\n  HASH_CALCULATION_UTILS_HASH_ALHORITHM,\n} from 'utils/hash-calculation-utils/hash-calculation-utils.const';\nimport { encodeArrayBufferToDOMString } from 'utils/string-encoding-utils';\n\nimport { commonUtilsArrayIncludesAll } from '../common-utils/common-utils-array';\nimport { eCRYPTO_UTILS_KEYS_USAGES } from '../encryption-utils/crypto-utils.const';\nimport {\n  calculateHash,\n  calculateHashNative,\n} from './../hash-calculation-utils/hash-calculation-utils';\nimport {\n  ENCRYPTIONS_KEYS_UTILS_JWK_FORMAT_OBJECT_KEYS,\n  MIN_JWK_PROPS_COUNT,\n  MIN_JWK_STRING_LENGTH,\n} from './encryption-keys-utils.const';\nimport { crypto } from '../data-sign-utils/main.data-sign-utils.const';\n\nexport const isCryptoKey = (v: any): v is CryptoKey => v instanceof CryptoKey;\n\nexport const isCryptoKeyPair = (\n  keyPair: any,\n  checkPrivateKeys: boolean = true\n): keyPair is CryptoKeyPair => {\n  return (\n    typeof keyPair === 'object' &&\n    isCryptoKey(keyPair.publicKey) &&\n    (!checkPrivateKeys || isCryptoKey(keyPair.privateKey))\n  );\n};\n\nexport const isCryptoKeyIncludesUsages = (\n  cryptoKey: CryptoKey,\n  expectedUsages: eCRYPTO_UTILS_KEYS_USAGES[] | eCRYPTO_UTILS_KEYS_USAGES\n): boolean => {\n  const { usages } = cryptoKey;\n\n  if (typeof expectedUsages === 'string') {\n    return usages.includes(expectedUsages);\n  }\n  return commonUtilsArrayIncludesAll(usages, expectedUsages as string[]);\n};\n\nexport const isCryptoKeyDataSign = (cryptoKey: any): cryptoKey is CryptoKey =>\n  isCryptoKey(cryptoKey) &&\n  isCryptoKeyIncludesUsages(cryptoKey, eCRYPTO_UTILS_KEYS_USAGES.sign);\n\nexport const isCryptoKeyDataVerify = (cryptoKey: any): cryptoKey is CryptoKey =>\n  isCryptoKey(cryptoKey) &&\n  isCryptoKeyIncludesUsages(cryptoKey, eCRYPTO_UTILS_KEYS_USAGES.verify);\n\nexport const isCryptoKeyDataEncryption = (\n  cryptoKey: any\n): cryptoKey is CryptoKey =>\n  isCryptoKey(cryptoKey) &&\n  isCryptoKeyIncludesUsages(cryptoKey, eCRYPTO_UTILS_KEYS_USAGES.encrypt);\n\nexport const isCryptoKeyDataDecryption = (\n  cryptoKey: any\n): cryptoKey is CryptoKey =>\n  isCryptoKey(cryptoKey) &&\n  isCryptoKeyIncludesUsages(cryptoKey, eCRYPTO_UTILS_KEYS_USAGES.decrypt);\n\nexport const isCryptoKeyPairExportedAsString = (keyPair: any): boolean => {\n  return typeof keyPair === 'string' && keyPair.length >= MIN_JWK_STRING_LENGTH;\n};\n\nexport const isJWK = (\n  keyObject: object,\n  isReturnError: boolean = false\n): Error | boolean => {\n  if (keyObject && typeof keyObject === 'object') {\n    const options = Object.keys(keyObject);\n    const optionsCount = options.length;\n\n    if (optionsCount > MIN_JWK_PROPS_COUNT) {\n      let idx = 0;\n      let optionName: string;\n\n      for (; idx < optionsCount; idx += 1) {\n        optionName = options[idx];\n        if (\n          !ENCRYPTIONS_KEYS_UTILS_JWK_FORMAT_OBJECT_KEYS.includes(optionName)\n        ) {\n          return isReturnError\n            ? new Error(`There is an unknown property ${optionName}`)\n            : false;\n        }\n      }\n      return true;\n    }\n  }\n  return isReturnError ? new Error('There is a wrong format of JWK') : false;\n};\n\nexport const getJWK = (\n  key: any,\n  isReturnError: boolean = false\n): JsonWebKey | boolean | Error => {\n  let keyObject = key;\n\n  if (typeof key === 'string' && key.length > MIN_JWK_STRING_LENGTH) {\n    try {\n      keyObject = JSON.parse(key);\n    } catch (e) {\n      return e;\n    }\n  }\n\n  const isJWKValid = isJWK(keyObject, isReturnError);\n\n  if (isJWKValid === true) {\n    return keyObject as JsonWebKey;\n  }\n  return isJWKValid instanceof Error\n    ? isJWKValid\n    : new Error('There is a wrong format of JWK');\n};\n\nexport const getJWKOrError = (key: any): JsonWebKey | Error =>\n  getJWK(key, true) as JsonWebKey | Error;\n\nexport const getJWKOrBool = (key: any): JsonWebKey | boolean =>\n  getJWK(key, false) as JsonWebKey | boolean;\n\nexport const exportCryptokeyInFormat = async (\n  key: CryptoKey,\n  format: CONST_CRYPTO_KEYS_TYPES_EXPORT_FORMATS\n): Promise<ArrayBuffer | JsonWebKey | Error> => {\n  try {\n    const result = await crypto.subtle.exportKey(format, key);\n\n    if (result instanceof Error) {\n      console.error(result);\n      return new Error(\n        'exportCryptokeyInFormat::error returned from the exportKey'\n      );\n    }\n    return result;\n  } catch (err) {\n    console.error(err);\n    return new Error(\n      'exportCryptokeyInFormat::An error thrown when export the crypto key'\n    );\n  }\n};\n\n/**\n * calculates hash string of the crypto key\n * @param {CryptoKey} key\n */\nexport const calcCryptoKeyHash = async (\n  key: CryptoKey,\n  alg: HASH_CALCULATION_UTILS_HASH_ALHORITHM = HASH_CALCULATION_UTILS_DEFAULT_HASH_ALHORITHM\n): Promise<Error | string> => {\n  if (!(key instanceof CryptoKey)) {\n    return new Error('Key os not an instance of CryptoKey');\n  }\n  if (!key.extractable) {\n    return new Error('The crypto key is not extractable');\n  }\n\n  let format: CONST_CRYPTO_KEYS_TYPES_EXPORT_FORMATS =\n    CONST_CRYPTO_KEYS_TYPES_EXPORT_FORMATS.RAW;\n  const keyAlgName = key.algorithm.name.toLowerCase();\n\n  if (keyAlgName.includes('rsa-') || keyAlgName.includes('ecdsa')) {\n    if (key.type.includes(CONST_CRYPTO_KEYS_TYPES.PUBLIC)) {\n      format = CONST_CRYPTO_KEYS_TYPES_EXPORT_FORMATS.SPKI;\n    } else {\n      format = CONST_CRYPTO_KEYS_TYPES_EXPORT_FORMATS.PKCS8;\n    }\n  }\n\n  const exportedCryptoKey = await exportCryptokeyInFormat(key, format);\n\n  if (exportedCryptoKey instanceof Error) {\n    console.error(exportedCryptoKey);\n    return new Error('Failed to export the crypto key in the RAW format');\n  }\n\n  const hashCalcResult = await calculateHashNative(\n    exportedCryptoKey as ArrayBuffer,\n    alg\n  );\n\n  if (hashCalcResult instanceof Error) {\n    console.error(hashCalcResult);\n    return new Error('Failed to calculate a hash for the exported crypto key');\n  }\n  return encodeArrayBufferToDOMString(hashCalcResult);\n};\n\n// allow to absent for a private keys in a pairs\nexport const calcCryptoKeyPairHash = async (\n  cryptoPair: CryptoKeyPair,\n  alg?: HASH_CALCULATION_UTILS_HASH_ALHORITHM\n): Promise<Error | string> => {\n  const pending = [calcCryptoKeyHash(cryptoPair.publicKey)];\n\n  if (cryptoPair.privateKey) {\n    pending.push(calcCryptoKeyHash(cryptoPair.privateKey));\n  }\n\n  const results = await Promise.all(pending);\n\n  if (results[0] instanceof Error) {\n    return new Error('Failed to calculate hash of the private key');\n  }\n  if (results[1] instanceof Error) {\n    return new Error('Failed to calculate hash of the puclic key');\n  }\n  return calculateHash(`${results[0]}___${results[1]}`);\n};\n","/home/paul/projects/protocol/src/utils/encryption-keys-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/crypto-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/crypto-utils.types.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/decrypt-data.encryption-utils.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/encrypt-data.encryption-utils.ts",["2502"],"import { cryptoModule } from './main.crypto-utils.const';\nimport { crypto } from '../data-sign-utils/main.data-sign-utils.const';\nimport {\n  CRYPTO_UTIL_KEY_DESC,\n  CRYPTO_UTIL_ENCRYPTION_KEY_TYPE,\n  INITIALIZATION_VECTOR_DEFAULT_LENGTH,\n} from './crypto-utils.const';\nimport {\n  TCRYPTO_UTIL_ENCRYPT_DATA_TYPES,\n  TCRYPTO_UTIL_ENCRYPT_DATA_TYPES_NATIVE,\n  TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n  TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG,\n  TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR,\n} from './crypto-utils.types';\nimport { getKeyOfType, exportKey } from './keys.encryption-utils';\nimport {\n  convertToTypedArray,\n  typedArrayToString,\n  arrayBufferFromTypedArray,\n  concatArrayBuffers,\n  getBytesFromArrayBuffer,\n} from 'utils/typed-array-utils';\nimport { decodeDOMStringToArrayBuffer } from 'utils/string-encoding-utils';\n\n/**\n * return a random vector, used e.g. for aes-gcm\n * encryption\n * @param vectorLength - lenght of the vector generated\n */\nexport const generateInitializationVectorNative = (\n  vectorLength: number = INITIALIZATION_VECTOR_DEFAULT_LENGTH\n): Uint8Array | Error => {\n  try {\n    return crypto.getRandomValues(new Uint8Array(vectorLength));\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const generateInitializationVectorNativeArrayBuffer = (\n  vectorLength?: number\n): ArrayBuffer | Error => {\n  const iv = generateInitializationVectorNative(vectorLength);\n\n  if (iv instanceof Error) {\n    return iv;\n  }\n  return arrayBufferFromTypedArray(iv);\n};\n\nexport const concatDataWithInitializationVector = (\n  options: TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR\n): ArrayBuffer | Error => {\n  try {\n    return concatArrayBuffers(options.iv, options.data);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const getInitializationVectorFromData = (\n  arrayBuffer: ArrayBuffer,\n  ivLengthBytes: number = INITIALIZATION_VECTOR_DEFAULT_LENGTH\n): TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR | Error => {\n  try {\n    const iv = getBytesFromArrayBuffer(arrayBuffer, 0, ivLengthBytes);\n\n    if (iv instanceof Error) {\n      return iv;\n    }\n\n    const data = getBytesFromArrayBuffer(arrayBuffer, ivLengthBytes);\n\n    if (data instanceof Error) {\n      return data;\n    }\n    return {\n      iv,\n      data,\n    };\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const getInitializationVectorFromDataString = (\n  data: string,\n  ivLengthBytes?: number\n): TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR | Error => {\n  const dataArrayBuffer = decodeDOMStringToArrayBuffer(data);\n\n  if (dataArrayBuffer instanceof Error) {\n    return dataArrayBuffer;\n  }\n  return getInitializationVectorFromData(dataArrayBuffer, ivLengthBytes);\n};\n\nexport const encryptNative = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: CryptoKey,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES_NATIVE,\n  //an optional params for the encryption method\n  cryptoKeyConfig: TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG = CRYPTO_UTIL_KEY_DESC\n): Promise<ArrayBuffer | Error> => {\n  try {\n    const res = await cryptoModule.encrypt(cryptoKeyConfig, key, data);\n\n    return res;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const encryptToTypedArray = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES,\n  //an optional params for the encryption method\n  cryptoKeyConfig?: TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG\n): Promise<ArrayBuffer | Error> => {\n  let k;\n\n  if (key instanceof CryptoKey) {\n    k = key;\n  } else {\n    k = await getKeyOfType(key, CRYPTO_UTIL_ENCRYPTION_KEY_TYPE);\n  }\n  if (k instanceof Error) {\n    return k;\n  }\n\n  const d = convertToTypedArray(data);\n\n  if (d instanceof Error) {\n    return d;\n  }\n\n  return encryptNative(k, d, cryptoKeyConfig);\n};\n\nexport const encryptToString = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES,\n  //an optional params for the encryption method\n  cryptoKeyConfig?: TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG\n): Promise<string | Error> => {\n  const encryptedData = await encryptToTypedArray(key, data);\n\n  if (encryptedData instanceof Error) {\n    return encryptedData;\n  }\n\n  return typedArrayToString(encryptedData);\n};\n","/home/paul/projects/protocol/src/utils/encryption-utils/encryption-utils.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/keys.encryption-utils.ts",["2503","2504"],"import { isCryptoKeyPair } from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport {\n  CRYPTO_UTIL_GENERATE_KEYPAIR_OPTIONS,\n  CRYPTO_UTIL_KEYPAIR_USAGES,\n  CRYPTO_UTIL_PUBLIC_KEY_USAGE,\n  CRYPTO_UTIL_PRIVATE_KEY_USAGE,\n  CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n  CRYPTO_UTIL_KEY_DESC,\n  CRYPTO_UTIL_KEYS_EXTRACTABLE,\n  CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME,\n  CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME,\n} from './crypto-utils.const';\nimport { cryptoModule } from './main.crypto-utils.const';\nimport {\n  TCRYPTO_UTIL_KEY_EXPORT_FORMAT_TYPE,\n  TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE,\n  TCRYPTO_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE,\n  TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n} from './crypto-utils.types';\nimport { stringify } from 'utils/main-utils';\nimport { decryptDataByPassword } from 'utils';\nimport { generateSalt } from './salt-utils';\nimport { CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME } from './crypto-utils.const';\nimport { encryptDataWithPassword } from '../password-utils/encrypt.password-utils';\nimport { encodeArrayBufferToDOMString } from '../string-encoding-utils';\nimport { TCRYPTO_UTIL_KEYPAIR_PREIMPORT_FORMAT_TYPE } from './crypto-utils.types';\nimport { typedArrayToString } from '../typed-array-utils';\n\nexport const isCryptoKeyPairImported = (\n  key: any,\n  checkPrivateKey: boolean = true\n): key is TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE => {\n  return (\n    typeof key === 'object' &&\n    !!key[CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME] &&\n    (!checkPrivateKey || !!key[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME])\n  );\n};\n\nexport const generateKeyPair = (): PromiseLike<CryptoKeyPair> =>\n  cryptoModule.generateKey(\n    CRYPTO_UTIL_GENERATE_KEYPAIR_OPTIONS,\n    CRYPTO_UTIL_KEYS_EXTRACTABLE,\n    CRYPTO_UTIL_KEYPAIR_USAGES\n  );\n\nexport const exportKey = (\n  key: CryptoKey\n): PromiseLike<TCRYPTO_UTIL_KEY_EXPORT_FORMAT_TYPE | Error> => {\n  try {\n    return cryptoModule.exportKey(CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT, key);\n  } catch (err) {\n    console.error(err);\n    return err;\n  }\n};\n\nexport const exportKeyAsString = async (\n  key: CryptoKey\n): Promise<Error | string> => {\n  return stringify(await exportKey(key));\n};\n\nexport const exportPublicKey = async (keyPair: CryptoKeyPair) => {\n  return exportKey(keyPair.publicKey);\n};\n\nexport const exportPublicKeyAsString = async (keyPair: CryptoKeyPair) => {\n  const publicKey = await exportPublicKey(keyPair);\n\n  if (publicKey instanceof Error) {\n    return publicKey;\n  }\n  return stringify(publicKey);\n};\n\nexport const exportKeyPair = async (\n  keyPair: CryptoKeyPair,\n  password?: string\n): Promise<TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (isCryptoKeyPair(keyPair, !!password)) {\n      // do it in parallel\n      const [privateKey, publicKey] = await Promise.all([\n        password || keyPair.privateKey\n          ? exportKey(keyPair.privateKey)\n          : Promise.resolve(undefined),\n        exportKey(keyPair.publicKey),\n      ]).catch((err) => [err, err]);\n\n      if (privateKey instanceof Error) {\n        return privateKey;\n      }\n      if (publicKey instanceof Error) {\n        return publicKey;\n      }\n\n      const result: TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE = {\n        [CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: publicKey,\n        [CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: privateKey,\n      };\n\n      if (password) {\n        const salt = generateSalt();\n\n        if (salt instanceof Error) {\n          return new Error('Failed to generate a unique salt value');\n        }\n\n        const encryptedPrivateKey = await encryptDataWithPassword(\n          password,\n          salt,\n          privateKey\n        );\n\n        if (encryptedPrivateKey instanceof Error) {\n          return new Error(\n            'Failed to encrypt private key with password provided'\n          );\n        }\n\n        const saltStringified = typedArrayToString(salt);\n\n        if (saltStringified instanceof Error) {\n          return new Error(\n            'Failed to stringify the salt for the encryption private key'\n          );\n        }\n\n        const decryptedPrivateKey = await decryptDataByPassword(\n          password,\n          saltStringified,\n          encryptedPrivateKey\n        );\n\n        if (decryptedPrivateKey instanceof Error) {\n          return new Error('Failed to decrypt private key for data encryption');\n        }\n        result[CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME] = saltStringified;\n        result[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME] = encryptedPrivateKey;\n      }\n      return result;\n    }\n    return new Error('Argument given must be a CryptoKeyPair');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const exportKeyPairAsString = async (\n  keyPair: CryptoKeyPair,\n  password?: string\n): Promise<string | Error> => {\n  const exportedKeyPair = await exportKeyPair(keyPair, password);\n\n  if (exportedKeyPair instanceof Error) {\n    return exportedKeyPair;\n  }\n  try {\n    return stringify(exportedKeyPair);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importKey = (\n  key: object,\n  isPublic: boolean = true\n): PromiseLike<CryptoKey> => {\n  return cryptoModule.importKey(\n    CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n    key,\n    CRYPTO_UTIL_KEY_DESC,\n    CRYPTO_UTIL_KEYS_EXTRACTABLE,\n    [isPublic ? CRYPTO_UTIL_PUBLIC_KEY_USAGE : CRYPTO_UTIL_PRIVATE_KEY_USAGE]\n  );\n};\n\nexport const importPublicKey = (key: object): PromiseLike<CryptoKey> =>\n  importKey(key, true);\n\nexport const importPrivateKey = (key: object): PromiseLike<CryptoKey> =>\n  importKey(key, false);\n\nexport const importKeyPair = async (\n  keyPair: TCRYPTO_UTIL_KEYPAIR_PREIMPORT_FORMAT_TYPE,\n  checkPrivateKey: boolean = true\n): Promise<TCRYPTO_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (isCryptoKeyPairImported(keyPair, checkPrivateKey)) {\n      const importResult = await Promise.all([\n        (async () => {\n          try {\n            return await importPublicKey(\n              keyPair[CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]\n            );\n          } catch (err) {\n            return err;\n          }\n        })(),\n        (async () => {\n          try {\n            if (\n              checkPrivateKey ||\n              keyPair[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]\n            ) {\n              return await importPrivateKey(\n                keyPair[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]\n              );\n            }\n          } catch (err) {\n            return err;\n          }\n        })(),\n      ]);\n      const publicKey = importResult[0];\n      let privateKey = importResult[1];\n\n      if (publicKey instanceof Error) {\n        return publicKey;\n      }\n      if (privateKey instanceof Error) {\n        if (checkPrivateKey) {\n          return privateKey;\n        }\n        privateKey = undefined;\n      }\n      return {\n        [CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: publicKey,\n        [CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: privateKey,\n      };\n    }\n    return new Error('The argument must be an instance of CryptoKeyPair');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importKeyPairFromString = async (\n  keyPairString: string,\n  password?: string\n): Promise<TCRYPTO_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (typeof keyPairString === 'string') {\n      const keyPairObject = JSON.parse(keyPairString);\n\n      if (password && keyPairObject[CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME]) {\n        if (\n          typeof keyPairObject[CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME] !== 'string'\n        ) {\n          return new Error('A salt value must be a string');\n        }\n\n        const decryptedPrivateKey = await decryptDataByPassword(\n          password,\n          keyPairObject[CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME],\n          keyPairObject[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]\n        );\n\n        if (decryptedPrivateKey instanceof Error) {\n          console.error('Failed to decrypt the data encryption private key');\n          return decryptedPrivateKey;\n        }\n        try {\n          keyPairObject[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME] = JSON.parse(\n            decryptedPrivateKey\n          );\n        } catch (err) {\n          console.error(err);\n          return new Error(\n            'Failed to parse dataencryption Private key from the string decrypted'\n          );\n        }\n      }\n      return importKeyPair(keyPairObject, !!password);\n    }\n    return new Error('A key pair must be a string');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importKeyFromString = (\n  keyString: string,\n  isPublic: boolean = true\n): PromiseLike<CryptoKey> | Error => {\n  try {\n    return importKey(JSON.parse(keyString), isPublic);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importPublicKeyFromString = (\n  key: string\n): PromiseLike<CryptoKey> | Error => importKeyFromString(key, true);\n\nexport const importPrivateKeyFromString = (\n  key: string\n): PromiseLike<CryptoKey> | Error => importKeyFromString(key, false);\n\nexport const checkIfStringIsKeyPair = (keyString: string): boolean => {\n  return (\n    keyString.includes(CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME) &&\n    keyString.includes(CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME)\n  );\n};\n\nconst KEY_NOT_FOUND_ERROR_MESSAGE = 'A key of the required type was not found';\n\nexport const getKeyOfType = async (\n  key: TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n  type: KeyType\n): Promise<CryptoKey | Error> => {\n  if (typeof key === 'string') {\n    if (checkIfStringIsKeyPair(key)) {\n      const keyPair = await importKeyPairFromString(key);\n\n      if (keyPair instanceof Error) {\n        return keyPair;\n      }\n      return getKeyOfType(keyPair, type);\n    } else {\n      const keyFromString = await importKeyFromString(key, type === 'public');\n\n      if (keyFromString instanceof Error) {\n        return keyFromString;\n      }\n      return getKeyOfType(keyFromString, type);\n    }\n  }\n  if (key instanceof CryptoKey) {\n    return key.type === type ? key : new Error(KEY_NOT_FOUND_ERROR_MESSAGE);\n  }\n  if (typeof key === 'object') {\n    const keys = Object.values(key);\n    const keyResulted = keys.find(\n      (k: CryptoKey) => k && k.type && k.type === type\n    );\n\n    return keyResulted || new Error(KEY_NOT_FOUND_ERROR_MESSAGE);\n  }\n  return new Error('There is an unsupported type of the key given');\n};\n","/home/paul/projects/protocol/src/utils/encryption-utils/main.crypto-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/salt-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/salt-utils.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/salt-utils.types.ts",[],"/home/paul/projects/protocol/src/utils/files-utils/files-utils-download.ts",[],"/home/paul/projects/protocol/src/utils/files-utils/files-utils-size.ts",[],"/home/paul/projects/protocol/src/utils/files-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/firebase-utils/firebase-utils.ts",[],"/home/paul/projects/protocol/src/utils/firebase-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/hash-calculation-utils/hash-calculation-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/hash-calculation-utils/hash-calculation-utils.ts",[],"/home/paul/projects/protocol/src/utils/hash-calculation-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/identity-utils/identity-utils.ts",[],"/home/paul/projects/protocol/src/utils/identity-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/index.ts",[],"/home/paul/projects/protocol/src/utils/ipfs-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils-libp2p/index.js",["2505"],"/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils-libp2p/ipfs-utils-libp2p.const.ts",[],"/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils-libp2p/ipfs-utils-libp2p.ts",["2506","2507","2508","2509"],"// example https://github.com/ipfs/js-ipfs/blob/master/examples/custom-libp2p/index.js\n// TODO use https://github.com/libp2p/js-libp2p-webrtc-star as transport\n// https://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf\n// TODO - use https://github.com/daviddias/webrtc-explorer\n// about libp2p-secio https://github.com/auditdrivencrypto/secure-channel/blob/master/prior-art.md#ipfss-secure-channel\nimport * as Libp2p from 'libp2p';\nimport * as KadDHT from 'libp2p-kad-dht';\nimport * as TCP from 'libp2p-tcp';\nimport * as WS from 'libp2p-websockets';\n// import * as WRTCDirect from 'libp2p-webrtc-direct';\nimport * as SPDY from 'libp2p-spdy';\nimport * as MPLEX from 'pull-mplex';\nimport * as SECIO from 'libp2p-secio';\nimport * as WRTCStar from 'libp2p-webrtc-star';\n// import Stardust from 'libp2p-stardust';\nimport * as Bootstrap from 'libp2p-bootstrap';\nimport * as PubSubGossip from 'libp2p-gossipsub';\nimport DelegatedPeerRouter from 'libp2p-delegated-peer-routing';\nimport DelegatedContentRouter from 'libp2p-delegated-content-routing';\nimport multiaddr from 'multiaddr';\nimport {\n  STARDUST_SERVER,\n  DELEGATE_CONTENT_ROUTER,\n  DELEGATE_PEER_ROUTER,\n  WEB_RTC_STAR_SERVER,\n} from './ipfs-utils-libp2p.const';\n\nconst upgrader = {\n  upgradeInbound: (maConn: any) => maConn,\n  upgradeOutbound: (maConn: any) => maConn,\n};\n\n// libp2p configuration for browsers\n// https://github.com/ipfs/js-ipfs/blob/master/src/core/runtime/libp2p-browser.js\nexport const getLibPeerToPeer = (opts: any) => {\n  // Set convenience variables to clearly showcase some of the useful things that are available\n  const peerInfo = opts.peerInfo;\n  const peerBook = opts.peerBook;\n  // bootstrap peers in the main configuration\n  const bootstrapList = opts.config.Bootstrap;\n\n  // Create our WebRTC transport and give it our PeerId, straight from the ipfs node\n  peerInfo.multiaddrs.add(\n    multiaddr(\n      `/ip4/${WEB_RTC_STAR_SERVER.host}/tcp/${WEB_RTC_STAR_SERVER.port}/ws/p2p-webrtc-star`\n    )\n  );\n\n  // Content and peer routing\n  // https://github.com/libp2p/js-libp2p/tree/master/examples/peer-and-content-routing\n  // https://github.com/libp2p/js-libp2p/tree/master/examples/delegated-routing\n  const delegatePeerRouter = new DelegatedPeerRouter(DELEGATE_PEER_ROUTER);\n  const delegateContentRouter = new DelegatedContentRouter(\n    peerInfo.id,\n    DELEGATE_CONTENT_ROUTER\n  );\n\n  // Build and return our libp2p node\n  return new Libp2p(\n    {\n      peerInfo,\n      peerBook,\n      /**\n     *  https://github.com/libp2p/js-libp2p/tree/master/src/switch\n     * bp2p-switch is a dialer machine, it leverages the multiple libp2p transports, stream muxers, crypto channels and other connection upgrades to dial to peers in the libp2p network. It also supports Protocol Multiplexing through a multicodec and multistream-select handshake.\n     * libp2p-switch supports private networking. In order to enabled private networks, the switch.protector must be set and must contain a protect method. \n     * denyTTL: - number of ms a peer should not be dialable to after it errors. Each successive deny will increase the TTL from the base value. Defaults to 5 minutes\n       denyAttempts: - number of times a peer can be denied before they are permanently denied. Defaults to 5.\n       maxParallelDials: - number of concurrent dials the switch should allow. Defaults to 100\n       maxColdCalls: - number of queued cold calls that are allowed. Defaults to 50\n       dialTimeout: - number of ms a dial to a peer should be allowed to run. Defaults to 30000 (30 seconds)\n     * \n     */\n      switch: {\n        denyTTL: 2 * 60 * 1e3, // 2 minute base\n        denyAttempts: 5, // back off 5 times\n        maxParallelDials: 100,\n        maxColdCalls: 25,\n        dialTimeout: 20e3,\n      },\n      // Lets limit the connection managers peers and have it check peer health less frequently\n      connectionManager: {\n        minPeers: 25,\n        maxPeers: 100,\n        pollInterval: 5000,\n      },\n      modules: {\n        transport: [\n          TCP,\n          WS,\n          // TODO - WRTCDirect, depending on webrtc nodejs lib which is not necessary\n          WRTCStar,\n          // TODO - when the module will be stable use it\n          // Stardust,\n        ],\n        peerDiscovery: [Bootstrap],\n        streamMuxer: [MPLEX, SPDY],\n        connEncryption: [SECIO],\n        dht: KadDHT,\n        // https://github.com/libp2p/specs/tree/master/pubsub/gossipsub\n        pubsub: PubSubGossip,\n        contentRouting: [delegateContentRouter],\n        peerRouting: [delegatePeerRouter],\n      },\n      config: {\n        peerDiscovery: {\n          // auto dial to peers we find when we have less peers than `connectionManager.minPeers`\n          autoDial: true,\n          bootstrap: {\n            list: bootstrapList,\n          },\n          webRTCStar: {\n            enabled: true,\n          },\n        },\n        transport: {\n          WebRTCStar: {\n            // webrtc-star options\n            interval: 1000, // ms\n            enabled: true,\n            id: peerInfo.id,\n            upgrader,\n          },\n          // TODO - when stabilized use it\n          // stardust: {\n          //   enabled: true,\n          //   upgrader,\n          //   libp2p: Libp2p,\n          //   id: peerInfo.id,\n          // },\n        },\n        // Turn on relay with hop active so we can connect to more peers\n        // implements the circuit-relay mechanism that allows nodes that\n        // don't speak the same protocol to communicate using a third relay node.\n        // https://github.com/libp2p/js-libp2p-circuit - DEPRECATED, but docs\n        // can be forund on here\n        // https://github.com/libp2p/specs/tree/master/relay\n        /**\n         * The circuit relay is a means to establish connectivity between libp2p nodes (e.g. IPFS nodes) that wouldn't otherwise be able to establish a direct connection to each other.\n         *\n         * Relay is needed in situations where nodes are behind NAT, reverse proxies, firewalls and/or simply don't support the same transports (e.g. go-ipfs vs. browser-ipfs). Even though libp2p has modules for NAT traversal (go-libp2p-nat), piercing through NATs isn't always an option. The circuit relay protocol exists to overcome those scenarios.\n         * Unlike a transparent tunnel, where a libp2p peer would just proxy a communication stream to a destination (the destination being unaware of the original source), a circuit relay makes the destination aware of the original source and the circuit followed to establish communication between the two.\n         */\n        relay: {\n          enabled: true,\n          hop: {\n            enabled: true,\n            active: true,\n          },\n        },\n        /**\n         * Create a new KadDHT.\n         *\n         * @param {Switch} sw libp2p-switch instance\n         * @param {object} options DHT options\n         * @param {number} options.kBucketSize k-bucket size (default 20)\n         * @param {number} options.concurrency alpha concurrency of queries (default 3) limiting the scope of queries to k closest peers\n         * @param {Datastore} options.datastore datastore (default MemoryDatastore)\n         * @param {object} options.validators validators object with namespace as keys and function(key, record, callback)\n         * @param {object} options.selectors selectors object with namespace as keys and function(key, records)\n         * @param {randomWalkOptions} options.randomWalk randomWalk options\n         */\n        /**\n         * Random walk options\n         *\n         * @typedef {Object} randomWalkOptions\n         * @property {boolean} enabled discovery enabled (default: true)\n         * @property {number} queriesPerPeriod how many queries to run per period (default: 1)\n         * @property {number} interval how often to run the the random-walk process, in milliseconds (default: 300000)\n         * @property {number} timeout how long to wait for the the random-walk query to run, in milliseconds (default: 30000)\n         * @property {number} delay how long to wait before starting the first random walk, in milliseconds (default: 10000)\n         */\n        dht: {\n          enabled: true,\n          kBucketSize: 20,\n          concurrency: 5,\n          randomWalk: {\n            queriesPerPeriod: 2,\n            enabled: true,\n            interval: 10e3, // This is set low intentionally, so more peers are discovered quickly. Higher intervals are recommended\n            timeout: 2e3, // End the query quickly since we're running so frequently\n          },\n        },\n        pubsub: {\n          enabled: true,\n          emitSelf: true,\n          signMessages: false,\n          strictSigning: false,\n        },\n      },\n    },\n    peerInfo\n  );\n};\n","/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils.const.ts",["2510","2511","2512","2513"],"// export const IPFS_UTILS_DEFAULT_OPTIONS = {\n//   config: {\n//     Addresses: {\n//       Swarm: [\n//         '/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star',\n//         '/ip4/127.0.0.1/tcp/9090/ws/p2p-webrtc-star',\n//       ],\n//     },\n//   },\n// };\n\nimport { WEB_RTC_STAR_SERVER } from './ipfs-utils-libp2p/ipfs-utils-libp2p.const';\n\nconst API_SERVER = {\n  host: '127.0.0.1',\n  port: '5001',\n};\n\nconst GATEWAY_SERVER = {\n  host: '127.0.0.1',\n  port: '8080',\n};\n\nconst BOOTSTRAP_NODE = {\n  host: '127.0.0.1',\n  port: '4002',\n};\n\nexport const IPFS_UTILS_DEFAULT_OPTIONS = {\n  // TODO - uncomment after server-side integrated\n  // config: {\n  //   Addresses: {\n  //     Swarm: [\n  //       `/ip4/${WEB_RTC_STAR_SERVER.host}/tcp/${WEB_RTC_STAR_SERVER.port}/ws/p2p-webrtc-star`,\n  //     ],\n  //     API: `/ip4/${API_SERVER.host}/tcp/${API_SERVER.port}`,\n  //     Gateway: `/ip4/${GATEWAY_SERVER.host}/tcp/${GATEWAY_SERVER.port}`,\n  //   },\n  //   Bootstrap: [\n  //     `/ip4/${BOOTSTRAP_NODE.host}/tcp/${BOOTSTRAP_NODE.port}/ws/ipfs/Qma6wr1oVavRghh4QDXxx1R1Ngo5ahreRRwkZgeYaUPKXs`,\n  //   ],\n  // },\n  // preload: {\n  //   // TODO - caused errors https://github.com/ipfs/go-ipfs/issues/6204\n  //   enabled: false,\n  //   addresses: [`/ip4/${API_SERVER.host}/tcp/${API_SERVER.port}`],\n  // },\n  EXPERIMENTAL: {\n    ipnsPubsub: true,\n    sharding: true,\n  },\n  relay: {\n    enabled: true,\n    hop: {\n      enabled: true,\n      active: true,\n    },\n  },\n  dht: {\n    enabled: true,\n    kBucketSize: 20,\n    concurrency: 5,\n    randomWalk: {\n      queriesPerPeriod: 2,\n      enabled: true,\n      interval: 10e3, // This is set low intentionally, so more peers are discovered quickly. Higher intervals are recommended\n      timeout: 2e3, // End the query quickly since we're running so frequently\n    },\n  },\n  pubsub: {\n    enabled: true,\n    emitSelf: true,\n    signMessages: false,\n    strictSigning: false,\n  },\n};\n\nexport const IPFS_UTILS_DEFAULT_TIMEOUT_MS = 30000;\n","/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils.ts",["2514","2515"],"import IPFS from 'ipfs';\nimport {\n  IPFS_UTILS_DEFAULT_OPTIONS,\n  IPFS_UTILS_DEFAULT_TIMEOUT_MS,\n} from './ipfs-utils.const';\nimport { getLibPeerToPeer } from './ipfs-utils-libp2p/ipfs-utils-libp2p';\n\n/**\n * create a ready to use connection to IPFS with a basis default options\n */\nexport const ipfsUtilsConnectBasic = async (\n  options?: object,\n  timeoutMs: number = IPFS_UTILS_DEFAULT_TIMEOUT_MS\n) => {\n  let timer: NodeJS.Timeout | undefined;\n  try {\n    timer = setTimeout(() => {\n      throw new Error('Connection timed out');\n    }, timeoutMs);\n    return await IPFS.create({\n      ...IPFS_UTILS_DEFAULT_OPTIONS,\n      ...options,\n      // TODO - https://github.com/ipfs/go-ipfs/issues/6204 - try when resolved libp2p: getLibPeerToPeer,\n    });\n  } finally {\n    clearTimeout(timer!);\n  }\n};\n","/home/paul/projects/protocol/src/utils/lazy-loading-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/lazy-loading-utils/lazy-loading-utils.ts",[],"/home/paul/projects/protocol/src/utils/main-utils.ts",[],"/home/paul/projects/protocol/src/utils/password-utils/decrypt.password-utils.ts",[],"/home/paul/projects/protocol/src/utils/password-utils/derive-key.password-utils.ts",[],"/home/paul/projects/protocol/src/utils/password-utils/encrypt.password-utils.ts",[],"/home/paul/projects/protocol/src/utils/password-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/password-utils/password-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/password-utils/password-utils.types.ts",[],"/home/paul/projects/protocol/src/utils/string-encoding-utils.ts",["2516"],"/**\n * The sulutions is right from the article\n * https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String\n */\n\nexport function encodeArrayBufferToDOMString(buf: ArrayBuffer) {\n  return String.fromCharCode.apply(null, new Uint16Array(buf) as any);\n}\nexport function decodeDOMStringToArrayBuffer(str: string) {\n  const buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n  const bufView = new Uint16Array(buf);\n  for (let i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n","/home/paul/projects/protocol/src/utils/string-utilities.ts",[],"/home/paul/projects/protocol/src/utils/typed-array-utils.ts",[],"/home/paul/projects/protocol/src/utils/validation-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/validation-utils/validation-utils-timestamp.ts",[],"/home/paul/projects/protocol/src/utils/validation-utils/validation-utils-validation-error.ts",[],"/home/paul/projects/protocol/src/utils/validation-utils/validation-utils.ts",["2517","2518"],"import { ValidationError } from './validation-utils-validation-error';\nimport Ajv, { ValidateFunction } from 'ajv';\nimport ajvJSONSchemaDraft6 from 'ajv/lib/refs/json-schema-draft-06.json';\nimport memoize from 'lodash.memoize';\nimport { isDEV } from 'const/common-values/common-values-env';\n\nconst ajv = new Ajv({\n  allErrors: isDEV,\n  verbose: isDEV,\n});\n\najv.addMetaSchema(ajvJSONSchemaDraft6);\n\nconst ajvVerbose = new Ajv({\n  allErrors: true,\n  verbose: true,\n});\n\najvVerbose.addMetaSchema(ajvJSONSchemaDraft6);\n\nexport const getValidatorForJSONSchema = memoize(\n  (schema: object): ValidateFunction => ajv.compile(schema)\n);\n\nexport const validateBySchema = (schema: object, value: any): boolean => {\n  return !!getValidatorForJSONSchema(schema)(value);\n};\n\nexport const getVerboseValidatorForJSONSchema = memoize(\n  (schema: object): ValidateFunction => ajvVerbose.compile(schema)\n);\n\nexport const validateVerboseBySchema = (\n  schema: object,\n  value: any\n): Error | void => {\n  const validator = getVerboseValidatorForJSONSchema(schema);\n  const validationResult = validator(value);\n\n  if (!validationResult) {\n    return new ValidationError(validator.errors);\n  }\n};\n","/home/paul/projects/protocol/src/components/userProfile/index.ts",[],"/home/paul/projects/protocol/src/components/userProfile/userProfile.tsx",[],"/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/index.ts",[],"/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/statused-class-helper.const.ts",[],"/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/statused-class-helper.ts",["2519"],"import { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport {\n  IStatusedClassHelperOptions,\n  TStatusClassHelperStatusChangesEmitter,\n  IStatusedClassHelperStatusEmitterEvents,\n  IStatusedClassHelper,\n} from './statused-class-helper.types';\nimport assert from 'assert';\nimport {\n  STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT,\n  STATUSED_CLASS_HELPER_STATUS_CHANGED_EVENT_NAME,\n} from './statused-class-helper.const';\n\nexport class StatusedClassHelper<\n  StatusChangedEventName extends string,\n  Status extends string\n> implements IStatusedClassHelper<StatusChangedEventName, Status> {\n  public get currentStatus(): Status | undefined {\n    return this.__currentStatus || undefined;\n  }\n  protected __currentStatus?: Status;\n  /**\n   * is this instance ready to use.\n   *\n   * @protected\n   * @type {boolean}\n   * @memberof StatusedClassHelper\n   */\n  protected __isReadyStatusedClassHelper: boolean = false;\n  /**\n   * Emitter of a status changes.\n   * Used for inner purposes mostly.\n   *\n   * @protected\n   * @memberof StatusedClassHelper\n   */\n  protected __emitterInnerStatusChanged = new EventEmitter<\n    IStatusedClassHelperStatusEmitterEvents<Status>\n  >();\n  protected __emitterExternal?: TStatusClassHelperStatusChangesEmitter<\n    StatusChangedEventName,\n    Status\n  >;\n  protected __emitterEventStatusChanged?: StatusChangedEventName;\n\n  constructor(\n    options: IStatusedClassHelperOptions<StatusChangedEventName, Status>\n  ) {\n    this.__validateOptionsStatusClassHelper(options);\n    this.__setOptionsStatusClassHelper(options);\n    this.__setListenerForStatusChanges();\n    this.__setIsReady();\n  }\n  setStatus(status: Status): void {\n    this.__checkIsStatusedClassHelperReady();\n    this.__setNewStatus(status);\n    this.__emitExternalEmitterNewStatus(status);\n  }\n\n  waitTillStatus = async <S extends Status | undefined>(\n    currentStatus: S,\n    timeoutMs: number = STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT\n  ): Promise<Status | undefined> => {\n    this.__checkIsStatusedClassHelperReady();\n    if (this.__currentStatus !== currentStatus) {\n      return this.__currentStatus;\n    }\n    return this.__resolveOnCondition(\n      (newStatus: Status) => newStatus !== currentStatus,\n      timeoutMs\n    );\n  };\n  waitForStatus = async <S extends Status | undefined>(\n    trgetStatus: S,\n    timeoutMs: number = STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT\n  ): Promise<Status | undefined> => {\n    this.__checkIsStatusedClassHelperReady();\n    if (this.__currentStatus === trgetStatus) {\n      return this.__currentStatus;\n    }\n    return this.__resolveOnCondition(\n      (newStatus: Status) => newStatus === trgetStatus,\n      timeoutMs\n    );\n  };\n\n  listenForStatusChanged(\n    timeoutMs: number = STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT\n  ) {\n    this.__checkIsStatusedClassHelperReady();\n    return this.__resolveOnCondition(() => true, timeoutMs);\n  }\n\n  clearStatus() {\n    this.__clearStatus();\n  }\n\n  stopStatusEmitter() {\n    this.__clearStatus();\n    this.__unsetIsReady();\n    this.__clearEventEmitters();\n    this.__clearOptions();\n  }\n\n  protected __setIsReady(): void {\n    this.__isReadyStatusedClassHelper = true;\n  }\n\n  protected __unsetIsReady(): void {\n    this.__isReadyStatusedClassHelper = false;\n  }\n\n  protected __emitStatusChaned(statusName: string): void {\n    this.__emitterInnerStatusChanged.emit(\n      STATUSED_CLASS_HELPER_STATUS_CHANGED_EVENT_NAME,\n      statusName\n    );\n  }\n\n  protected __handleEmitterStatusChanged = (statusName: Status): void => {\n    this.__setNewStatus(statusName);\n    this.__emitStatusChaned(statusName);\n  };\n\n  protected __getEmitterEventStatusChanged = (): StatusChangedEventName => {\n    const emitterEventStatusChanged = this.__emitterEventStatusChanged;\n\n    if (!emitterEventStatusChanged) {\n      throw new Error('emitterEventStatusChanged must not be empty');\n    }\n    return emitterEventStatusChanged;\n  };\n\n  protected __setListenerForStatusChanges(): void {\n    this.__emitterExternal?.addListener(\n      this.__getEmitterEventStatusChanged(),\n      this.__handleEmitterStatusChanged\n    );\n  }\n\n  protected __validateOptionsStatusClassHelper(\n    options: IStatusedClassHelperOptions<StatusChangedEventName, Status>\n  ): void {\n    assert(!!options, 'Options must be provided');\n    assert(typeof options === 'object', 'Options must be an object');\n\n    const {\n      statusChangedEventName,\n      statusChangesEmitter: statusChanesEmitter,\n    } = options;\n\n    assert(\n      !!statusChangedEventName,\n      'Status changed event name must be provided and not empty'\n    );\n    assert(\n      typeof statusChangedEventName === 'string',\n      'Status changed event name must be a string'\n    );\n    assert(\n      !!statusChanesEmitter,\n      'An event emitter must be provided for listening an event leads to a status chage'\n    );\n    assert(\n      typeof statusChanesEmitter === 'object',\n      'An event emitter instance must be an object'\n    );\n    assert(\n      typeof statusChanesEmitter.addListener === 'function',\n      'An event emitter instance must have \"addListener\" method'\n    );\n    assert(\n      statusChanesEmitter.addListener.length > 0,\n      'An event emitter instance must have \"addListener\" method which accepts an event name'\n    );\n    assert(\n      typeof statusChanesEmitter.emit === 'function',\n      'An event emitter instance must have \"emit\" method'\n    );\n    assert(\n      statusChanesEmitter.emit.length > 1,\n      'An event emitter instance must have \"emit\" method which accepts an event name with a new status'\n    );\n  }\n\n  protected __setOptionsStatusClassHelper(\n    options: IStatusedClassHelperOptions<StatusChangedEventName, Status>\n  ): void {\n    this.__emitterEventStatusChanged = options.statusChangedEventName;\n    this.__emitterExternal = options.statusChangesEmitter;\n  }\n\n  /**\n   *  Returns a Promise wich will be resolved\n   *  when the resolver callback return true.\n   *\n   * @param {(status: Status) => boolean} resolver\n   * @param {number} [timeoutMs] - if specified than will be rejected after this milliseconds count\n   * @returns {Promise<Status>} - promised will be resolved with a new status which is meets the requirements\n   * @throws - on timeout if the timeout value specified\n   */\n  protected __resolveOnCondition = async (\n    resolver: (status: Status) => boolean,\n    timeoutMs?: number\n  ): Promise<Status> => {\n    return await new Promise((res, rej) => {\n      let timer: NodeJS.Timeout | undefined;\n      const listenerStatusChanged = (newStatus: Status) => {\n        if (this.__isReadyStatusedClassHelper) {\n          timer && clearTimeout(timer);\n          rej(new Error('The instance was closed'));\n        }\n        if (resolver(newStatus) === true) {\n          timer && clearTimeout(timer);\n          res(newStatus);\n        }\n      };\n\n      this.__emitterInnerStatusChanged.once(\n        STATUSED_CLASS_HELPER_STATUS_CHANGED_EVENT_NAME,\n        listenerStatusChanged\n      );\n      if (timeoutMs) {\n        timer = setTimeout(() => {\n          timer = undefined;\n          this.__emitterInnerStatusChanged.removeListener(\n            STATUSED_CLASS_HELPER_STATUS_CHANGED_EVENT_NAME,\n            listenerStatusChanged\n          );\n          rej(new Error(`Timed out waiting for a status`));\n        }, timeoutMs);\n      }\n    });\n  };\n\n  /**\n   * Checks whether the instance is ready to be used.\n   * If not, then throw an error.\n   *\n   * @protected\n   * @memberof StatusedClassHelper\n   */\n  protected __checkIsStatusedClassHelperReady(): void {\n    if (!this.__isReadyStatusedClassHelper) {\n      throw new Error('The instance is not ready to be used');\n    }\n  }\n\n  protected __setNewStatus(statusName: Status): void {\n    this.__currentStatus = statusName;\n  }\n\n  protected __emitExternalEmitterNewStatus(\n    statusName: Status | undefined\n  ): void {\n    this.__emitterExternal?.emit(\n      this.__getEmitterEventStatusChanged(),\n      statusName\n    );\n  }\n\n  protected __clearEventEmitters(): void {\n    this.__emitterExternal?.removeListener(\n      this.__getEmitterEventStatusChanged(),\n      this.__handleEmitterStatusChanged\n    );\n    this.__emitterInnerStatusChanged.removeAllListeners();\n    (this.__emitterInnerStatusChanged as any) = undefined;\n    this.__emitterExternal = undefined;\n  }\n\n  protected __clearOptions(): void {\n    this.__emitterEventStatusChanged = undefined;\n  }\n\n  protected __clearStatus(): void {\n    this.__emitExternalEmitterNewStatus(undefined);\n    this.__currentStatus = undefined;\n  }\n}\n","/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/statused-class-helper.types.ts",["2520"],"import { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport { STATUSED_CLASS_HELPER_STATUS_CHANGED_EVENT_NAME } from './statused-class-helper.const';\n\nexport type TStatusClassHelperStatusChangesEmitter<\n  SCE extends string,\n  Status extends string\n  > = EventEmitter<{ [key in SCE]: (status: Status, ...other: any[]) => void }>;\n\nexport interface IStatusedClassHelperOptions<\n  SCE extends string,\n  Status extends string\n  > {\n  statusChangesEmitter: TStatusClassHelperStatusChangesEmitter<SCE, Status>;\n  statusChangedEventName: SCE;\n}\n\n/**\n * Events which can be emitted by the inner events emitter\n *\n * @export\n * @interface IStatusedClassHelperStatusEmitterEvents\n * @template Status\n */\nexport interface IStatusedClassHelperStatusEmitterEvents<\n  Status extends string\n  > {\n  /**\n   * Status changed event, emits with a new status value\n   * or undefined if the instance status was cleared.\n   *\n   * @memberof IStatusedClassHelperStatusEmitterEvents\n   */\n  [STATUSED_CLASS_HELPER_STATUS_CHANGED_EVENT_NAME]: (\n    status: Status | undefined\n  ) => void;\n}\n\nexport interface IStatusedClassHelper<\n  StatusChangedEventName extends string,\n  Status extends string\n  > {\n  /**\n   * The current status of the instance\n   * or undefined if there is no status.\n   *\n   * @type {(Status | undefined)}\n   * @memberof IStatusedClassHelper\n   */\n  readonly currentStatus: Status | undefined;\n  /**\n   * Set the current status value and\n   * emit an event on the external\n   * emitter, that the current\n   * status was changed.\n   *\n   * @param {Status} status\n   * @memberof IStatusedClassHelper\n   * @throws - e.g. the instance is not ready\n   */\n  setStatus(status: Status): void;\n  /**\n   * Retruns a promise which will be resolved\n   * when the current status changed from the status provided.\n   *\n   * @param {(Status | undefined)} status - waiting till the current status value won't changed on something else.\n   * @param {number} [timeoutMs = STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT] - timeout in milliseconds, if not specified the default value will be used\n   * @returns {(Promise<Status | undefined>)}\n   * @memberof IStatusedClassHelper\n   * @throws - e.g. if a status won't change within the time specified\n   */\n  waitTillStatus(\n    status: Status | undefined,\n    timeoutMs?: number\n  ): Promise<Status | undefined>;\n  /**\n   * Retruns a promise which will be resolved\n   * when the current status changed to the target value.\n   *\n   * @param {(Status | undefined)} status - waiting till the current status value won't changed on the provided.\n   * @param {number} [timeoutMs = STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT] - timeout in milliseconds, if not specified the default value will be used\n   * @returns {(Promise<Status | undefined>)}\n   * @memberof IStatusedClassHelper\n   * @throws - e.g. if a status won't change within the time specified\n   */\n  waitForStatus(\n    status: Status | undefined,\n    timeoutMs?: number\n  ): Promise<Status | undefined>;\n\n  /**\n   * Returns a promise which will be resolved\n   * when the instance's status changed\n   * to another value.\n   *\n   * @param {number} [timeoutMs=STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT] - will be rejected after this timeout\n   * @returns {(Promise<Status | undefined>)}\n   * @memberof IStatusedClassHelper\n   * @throws\n   */\n  listenForStatusChanged(timeoutMs?: number): Promise<Status | undefined>;\n\n  /**\n   * Release all emitters and stop listening for events.\n   *\n   * @memberof IStatusedClassHelper\n   */\n  stopStatusEmitter(): void;\n}\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database.ts",["2521","2522","2523"],"import {\n  ISwarmMessageDatabaseEvents,\n  ISwarmMessageDatabaseMessagingMethods,\n  ISwarmMessagesDatabaseConnectCurrentUserOptions,\n  ISwarmMessagesDatabaseConnectOptions,\n  ISwarmMessagesDatabaseReady,\n  TSwarmMessageDatabaseMessagesCached,\n} from './swarm-messages-database.types';\nimport {\n  ESwarmStoreConnector,\n  ESwarmStoreEventNames,\n} from '../swarm-store-class/swarm-store-class.const';\nimport assert from 'assert';\nimport {\n  ISwarmMessageStore,\n  ISwarmMessageStoreDeleteMessageArg,\n} from '../swarm-message-store/swarm-message-store.types';\nimport { getEventEmitterInstance } from '../basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport { ESwarmMessageStoreEventNames } from '../swarm-message-store/swarm-message-store.const';\nimport { ISwarmMessageInstanceDecrypted } from '../swarm-message/swarm-message-constructor.types';\nimport { TTypedEmitter } from '../basic-classes/event-emitter-class-base/event-emitter-class-base.types';\nimport {\n  TSwarmStoreDatabaseEntityAddress,\n  TSwarmStoreDatabaseEntityKey,\n  TSwarmStoreDatabaseEntityUniqueIndex,\n  TSwarmStoreDatabaseOptions,\n  TSwarmStoreDatabaseType,\n  TSwarmStoreValueTypes,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport validateUserIdentifier from '../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier';\nimport { TSwarmMessageUserIdentifierSerialized } from '../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { SwarmMessagesDatabaseCache } from './swarm-messages-database-subclasses/swarm-messages-database-cache';\nimport {\n  ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions,\n  ISwarmMessagesDatabaseCacheOptions,\n  ISwarmMessagesDatabaseCache,\n} from './swarm-messages-database.types';\nimport { isConstructor } from '../../utils/common-utils/common-utils-classes';\nimport {\n  ESwarmMessagesDatabaseCacheEventsNames,\n  SWARM_MESSAGES_DATABASE_MESSAGES_CACHE_UPDATE_RETRY_DELAY_MS,\n  SWARM_MESSAGES_DATABASE_MESSAGES_EMITTED_UNIQ_ID_ADDRESS_PREFIX,\n} from './swarm-messages-database.const';\nimport { ISwarmMessageStoreMessageWithMeta } from '../swarm-message-store/swarm-message-store.types';\nimport { delay } from '../../utils/common-utils/common-utils-timer';\n\nexport class SwarmMessagesDatabase<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>\n> implements ISwarmMessageDatabaseMessagingMethods<P, DbType> {\n  get dbName(): string | undefined {\n    return this._dbName;\n  }\n\n  get dbType(): DbType {\n    return this._dbType as DbType;\n  }\n\n  get isReady(): boolean {\n    return this._isReady && !!this._swarmMessageStore;\n  }\n\n  get emitter(): TTypedEmitter<ISwarmMessageDatabaseEvents<P, DbType>> {\n    return this._emitter;\n  }\n\n  get isMessagesListContainsAllMessages(): boolean {\n    return !!this._swarmMessagesCache?.whetherMessagesListContainsAllMessages;\n  }\n\n  get whetherMessagesListUpdateInProgress(): boolean {\n    return !!this._swarmMessagesCache?.isUpdating;\n  }\n\n  get cachedMessages():\n    | TSwarmMessageDatabaseMessagesCached<P, DbType>\n    | undefined {\n    return this._messagesCached;\n  }\n\n  protected get _currentUserId():\n    | TSwarmMessageUserIdentifierSerialized\n    | undefined {\n    return this._currentUserOptons?.userId;\n  }\n\n  /**\n   * Is this instance is Key-Value database\n   *\n   * @readonly\n   * @protected\n   * @memberof SwarmMessagesDatabase\n   */\n  protected get _isKeyValueDatabase() {\n    return this._dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE;\n  }\n\n  /**\n   * name of the databasESwarmStoreConnectorOrbitDbDatabaseTypee\n   *\n   * @protected\n   * @type {string}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _dbName?: string;\n\n  protected _dbType?: DbType;\n\n  protected _emitter = getEventEmitterInstance<\n    ISwarmMessageDatabaseEvents<P, DbType>\n  >();\n\n  /**\n   * An instance implemented ISwarmMessageStore\n   * interface.\n   *\n   * @protected\n   * @type {ISwarmMessageStore<P>}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _swarmMessageStore?: ISwarmMessageStore<P, DbType>;\n\n  /**\n   * Implementation of a swarm messages cahce\n   *\n   * @protected\n   * @type {ISwarmMessagesDatabaseCache<P, DbType>}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _swarmMessagesCache?: ISwarmMessagesDatabaseCache<P, DbType>;\n\n  /**\n   * Options for the database which used for\n   * database initialization via ISwarmMessageStore.\n   *\n   * @protectedimport { ISwarmMessagesDatabaseReady, } from './swarm-messages-database.types';\n   * @type {TSwarmStoreDatabaseOptions}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _dbOptions?: TSwarmStoreDatabaseOptions<P, T>;\n\n  protected _currentUserOptons?: ISwarmMessagesDatabaseConnectCurrentUserOptions;\n\n  protected _cacheOptions?: ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions<\n    P,\n    DbType\n  >;\n\n  protected _isReady: boolean = false;\n\n  protected _newMessagesEmitted = new Set<string>();\n\n  /**\n   * Swarm messages cached\n   *\n   * @protected\n   * @type {(TSwarmMessageDatabaseMessagesCached<P, DbType> | undefined)}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _messagesCached:\n    | TSwarmMessageDatabaseMessagesCached<P, DbType>\n    | undefined;\n\n  async connect(\n    options: ISwarmMessagesDatabaseConnectOptions<P, T, DbType>\n  ): Promise<void> {\n    this._handleOptions(options);\n    await this._openDatabaseInstance();\n    await this._startSwarmMessagesCache();\n    this._setListeners();\n    this._setIsReady();\n    this._updateMessagesCache();\n  }\n\n  close = async (): Promise<void> => {\n    if (!this.isReady) {\n      console.warn('SwarmMessageDatabase instance was already closed');\n      return;\n    }\n    this._unsetIsReady();\n    await this._closeSwarmDatabaseInstance();\n    await this._closeSwarmMessagesCahceInstance();\n    this._emitInstanceClosed();\n    this._handleDatabaseClosed();\n  };\n\n  drop = async (): Promise<void> => {\n    if (!this.isReady) {\n      console.warn('SwarmMessageDatabase instance was already closed');\n      return;\n    }\n    this._unsetIsReady();\n    await this._dropSwarmDatabaseInstance();\n    this._emitDatabaseDropped();\n    this._handleDatabaseClosed();\n  };\n\n  addMessage = (\n    ...args: Parameters<\n      ISwarmMessageDatabaseMessagingMethods<P, DbType>['addMessage']\n    >\n  ): ReturnType<\n    ISwarmMessageDatabaseMessagingMethods<P, DbType>['addMessage']\n  > => {\n    if (!this._checkIsReady()) {\n      throw new Error('The instance is not ready to use');\n    }\n    return this._swarmMessageStore.addMessage(this._dbName, ...args);\n  };\n\n  deleteMessage = (\n    messageAddressOrKey: ISwarmMessageStoreDeleteMessageArg<P>\n  ): ReturnType<\n    ISwarmMessageDatabaseMessagingMethods<P, DbType>['deleteMessage']\n  > => {\n    if (!this._checkIsReady()) {\n      throw new Error('The instance is not ready to use');\n    }\n    return this._swarmMessageStore.deleteMessage(\n      this._dbName,\n      messageAddressOrKey\n    );\n  };\n\n  collect = (\n    ...args: Parameters<\n      ISwarmMessageDatabaseMessagingMethods<P, DbType>['collect']\n    >\n  ): ReturnType<\n    ISwarmMessageDatabaseMessagingMethods<P, DbType>['collect']\n  > => {\n    if (!this._checkIsReady()) {\n      throw new Error('The instance is not ready to use');\n    }\n    return this._swarmMessageStore.collect(this._dbName, ...args);\n  };\n\n  collectWithMeta = (\n    ...args: Parameters<\n      ISwarmMessageDatabaseMessagingMethods<P, DbType>['collectWithMeta']\n    >\n  ): ReturnType<\n    ISwarmMessageDatabaseMessagingMethods<P, DbType>['collectWithMeta']\n  > => {\n    if (!this._checkIsReady()) {\n      throw new Error('The instance is not ready to use');\n    }\n    return this._swarmMessageStore.collectWithMeta(this._dbName, ...args);\n  };\n\n  /**\n   * Checks if the instance is ready to use\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _checkIsReady(): this is ISwarmMessagesDatabaseReady<P, DbType> {\n    if (!this._isReady) {\n      throw new Error('The instance is not ready to use');\n    }\n    if (!this._swarmMessageStore) {\n      throw new Error(\n        'Implementation of the SwarmMessgaeStore interface is not provided'\n      );\n    }\n    if (!this._dbName) {\n      throw new Error('Database name is not defined for the instance');\n    }\n    if (!this._currentUserId) {\n      throw new Error('Identity of the current user is not defined');\n    }\n    if (!this._swarmMessagesCache) {\n      throw new Error('Swarm messages cahce is not exists');\n    }\n    return true;\n  }\n\n  protected _validateOptions(\n    options: ISwarmMessagesDatabaseConnectOptions<P, T, DbType>\n  ): void {\n    assert(!!options, 'An options object must be provided');\n    assert(typeof options === 'object', 'Options must be an object');\n    assert(!!options.dbOptions, 'An options for database must be provided');\n    assert(\n      typeof options.dbOptions === 'object',\n      'An options for database must be an object'\n    );\n    assert(\n      !!options.swarmMessageStore,\n      'An instance implemented SwarmMessageStore interface must be provided'\n    );\n    assert(\n      options.swarmMessageStore.isReady,\n      'An implementation of the ISwarmMessageStore interface must be ready to use'\n    );\n    assert(!!options.user, 'The current user options must be defined');\n    assert(\n      typeof options.user === 'object',\n      'The current user options should be an object'\n    );\n    validateUserIdentifier(options.user.userId);\n  }\n\n  protected _setDbOptions(dbOptions: TSwarmStoreDatabaseOptions<P, T>): void {\n    this._dbOptions = dbOptions;\n    this._dbName = dbOptions.dbName;\n    this._dbType = dbOptions.dbType as DbType;\n  }\n\n  protected _setUserOptions(\n    optionsUser: ISwarmMessagesDatabaseConnectCurrentUserOptions\n  ): void {\n    this._currentUserOptons = optionsUser;\n  }\n\n  protected _setOptions(\n    options: ISwarmMessagesDatabaseConnectOptions<P, T, DbType>\n  ): void {\n    this._setDbOptions(options.dbOptions);\n    this._swarmMessageStore = options.swarmMessageStore;\n    this._setUserOptions(options.user);\n  }\n\n  protected _validateCacheOptions(\n    options?: ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions<\n      P,\n      DbType\n    >\n  ): void {\n    if (!options) {\n      return;\n    }\n    assert(\n      typeof options === 'object',\n      'Swarm messages cache options must be an object'\n    );\n    if (options.cacheConstructor) {\n      assert(\n        isConstructor(options.cacheConstructor),\n        'cacheConstructor option should be a constructor'\n      );\n    }\n  }\n\n  protected _setCacheOptions(\n    options: ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions<\n      P,\n      DbType\n    >\n  ): void {\n    this._cacheOptions = options;\n  }\n\n  /**\n   * Handle options provided for the connect\n   * method.\n   *\n   * @protected\n   * @param {ISwarmMessage_handleDatabaseClosedsDatabaseConnectOptions<P>} options\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _handleOptions(\n    options: ISwarmMessagesDatabaseConnectOptions<P, T, DbType>\n  ): void {\n    this._validateOptions(options);\n    this._setOptions(options);\n    if (options.cacheOptions) {\n      this._validateCacheOptions(options.cacheOptions);\n      this._setCacheOptions(options.cacheOptions);\n    }\n  }\n\n  protected _checkDatabaseProps(): this is Omit<\n    ISwarmMessagesDatabaseReady<P, DbType>,\n    'isReady'\n  > {\n    const swarmMessageStore = this._swarmMessageStore;\n\n    if (!swarmMessageStore) {\n      throw new Error(\n        'A SwarmMessageStore interface implementation is not defined'\n      );\n    }\n\n    const { _dbName } = this;\n\n    if (!_dbName) {\n      throw new Error('A database name is not defined');\n    }\n    return true;\n  }\n\n  /**\n   * Set the database is ready to use.\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _setIsReady = (): void => {\n    this._isReady = true;\n  };\n\n  /**\n   * Unset flag that the database is ready to use.\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _unsetIsReady = (): void => {\n    this._isReady = false;\n  };\n\n  protected _setMessagesCached = (\n    messagesCached: TSwarmMessageDatabaseMessagesCached<P, DbType> | undefined\n  ) => {\n    this._messagesCached = messagesCached;\n  };\n\n  protected _updateMessagesCache(): void {\n    if (!this._isReady) {\n      console.warn(`The database ${this._dbName}:${this._dbType} is not ready`);\n      return;\n    }\n    if (this._checkIsReady()) {\n      this._swarmMessagesCache.update().catch(async (err) => {\n        console.error(`Failed to update messages cache ${err.message}`);\n        await delay(\n          SWARM_MESSAGES_DATABASE_MESSAGES_CACHE_UPDATE_RETRY_DELAY_MS\n        );\n        this._updateMessagesCache();\n      });\n    }\n  }\n\n  protected _getSwarmMessageWithMeta(\n    dbName: string,\n    message: ISwarmMessageInstanceDecrypted,\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ): ISwarmMessageStoreMessageWithMeta<P> {\n    return {\n      dbName,\n      message,\n      messageAddress,\n      key,\n    };\n  }\n\n  /**\n   * Add message to the cache by it's description.\n   *\n   * @protected\n   * @param {string} dbName\n   * @param {ISwarmMessageInstanceDecrypted} message\n   * @param {TSwarmStoreDatabaseEntityAddress<P>} messageAddress\n   * @param {TSwarmStoreDatabaseEntityKey<P>} [key]\n   * @returns {Promise<void>}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _addMessageToCache(\n    dbName: string,\n    message: ISwarmMessageInstanceDecrypted,\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ): Promise<void> {\n    if (this._checkIsReady()) {\n      return this._swarmMessagesCache.addMessage(\n        this._getSwarmMessageWithMeta(dbName, message, messageAddress, key)\n      );\n    }\n    throw new Error('Swarm messages cache is not ready');\n  }\n\n  protected _removeMessageFromCache(\n    messageAddress: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n      : TSwarmStoreDatabaseEntityAddress<P>,\n    key: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityKey<P>\n      : undefined\n  ): Promise<void> {\n    if (this._checkIsReady()) {\n      if (!messageAddress && !key) {\n        throw new Error(\n          'Messages address or message key requered to remove message from the cache'\n        );\n      }\n      return this._swarmMessagesCache.deleteMessage(messageAddress, key);\n    }\n    throw new Error('Swarm messages cache is not ready');\n  }\n\n  protected _handleDatabaseLoadingEvent = (\n    dbName: string,\n    percentage: number\n  ): void => {\n    if (this._dbName !== dbName) return;\n    this._emitter.emit(ESwarmStoreEventNames.DB_LOADING, dbName, percentage);\n  };\n\n  protected _handleDatabaseUpdatedEvent = (dbName: string): void => {\n    if (this._dbName !== dbName) return;\n    debugger;\n    this._emitter.emit(ESwarmStoreEventNames.UPDATE, dbName);\n    this._updateMessagesCache();\n  };\n\n  /**\n   * Returns a unique value for the message to set it in\n   * the list of messages received.\n   *\n   * @param {TSwarmStoreDatabaseEntityAddress<P>} messageAddress\n   * @param {TSwarmStoreDatabaseEntityKey<P>} [key]\n   * @param {ISwarmMessageInstanceDecrypted} [message] - optional cause for DELETE messages\n   * a message object by itself may be not exists.\n   * @returns {string}\n   */\n  protected _getMessageUniqueIdForEmittedAsNewList = (\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>,\n    message?: ISwarmMessageInstanceDecrypted\n  ): string => {\n    return message\n      ? message.sig\n      : `${SWARM_MESSAGES_DATABASE_MESSAGES_EMITTED_UNIQ_ID_ADDRESS_PREFIX}::${messageAddress}`;\n  };\n\n  /**\n   * Add message to the list of a messages uniq id's which\n   * were emitted as a new before\n   *\n   * @param {TSwarmStoreDatabaseEntityAddress<P>} messageAddress\n   * @param {TSwarmStoreDatabaseEntityKey<P>} [key]\n   * @param {ISwarmMessageInstanceDecrypted} [message] - optional cause for DELETE messages\n   * a message object by itself may be not exists.\n   */\n  protected _addMessageToListOfEmitted = (\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>,\n    message?: ISwarmMessageInstanceDecrypted\n  ): void => {\n    this._newMessagesEmitted.add(\n      this._getMessageUniqueIdForEmittedAsNewList(messageAddress, key, message)\n    );\n  };\n\n  /**\n   * Checks whether the message is already been emitted as a new message\n   *\n   * @param {TSwarmStoreDatabaseEntityAddress<P>} messageAddress\n   * @param {TSwarmStoreDatabaseEntityKey<P>} [key]\n   * @param {ISwarmMessageInstanceDecrypted} [message] - optional cause for DELETE messages\n   * a message object by itself may be not exists.\n   * @returns {boolean}\n   */\n  protected _isMessageAlreadyEmitted = (\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>,\n    message?: ISwarmMessageInstanceDecrypted\n  ): boolean => {\n    return this._newMessagesEmitted.has(\n      this._getMessageUniqueIdForEmittedAsNewList(messageAddress, key, message)\n    );\n  };\n\n  protected _handleDatabaseNewMessage = (\n    dbName: string,\n    message: ISwarmMessageInstanceDecrypted,\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ) => {\n    if (this._dbName !== dbName) return;\n    debugger;\n    if (this._isMessageAlreadyEmitted(messageAddress, key, message)) {\n      return;\n    }\n    debugger;\n    this._emitter.emit(\n      ESwarmMessageStoreEventNames.NEW_MESSAGE,\n      dbName,\n      message,\n      messageAddress,\n      key\n    );\n    this._addMessageToListOfEmitted(messageAddress, key, message);\n    this._handleCacheUpdateOnNewMessage(message, messageAddress, key);\n  };\n\n  protected _handleDatabaseDeleteMessage = (\n    dbName: string,\n    userID: TSwarmMessageUserIdentifierSerialized,\n    // the global unique address (hash) of the DELETE message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // the global unique address (hash) of the DELETED message in the swarm\n    messageDeletedAddress: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n      : TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key for the value,\n    // for feed store it will be hash of the message which deleted by this one.\n    keyOrHash: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityKey<P>\n      : undefined\n  ) => {\n    if (this._dbName !== dbName) return;\n\n    const keyToCheckAlreadyEmitted = this._isKeyValueDatabase\n      ? keyOrHash\n      : undefined;\n\n    if (\n      this._isMessageAlreadyEmitted(messageAddress, keyToCheckAlreadyEmitted)\n    ) {\n      return;\n    }\n    debugger;\n    this._emitter.emit(\n      ESwarmMessageStoreEventNames.DELETE_MESSAGE,\n      dbName,\n      userID,\n      messageAddress,\n      messageDeletedAddress,\n      keyOrHash\n    );\n    this._addMessageToListOfEmitted(messageAddress, keyToCheckAlreadyEmitted);\n    this._handleCacheUpdateOnDeleteMessage(\n      userID,\n      messageAddress,\n      messageDeletedAddress,\n      keyOrHash\n    );\n  };\n\n  protected _handleDatabaseMessageError = (\n    dbName: string,\n    // swarm message string failed to deserialize\n    messageSerialized: string,\n    // error occurred while deserializing the message\n    error: Error,\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ) => {\n    if (this._dbName !== dbName) return;\n    this._emitter.emit(\n      ESwarmMessageStoreEventNames.NEW_MESSAGE_ERROR,\n      dbName,\n      messageSerialized,\n      error,\n      messageAddress,\n      key\n    );\n  };\n\n  protected _handleDatabaseReadyEvent = (dbName: string): void => {\n    if (this._dbName !== dbName) return;\n    this._emitter.emit(ESwarmStoreEventNames.READY, dbName);\n    this._setIsReady();\n  };\n\n  protected _emitInstanceClosed() {\n    if (!this._dbName) {\n      throw new Error(\n        'SwarmMessagesDatabase::_emitInstanceClosed: failed cause there is no database name defined'\n      );\n    }\n    this._emitter.emit(ESwarmStoreEventNames.CLOSE_DATABASE, this._dbName);\n  }\n\n  protected _handleDatabaseClosedEvent = (dbName: string): void => {\n    if (this._dbName !== dbName) return;\n    this._emitInstanceClosed();\n    this._handleDatabaseClosed();\n  };\n\n  protected _emitDatabaseDropped(): void {\n    if (!this._dbName) {\n      throw new Error(\n        'SwarmMessagesDatabase::_emitDatabaseDropped: failed cause there is no database name defined'\n      );\n    }\n    this._emitter.emit(ESwarmStoreEventNames.DROP_DATABASE, this._dbName);\n  }\n\n  protected _handleDatabaseDroppedEvent = (dbName: string): void => {\n    if (this._dbName !== dbName) return;\n    this._emitDatabaseDropped();\n    this._handleDatabaseClosed();\n  };\n\n  /**\n   /**\n   * Set listeners to listen events of the SwarmMessageStore\n   * implementation.\n   *\n   *\n   * @protected\n   * @param {boolean} [isSetListeners=true] - set or remove the listeners\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _setSwarmMessagesStoreListeners(\n    isSetListeners: boolean = true\n  ): void {\n    const method = isSetListeners ? 'addListener' : 'removeListener';\n\n    this._swarmMessageStore?.[method](\n      ESwarmStoreEventNames.DB_LOADING,\n      this._handleDatabaseLoadingEvent\n    );\n    this._swarmMessageStore?.[method](\n      ESwarmStoreEventNames.UPDATE,\n      this._handleDatabaseUpdatedEvent\n    );\n    this._swarmMessageStore?.[method](\n      ESwarmMessageStoreEventNames.NEW_MESSAGE,\n      this._handleDatabaseNewMessage\n    );\n    this._swarmMessageStore?.[method](\n      ESwarmMessageStoreEventNames.DELETE_MESSAGE,\n      this._handleDatabaseDeleteMessage\n    );\n    this._swarmMessageStore?.[method](\n      ESwarmStoreEventNames.READY,\n      this._handleDatabaseReadyEvent\n    );\n    this._swarmMessageStore?.[method](\n      ESwarmStoreEventNames.CLOSE_DATABASE,\n      this._handleDatabaseClosedEvent\n    );\n    this._swarmMessageStore?.[method](\n      ESwarmStoreEventNames.DROP_DATABASE,\n      this._handleDatabaseDroppedEvent\n    );\n  }\n\n  protected _handleCacheUpdating = (): void => {\n    this._emitter.emit(ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATING);\n  };\n\n  protected _handleCacheUpdated = (\n    messagesCached: TSwarmMessageDatabaseMessagesCached<P, DbType> | undefined\n  ): void => {\n    debugger;\n    this._setMessagesCached(messagesCached);\n    this.emitter.emit(\n      ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATED,\n      messagesCached\n    );\n  };\n\n  /**\n   * Set listeners for swarm messages cache events\n   *\n   * @protected\n   * @param {boolean} [isSetListeners=true]\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _setCacheListeners(isSetListeners: boolean = true): void {\n    if (!this._swarmMessagesCache) {\n      throw new Error('Swarm messages cache is not defined');\n    }\n\n    const { emitter } = this._swarmMessagesCache;\n    const method = isSetListeners ? 'addListener' : 'removeListener';\n\n    emitter[method](\n      ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATING as any,\n      this._handleCacheUpdating\n    );\n    emitter[method](\n      ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATED as any,\n      this._handleCacheUpdated\n    );\n  }\n\n  protected _setListeners(isSetListeners: boolean = true): void {\n    this._setSwarmMessagesStoreListeners(isSetListeners);\n    this._setCacheListeners(isSetListeners);\n  }\n\n  protected async _openDatabaseInstance(): Promise<void> {\n    if (!this._swarmMessageStore) {\n      throw new Error('Swarm message store must be provided');\n    }\n    if (!this._dbOptions) {\n      throw new Error('There is no options provided for the database');\n    }\n\n    const result = await this._swarmMessageStore?.openDatabase(this._dbOptions);\n\n    if (result instanceof Error) {\n      throw new Error(`Failed top open the database: ${result.message}`);\n    }\n  }\n\n  protected _getSwarmMessagesCacheOptions(): ISwarmMessagesDatabaseCacheOptions<\n    P,\n    DbType\n  > {\n    if (!this._dbType) {\n      throw new Error('Failed to defined database type');\n    }\n    return {\n      dbInstance: this,\n      dbType: this._dbType,\n    };\n  }\n\n  protected async _startSwarmMessagesCache(): Promise<void> {\n    const SwarmMessagesCacheConstructor =\n      this._cacheOptions?.cacheConstructor || SwarmMessagesDatabaseCache;\n    const swarmMessagesCacheOptions = this._getSwarmMessagesCacheOptions();\n    const swarmMessagesCache = new SwarmMessagesCacheConstructor(\n      swarmMessagesCacheOptions\n    );\n\n    await swarmMessagesCache.start();\n    this._swarmMessagesCache = swarmMessagesCache;\n  }\n\n  protected _unsetOptions(): void {\n    this._dbName = undefined;\n    this._dbOptions = undefined;\n    this._dbType = undefined;\n    this._currentUserOptons = undefined;\n  }\n\n  protected _unsetThisInstanceListeners(): void {\n    this._emitter.removeAllListeners();\n  }\n\n  protected _unsetSwarmStoreListeners() {\n    this._setListeners(false);\n  }\n\n  protected _unsetSwarmMessageStoreInstance(): void {\n    this._unsetSwarmStoreListeners();\n    this._swarmMessageStore = undefined;\n  }\n\n  /**\n   * Close the database\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabase\n   */\n  protected async _handleDatabaseClosed() {\n    this._unsetIsReady();\n    this._unsetOptions();\n    this._unsetThisInstanceListeners();\n    this._unsetSwarmMessageStoreInstance();\n  }\n\n  protected async _closeSwarmDatabaseInstance(): Promise<void> {\n    if (!this._checkDatabaseProps()) {\n      throw new Error('Database props are not valid');\n    }\n    const dbName = this._dbName;\n    const result = await this._swarmMessageStore.closeDatabase(dbName);\n\n    if (result instanceof Error) {\n      throw new Error(\n        `Failed to close the database ${dbName}: ${result.message}`\n      );\n    }\n  }\n\n  protected _closeSwarmMessagesCahceInstance(): Promise<void> {\n    if (!this._swarmMessagesCache) {\n      throw new Error('There is no active instance for caching swarm messages');\n    }\n    return this._swarmMessagesCache.close();\n  }\n\n  protected async _dropSwarmDatabaseInstance() {\n    if (!this._checkDatabaseProps()) {\n      throw new Error('Database props are not valid');\n    }\n\n    const dbName = this._dbName;\n    const result = await this._swarmMessageStore?.dropDatabase(dbName);\n\n    if (result instanceof Error) {\n      throw new Error(\n        `Failed to drop the database ${dbName}: ${result.message}`\n      );\n    }\n  }\n\n  /**\n   * Handle what to do with a cache of the messages\n   * if a new message added to the storage.\n   *\n   * @protected\n   * @param {ISwarmMessageInstanceDecrypted} message\n   * @param {TSwarmStoreDatabaseEntityUniqueAddress<P>} messageAddress\n   * @param {string} [key]\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _handleCacheUpdateOnNewMessage(\n    message: ISwarmMessageInstanceDecrypted,\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ) {\n    if (this._checkIsReady()) {\n      this._addMessageToCache(this._dbName, message, messageAddress, key);\n    }\n  }\n\n  /**\n   * Performing the swarm messages cache updating\n   * on message removed from the databse.\n   *\n   * @protected\n   * @param {TSwarmMessageUserIdentifierSerialized} userID\n   * @param {TSwarmStoreDatabaseEntityUniqueAddress<P>} messageAddress\n   * @param {string} [keyOrHash]\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _handleCacheUpdateOnDeleteMessage(\n    userID: TSwarmMessageUserIdentifierSerialized,\n    // the global unique address (hash) of the DELETE message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // deleted message address\n    messageDeletedAddress: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n      : TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key for the value,\n    // for feed store it will be hash of the message which deleted by this one.\n    keyOrHash: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityKey<P>\n      : undefined\n  ) {\n    if (this._checkIsReady()) {\n      this._removeMessageFromCache(messageDeletedAddress, keyOrHash);\n    }\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database.types.ts",["2524","2525"],"/home/paul/projects/protocol/src/components/message-component/index.ts",[],"/home/paul/projects/protocol/src/components/message-component/message-component.tsx",[],"/home/paul/projects/protocol/src/components/swarm-messages-database-component/index.ts",[],"/home/paul/projects/protocol/src/components/swarm-messages-database-component/swarm-messages-database-component.tsx",["2526","2527","2528","2529"],"import React from 'react';\nimport { IConnectionBridge } from 'classes/connection-bridge/connection-bridge.types';\nimport { ISwarmStoreDatabaseBaseOptions } from 'classes/swarm-store-class/swarm-store-class.types';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../../classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY } from '../connect-to-swarm/connect-to-swarm.const';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseOptions,\n  ESwarmStoreConnectorOrbitDbDatabaseIteratorOption,\n} from '../../classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { MessageComponent } from '../message-component/message-component';\nimport {\n  connectToDatabase,\n  setMessageListener,\n} from './swarm-messages-database-component.utils';\nimport { ESwarmStoreConnector } from '../../classes/swarm-store-class/swarm-store-class.const';\nimport { SwarmMessagesDatabase } from '../../classes/swarm-messages-database';\nimport {\n  TSwarmStoreDatabaseEntityKey,\n  TSwarmStoreDatabaseType,\n  TSwarmStoreValueTypes,\n} from '../../classes/swarm-store-class/swarm-store-class.types';\nimport {\n  ISwarmMessagesDatabaseMessageDescription,\n  ISwarmMessagesDatabaseDeleteMessageDescription,\n} from './swarm-messages-database-component.types';\nimport { ISwarmMessageInstanceDecrypted } from '../../classes/swarm-message/swarm-message-constructor.types';\nimport { ISwarmMessageStoreDeleteMessageArg } from '../../classes/swarm-message-store/swarm-message-store.types';\nimport {\n  setMessageDeleteListener,\n  setCacheUpdateListener,\n} from './swarm-messages-database-component.utils';\nimport { TSwarmMessageDatabaseMessagesCached } from '../../classes/swarm-messages-database/swarm-messages-database.types';\nimport { isValidSwarmMessageDecryptedFormat } from '../../classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-swarm-message';\nimport { TSwarmMessageUserIdentifierSerialized } from '../../classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\n\ninterface IProps {\n  userId: TSwarmMessageUserIdentifierSerialized;\n  databaseOptions: ISwarmStoreDatabaseBaseOptions;\n  connectionBridge?: IConnectionBridge;\n  isOpenImmediate?: boolean;\n}\n\ninterface IState<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>\n> {\n  messages: TSwarmMessageDatabaseMessagesCached<P, DbType> | undefined;\n  isOpening: boolean;\n  isClosing: boolean;\n  db?: SwarmMessagesDatabase<P, T, DbType>;\n}\n\nexport class SwarmMessagesDatabaseComponent<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>\n> extends React.PureComponent<IProps, IState<P, T, DbType>> {\n  state: IState<P, T, DbType> = {\n    messages: undefined,\n    isOpening: false,\n    isClosing: false,\n    db: undefined as SwarmMessagesDatabase<P, T, DbType> | undefined,\n  };\n\n  get isOpened(): boolean {\n    const { isOpening, isClosing, db } = this.state;\n\n    return !isOpening && !isClosing && !!db;\n  }\n\n  get isUpdating(): boolean {\n    return !!this.state.db?.whetherMessagesListUpdateInProgress;\n  }\n\n  get messagesCached():\n    | TSwarmMessageDatabaseMessagesCached<P, DbType>\n    | undefined {\n    return this.state.db?.cachedMessages;\n  }\n\n  queryDatabase = async () => {\n    const { db } = this.state;\n\n    if (db) {\n      const result = await db.collect({\n        [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.limit]: -1,\n      } as any);\n      console.log(result);\n    }\n  };\n\n  queryDatabaseMessagesWithMeta = async () => {\n    const { db } = this.state;\n\n    if (db) {\n      const result = await db.collectWithMeta({\n        [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.limit]: -1,\n      } as any);\n      console.log(result);\n    }\n  };\n\n  onNewMessage = (\n    message: ISwarmMessagesDatabaseMessageDescription<P>\n  ): void => {\n    console.log('New message', message);\n  };\n\n  onMessageDelete = (\n    deleteMessageDescription: ISwarmMessagesDatabaseDeleteMessageDescription<P>\n  ) => {\n    console.log('Message removed', deleteMessageDescription);\n  };\n\n  onMessagesCacheUpdated = (\n    messages: TSwarmMessageDatabaseMessagesCached<P, DbType> | undefined\n  ) => {\n    console.log('Cache updated', messages);\n    this.setState({\n      messages,\n    });\n  };\n\n  handleDbClose = async () => {\n    const { connectionBridge } = this.props;\n    const { isClosing, db } = this.state;\n\n    if (connectionBridge && db && this.isOpened && !isClosing) {\n      try {\n        this.setState({ isClosing: true });\n        await db.close();\n        this.setState({ db: undefined });\n      } catch (err) {\n        console.error(err);\n      } finally {\n        this.setState({ isClosing: false });\n      }\n    }\n  };\n\n  handleDbOpen = async () => {\n    const { connectionBridge, databaseOptions } = this.props;\n    const { isOpening } = this.state;\n\n    if (\n      connectionBridge &&\n      connectionBridge.storage &&\n      !this.isOpened &&\n      !isOpening\n    ) {\n      try {\n        this.setState({ isOpening: true });\n\n        const dbOptions = {\n          ...databaseOptions,\n          grantAccess: async (...args: any[]) => {\n            console.log(...args);\n            return true;\n          },\n        };\n        const db = (await connectToDatabase({\n          dbOptions,\n          swarmMessageStore: connectionBridge.storage,\n          user: {\n            userId: this.props.userId,\n          },\n        })) as any;\n\n        setMessageListener(db, this.onNewMessage);\n        setMessageDeleteListener(db, this.onMessageDelete);\n        setCacheUpdateListener(db, this.onMessagesCacheUpdated);\n        this.setState({ db });\n      } catch (err) {\n        console.error(err);\n      } finally {\n        this.setState({ isOpening: false });\n      }\n    }\n  };\n\n  handleDeleteMessage = async (\n    id: TSwarmStoreDatabaseEntityKey<P>,\n    message: ISwarmMessageInstanceDecrypted,\n    key: string | undefined\n  ): Promise<void> => {\n    const { db } = this.state;\n    let removeArg:\n      | TSwarmStoreDatabaseEntityKey<P>\n      | string\n      | ISwarmMessageInstanceDecrypted\n      | undefined;\n\n    if (this.isOpened && db?.isReady) {\n      const { dbType } = db;\n\n      if (dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE) {\n        if (!key) {\n          throw new Error(\n            'For key-value database type a key must be provided to delete a message'\n          );\n        }\n        removeArg = key;\n      } else if (db.dbType === ESwarmStoreConnectorOrbitDbDatabaseType.FEED) {\n        removeArg = id;\n      } else {\n        removeArg = message;\n      }\n      return db.deleteMessage(\n        removeArg as ISwarmMessageStoreDeleteMessageArg<P>\n      );\n    }\n  };\n\n  protected sendSwarmMessage = async () => {\n    const { databaseOptions } = this.props;\n    const { db } = this.state;\n\n    try {\n      if (this.isOpened && db) {\n        if (!databaseOptions.isPublic) {\n          alert('It is not a public database');\n          return;\n        }\n\n        let key: string | undefined;\n\n        if (\n          (databaseOptions as ISwarmStoreConnectorOrbitDbDatabaseOptions<\n            string\n          >).dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n        ) {\n          key = prompt('Key for the message', '') || undefined;\n          if (!key) {\n            return;\n          }\n        }\n\n        const message = prompt('Message', '');\n\n        await db.addMessage(\n          {\n            ...CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY,\n            pld: message || '',\n          },\n          key as TSwarmStoreDatabaseEntityKey<P> | undefined\n        );\n      }\n    } catch (err) {\n      console.error(err);\n      alert(err.message);\n    }\n  };\n\n  componentDidMount() {\n    const { isOpenImmediate } = this.props;\n\n    if (isOpenImmediate) {\n      this.handleDbOpen();\n    }\n  }\n\n  render() {\n    const { isOpening, isClosing } = this.state;\n    const { databaseOptions } = this.props;\n    const { isOpened, isUpdating } = this;\n    const { dbName, isPublic } = databaseOptions;\n    // TODO - this.messagesCached doesn't work\n    const { messages } = this.state;\n\n    return (\n      <div style={{ border: '1px solid black' }}>\n        Database: {dbName}, {isOpened ? 'opened' : 'closed'},{' '}\n        {isPublic ? 'is public' : ''}, {isOpening && 'is opening'},{' '}\n        {isClosing && 'is closing'};\n        <br />\n        {isOpened ? (\n          <button onClick={this.handleDbClose}>Close</button>\n        ) : (\n          <button onClick={this.handleDbOpen}>Open</button>\n        )}\n        <br />\n        {isOpened && (\n          <button onClick={this.sendSwarmMessage}>Send message</button>\n        )}\n        {isUpdating && <div>Updating...</div>}\n        <div>\n          Messages:\n          {messages &&\n            Array.from(messages.entries()).map(([key, messageWithMeta]) => {\n              const {\n                messageAddress,\n                dbName: messageDbName,\n                message,\n              } = messageWithMeta;\n              let messageId = '';\n\n              if (message instanceof Error) {\n                return <div>Error: {message.message}</div>;\n              }\n              try {\n                if (!isValidSwarmMessageDecryptedFormat(message)) {\n                  return <div>Message has an invalid format</div>;\n                }\n              } catch (err) {\n                return <div>Error message format: {err.message}</div>;\n              }\n              if (messageAddress instanceof Error) {\n                messageId = messageAddress.message;\n              } else if (messageAddress) {\n                messageId = messageAddress;\n              }\n              return (\n                <MessageComponent\n                  key={key}\n                  dbName={messageDbName || dbName}\n                  id={messageId as TSwarmStoreDatabaseEntityKey<P>}\n                  k={key}\n                  message={message}\n                  deleteMessage={this.handleDeleteMessage}\n                />\n              );\n            })}\n        </div>\n      </div>\n    );\n  }\n}\n","/home/paul/projects/protocol/src/components/swarm-messages-database-component/swarm-messages-database-component.types.ts",[],"/home/paul/projects/protocol/src/components/swarm-messages-database-component/swarm-messages-database-component.utils.ts",["2530"],"import { SwarmMessagesDatabase } from '../../classes/swarm-messages-database/swarm-messages-database';\nimport { ESwarmStoreConnector } from '../../classes/swarm-store-class/swarm-store-class.const';\nimport {\n  ISwarmMessagesDatabaseConnectOptions,\n  TSwarmMessageDatabaseMessagesCached,\n} from '../../classes/swarm-messages-database/swarm-messages-database.types';\nimport { ISwarmMessageInstanceDecrypted } from '../../classes/swarm-message/swarm-message-constructor.types';\nimport {\n  ISwarmMessagesDatabaseMessageDescription,\n  ISwarmMessagesDatabaseDeleteMessageDescription,\n} from './swarm-messages-database-component.types';\nimport { ESwarmMessageStoreEventNames } from '../../classes/swarm-message-store/swarm-message-store.const';\nimport { ESwarmMessagesDatabaseCacheEventsNames } from '../../classes/swarm-messages-database/swarm-messages-database.const';\nimport {\n  TSwarmStoreValueTypes,\n  TSwarmStoreDatabaseType,\n  TSwarmStoreDatabaseEntityKey,\n  TSwarmStoreDatabaseEntityAddress,\n  TSwarmStoreDatabaseEntityUniqueIndex,\n} from '../../classes/swarm-store-class/swarm-store-class.types';\n\nexport const connectToDatabase = async <\n  P extends ESwarmStoreConnector = ESwarmStoreConnector.OrbitDB,\n  V extends TSwarmStoreValueTypes<P> = TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P> = TSwarmStoreDatabaseType<P>\n>(\n  options: ISwarmMessagesDatabaseConnectOptions<P, V, DbType>\n): Promise<SwarmMessagesDatabase<P, V, DbType>> => {\n  const db = new SwarmMessagesDatabase<P, V, DbType>();\n\n  await db.connect(options);\n  return db;\n};\n\nexport const setMessageListener = <\n  P extends ESwarmStoreConnector = ESwarmStoreConnector.OrbitDB,\n  V extends TSwarmStoreValueTypes<P> = TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P> = TSwarmStoreDatabaseType<P>,\n  T extends SwarmMessagesDatabase<P, V, DbType> = SwarmMessagesDatabase<\n    ESwarmStoreConnector.OrbitDB,\n    V,\n    DbType\n  >\n>(\n  db: T,\n  messagesListener: (\n    message: ISwarmMessagesDatabaseMessageDescription<P>\n  ) => void\n): (() => void) => {\n  const listener = (\n    dbName: string,\n    message: ISwarmMessageInstanceDecrypted,\n    // the global unique address of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ) => {\n    messagesListener({\n      message,\n      id: messageAddress,\n      key,\n    });\n  };\n  db.emitter.addListener(ESwarmMessageStoreEventNames.NEW_MESSAGE, listener);\n  return () => {\n    db.emitter.removeListener(\n      ESwarmMessageStoreEventNames.NEW_MESSAGE,\n      listener\n    );\n  };\n};\n\nexport const setMessageDeleteListener = <\n  P extends ESwarmStoreConnector = ESwarmStoreConnector.OrbitDB,\n  V extends TSwarmStoreValueTypes<P> = TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P> = TSwarmStoreDatabaseType<P>,\n  T extends SwarmMessagesDatabase<P, V, DbType> = SwarmMessagesDatabase<\n    ESwarmStoreConnector.OrbitDB,\n    V,\n    DbType\n  >\n>(\n  db: T,\n  messagesDeleteListener: (\n    message: ISwarmMessagesDatabaseDeleteMessageDescription<P>\n  ) => void\n): (() => void) => {\n  const listener = (\n    dbName: string,\n    // the user who removed the message\n    userId: string,\n    // the global unique address (hash) of the DELETE message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // the global unique address (hash) of the DELETED message in the swarm\n    messageDeletedAddress: TSwarmStoreDatabaseEntityAddress<P> | undefined,\n    // for key-value store it will be the key for the value,\n    // for feed store it will be hash of the message which deleted by this one.\n    key: TSwarmStoreDatabaseEntityKey<P> | undefined\n  ) => {\n    messagesDeleteListener({\n      id: messageAddress,\n      idDeleted: messageDeletedAddress,\n      key,\n      userId,\n    });\n  };\n\n  db.emitter.addListener(ESwarmMessageStoreEventNames.DELETE_MESSAGE, listener);\n  return () =>\n    db.emitter.removeListener(\n      ESwarmMessageStoreEventNames.DELETE_MESSAGE,\n      listener\n    );\n};\n\nexport const setCacheUpdateListener = <\n  P extends ESwarmStoreConnector = ESwarmStoreConnector.OrbitDB,\n  V extends TSwarmStoreValueTypes<P> = TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P> = TSwarmStoreDatabaseType<P>,\n  T extends SwarmMessagesDatabase<P, V, DbType> = SwarmMessagesDatabase<\n    ESwarmStoreConnector.OrbitDB,\n    V,\n    DbType\n  >\n>(\n  db: T,\n  cacheUpdateListener: (\n    messages: TSwarmMessageDatabaseMessagesCached<P, DbType> | undefined\n  ) => unknown\n) => {\n  const listener = (\n    messages: TSwarmMessageDatabaseMessagesCached<P, DbType> | undefined\n  ) => {\n    debugger;\n    cacheUpdateListener(messages);\n  };\n  db.emitter.addListener(\n    ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATED,\n    listener\n  );\n  return () =>\n    db.emitter.removeListener(\n      ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATED,\n      listener\n    );\n};\n","/home/paul/projects/protocol/src/components/swarm-store-db-component/index.ts",[],"/home/paul/projects/protocol/src/components/swarm-store-db-component/swarm-store-db-component.tsx",["2531"],"import React from 'react';\nimport { IConnectionBridge } from 'classes/connection-bridge/connection-bridge.types';\nimport { ISwarmStoreDatabaseBaseOptions } from 'classes/swarm-store-class/swarm-store-class.types';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../../classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY } from '../connect-to-swarm/connect-to-swarm.const';\nimport { ISwarmStoreConnectorOrbitDbDatabaseOptions } from '../../classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { MessageComponent } from '../message-component/message-component';\nimport { IMessageDescription } from '../connect-to-swarm/connect-to-swarm';\n\ninterface IProps {\n  databaseOptions: ISwarmStoreDatabaseBaseOptions;\n  isOpened: boolean;\n  connectionBridge?: IConnectionBridge;\n  messages: IMessageDescription[];\n}\n\nexport class SwarmStoreDbComponent extends React.PureComponent<IProps> {\n  state = {\n    isOpening: false as boolean,\n    isClosing: false as boolean,\n  };\n\n  handleDbClose = async () => {\n    const { connectionBridge, databaseOptions, isOpened } = this.props;\n    const { isClosing } = this.state;\n\n    if (connectionBridge && isOpened && !isClosing) {\n      try {\n        this.setState({ isClosing: true });\n        await connectionBridge.storage?.closeDatabase(databaseOptions.dbName);\n      } catch (err) {\n        console.error(err);\n      } finally {\n        this.setState({ isClosing: false });\n      }\n    }\n  };\n\n  handleDbOpen = async () => {\n    const { connectionBridge, databaseOptions, isOpened } = this.props;\n    const { isOpening } = this.state;\n\n    if (connectionBridge && !isOpened && !isOpening) {\n      try {\n        this.setState({ isOpening: true });\n        await connectionBridge.storage?.openDatabase({\n          ...databaseOptions,\n          grantAccess: async (...args: any[]) => {\n            console.log(...args);\n            return true;\n          },\n        });\n      } catch (err) {\n        console.error(err);\n      } finally {\n        this.setState({ isOpening: false });\n      }\n    }\n  };\n\n  protected sendSwarmMessage = async () => {\n    const { connectionBridge, databaseOptions, isOpened } = this.props;\n    try {\n      if (isOpened && connectionBridge) {\n        if (!databaseOptions.isPublic) {\n          alert('It is not a public database');\n          return;\n        }\n\n        let key: string | undefined;\n\n        if (\n          (databaseOptions as ISwarmStoreConnectorOrbitDbDatabaseOptions<\n            string\n          >).dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n        ) {\n          key = prompt('Key for the message', '') || undefined;\n          if (!key) {\n            return;\n          }\n        }\n\n        const message = prompt('Message', '');\n\n        await connectionBridge?.storage?.addMessage(\n          databaseOptions.dbName,\n          {\n            ...CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY,\n            pld: message || '',\n          },\n          key\n        );\n      }\n    } catch (err) {\n      console.error(err);\n      alert(err.message);\n    }\n  };\n\n  render() {\n    const { isOpening, isClosing } = this.state;\n    const { databaseOptions, isOpened, messages } = this.props;\n    const { dbName, isPublic } = databaseOptions;\n\n    return (\n      <div style={{ border: '1px solid black' }}>\n        Database: {dbName}, {isOpened ? 'opened' : 'closed'},{' '}\n        {isPublic ? 'is public' : ''}, {isOpening && 'is opening'},{' '}\n        {isClosing && 'is closing'};\n        <br />\n        {isOpened ? (\n          <button onClick={this.handleDbClose}>Close</button>\n        ) : (\n          <button onClick={this.handleDbOpen}>Open</button>\n        )}\n        <br />\n        {isOpened && (\n          <button onClick={this.sendSwarmMessage}>Send message</button>\n        )}\n        <div>\n          Messages:\n          {messages.map((message) => {\n            return (\n              <MessageComponent\n                key={message.id}\n                dbName={dbName}\n                id={message.id}\n                k={message.key}\n                message={message.message}\n              />\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/event-emitter-class-base/event-emitter-class-base.types.ts",["2532"],"import EEmitter from 'events';\nimport TypedEmitter from 'strict-event-emitter-types';\n\nexport type TTypedEmitter<IEvents extends Record<string, any>> = TypedEmitter<\n  EEmitter,\n  IEvents\n>;\n","/home/paul/projects/protocol/src/classes/storage-providers/storage-in-memory-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-in-memory-provider/storage-in-memory-provider.ts",["2533"],"import assert from 'assert';\n\nimport { isTypedArrayNative } from 'utils/typed-array-utils';\n\nimport {\n  StorageProvider,\n  IStorageProviderOptions,\n} from '../storage-providers.types';\nimport { TStorageInMemory } from './storage-in-memory-provider.types';\n\nexport class StorageProviderInMemory<V = any> extends StorageProvider<V> {\n  public static isBufferSupported = true;\n\n  private _isConnected: boolean = false;\n\n  private _options?: IStorageProviderOptions;\n\n  private _storage?: TStorageInMemory<V>;\n\n  public async connect(\n    options?: IStorageProviderOptions\n  ): Promise<true | Error> {\n    try {\n      if (!this._isConnected) {\n        this._storage = new Map();\n        this._setOptions(options);\n        this._setIsConnected();\n      }\n      return true;\n    } catch (err) {\n      console.error('SecretStorageProviderLevelJS', err);\n      return err;\n    }\n  }\n\n  public async disconnect(): Promise<true | Error> {\n    try {\n      if (this._isConnected) {\n        this._unsetOptions();\n        this._unsetDb();\n        this._unsetIsConnected();\n      }\n      return true;\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public async set(key: string, value?: V | Uint8Array): Promise<Error | true> {\n    if (!value) {\n      return this.unset(key);\n    }\n    try {\n      this._checkIsReady();\n      this._storage?.set(key, value as V);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async unset(key: string): Promise<Error | true> {\n    try {\n      this._checkIsReady();\n      this._storage?.delete(key);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async clearDb(): Promise<Error | boolean> {\n    try {\n      this._checkIsReady();\n      this._storage?.clear();\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * WARNING! If the value is empty\n   * it will be removed with the leveljs.del\n   *\n   * @param {string} key\n   * @param {string} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public setUInt8Array(key: string, value?: Uint8Array): Promise<Error | true> {\n    return this.set(key, value);\n  }\n\n  public async get(key: string): Promise<V | Error | undefined> {\n    try {\n      this._checkIsReady();\n      return this._storage?.get(key);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async getUInt8Array(\n    key: string\n  ): Promise<Error | Uint8Array | undefined> {\n    try {\n      this._checkIsReady();\n\n      const item = await this.get(key);\n\n      if (item instanceof Error) {\n        throw item;\n      }\n      if (Array.isArray(item) || isTypedArrayNative(item)) {\n        return new Uint8Array(item);\n      }\n      if (item) {\n        throw new Error('The entiry is not related to Uint8Array');\n      }\n      return undefined;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected _setOptions(options?: IStorageProviderOptions): void {\n    if (options) {\n      assert(\n        options && typeof options !== 'object',\n        'Options must be an object'\n      );\n      this._options = options;\n    }\n  }\n\n  protected _setIsConnected() {\n    this._isConnected = true;\n  }\n\n  protected _unsetIsConnected() {\n    this._isConnected = false;\n  }\n\n  protected _unsetOptions() {\n    this._options = undefined;\n  }\n\n  protected _unsetDb() {\n    this._storage = undefined;\n  }\n\n  protected _checkIsReady(): this is { _storage: TStorageInMemory<V> } {\n    assert(this._isConnected, 'The instance is disconnected');\n    assert(this._storage instanceof Map, 'Storage is not initialized');\n    return true;\n  }\n}\n","/home/paul/projects/protocol/src/classes/storage-providers/storage-in-memory-provider/storage-in-memory-provider.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database.const.ts",[],"/home/paul/projects/protocol/src/utils/throttling-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/index.ts",[],"/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/throttling-utils-idle-callback.const.ts",[],"/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/throttling-utils-idle-callback.ts",["2534","2535"],"import { THROTTLING_UTILS_IDLE_CALLBACK_TIMEOUT_DEFAULT_MS } from './throttling-utils-idle-callback.const';\nimport {\n  RequestIdleCallback,\n  CancelRequestIdleCallback,\n  RequestIdleCallbackArgument,\n} from './throttling-utils-idle-callback.types';\n\nexport const getRequestIdleCallback = (): RequestIdleCallback =>\n  (window as any).requestIdleCallback ||\n  function(cb) {\n    return setTimeout(function() {\n      const start = Date.now();\n      cb({\n        didTimeout: false,\n        timeRemaining: function() {\n          return Math.max(0, 50 - (Date.now() - start));\n        },\n      });\n    }, 1);\n  };\n\nexport const getCancelRequestIdleCallback = (): CancelRequestIdleCallback =>\n  (window as any).cancelIdleCallback ||\n  function(id: number) {\n    clearTimeout(id);\n  };\n\nexport const resolveOnIdleCallback = (\n  timeoutMs: number = THROTTLING_UTILS_IDLE_CALLBACK_TIMEOUT_DEFAULT_MS\n): Promise<{\n  timeRemaining: number;\n  didTimeout: boolean;\n}> =>\n  new Promise((res) => {\n    const requestIdleCallback = getRequestIdleCallback();\n    const idleCallback = requestIdleCallback(\n      (e: RequestIdleCallbackArgument) => {\n        const timeRemaining = Number(e.timeRemaining && e.timeRemaining());\n        res({\n          timeRemaining,\n          didTimeout: !!e.didTimeout,\n        });\n        getCancelRequestIdleCallback()(idleCallback);\n      },\n      { timeout: timeoutMs }\n    );\n  });\n","/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/throttling-utils-idle-callback.types.ts",["2536"],"export interface RequestIdleCallbackArgument {\n  didTimeout?: boolean;\n  timeRemaining?(): number;\n}\n\nexport interface RequestIdleCallbackOptions {\n  timeout?: number;\n}\n\nexport type RequestIdleCallbackId = number;\n\nexport interface RequestIdleCallback {\n  (\n    cb: (deadline: RequestIdleCallbackArgument) => any,\n    options?: RequestIdleCallbackOptions\n  ): RequestIdleCallbackId;\n}\n\nexport interface CancelRequestIdleCallback {\n  (id: RequestIdleCallbackId): void;\n}\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.ts",["2537","2538","2539"],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-message-with-meta.ts",["2540"],"import assert from 'assert';\nimport { ISwarmMessageStoreMessageWithMeta } from '../../swarm-message-store.types';\nimport { ESwarmStoreConnector } from '../../../swarm-store-class/swarm-store-class.const';\nimport { isValidSwarmMessageDecryptedFormat } from './swarm-message-store-validator-swarm-message';\n\n/**\n * Validates swarm message with meta format\n *\n * @export\n * @template P\n * @param {ISwarmMessageStoreMessageWithMeta<P>} swarmMessageWithMeta\n * @returns {true}\n * @throws - is format is not valid\n */\nexport function validateSwarmMessageWithMeta<P extends ESwarmStoreConnector>(\n  swarmMessageWithMeta: any\n): swarmMessageWithMeta is ISwarmMessageStoreMessageWithMeta<P> {\n  if (!swarmMessageWithMeta) {\n    alert('No swarm message with meta');\n    debugger;\n  }\n  assert(!!swarmMessageWithMeta, 'Swarm message with meta is not defined');\n  assert(\n    typeof swarmMessageWithMeta === 'object',\n    'Swarm message with meta should be an object'\n  );\n  assert(!!swarmMessageWithMeta.dbName, 'A databse name should not be empty');\n  assert(\n    typeof swarmMessageWithMeta.dbName === 'string',\n    'A database name should be a string'\n  );\n  assert(\n    !!swarmMessageWithMeta.messageAddress,\n    'A message address should not be empty'\n  );\n  assert(\n    typeof swarmMessageWithMeta.messageAddress === 'string',\n    'A message address should not be empty'\n  );\n  if (swarmMessageWithMeta.key) {\n    assert(\n      typeof swarmMessageWithMeta.key === 'string',\n      'Swarm message key should be a string'\n    );\n  }\n  isValidSwarmMessageDecryptedFormat(swarmMessageWithMeta.message);\n  return true;\n}\n","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-swarm-message.ts",["2541","2542","2543"],"import assert from 'assert';\nimport {\n  ISwarmMessageInstanceDecrypted,\n  ISwarmMessageEncrypted,\n  TSwarmMessageInstance,\n} from '../../../swarm-message/swarm-message-constructor.types';\nimport SwarmMessageSubclassFieldsValidator from '../../../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator';\n\nconst swarmMessageFieldsValidator = new SwarmMessageSubclassFieldsValidator();\n\n/**\n * Validates swarm message decrypted instance format\n *\n * @export\n * @param {ISwarmMessageInstanceDecrypted} message\n * @returns {true}\n * @throws - throw error if format is not valid\n */\nexport function isValidSwarmMessageDecryptedFormat(\n  message: any\n): message is ISwarmMessageInstanceDecrypted {\n  assert(!!message, 'Swarm message should be defined');\n  assert(\n    typeof message.bdy === 'object',\n    'Body of a decrypted message should be an object'\n  );\n  swarmMessageFieldsValidator.validateMessage(message);\n  return true;\n}\n\n/**\n * Validates swarm message encrypted instance format\n *\n * @export\n * @param {ISwarmMessageInstanceDecrypted} message\n * @returns {true}\n * @throws - throw an error if format is not valid\n */\nexport function isValidSwarmMessageEncryptedFormat(\n  message: any\n): message is ISwarmMessageEncrypted {\n  assert(!!message, 'Swarm message should be defined');\n  assert(\n    typeof message.bdy === 'string',\n    'Body of an encrypted message should be a string'\n  );\n  swarmMessageFieldsValidator.validateMessage(message);\n  return true;\n}\n\n/**\n * Validate is swarm message encrypted or decrypted has a valid format\n *\n * @export\n * @param {*} message\n * @returns {true}\n * @throws - if a message hasn't a valid format\n */\nexport function isValidSwarmMessageEncryptedOrDescryptedFormat(\n  message: any\n): message is TSwarmMessageInstance {\n  assert(!!message, 'Swarm message should be defined');\n  assert(\n    typeof message.bdy === 'string',\n    'Body of an encrypted message should be a string'\n  );\n  swarmMessageFieldsValidator.validateMessage(message);\n  return true;\n}\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-classes.ts",["2544","2545"],"import { ConstructorType } from 'types/helper.types';\n\nexport const isConstructor = (v: any): v is ConstructorType<any> => {\n  return (\n    typeof v === 'function' &&\n    typeof v.prototype?.constructor?.name === 'string'\n  );\n};\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-maps.ts",["2546","2547","2548","2549","2550"],"export function filterMapKeys<M extends Map<any, any>, F extends Array<any>>(\n  map: M,\n  filterKeys: F\n): M {\n  if (!filterKeys.length) {\n    return map;\n  }\n\n  const filteredMap = new Map() as M;\n\n  for (const [key, value] of map) {\n    if (!filterKeys.includes(key)) {\n      filteredMap.set(key, value);\n    }\n  }\n  return filteredMap;\n}\n\n/**\n * Merge all maps into the target\n *\n * @export\n * @template M\n * @param {M} mapTarget\n * @param {...M[]} maps\n * @returns {M}\n */\nexport function concatMaps<M extends Map<any, any>>(\n  mapTarget: M,\n  ...maps: M[]\n): M {\n  const mergedMap = mapTarget;\n\n  for (let idx = 0, len = maps.length; idx < len; idx += 1) {\n    const map = maps[idx];\n    let entry;\n    for (entry of map) {\n      mergedMap.set(entry[0], entry[1]);\n    }\n  }\n  return mergedMap;\n}\n","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-memoization.ts",["2551","2552","2553","2554","2555"],"import { FirstPrameter } from '../../types';\nimport { commonUtilsAreAllArraysEqual } from '../common-utils';\nimport { mapValuesForFurtherComparision } from './data-cache-utils-main';\n\nexport const memoize = <\n  F extends (arg: any) => any,\n  A extends FirstPrameter<F>,\n  R extends ReturnType<F>\n>(\n  functionToMemoize: F\n): ((arg: A) => R) => {\n  const cachedResults = new Map<A, R>();\n  const memoized = (a: A): R => {\n    const cachedResult = cachedResults.get(a);\n\n    if (cachedResult) {\n      return cachedResult;\n    }\n\n    const result = functionToMemoize(a);\n\n    cachedResults.set(a, result);\n    return result;\n  };\n\n  memoized.clean = () => cachedResults.clear();\n  return memoized;\n};\n\n/**\n * Returns a function which will return the same result\n * as the last one if the arguments are equals to the\n * arguments for the last result memoized.\n *\n * @template R\n * @template A\n * @template F\n * @param {F} func\n * @returns {(...arg: A) => R} - returns a function which only the last result will be memoized\n */\nexport const memoizeLastReturnedValue = <F extends (...arg: any[]) => any>(\n  func: F\n) => {\n  let lastArgs: any[];\n  let lastReturnValue: ReturnType<F>;\n\n  return (...args: Parameters<F>): ReturnType<F> => {\n    const argsMappedForComparision = mapValuesForFurtherComparision(args);\n\n    if (\n      !lastArgs ||\n      !commonUtilsAreAllArraysEqual(lastArgs, argsMappedForComparision)\n    ) {\n      lastArgs = argsMappedForComparision;\n      lastReturnValue = func(...args);\n    }\n    return lastReturnValue;\n  };\n};\n","/home/paul/projects/protocol/src/components/connect-to-swarm-immediate/connect-to-swarm-immediate.const.ts",[],"/home/paul/projects/protocol/src/components/connect-to-swarm-immediate/connect-to-swarm-immediate.tsx",[],"/home/paul/projects/protocol/src/components/connect-to-swarm-immediate/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.const.ts",[],"/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-main.ts",[],"/home/paul/projects/protocol/src/const/const-helpers.ts",[],"/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-main.ts",["2556","2557"],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-common/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-common/swarm-message-utils-common-decrypted.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store-subclasses/swarm-messages-database-messages-cached-store-core/swarm-messages-database-messages-cached-store-core.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store-subclasses/swarm-messages-database-messages-cached-store-feed/swarm-messages-database-messages-cached-store-feed.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store-subclasses/swarm-messages-database-messages-cached-store-keyvalue/swarm-messages-database-messages-cached-store-keyvalue.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.types.ts",["2558","2559","2560"],{"ruleId":null,"fatal":true,"severity":2,"message":"2561"},{"ruleId":null,"fatal":true,"severity":2,"message":"2562"},{"ruleId":null,"fatal":true,"severity":2,"message":"2563"},{"ruleId":null,"fatal":true,"severity":2,"message":"2564"},{"ruleId":"2565","severity":1,"message":"2566","line":16,"column":56,"nodeType":"2567","messageId":"2568","endLine":16,"endColumn":59},{"ruleId":"2565","severity":1,"message":"2566","line":18,"column":28,"nodeType":"2567","messageId":"2568","endLine":18,"endColumn":31},{"ruleId":"2565","severity":1,"message":"2566","line":34,"column":37,"nodeType":"2567","messageId":"2568","endLine":34,"endColumn":40},{"ruleId":"2565","severity":1,"message":"2566","line":45,"column":42,"nodeType":"2567","messageId":"2568","endLine":45,"endColumn":45},{"ruleId":"2565","severity":1,"message":"2566","line":84,"column":22,"nodeType":"2567","messageId":"2568","endLine":84,"endColumn":25},{"ruleId":"2565","severity":1,"message":"2566","line":88,"column":47,"nodeType":"2567","messageId":"2568","endLine":88,"endColumn":50},{"ruleId":"2565","severity":1,"message":"2566","line":89,"column":47,"nodeType":"2567","messageId":"2568","endLine":89,"endColumn":50},{"ruleId":"2565","severity":1,"message":"2566","line":59,"column":65,"nodeType":"2567","messageId":"2568","endLine":59,"endColumn":68},{"ruleId":"2565","severity":1,"message":"2566","line":69,"column":37,"nodeType":"2567","messageId":"2568","endLine":69,"endColumn":40},{"ruleId":"2565","severity":1,"message":"2566","line":4,"column":27,"nodeType":"2567","messageId":"2568","endLine":4,"endColumn":30},{"ruleId":"2565","severity":1,"message":"2566","line":4,"column":58,"nodeType":"2567","messageId":"2568","endLine":4,"endColumn":61},{"ruleId":"2565","severity":1,"message":"2566","line":8,"column":34,"nodeType":"2567","messageId":"2568","endLine":8,"endColumn":37},{"ruleId":"2569","severity":1,"message":"2570","line":87,"column":15,"nodeType":"2571","messageId":"2572","endLine":87,"endColumn":27},{"ruleId":"2573","severity":1,"message":"2574","line":58,"column":9,"nodeType":"2575","endLine":58,"endColumn":15},{"ruleId":"2565","severity":1,"message":"2566","line":76,"column":27,"nodeType":"2567","messageId":"2568","endLine":76,"endColumn":30},{"ruleId":"2565","severity":1,"message":"2566","line":77,"column":39,"nodeType":"2567","messageId":"2568","endLine":77,"endColumn":42},{"ruleId":"2569","severity":1,"message":"2570","line":109,"column":36,"nodeType":"2571","messageId":"2572","endLine":109,"endColumn":40},{"ruleId":"2565","severity":1,"message":"2566","line":141,"column":38,"nodeType":"2567","messageId":"2568","endLine":141,"endColumn":41},{"ruleId":"2573","severity":1,"message":"2576","line":38,"column":7,"nodeType":"2575","endLine":38,"endColumn":17},{"ruleId":"2577","severity":1,"message":"2578","line":69,"column":3,"nodeType":"2579","endLine":69,"endColumn":19},{"ruleId":"2580","severity":1,"message":"2581","line":69,"column":17,"nodeType":"2582","messageId":"2583"},{"ruleId":"2573","severity":1,"message":"2584","line":3,"column":3,"nodeType":"2575","endLine":3,"endColumn":41},{"ruleId":"2573","severity":1,"message":"2585","line":1,"column":10,"nodeType":"2575","endLine":1,"endColumn":39},{"ruleId":"2565","severity":1,"message":"2566","line":2,"column":7,"nodeType":"2567","messageId":"2568","endLine":2,"endColumn":10},{"ruleId":"2565","severity":1,"message":"2566","line":13,"column":12,"nodeType":"2567","messageId":"2568","endLine":13,"endColumn":15},{"ruleId":"2565","severity":1,"message":"2566","line":47,"column":28,"nodeType":"2567","messageId":"2568","endLine":47,"endColumn":31},{"ruleId":"2565","severity":1,"message":"2566","line":67,"column":28,"nodeType":"2567","messageId":"2568","endLine":67,"endColumn":31},{"ruleId":"2565","severity":1,"message":"2566","line":38,"column":58,"nodeType":"2567","messageId":"2568","endLine":38,"endColumn":61},{"ruleId":"2569","severity":1,"message":"2570","line":191,"column":14,"nodeType":"2571","messageId":"2572","endLine":191,"endColumn":47},{"ruleId":"2569","severity":1,"message":"2570","line":217,"column":26,"nodeType":"2571","messageId":"2572","endLine":217,"endColumn":76},{"ruleId":"2569","severity":1,"message":"2570","line":217,"column":26,"nodeType":"2571","messageId":"2572","endLine":217,"endColumn":75},{"ruleId":"2565","severity":1,"message":"2566","line":361,"column":17,"nodeType":"2567","messageId":"2568","endLine":361,"endColumn":20},{"ruleId":"2569","severity":1,"message":"2570","line":45,"column":14,"nodeType":"2571","messageId":"2572","endLine":45,"endColumn":19},{"ruleId":"2569","severity":1,"message":"2570","line":45,"column":14,"nodeType":"2571","messageId":"2572","endLine":45,"endColumn":18},{"ruleId":"2565","severity":1,"message":"2566","line":159,"column":29,"nodeType":"2567","messageId":"2568","endLine":159,"endColumn":32},{"ruleId":"2565","severity":1,"message":"2566","line":189,"column":29,"nodeType":"2567","messageId":"2568","endLine":189,"endColumn":32},{"ruleId":"2565","severity":1,"message":"2566","line":228,"column":33,"nodeType":"2567","messageId":"2568","endLine":228,"endColumn":36},{"ruleId":"2573","severity":1,"message":"2586","line":4,"column":10,"nodeType":"2575","endLine":4,"endColumn":30},{"ruleId":"2565","severity":1,"message":"2566","line":37,"column":32,"nodeType":"2567","messageId":"2568","endLine":37,"endColumn":35},{"ruleId":"2569","severity":1,"message":"2570","line":103,"column":13,"nodeType":"2571","messageId":"2572","endLine":103,"endColumn":23},{"ruleId":"2569","severity":1,"message":"2570","line":103,"column":13,"nodeType":"2571","messageId":"2572","endLine":103,"endColumn":22},{"ruleId":"2569","severity":1,"message":"2570","line":134,"column":13,"nodeType":"2571","messageId":"2572","endLine":134,"endColumn":23},{"ruleId":"2569","severity":1,"message":"2570","line":134,"column":13,"nodeType":"2571","messageId":"2572","endLine":134,"endColumn":22},{"ruleId":"2569","severity":1,"message":"2570","line":152,"column":30,"nodeType":"2571","messageId":"2572","endLine":152,"endColumn":40},{"ruleId":"2569","severity":1,"message":"2570","line":152,"column":30,"nodeType":"2571","messageId":"2572","endLine":152,"endColumn":39},{"ruleId":"2565","severity":1,"message":"2566","line":7,"column":18,"nodeType":"2567","messageId":"2568","endLine":7,"endColumn":21},{"ruleId":"2587","severity":1,"message":"2588","line":340,"column":21,"nodeType":"2589","messageId":"2590","endLine":349,"endColumn":16},{"ruleId":"2587","severity":1,"message":"2588","line":350,"column":22,"nodeType":"2589","messageId":"2590","endLine":353,"endColumn":16},{"ruleId":"2565","severity":1,"message":"2566","line":10,"column":19,"nodeType":"2567","messageId":"2568","endLine":10,"endColumn":22},{"ruleId":"2565","severity":1,"message":"2566","line":26,"column":19,"nodeType":"2567","messageId":"2568","endLine":26,"endColumn":22},{"ruleId":"2565","severity":1,"message":"2566","line":19,"column":58,"nodeType":"2567","messageId":"2568","endLine":19,"endColumn":61},{"ruleId":"2565","severity":1,"message":"2566","line":34,"column":13,"nodeType":"2567","messageId":"2568","endLine":34,"endColumn":16},{"ruleId":"2565","severity":1,"message":"2566","line":65,"column":13,"nodeType":"2567","messageId":"2568","endLine":65,"endColumn":16},{"ruleId":"2565","severity":1,"message":"2566","line":88,"column":15,"nodeType":"2567","messageId":"2568","endLine":88,"endColumn":18},{"ruleId":"2573","severity":1,"message":"2591","line":11,"column":3,"nodeType":"2575","endLine":11,"endColumn":23},{"ruleId":"2565","severity":1,"message":"2566","line":218,"column":30,"nodeType":"2567","messageId":"2568","endLine":218,"endColumn":33},{"ruleId":"2565","severity":1,"message":"2566","line":255,"column":28,"nodeType":"2567","messageId":"2568","endLine":255,"endColumn":31},{"ruleId":"2565","severity":1,"message":"2566","line":16,"column":62,"nodeType":"2567","messageId":"2568","endLine":16,"endColumn":65},{"ruleId":"2565","severity":1,"message":"2566","line":27,"column":22,"nodeType":"2567","messageId":"2568","endLine":27,"endColumn":25},{"ruleId":"2565","severity":1,"message":"2566","line":73,"column":22,"nodeType":"2567","messageId":"2568","endLine":73,"endColumn":25},{"ruleId":"2565","severity":1,"message":"2566","line":74,"column":38,"nodeType":"2567","messageId":"2568","endLine":74,"endColumn":41},{"ruleId":"2565","severity":1,"message":"2566","line":120,"column":22,"nodeType":"2567","messageId":"2568","endLine":120,"endColumn":25},{"ruleId":"2565","severity":1,"message":"2566","line":134,"column":38,"nodeType":"2567","messageId":"2568","endLine":134,"endColumn":41},{"ruleId":"2565","severity":1,"message":"2566","line":6,"column":16,"nodeType":"2567","messageId":"2568","endLine":6,"endColumn":19},{"ruleId":"2565","severity":1,"message":"2566","line":82,"column":38,"nodeType":"2567","messageId":"2568","endLine":82,"endColumn":41},{"ruleId":"2565","severity":1,"message":"2566","line":95,"column":28,"nodeType":"2567","messageId":"2568","endLine":95,"endColumn":31},{"ruleId":"2569","severity":1,"message":"2570","line":186,"column":54,"nodeType":"2571","messageId":"2572","endLine":186,"endColumn":62},{"ruleId":"2580","severity":1,"message":"2592","line":244,"column":41,"nodeType":"2582","messageId":"2583"},{"ruleId":"2569","severity":1,"message":"2570","line":257,"column":21,"nodeType":"2571","messageId":"2572","endLine":257,"endColumn":34},{"ruleId":"2569","severity":1,"message":"2570","line":450,"column":19,"nodeType":"2571","messageId":"2572","endLine":450,"endColumn":32},{"ruleId":"2569","severity":1,"message":"2570","line":454,"column":17,"nodeType":"2571","messageId":"2572","endLine":454,"endColumn":57},{"ruleId":"2569","severity":1,"message":"2570","line":454,"column":17,"nodeType":"2571","messageId":"2572","endLine":454,"endColumn":30},{"ruleId":"2569","severity":1,"message":"2570","line":460,"column":19,"nodeType":"2571","messageId":"2572","endLine":460,"endColumn":32},{"ruleId":"2569","severity":1,"message":"2570","line":468,"column":19,"nodeType":"2571","messageId":"2572","endLine":468,"endColumn":32},{"ruleId":"2569","severity":1,"message":"2570","line":473,"column":23,"nodeType":"2571","messageId":"2572","endLine":473,"endColumn":41},{"ruleId":"2569","severity":1,"message":"2570","line":483,"column":19,"nodeType":"2571","messageId":"2572","endLine":483,"endColumn":32},{"ruleId":"2565","severity":1,"message":"2566","line":83,"column":11,"nodeType":"2567","messageId":"2568","endLine":83,"endColumn":14},{"ruleId":"2580","severity":1,"message":"2593","line":43,"column":24,"nodeType":"2582","messageId":"2583"},{"ruleId":"2569","severity":1,"message":"2570","line":112,"column":36,"nodeType":"2571","messageId":"2572","endLine":112,"endColumn":45},{"ruleId":"2569","severity":1,"message":"2570","line":157,"column":33,"nodeType":"2571","messageId":"2572","endLine":157,"endColumn":38},{"ruleId":"2573","severity":1,"message":"2594","line":232,"column":12,"nodeType":"2575","endLine":232,"endColumn":19},{"ruleId":"2573","severity":1,"message":"2595","line":232,"column":21,"nodeType":"2575","endLine":232,"endColumn":27},{"ruleId":"2573","severity":1,"message":"2596","line":1,"column":10,"nodeType":"2575","endLine":1,"endColumn":29},{"ruleId":"2565","severity":1,"message":"2566","line":47,"column":17,"nodeType":"2567","messageId":"2568","endLine":47,"endColumn":20},{"ruleId":"2565","severity":1,"message":"2566","line":42,"column":36,"nodeType":"2567","messageId":"2568","endLine":42,"endColumn":39},{"ruleId":"2565","severity":1,"message":"2566","line":143,"column":14,"nodeType":"2567","messageId":"2568","endLine":143,"endColumn":17},{"ruleId":"2569","severity":1,"message":"2570","line":206,"column":31,"nodeType":"2571","messageId":"2572","endLine":206,"endColumn":43},{"ruleId":"2569","severity":1,"message":"2570","line":231,"column":35,"nodeType":"2571","messageId":"2572","endLine":231,"endColumn":56},{"ruleId":"2569","severity":1,"message":"2570","line":244,"column":34,"nodeType":"2571","messageId":"2572","endLine":244,"endColumn":46},{"ruleId":"2565","severity":1,"message":"2566","line":388,"column":39,"nodeType":"2567","messageId":"2568","endLine":388,"endColumn":42},{"ruleId":"2569","severity":1,"message":"2570","line":546,"column":10,"nodeType":"2571","messageId":"2572","endLine":546,"endColumn":38},{"ruleId":"2565","severity":1,"message":"2566","line":3,"column":42,"nodeType":"2567","messageId":"2568","endLine":3,"endColumn":45},{"ruleId":"2565","severity":1,"message":"2566","line":34,"column":71,"nodeType":"2567","messageId":"2568","endLine":34,"endColumn":74},{"ruleId":"2573","severity":1,"message":"2597","line":546,"column":38,"nodeType":"2575","endLine":546,"endColumn":44},{"ruleId":"2573","severity":1,"message":"2597","line":858,"column":38,"nodeType":"2575","endLine":858,"endColumn":44},{"ruleId":"2565","severity":1,"message":"2566","line":972,"column":34,"nodeType":"2567","messageId":"2568","endLine":972,"endColumn":37},{"ruleId":"2565","severity":1,"message":"2566","line":4,"column":28,"nodeType":"2567","messageId":"2568","endLine":4,"endColumn":31},{"ruleId":"2573","severity":1,"message":"2598","line":12,"column":3,"nodeType":"2575","endLine":12,"endColumn":20},{"ruleId":"2565","severity":1,"message":"2566","line":94,"column":44,"nodeType":"2567","messageId":"2568","endLine":94,"endColumn":47},{"ruleId":"2565","severity":1,"message":"2566","line":112,"column":38,"nodeType":"2567","messageId":"2568","endLine":112,"endColumn":41},{"ruleId":"2565","severity":1,"message":"2566","line":708,"column":35,"nodeType":"2567","messageId":"2568","endLine":708,"endColumn":38},{"ruleId":"2565","severity":1,"message":"2566","line":1075,"column":44,"nodeType":"2567","messageId":"2568","endLine":1075,"endColumn":47},{"ruleId":"2565","severity":1,"message":"2566","line":22,"column":35,"nodeType":"2567","messageId":"2568","endLine":22,"endColumn":38},{"ruleId":"2565","severity":1,"message":"2566","line":60,"column":43,"nodeType":"2567","messageId":"2568","endLine":60,"endColumn":46},{"ruleId":"2565","severity":1,"message":"2566","line":44,"column":31,"nodeType":"2567","messageId":"2568","endLine":44,"endColumn":34},{"ruleId":"2565","severity":1,"message":"2566","line":45,"column":33,"nodeType":"2567","messageId":"2568","endLine":45,"endColumn":36},{"ruleId":"2565","severity":1,"message":"2566","line":132,"column":29,"nodeType":"2567","messageId":"2568","endLine":132,"endColumn":32},{"ruleId":"2565","severity":1,"message":"2566","line":137,"column":30,"nodeType":"2567","messageId":"2568","endLine":137,"endColumn":33},{"ruleId":"2569","severity":1,"message":"2570","line":188,"column":26,"nodeType":"2571","messageId":"2572","endLine":188,"endColumn":39},{"ruleId":"2569","severity":1,"message":"2570","line":212,"column":26,"nodeType":"2571","messageId":"2572","endLine":212,"endColumn":39},{"ruleId":"2573","severity":1,"message":"2599","line":6,"column":10,"nodeType":"2575","endLine":6,"endColumn":47},{"ruleId":"2573","severity":1,"message":"2600","line":1,"column":10,"nodeType":"2575","endLine":1,"endColumn":46},{"ruleId":"2565","severity":1,"message":"2566","line":227,"column":53,"nodeType":"2567","messageId":"2568","endLine":227,"endColumn":56},{"ruleId":"2601","severity":1,"message":"2602","line":344,"column":35,"nodeType":"2589","messageId":"2603"},{"ruleId":"2573","severity":1,"message":"2604","line":3,"column":3,"nodeType":"2575","endLine":3,"endColumn":34},{"ruleId":"2565","severity":1,"message":"2566","line":51,"column":55,"nodeType":"2567","messageId":"2568","endLine":51,"endColumn":58},{"ruleId":"2565","severity":1,"message":"2566","line":114,"column":28,"nodeType":"2567","messageId":"2568","endLine":114,"endColumn":31},{"ruleId":"2565","severity":1,"message":"2566","line":115,"column":8,"nodeType":"2567","messageId":"2568","endLine":115,"endColumn":11},{"ruleId":"2565","severity":1,"message":"2566","line":389,"column":45,"nodeType":"2567","messageId":"2568","endLine":389,"endColumn":48},{"ruleId":"2565","severity":1,"message":"2566","line":826,"column":5,"nodeType":"2567","messageId":"2568","endLine":826,"endColumn":8},{"ruleId":"2565","severity":1,"message":"2566","line":149,"column":30,"nodeType":"2567","messageId":"2568","endLine":149,"endColumn":33},{"ruleId":"2565","severity":1,"message":"2566","line":179,"column":5,"nodeType":"2567","messageId":"2568","endLine":179,"endColumn":8},{"ruleId":"2569","severity":1,"message":"2570","line":55,"column":26,"nodeType":"2571","messageId":"2572","endLine":55,"endColumn":47},{"ruleId":"2569","severity":1,"message":"2570","line":74,"column":26,"nodeType":"2571","messageId":"2572","endLine":74,"endColumn":47},{"ruleId":"2569","severity":1,"message":"2570","line":101,"column":26,"nodeType":"2571","messageId":"2572","endLine":101,"endColumn":47},{"ruleId":"2569","severity":1,"message":"2570","line":201,"column":26,"nodeType":"2571","messageId":"2572","endLine":201,"endColumn":47},{"ruleId":"2565","severity":1,"message":"2566","line":39,"column":64,"nodeType":"2567","messageId":"2568","endLine":39,"endColumn":67},{"ruleId":"2565","severity":1,"message":"2566","line":95,"column":5,"nodeType":"2567","messageId":"2568","endLine":95,"endColumn":8},{"ruleId":"2565","severity":1,"message":"2566","line":130,"column":50,"nodeType":"2567","messageId":"2568","endLine":130,"endColumn":53},{"ruleId":"2565","severity":1,"message":"2566","line":167,"column":33,"nodeType":"2567","messageId":"2568","endLine":167,"endColumn":36},{"ruleId":"2565","severity":1,"message":"2566","line":89,"column":64,"nodeType":"2567","messageId":"2568","endLine":89,"endColumn":67},{"ruleId":"2565","severity":1,"message":"2566","line":155,"column":31,"nodeType":"2567","messageId":"2568","endLine":155,"endColumn":34},{"ruleId":"2565","severity":1,"message":"2566","line":494,"column":20,"nodeType":"2567","messageId":"2568","endLine":494,"endColumn":23},{"ruleId":"2565","severity":1,"message":"2566","line":695,"column":52,"nodeType":"2567","messageId":"2568","endLine":695,"endColumn":55},{"ruleId":"2565","severity":1,"message":"2566","line":777,"column":62,"nodeType":"2567","messageId":"2568","endLine":777,"endColumn":65},{"ruleId":"2565","severity":1,"message":"2566","line":878,"column":12,"nodeType":"2567","messageId":"2568","endLine":878,"endColumn":15},{"ruleId":"2565","severity":1,"message":"2566","line":930,"column":12,"nodeType":"2567","messageId":"2568","endLine":930,"endColumn":15},{"ruleId":"2565","severity":1,"message":"2566","line":1062,"column":12,"nodeType":"2567","messageId":"2568","endLine":1062,"endColumn":15},{"ruleId":"2565","severity":1,"message":"2566","line":77,"column":5,"nodeType":"2567","messageId":"2568","endLine":77,"endColumn":8},{"ruleId":"2565","severity":1,"message":"2566","line":79,"column":5,"nodeType":"2567","messageId":"2568","endLine":79,"endColumn":8},{"ruleId":"2565","severity":1,"message":"2566","line":86,"column":11,"nodeType":"2567","messageId":"2568","endLine":86,"endColumn":14},{"ruleId":"2569","severity":1,"message":"2570","line":96,"column":23,"nodeType":"2571","messageId":"2572","endLine":96,"endColumn":32},{"ruleId":"2569","severity":1,"message":"2570","line":102,"column":27,"nodeType":"2571","messageId":"2572","endLine":102,"endColumn":36},{"ruleId":"2565","severity":1,"message":"2566","line":102,"column":40,"nodeType":"2567","messageId":"2568","endLine":102,"endColumn":43},{"ruleId":"2565","severity":1,"message":"2566","line":18,"column":22,"nodeType":"2567","messageId":"2568","endLine":18,"endColumn":25},{"ruleId":"2565","severity":1,"message":"2566","line":70,"column":26,"nodeType":"2567","messageId":"2568","endLine":70,"endColumn":29},{"ruleId":"2580","severity":1,"message":"2605","line":198,"column":23,"nodeType":"2582","messageId":"2583"},{"ruleId":"2565","severity":1,"message":"2566","line":92,"column":24,"nodeType":"2567","messageId":"2568","endLine":92,"endColumn":27},{"ruleId":"2565","severity":1,"message":"2566","line":113,"column":40,"nodeType":"2567","messageId":"2568","endLine":113,"endColumn":43},{"ruleId":"2565","severity":1,"message":"2566","line":113,"column":50,"nodeType":"2567","messageId":"2568","endLine":113,"endColumn":53},{"ruleId":"2565","severity":1,"message":"2566","line":317,"column":22,"nodeType":"2567","messageId":"2568","endLine":317,"endColumn":25},{"ruleId":"2565","severity":1,"message":"2566","line":332,"column":42,"nodeType":"2567","messageId":"2568","endLine":332,"endColumn":45},{"ruleId":"2565","severity":1,"message":"2566","line":955,"column":12,"nodeType":"2567","messageId":"2568","endLine":955,"endColumn":15},{"ruleId":"2565","severity":1,"message":"2566","line":1133,"column":5,"nodeType":"2567","messageId":"2568","endLine":1133,"endColumn":8},{"ruleId":"2573","severity":1,"message":"2606","line":2,"column":10,"nodeType":"2575","endLine":2,"endColumn":26},{"ruleId":"2573","severity":1,"message":"2607","line":3,"column":10,"nodeType":"2575","endLine":3,"endColumn":24},{"ruleId":"2573","severity":1,"message":"2608","line":4,"column":10,"nodeType":"2575","endLine":4,"endColumn":30},{"ruleId":"2565","severity":1,"message":"2566","line":61,"column":21,"nodeType":"2567","messageId":"2568","endLine":61,"endColumn":24},{"ruleId":"2565","severity":1,"message":"2566","line":118,"column":27,"nodeType":"2567","messageId":"2568","endLine":118,"endColumn":30},{"ruleId":"2565","severity":1,"message":"2566","line":382,"column":59,"nodeType":"2567","messageId":"2568","endLine":382,"endColumn":62},{"ruleId":"2565","severity":1,"message":"2566","line":4,"column":55,"nodeType":"2567","messageId":"2568","endLine":4,"endColumn":58},{"ruleId":"2609","severity":1,"message":"2610","line":118,"column":9,"nodeType":"2611","endLine":123,"endColumn":10},{"ruleId":"2573","severity":1,"message":"2612","line":1,"column":10,"nodeType":"2575","endLine":1,"endColumn":38},{"ruleId":"2573","severity":1,"message":"2596","line":3,"column":10,"nodeType":"2575","endLine":3,"endColumn":29},{"ruleId":"2573","severity":1,"message":"2613","line":4,"column":10,"nodeType":"2575","endLine":4,"endColumn":38},{"ruleId":"2565","severity":1,"message":"2566","line":15,"column":6,"nodeType":"2567","messageId":"2568","endLine":15,"endColumn":9},{"ruleId":"2565","severity":1,"message":"2566","line":19,"column":43,"nodeType":"2567","messageId":"2568","endLine":19,"endColumn":46},{"ruleId":"2565","severity":1,"message":"2566","line":19,"column":51,"nodeType":"2567","messageId":"2568","endLine":19,"endColumn":54},{"ruleId":"2565","severity":1,"message":"2566","line":24,"column":36,"nodeType":"2567","messageId":"2568","endLine":24,"endColumn":39},{"ruleId":"2565","severity":1,"message":"2566","line":24,"column":44,"nodeType":"2567","messageId":"2568","endLine":24,"endColumn":47},{"ruleId":"2565","severity":1,"message":"2566","line":36,"column":48,"nodeType":"2567","messageId":"2568","endLine":36,"endColumn":51},{"ruleId":"2565","severity":1,"message":"2566","line":36,"column":55,"nodeType":"2567","messageId":"2568","endLine":36,"endColumn":58},{"ruleId":"2565","severity":1,"message":"2566","line":40,"column":34,"nodeType":"2567","messageId":"2568","endLine":40,"endColumn":37},{"ruleId":"2565","severity":1,"message":"2566","line":47,"column":6,"nodeType":"2567","messageId":"2568","endLine":47,"endColumn":9},{"ruleId":"2565","severity":1,"message":"2566","line":6,"column":37,"nodeType":"2567","messageId":"2568","endLine":6,"endColumn":40},{"ruleId":"2565","severity":1,"message":"2566","line":6,"column":45,"nodeType":"2567","messageId":"2568","endLine":6,"endColumn":48},{"ruleId":"2565","severity":1,"message":"2566","line":8,"column":28,"nodeType":"2567","messageId":"2568","endLine":8,"endColumn":31},{"ruleId":"2565","severity":1,"message":"2566","line":5,"column":40,"nodeType":"2567","messageId":"2568","endLine":5,"endColumn":43},{"ruleId":"2565","severity":1,"message":"2566","line":5,"column":48,"nodeType":"2567","messageId":"2568","endLine":5,"endColumn":51},{"ruleId":"2565","severity":1,"message":"2566","line":8,"column":25,"nodeType":"2567","messageId":"2568","endLine":8,"endColumn":28},{"ruleId":"2565","severity":1,"message":"2566","line":6,"column":47,"nodeType":"2567","messageId":"2568","endLine":6,"endColumn":50},{"ruleId":"2565","severity":1,"message":"2566","line":6,"column":55,"nodeType":"2567","messageId":"2568","endLine":6,"endColumn":58},{"ruleId":"2565","severity":1,"message":"2566","line":9,"column":32,"nodeType":"2567","messageId":"2568","endLine":9,"endColumn":35},{"ruleId":"2565","severity":1,"message":"2566","line":7,"column":21,"nodeType":"2567","messageId":"2568","endLine":7,"endColumn":24},{"ruleId":"2565","severity":1,"message":"2566","line":23,"column":23,"nodeType":"2567","messageId":"2568","endLine":23,"endColumn":26},{"ruleId":"2565","severity":1,"message":"2566","line":24,"column":21,"nodeType":"2567","messageId":"2568","endLine":24,"endColumn":24},{"ruleId":"2577","severity":1,"message":"2578","line":50,"column":5,"nodeType":"2579","endLine":50,"endColumn":34},{"ruleId":"2565","severity":1,"message":"2566","line":50,"column":26,"nodeType":"2567","messageId":"2568","endLine":50,"endColumn":29},{"ruleId":"2580","severity":1,"message":"2581","line":50,"column":31,"nodeType":"2582","messageId":"2583"},{"ruleId":"2565","severity":1,"message":"2566","line":4,"column":49,"nodeType":"2567","messageId":"2568","endLine":4,"endColumn":52},{"ruleId":"2565","severity":1,"message":"2566","line":4,"column":66,"nodeType":"2567","messageId":"2568","endLine":4,"endColumn":69},{"ruleId":"2565","severity":1,"message":"2566","line":15,"column":21,"nodeType":"2567","messageId":"2568","endLine":15,"endColumn":24},{"ruleId":"2565","severity":1,"message":"2566","line":16,"column":22,"nodeType":"2567","messageId":"2568","endLine":16,"endColumn":25},{"ruleId":"2565","severity":1,"message":"2566","line":40,"column":15,"nodeType":"2567","messageId":"2568","endLine":40,"endColumn":18},{"ruleId":"2565","severity":1,"message":"2566","line":42,"column":20,"nodeType":"2567","messageId":"2568","endLine":42,"endColumn":23},{"ruleId":"2565","severity":1,"message":"2566","line":47,"column":33,"nodeType":"2567","messageId":"2568","endLine":47,"endColumn":36},{"ruleId":"2565","severity":1,"message":"2566","line":56,"column":26,"nodeType":"2567","messageId":"2568","endLine":56,"endColumn":29},{"ruleId":"2565","severity":1,"message":"2566","line":104,"column":25,"nodeType":"2567","messageId":"2568","endLine":104,"endColumn":28},{"ruleId":"2565","severity":1,"message":"2566","line":112,"column":18,"nodeType":"2567","messageId":"2568","endLine":112,"endColumn":21},{"ruleId":"2565","severity":1,"message":"2566","line":187,"column":16,"nodeType":"2567","messageId":"2568","endLine":187,"endColumn":19},{"ruleId":"2565","severity":1,"message":"2566","line":188,"column":18,"nodeType":"2567","messageId":"2568","endLine":188,"endColumn":21},{"ruleId":"2565","severity":1,"message":"2566","line":1,"column":33,"nodeType":"2567","messageId":"2568","endLine":1,"endColumn":36},{"ruleId":"2565","severity":1,"message":"2566","line":14,"column":17,"nodeType":"2567","messageId":"2568","endLine":14,"endColumn":20},{"ruleId":"2565","severity":1,"message":"2566","line":14,"column":22,"nodeType":"2567","messageId":"2568","endLine":14,"endColumn":25},{"ruleId":"2565","severity":1,"message":"2566","line":14,"column":33,"nodeType":"2567","messageId":"2568","endLine":14,"endColumn":36},{"ruleId":"2565","severity":1,"message":"2566","line":14,"column":46,"nodeType":"2567","messageId":"2568","endLine":14,"endColumn":49},{"ruleId":"2565","severity":1,"message":"2566","line":4,"column":37,"nodeType":"2567","messageId":"2568","endLine":4,"endColumn":40},{"ruleId":"2565","severity":1,"message":"2566","line":8,"column":34,"nodeType":"2567","messageId":"2568","endLine":8,"endColumn":37},{"ruleId":"2565","severity":1,"message":"2566","line":17,"column":35,"nodeType":"2567","messageId":"2568","endLine":17,"endColumn":38},{"ruleId":"2565","severity":1,"message":"2566","line":31,"column":46,"nodeType":"2567","messageId":"2568","endLine":31,"endColumn":49},{"ruleId":"2565","severity":1,"message":"2566","line":31,"column":74,"nodeType":"2567","messageId":"2568","endLine":31,"endColumn":77},{"ruleId":"2565","severity":1,"message":"2566","line":36,"column":8,"nodeType":"2567","messageId":"2568","endLine":36,"endColumn":11},{"ruleId":"2569","severity":1,"message":"2570","line":249,"column":38,"nodeType":"2571","messageId":"2572","endLine":249,"endColumn":57},{"ruleId":"2565","severity":1,"message":"2566","line":250,"column":44,"nodeType":"2567","messageId":"2568","endLine":250,"endColumn":47},{"ruleId":"2565","severity":1,"message":"2566","line":4,"column":14,"nodeType":"2567","messageId":"2568","endLine":4,"endColumn":17},{"ruleId":"2573","severity":1,"message":"2614","line":13,"column":3,"nodeType":"2575","endLine":13,"endColumn":20},{"ruleId":"2573","severity":1,"message":"2615","line":4,"column":3,"nodeType":"2575","endLine":4,"endColumn":21},{"ruleId":"2565","severity":1,"message":"2566","line":10,"column":41,"nodeType":"2567","messageId":"2568","endLine":10,"endColumn":44},{"ruleId":"2565","severity":1,"message":"2566","line":14,"column":41,"nodeType":"2567","messageId":"2568","endLine":14,"endColumn":44},{"ruleId":"2565","severity":1,"message":"2566","line":20,"column":44,"nodeType":"2567","messageId":"2568","endLine":20,"endColumn":47},{"ruleId":"2565","severity":1,"message":"2566","line":24,"column":43,"nodeType":"2567","messageId":"2568","endLine":24,"endColumn":46},{"ruleId":"2565","severity":1,"message":"2566","line":28,"column":47,"nodeType":"2567","messageId":"2568","endLine":28,"endColumn":50},{"ruleId":"2565","severity":1,"message":"2566","line":24,"column":32,"nodeType":"2567","messageId":"2568","endLine":24,"endColumn":35},{"ruleId":"2565","severity":1,"message":"2566","line":27,"column":12,"nodeType":"2567","messageId":"2568","endLine":27,"endColumn":15},{"ruleId":"2565","severity":1,"message":"2566","line":49,"column":48,"nodeType":"2567","messageId":"2568","endLine":49,"endColumn":51},{"ruleId":"2565","severity":1,"message":"2566","line":53,"column":50,"nodeType":"2567","messageId":"2568","endLine":53,"endColumn":53},{"ruleId":"2565","severity":1,"message":"2566","line":58,"column":14,"nodeType":"2567","messageId":"2568","endLine":58,"endColumn":17},{"ruleId":"2565","severity":1,"message":"2566","line":64,"column":14,"nodeType":"2567","messageId":"2568","endLine":64,"endColumn":17},{"ruleId":"2565","severity":1,"message":"2566","line":69,"column":58,"nodeType":"2567","messageId":"2568","endLine":69,"endColumn":61},{"ruleId":"2565","severity":1,"message":"2566","line":102,"column":8,"nodeType":"2567","messageId":"2568","endLine":102,"endColumn":11},{"ruleId":"2565","severity":1,"message":"2566","line":125,"column":36,"nodeType":"2567","messageId":"2568","endLine":125,"endColumn":39},{"ruleId":"2565","severity":1,"message":"2566","line":128,"column":35,"nodeType":"2567","messageId":"2568","endLine":128,"endColumn":38},{"ruleId":"2573","severity":1,"message":"2616","line":15,"column":24,"nodeType":"2575","endLine":15,"endColumn":33},{"ruleId":"2573","severity":1,"message":"2617","line":25,"column":10,"nodeType":"2575","endLine":25,"endColumn":38},{"ruleId":"2565","severity":1,"message":"2566","line":30,"column":8,"nodeType":"2567","messageId":"2568","endLine":30,"endColumn":11},{"ruleId":null,"fatal":true,"severity":2,"message":"2618"},{"ruleId":"2573","severity":1,"message":"2619","line":22,"column":3,"nodeType":"2575","endLine":22,"endColumn":18},{"ruleId":"2565","severity":1,"message":"2566","line":29,"column":28,"nodeType":"2567","messageId":"2568","endLine":29,"endColumn":31},{"ruleId":"2565","severity":1,"message":"2566","line":30,"column":29,"nodeType":"2567","messageId":"2568","endLine":30,"endColumn":32},{"ruleId":"2565","severity":1,"message":"2566","line":35,"column":40,"nodeType":"2567","messageId":"2568","endLine":35,"endColumn":43},{"ruleId":"2573","severity":1,"message":"2620","line":12,"column":10,"nodeType":"2575","endLine":12,"endColumn":29},{"ruleId":"2573","severity":1,"message":"2621","line":14,"column":7,"nodeType":"2575","endLine":14,"endColumn":17},{"ruleId":"2573","severity":1,"message":"2622","line":19,"column":7,"nodeType":"2575","endLine":19,"endColumn":21},{"ruleId":"2573","severity":1,"message":"2623","line":24,"column":7,"nodeType":"2575","endLine":24,"endColumn":21},{"ruleId":"2573","severity":1,"message":"2624","line":6,"column":10,"nodeType":"2575","endLine":6,"endColumn":26},{"ruleId":"2569","severity":1,"message":"2570","line":26,"column":18,"nodeType":"2571","messageId":"2572","endLine":26,"endColumn":24},{"ruleId":"2565","severity":1,"message":"2566","line":7,"column":66,"nodeType":"2567","messageId":"2568","endLine":7,"endColumn":69},{"ruleId":"2565","severity":1,"message":"2566","line":25,"column":57,"nodeType":"2567","messageId":"2568","endLine":25,"endColumn":60},{"ruleId":"2565","severity":1,"message":"2566","line":35,"column":10,"nodeType":"2567","messageId":"2568","endLine":35,"endColumn":13},{"ruleId":"2565","severity":1,"message":"2566","line":268,"column":42,"nodeType":"2567","messageId":"2568","endLine":268,"endColumn":45},{"ruleId":"2565","severity":1,"message":"2566","line":7,"column":63,"nodeType":"2567","messageId":"2568","endLine":7,"endColumn":66},{"ruleId":"2573","severity":1,"message":"2625","line":25,"column":3,"nodeType":"2575","endLine":25,"endColumn":39},{"ruleId":"2565","severity":1,"message":"2566","line":781,"column":64,"nodeType":"2567","messageId":"2568","endLine":781,"endColumn":67},{"ruleId":"2565","severity":1,"message":"2566","line":785,"column":63,"nodeType":"2567","messageId":"2568","endLine":785,"endColumn":66},{"ruleId":"2573","severity":1,"message":"2625","line":24,"column":10,"nodeType":"2575","endLine":24,"endColumn":46},{"ruleId":"2565","severity":1,"message":"2566","line":40,"column":5,"nodeType":"2567","messageId":"2568","endLine":40,"endColumn":8},{"ruleId":"2565","severity":1,"message":"2566","line":88,"column":12,"nodeType":"2567","messageId":"2568","endLine":88,"endColumn":15},{"ruleId":"2565","severity":1,"message":"2566","line":99,"column":12,"nodeType":"2567","messageId":"2568","endLine":99,"endColumn":15},{"ruleId":"2565","severity":1,"message":"2566","line":157,"column":40,"nodeType":"2567","messageId":"2568","endLine":157,"endColumn":43},{"ruleId":"2565","severity":1,"message":"2566","line":168,"column":16,"nodeType":"2567","messageId":"2568","endLine":168,"endColumn":19},{"ruleId":"2573","severity":1,"message":"2625","line":19,"column":3,"nodeType":"2575","endLine":19,"endColumn":39},{"ruleId":"2565","severity":1,"message":"2566","line":48,"column":40,"nodeType":"2567","messageId":"2568","endLine":48,"endColumn":43},{"ruleId":"2565","severity":1,"message":"2566","line":4,"column":58,"nodeType":"2567","messageId":"2568","endLine":4,"endColumn":61},{"ruleId":"2565","severity":1,"message":"2566","line":11,"column":42,"nodeType":"2567","messageId":"2568","endLine":11,"endColumn":45},{"ruleId":"2565","severity":1,"message":"2566","line":9,"column":14,"nodeType":"2567","messageId":"2568","endLine":9,"endColumn":17},{"ruleId":"2565","severity":1,"message":"2566","line":23,"column":14,"nodeType":"2567","messageId":"2568","endLine":23,"endColumn":17},{"ruleId":"2565","severity":1,"message":"2566","line":14,"column":52,"nodeType":"2567","messageId":"2568","endLine":14,"endColumn":55},{"ruleId":"2565","severity":1,"message":"2566","line":234,"column":54,"nodeType":"2567","messageId":"2568","endLine":234,"endColumn":57},{"ruleId":"2565","severity":1,"message":"2566","line":655,"column":15,"nodeType":"2567","messageId":"2568","endLine":655,"endColumn":18},{"ruleId":"2565","severity":1,"message":"2566","line":1647,"column":31,"nodeType":"2567","messageId":"2568","endLine":1647,"endColumn":34},{"ruleId":"2565","severity":1,"message":"2566","line":16,"column":25,"nodeType":"2567","messageId":"2568","endLine":16,"endColumn":28},{"ruleId":"2565","severity":1,"message":"2566","line":20,"column":12,"nodeType":"2567","messageId":"2568","endLine":20,"endColumn":15},{"ruleId":"2565","severity":1,"message":"2566","line":40,"column":12,"nodeType":"2567","messageId":"2568","endLine":40,"endColumn":15},{"ruleId":"2565","severity":1,"message":"2566","line":60,"column":12,"nodeType":"2567","messageId":"2568","endLine":60,"endColumn":15},{"ruleId":"2565","severity":1,"message":"2566","line":3,"column":34,"nodeType":"2567","messageId":"2568","endLine":3,"endColumn":37},{"ruleId":"2565","severity":1,"message":"2566","line":3,"column":61,"nodeType":"2567","messageId":"2568","endLine":3,"endColumn":64},{"ruleId":"2565","severity":1,"message":"2566","line":1,"column":45,"nodeType":"2567","messageId":"2568","endLine":1,"endColumn":48},{"ruleId":"2565","severity":1,"message":"2566","line":1,"column":50,"nodeType":"2567","messageId":"2568","endLine":1,"endColumn":53},{"ruleId":"2565","severity":1,"message":"2566","line":1,"column":72,"nodeType":"2567","messageId":"2568","endLine":1,"endColumn":75},{"ruleId":"2565","severity":1,"message":"2566","line":28,"column":42,"nodeType":"2567","messageId":"2568","endLine":28,"endColumn":45},{"ruleId":"2565","severity":1,"message":"2566","line":28,"column":47,"nodeType":"2567","messageId":"2568","endLine":28,"endColumn":50},{"ruleId":"2565","severity":1,"message":"2566","line":6,"column":19,"nodeType":"2567","messageId":"2568","endLine":6,"endColumn":22},{"ruleId":"2565","severity":1,"message":"2566","line":6,"column":27,"nodeType":"2567","messageId":"2568","endLine":6,"endColumn":30},{"ruleId":"2565","severity":1,"message":"2566","line":41,"column":61,"nodeType":"2567","messageId":"2568","endLine":41,"endColumn":64},{"ruleId":"2565","severity":1,"message":"2566","line":41,"column":71,"nodeType":"2567","messageId":"2568","endLine":41,"endColumn":74},{"ruleId":"2565","severity":1,"message":"2566","line":44,"column":17,"nodeType":"2567","messageId":"2568","endLine":44,"endColumn":20},{"ruleId":"2565","severity":1,"message":"2566","line":56,"column":56,"nodeType":"2567","messageId":"2568","endLine":56,"endColumn":59},{"ruleId":"2565","severity":1,"message":"2566","line":56,"column":64,"nodeType":"2567","messageId":"2568","endLine":56,"endColumn":67},{"ruleId":"2573","severity":1,"message":"2626","line":4,"column":3,"nodeType":"2575","endLine":4,"endColumn":35},{"ruleId":"2573","severity":1,"message":"2627","line":5,"column":3,"nodeType":"2575","endLine":5,"endColumn":31},{"ruleId":"2573","severity":1,"message":"2628","line":12,"column":10,"nodeType":"2575","endLine":12,"endColumn":49},"Parsing error: \"parserOptions.project\" has been set for @typescript-eslint/parser.\nThe file does not match your project config: docs/assets/js/main.js.\nThe file must be included in at least one of the projects provided.","Parsing error: \"parserOptions.project\" has been set for @typescript-eslint/parser.\nThe file does not match your project config: docs/assets/js/search.js.\nThe file must be included in at least one of the projects provided.","Parsing error: \"parserOptions.project\" has been set for @typescript-eslint/parser.\nThe file does not match your project config: module-build/index.js.\nThe file must be included in at least one of the projects provided.","Parsing error: \"parserOptions.project\" has been set for @typescript-eslint/parser.\nThe file does not match your project config: module-build/module-build.js.\nThe file must be included in at least one of the projects provided.","@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny","@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull","@typescript-eslint/no-unused-vars","'result' is assigned a value but never used.","Identifier","'thirdParam' is assigned a value but never used.","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","@typescript-eslint/no-empty-function","Unexpected empty constructor.","FunctionExpression","unexpected","'validateUserIdentityDescriptionVersion' is defined but never used.","'TCentralAuthorityUserIdentity' is defined but never used.","'CA_CONNECTION_STATUS' is defined but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'errorMessage'.","ArrowFunctionExpression","unsafeRefs","'TCACryptoPubilicKeys' is defined but never used.","Unexpected empty method 'setOptionsSwarmConnection'.","Unexpected empty async method 'close'.","'nothing' is assigned a value but never used.","'prefix' is assigned a value but never used.","'IFileStorageService' is defined but never used.","'status' is assigned a value but never used.","'exportPasswordKey' is defined but never used.","'TSwarmMessageUserIdentifierSerialized' is defined but never used.","'ISwarmMessageSubclassFieldsValidator' is defined but never used.","array-callback-return","Expected to return a value at the end of arrow function.","expectedAtEnd","'TSwarmMessageSignatureAlgorithm' is defined but never used.","Unexpected empty async method 'load'.","'FileStoreAddFile' is defined but never used.","'ConnectToSwarm' is defined but never used.","'SensitiveDataStorage' is defined but never used.","jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","'FileStorageClassProviderIPFS' is defined but never used.","'FileStorageClassProviderHTTP' is defined but never used.","'dataSignExportKey' is defined but never used.","'typedArrayToString' is defined but never used.","'exportKey' is defined but never used.","'encodeArrayBufferToDOMString' is defined but never used.","Parsing error: \"parserOptions.project\" has been set for @typescript-eslint/parser.\nThe file does not match your project config: src/utils/ipfs-utils/ipfs-utils-libp2p/index.js.\nThe file must be included in at least one of the projects provided.","'STARDUST_SERVER' is defined but never used.","'WEB_RTC_STAR_SERVER' is defined but never used.","'API_SERVER' is assigned a value but never used.","'GATEWAY_SERVER' is assigned a value but never used.","'BOOTSTRAP_NODE' is assigned a value but never used.","'getLibPeerToPeer' is defined but never used.","'TSwarmStoreDatabaseEntityUniqueIndex' is defined but never used.","'TSwarmStoreDatabaseEntityAddress' is defined but never used.","'TSwarmStoreDatabaseEntityKey' is defined but never used.","'ESwarmStoreConnectorOrbitDbDatabaseType' is defined but never used."]