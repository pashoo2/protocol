[{"/home/paul/projects/protocol/docs/assets/js/main.js":"1","/home/paul/projects/protocol/docs/assets/js/search.js":"2","/home/paul/projects/protocol/module-build/index.js":"3","/home/paul/projects/protocol/module-build/module-build.js":"4","/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-class.ts":"5","/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-class.types.ts":"6","/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-connections/channel-authority-connection-with-server-api/channel-authority-connection-with-server-api.ts":"7","/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-connections/channel-authority-connection-with-server-api/channel-authority-connection-with-server-api.types.ts":"8","/home/paul/projects/protocol/src/backog-classes/channel-authority-class/index.ts":"9","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.const.ts":"10","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.ts":"11","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.types.ts":"12","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.utils.ts":"13","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/index.ts":"14","/home/paul/projects/protocol/src/classes/basic-classes/error-extended-class-base/error-extended-class-base.ts":"15","/home/paul/projects/protocol/src/classes/basic-classes/error-extended-scoped-class-base/error-extended-scoped-class-base.ts":"16","/home/paul/projects/protocol/src/classes/basic-classes/error-extended-scoped-class-base/index.ts":"17","/home/paul/projects/protocol/src/classes/basic-classes/event-emitter-class-base/event-emitter-class-base.ts":"18","/home/paul/projects/protocol/src/classes/basic-classes/event-emitter-class-base/index.ts":"19","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-base-body-processor.ts":"20","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-base-response-error.ts":"21","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-response-processor.ts":"22","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-utils.ts":"23","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.const.ts":"24","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.ts":"25","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.types.ts":"26","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.utils.ts":"27","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/index.ts":"28","/home/paul/projects/protocol/src/classes/basic-classes/mime-types-class-base/index.ts":"29","/home/paul/projects/protocol/src/classes/basic-classes/mime-types-class-base/mime-types-class-base.const.ts":"30","/home/paul/projects/protocol/src/classes/basic-classes/mime-types-class-base/mime-types-class-base.ts":"31","/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/index.ts":"32","/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.const.ts":"33","/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.ts":"34","/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.types.ts":"35","/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/index.ts":"36","/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/queued-encryption-class-base.ts":"37","/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/queued-encryption-class-base.types.ts":"38","/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/index.ts":"39","/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/status-class-base.const.ts":"40","/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/status-class-base.ts":"41","/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/status-class-base.types.ts":"42","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const-auth-credentials.ts":"43","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const-crypto-keys-usages.ts":"44","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const.ts":"45","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/index.ts":"46","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-common.ts":"47","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-credentials.ts":"48","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-keys.ts":"49","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types.ts":"50","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/index.ts":"51","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v1/central-authority-class-user-identity-formatters-formatter-v1.ts":"52","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v1/index.ts":"53","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v2/central-authority-class-user-identity-formatters-formatter-v2.const.ts":"54","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v2/central-authority-class-user-identity-formatters-formatter-v2.ts":"55","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v2/index.ts":"56","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.const.ts":"57","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.ts":"58","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.types.ts":"59","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.utils.ts":"60","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/index.ts":"61","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/central-authority-class-user-identity-parsers-parser-v1.const.ts":"62","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/central-authority-class-user-identity-parsers-parser-v1.ts":"63","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/index.ts":"64","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v2/central-authority-class-user-identity-parsers-parser-v2.const.ts":"65","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v2/central-authority-class-user-identity-parsers-parser-v2.ts":"66","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v2/index.ts":"67","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.const.ts":"68","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.ts":"69","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.types.ts":"70","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.utils.ts":"71","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/index.ts":"72","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v1/central-authority-class-user-identity-validator-v1.ts":"73","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v1/index.ts":"74","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v2/central-authority-class-user-identity-validator-v2.ts":"75","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v2/index.ts":"76","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.const.ts":"77","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.ts":"78","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.types.ts":"79","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.utils.ts":"80","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/index.ts":"81","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const.ts":"82","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.ts":"83","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types.ts":"84","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/index.ts":"85","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class.const.ts":"86","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class.ts":"87","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class.types.ts":"88","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/central-authority-connection-firebase-base.const.ts":"89","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/central-authority-connection-firebase-base.ts":"90","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/central-authority-connection-firebase-base.types.ts":"91","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/index.ts":"92","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-connection-implementation/central-authority-connection-firebase-connection-implementation.ts":"93","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-connection-implementation/index.ts":"94","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.const.ts":"95","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.ts":"96","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.types.ts":"97","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/index.ts":"98","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database.const.ts":"99","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database.ts":"100","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/index.ts":"101","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators/central-authority-connection-firebase-utils.validators.const.ts":"102","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators/central-authority-connection-firebase-utils.validators.ts":"103","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators/index.ts":"104","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/index.ts":"105","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.auth.ts":"106","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.error-codes.ts":"107","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.restrictions.ts":"108","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.ts":"109","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/index.ts":"110","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.ts":"111","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.types.configuration.ts":"112","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/index.ts":"113","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const-error-codes.ts":"114","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const-status.ts":"115","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const.ts":"116","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/index.ts":"117","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-pool/central-authority-connections-pool.ts":"118","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-pool/central-authority-connections-pool.types.ts":"119","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-pool/index.ts":"120","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.common/central-authority-connections-utils.common.ts":"121","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.normalizers.ts":"122","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.ts":"123","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.validators/central-authority-connections-utils.validators.const.ts":"124","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.validators/central-authority-connections-utils.validators.ts":"125","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/index.ts":"126","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections.const.ts":"127","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections.types.ts":"128","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/index.ts":"129","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.const.ts":"130","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.ts":"131","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.types.ts":"132","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/index.ts":"133","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/index.ts":"134","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.const.ts":"135","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.ts":"136","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.types.ts":"137","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/index.ts":"138","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/index.ts":"139","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/index.ts":"140","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-swarm-credentials-provider/central-authority-swarm-credentials-provider.ts":"141","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-swarm-credentials-provider/central-authority-swarm-credentials-provider.types.ts":"142","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-swarm-credentials-provider/index.ts":"143","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-common.ts":"144","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-export.ts":"145","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-generate.ts":"146","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-import.ts":"147","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys.const.ts":"148","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys.ts":"149","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/index.ts":"150","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials-crypto-keys.ts":"151","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials.const.ts":"152","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials.ts":"153","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/index.ts":"154","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/index.ts":"155","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials.ts":"156","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/index.ts":"157","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys-schemas.ts":"158","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys.ts":"159","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/index.ts":"160","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user.schemes.ts":"161","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user.ts":"162","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/index.ts":"163","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/index.ts":"164","/home/paul/projects/protocol/src/classes/central-authority-class/index.ts":"165","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.const.ts":"166","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.ts":"167","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.types.ts":"168","/home/paul/projects/protocol/src/classes/connection-bridge/index.ts":"169","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.const.ts":"170","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.ts":"171","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.types.ts":"172","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/index.ts":"173","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.const.ts":"174","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.ts":"175","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.types.ts":"176","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/index.ts":"177","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/index.ts":"178","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class.const.ts":"179","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class.ts":"180","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class.types.ts":"181","/home/paul/projects/protocol/src/classes/filestorage-class/index.ts":"182","/home/paul/projects/protocol/src/classes/index.ts":"183","/home/paul/projects/protocol/src/classes/open-storage/index.ts":"184","/home/paul/projects/protocol/src/classes/open-storage/open-storage.const.ts":"185","/home/paul/projects/protocol/src/classes/open-storage/open-storage.ts":"186","/home/paul/projects/protocol/src/classes/open-storage/open-storage.types.ts":"187","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/index.ts":"188","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.const.ts":"189","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.ts":"190","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.types.ts":"191","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.utils.ts":"192","/home/paul/projects/protocol/src/classes/safe-storage-class/index.ts":"193","/home/paul/projects/protocol/src/classes/safe-storage-class/safe-storage-class.const.ts":"194","/home/paul/projects/protocol/src/classes/safe-storage-class/safe-storage-class.ts":"195","/home/paul/projects/protocol/src/classes/safe-storage-class/safe-storage-class.types.ts":"196","/home/paul/projects/protocol/src/classes/secret-storage-class/index.ts":"197","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/index.ts":"198","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-login/index.ts":"199","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-login/secret-storage-class-utils-login.const.ts":"200","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-login/secret-storage-class-utils-login.ts":"201","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-main/index.ts":"202","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-main/secret-storage-class-utils-main.ts":"203","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-password/index.ts":"204","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-password/secret-storage-class-utils-password.ts":"205","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class.const.ts":"206","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class.ts":"207","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class.types.ts":"208","/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/index.ts":"209","/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/sensitive-data-session-storage.const.ts":"210","/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/sensitive-data-session-storage.ts":"211","/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/sensitive-data-session-storage.types.ts":"212","/home/paul/projects/protocol/src/classes/storage-providers/index.ts":"213","/home/paul/projects/protocol/src/classes/storage-providers/storage-level-js-provider/index.ts":"214","/home/paul/projects/protocol/src/classes/storage-providers/storage-level-js-provider/secret-storage-level-js-provider.const.ts":"215","/home/paul/projects/protocol/src/classes/storage-providers/storage-level-js-provider/secret-storage-level-js-provider.ts":"216","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-forage-provider/index.ts":"217","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-forage-provider/secret-storage-local-forage-provider.const.ts":"218","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-forage-provider/secret-storage-local-forage-provider.ts":"219","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-storage-provider/index.ts":"220","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-storage-provider/secret-storage-local-storage-provider.ts":"221","/home/paul/projects/protocol/src/classes/storage-providers/storage-providers.const.ts":"222","/home/paul/projects/protocol/src/classes/storage-providers/storage-providers.ts":"223","/home/paul/projects/protocol/src/classes/storage-providers/storage-providers.types.ts":"224","/home/paul/projects/protocol/src/classes/storage-providers/storage-session-storage-provider/index.ts":"225","/home/paul/projects/protocol/src/classes/storage-providers/storage-session-storage-provider/secret-storage-session-storage-provider.ts":"226","/home/paul/projects/protocol/src/classes/swarm-message/index.ts":"227","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-constructor.const.ts":"228","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-constructor.ts":"229","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-constructor.types.ts":"230","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/index.ts":"231","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-parser/index.ts":"232","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-parser/swarm-message-subclass-parser.ts":"233","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-parser/swarm-message-subclass-parser.types.ts":"234","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/index.ts":"235","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.const.ts":"236","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.ts":"237","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.types.ts":"238","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/index.ts":"239","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/index.ts":"240","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/index.ts":"241","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/index.ts":"242","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/swarm-message-subclass-validator-fields-validator-body-raw.const.ts":"243","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/swarm-message-subclass-validator-fields-validator-body-raw.ts":"244","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/index.ts":"245","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/swarm-message-subclass-validator-fields-validator-signature.const.ts":"246","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/swarm-message-subclass-validator-fields-validator-signature.ts":"247","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/index.ts":"248","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied.ts":"249","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied.types.ts":"250","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/index.ts":"251","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized.ts":"252","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized.types.ts":"253","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/index.ts":"254","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.const.ts":"255","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.ts":"256","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.types.ts":"257","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/index.ts":"258","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.const.ts":"259","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.ts":"260","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.types.ts":"261","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/index.ts":"262","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/swarm-message-subclass-validator-fields-validator-validator-type.ts":"263","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/swarm-message-subclass-validator-fields-validator-validator-type.types.ts":"264","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/index.ts":"265","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.const.ts":"266","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.ts":"267","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types.ts":"268","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator.ts":"269","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator.types.ts":"270","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/index.ts":"271","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/swarm-message-subclass-validator-signature-validator.ts":"272","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/swarm-message-subclass-validator-signature-validator.types.ts":"273","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.const.ts":"274","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.ts":"275","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.types.ts":"276","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/index.ts":"277","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-parser/index.ts":"278","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-parser/swarm-message-utils-body-parser.ts":"279","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-parser/swarm-message-utils-body-parser.types.ts":"280","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-serializer/index.ts":"281","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-serializer/swarm-message-utils-body-serializer.ts":"282","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-serializer/swarm-message-utils-body-serializer.types.ts":"283","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-parser/index.ts":"284","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-parser/swarm-message-utils-message-parser.ts":"285","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-parser/swarm-message-utils-message-parser.types.ts":"286","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-serializer/index.ts":"287","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-serializer/swarm-message-utils-message-serializer.ts":"288","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-serializer/swarm-message-utils-message-serializer.types.ts":"289","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/index.ts":"290","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.const.ts":"291","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.ts":"292","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.types.ts":"293","/home/paul/projects/protocol/src/classes/swarm-message-store/index.ts":"294","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/index.ts":"295","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-common/index.ts":"296","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-common/swarm-message-store-utils-common.ts":"297","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-connector-options-provider/index.ts":"298","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-connector-options-provider/swarm-message-store-utils-connector-options-provider.ts":"299","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store.const.ts":"300","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store.ts":"301","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store.types.ts":"302","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/index.ts":"303","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-message-encrypted-cache.utils.ts":"304","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.const.ts":"305","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.ts":"306","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types.ts":"307","/home/paul/projects/protocol/src/classes/swarm-store-class/index.ts":"308","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class.const.ts":"309","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class.ts":"310","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class.types.ts":"311","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/index.ts":"312","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/index.ts":"313","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/index.ts":"314","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/index.ts":"315","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.const.ts":"316","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.ts":"317","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.types.ts":"318","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/index.ts":"319","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const.ts":"320","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.ts":"321","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types.ts":"322","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/index.ts":"323","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider.const.ts":"324","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider.ts":"325","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/index.ts":"326","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.const.ts":"327","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.ts":"328","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.utils.ts":"329","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-cache/index.ts":"330","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-cache/swarm-store-connector-orbit-db-subclass-storage-cache.ts":"331","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/index.ts":"332","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.ts":"333","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.types.ts":"334","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.const.ts":"335","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.ts":"336","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types.ts":"337","/home/paul/projects/protocol/src/components/app-render.tsx":"338","/home/paul/projects/protocol/src/components/app.tsx":"339","/home/paul/projects/protocol/src/components/connect-to-swarm/connect-to-swarm.tsx":"340","/home/paul/projects/protocol/src/components/connect-to-swarm/connect-to-swarm.utils.ts":"341","/home/paul/projects/protocol/src/components/connect-to-swarm/index.ts":"342","/home/paul/projects/protocol/src/components/filestore-add-file/filestore-add-file.tsx":"343","/home/paul/projects/protocol/src/components/filestore-add-file/filestore-add-file.utils.ts":"344","/home/paul/projects/protocol/src/components/filestore-add-file/index.ts":"345","/home/paul/projects/protocol/src/components/sensitive-data-storage/index.ts":"346","/home/paul/projects/protocol/src/components/sensitive-data-storage/sensitive-data-storage.tsx":"347","/home/paul/projects/protocol/src/const/common-date-time/common-date-time-main.ts":"348","/home/paul/projects/protocol/src/const/common-date-time/common-date-time-ntp-servers.const.ts":"349","/home/paul/projects/protocol/src/const/common-date-time/common-date-time-timezone.const.ts":"350","/home/paul/projects/protocol/src/const/common-date-time/index.ts":"351","/home/paul/projects/protocol/src/const/common-values/common-values-env.ts":"352","/home/paul/projects/protocol/src/const/common-values/common-values.ts":"353","/home/paul/projects/protocol/src/const/common-values/index.ts":"354","/home/paul/projects/protocol/src/const/const-api-conf.ts":"355","/home/paul/projects/protocol/src/const/const-crypto-keys/const-crypto-keys.ts":"356","/home/paul/projects/protocol/src/const/const-crypto-keys/index.ts":"357","/home/paul/projects/protocol/src/const/const-validation-regex/const-validation-regex-common.ts":"358","/home/paul/projects/protocol/src/const/const-validation-regex/index.ts":"359","/home/paul/projects/protocol/src/const/const-validation-schemes/const-validation-schemes-common.ts":"360","/home/paul/projects/protocol/src/const/const-validation-schemes/const-validation-schemes-credentials.ts":"361","/home/paul/projects/protocol/src/const/const-validation-schemes/const-validation-schemes.ts":"362","/home/paul/projects/protocol/src/const/const-validation-schemes/index.ts":"363","/home/paul/projects/protocol/src/const/const-validation-values/const-validation-values-messaging-date.ts":"364","/home/paul/projects/protocol/src/const/const-validation-values/index.ts":"365","/home/paul/projects/protocol/src/const/const-values-restrictions-common.ts":"366","/home/paul/projects/protocol/src/dev.ts":"367","/home/paul/projects/protocol/src/index.ts":"368","/home/paul/projects/protocol/src/prod.ts":"369","/home/paul/projects/protocol/src/react-app-env.d.ts":"370","/home/paul/projects/protocol/src/types/channels.types.ts":"371","/home/paul/projects/protocol/src/types/common.types.ts":"372","/home/paul/projects/protocol/src/types/encryption-keys.types.ts":"373","/home/paul/projects/protocol/src/types/helper.types.ts":"374","/home/paul/projects/protocol/src/types/index.d.ts":"375","/home/paul/projects/protocol/src/types/ipfs.d.ts":"376","/home/paul/projects/protocol/src/types/ipfs.types.d.ts":"377","/home/paul/projects/protocol/src/types/libp2p-bootstrap.d.ts":"378","/home/paul/projects/protocol/src/types/libp2p-delegated-content-routing.d.ts":"379","/home/paul/projects/protocol/src/types/libp2p-delegated-peer-routing.d.ts":"380","/home/paul/projects/protocol/src/types/libp2p-gossipsub.d.ts":"381","/home/paul/projects/protocol/src/types/libp2p-kad-dht.d.ts":"382","/home/paul/projects/protocol/src/types/libp2p-mdns.d.ts":"383","/home/paul/projects/protocol/src/types/libp2p-secio.d.ts":"384","/home/paul/projects/protocol/src/types/libp2p-spdy.d.ts":"385","/home/paul/projects/protocol/src/types/libp2p-stardust.d.ts":"386","/home/paul/projects/protocol/src/types/libp2p-tcp.d.ts":"387","/home/paul/projects/protocol/src/types/libp2p-webrtc-direct.d.ts":"388","/home/paul/projects/protocol/src/types/libp2p-webrtc-star.d.ts":"389","/home/paul/projects/protocol/src/types/libp2p-websocket-star.d.ts":"390","/home/paul/projects/protocol/src/types/libp2p-websockets.d.ts":"391","/home/paul/projects/protocol/src/types/libp2p.d.ts":"392","/home/paul/projects/protocol/src/types/main.types.ts":"393","/home/paul/projects/protocol/src/types/multiaddr.d.ts":"394","/home/paul/projects/protocol/src/types/orbit-db-cache.d.ts":"395","/home/paul/projects/protocol/src/types/orbit-db-identity-provider-ext.d.ts":"396","/home/paul/projects/protocol/src/types/orbit-db-keystore.d.ts":"397","/home/paul/projects/protocol/src/types/orbit-db-storage-adapter.d.ts":"398","/home/paul/projects/protocol/src/types/pull-mplex.d.ts":"399","/home/paul/projects/protocol/src/types/storage.types.ts":"400","/home/paul/projects/protocol/src/types/users.types.ts":"401","/home/paul/projects/protocol/src/utils/common-utils/common-utils-array.ts":"402","/home/paul/projects/protocol/src/utils/common-utils/common-utils-check-value.ts":"403","/home/paul/projects/protocol/src/utils/common-utils/common-utils-date-time-synced.ts":"404","/home/paul/projects/protocol/src/utils/common-utils/common-utils-date-time.ts":"405","/home/paul/projects/protocol/src/utils/common-utils/common-utils-main.ts":"406","/home/paul/projects/protocol/src/utils/common-utils/common-utils-number.ts":"407","/home/paul/projects/protocol/src/utils/common-utils/common-utils-objects.ts":"408","/home/paul/projects/protocol/src/utils/common-utils/common-utils-timer.ts":"409","/home/paul/projects/protocol/src/utils/common-utils/common-utils-url.ts":"410","/home/paul/projects/protocol/src/utils/common-utils/common-utils.ts":"411","/home/paul/projects/protocol/src/utils/common-utils/index.ts":"412","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.const.ts":"413","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.ts":"414","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.types.ts":"415","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/index.ts":"416","/home/paul/projects/protocol/src/utils/data-cache-utils/index.ts":"417","/home/paul/projects/protocol/src/utils/data-compression-utils/data-compression-utils-strings.ts":"418","/home/paul/projects/protocol/src/utils/data-compression-utils/data-compression-utils.const.ts":"419","/home/paul/projects/protocol/src/utils/data-compression-utils/data-compression-utils.ts":"420","/home/paul/projects/protocol/src/utils/data-compression-utils/index.ts":"421","/home/paul/projects/protocol/src/utils/data-sign-utils/data-sign-utils.const.ts":"422","/home/paul/projects/protocol/src/utils/data-sign-utils/data-sign-utils.ts":"423","/home/paul/projects/protocol/src/utils/data-sign-utils/data-sign-utils.types.ts":"424","/home/paul/projects/protocol/src/utils/data-sign-utils/index.ts":"425","/home/paul/projects/protocol/src/utils/data-sign-utils/keys.data-sign-utils.ts":"426","/home/paul/projects/protocol/src/utils/data-sign-utils/main.data-sign-utils.const.ts":"427","/home/paul/projects/protocol/src/utils/data-sign-utils/sign-data.encryption-utils.ts":"428","/home/paul/projects/protocol/src/utils/data-sign-utils/verify-data.encryption-utils.ts":"429","/home/paul/projects/protocol/src/utils/data-validators-utils/data-validators-utils-common.ts":"430","/home/paul/projects/protocol/src/utils/data-validators-utils/data-validators-utils.ts":"431","/home/paul/projects/protocol/src/utils/data-validators-utils/index.ts":"432","/home/paul/projects/protocol/src/utils/encryption-keys-utils/encryption-keys-utils.const.ts":"433","/home/paul/projects/protocol/src/utils/encryption-keys-utils/encryption-keys-utils.ts":"434","/home/paul/projects/protocol/src/utils/encryption-keys-utils/index.ts":"435","/home/paul/projects/protocol/src/utils/encryption-utils/crypto-utils.const.ts":"436","/home/paul/projects/protocol/src/utils/encryption-utils/crypto-utils.types.ts":"437","/home/paul/projects/protocol/src/utils/encryption-utils/decrypt-data.encryption-utils.ts":"438","/home/paul/projects/protocol/src/utils/encryption-utils/encrypt-data.encryption-utils.ts":"439","/home/paul/projects/protocol/src/utils/encryption-utils/encryption-utils.ts":"440","/home/paul/projects/protocol/src/utils/encryption-utils/index.ts":"441","/home/paul/projects/protocol/src/utils/encryption-utils/keys.encryption-utils.ts":"442","/home/paul/projects/protocol/src/utils/encryption-utils/main.crypto-utils.const.ts":"443","/home/paul/projects/protocol/src/utils/encryption-utils/salt-utils.const.ts":"444","/home/paul/projects/protocol/src/utils/encryption-utils/salt-utils.ts":"445","/home/paul/projects/protocol/src/utils/encryption-utils/salt-utils.types.ts":"446","/home/paul/projects/protocol/src/utils/files-utils/files-utils-download.ts":"447","/home/paul/projects/protocol/src/utils/files-utils/files-utils-size.ts":"448","/home/paul/projects/protocol/src/utils/files-utils/index.ts":"449","/home/paul/projects/protocol/src/utils/firebase-utils/firebase-utils.ts":"450","/home/paul/projects/protocol/src/utils/firebase-utils/index.ts":"451","/home/paul/projects/protocol/src/utils/hash-calculation-utils/hash-calculation-utils.const.ts":"452","/home/paul/projects/protocol/src/utils/hash-calculation-utils/hash-calculation-utils.ts":"453","/home/paul/projects/protocol/src/utils/hash-calculation-utils/index.ts":"454","/home/paul/projects/protocol/src/utils/identity-utils/identity-utils.ts":"455","/home/paul/projects/protocol/src/utils/identity-utils/index.ts":"456","/home/paul/projects/protocol/src/utils/index.ts":"457","/home/paul/projects/protocol/src/utils/ipfs-utils/index.ts":"458","/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils-libp2p/ipfs-utils-libp2p.const.ts":"459","/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils-libp2p/ipfs-utils-libp2p.ts":"460","/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils.const.ts":"461","/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils.ts":"462","/home/paul/projects/protocol/src/utils/lazy-loading-utils/index.ts":"463","/home/paul/projects/protocol/src/utils/lazy-loading-utils/lazy-loading-utils.ts":"464","/home/paul/projects/protocol/src/utils/main-utils.ts":"465","/home/paul/projects/protocol/src/utils/password-utils/decrypt.password-utils.ts":"466","/home/paul/projects/protocol/src/utils/password-utils/derive-key.password-utils.ts":"467","/home/paul/projects/protocol/src/utils/password-utils/encrypt.password-utils.ts":"468","/home/paul/projects/protocol/src/utils/password-utils/index.ts":"469","/home/paul/projects/protocol/src/utils/password-utils/password-utils.const.ts":"470","/home/paul/projects/protocol/src/utils/password-utils/password-utils.types.ts":"471","/home/paul/projects/protocol/src/utils/string-encoding-utils.ts":"472","/home/paul/projects/protocol/src/utils/string-utilities.ts":"473","/home/paul/projects/protocol/src/utils/typed-array-utils.ts":"474","/home/paul/projects/protocol/src/utils/validation-utils/index.ts":"475","/home/paul/projects/protocol/src/utils/validation-utils/validation-utils-timestamp.ts":"476","/home/paul/projects/protocol/src/utils/validation-utils/validation-utils-validation-error.ts":"477","/home/paul/projects/protocol/src/utils/validation-utils/validation-utils.ts":"478","/home/paul/projects/protocol/src/components/userProfile/index.ts":"479","/home/paul/projects/protocol/src/components/userProfile/userProfile.tsx":"480","/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/index.ts":"481","/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/statused-class-helper.const.ts":"482","/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/statused-class-helper.ts":"483","/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/statused-class-helper.types.ts":"484","/home/paul/projects/protocol/src/classes/swarm-messages-database/index.ts":"485","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database.ts":"486","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database.types.ts":"487","/home/paul/projects/protocol/src/components/message-component/index.ts":"488","/home/paul/projects/protocol/src/components/message-component/message-component.tsx":"489","/home/paul/projects/protocol/src/components/swarm-messages-database-component/index.ts":"490","/home/paul/projects/protocol/src/components/swarm-messages-database-component/swarm-messages-database-component.tsx":"491","/home/paul/projects/protocol/src/components/swarm-messages-database-component/swarm-messages-database-component.types.ts":"492","/home/paul/projects/protocol/src/components/swarm-messages-database-component/swarm-messages-database-component.utils.ts":"493","/home/paul/projects/protocol/src/components/swarm-store-db-component/index.ts":"494","/home/paul/projects/protocol/src/components/swarm-store-db-component/swarm-store-db-component.tsx":"495","/home/paul/projects/protocol/src/classes/basic-classes/event-emitter-class-base/event-emitter-class-base.types.ts":"496","/home/paul/projects/protocol/src/classes/storage-providers/storage-in-memory-provider/index.ts":"497","/home/paul/projects/protocol/src/classes/storage-providers/storage-in-memory-provider/storage-in-memory-provider.ts":"498","/home/paul/projects/protocol/src/classes/storage-providers/storage-in-memory-provider/storage-in-memory-provider.types.ts":"499","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/index.ts":"500","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.const.ts":"501","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.ts":"502","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.types.ts":"503","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database.const.ts":"504","/home/paul/projects/protocol/src/utils/throttling-utils/index.ts":"505","/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/index.ts":"506","/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/throttling-utils-idle-callback.const.ts":"507","/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/throttling-utils-idle-callback.ts":"508","/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/throttling-utils-idle-callback.types.ts":"509","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/index.ts":"510","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/index.ts":"511","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.ts":"512","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/index.ts":"513","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-message-with-meta.ts":"514","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-swarm-message.ts":"515","/home/paul/projects/protocol/src/utils/common-utils/common-utils-classes.ts":"516","/home/paul/projects/protocol/src/utils/common-utils/common-utils-maps.ts":"517","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-memoization.ts":"518","/home/paul/projects/protocol/src/components/connect-to-swarm-immediate/connect-to-swarm-immediate.tsx":"519","/home/paul/projects/protocol/src/components/connect-to-swarm-immediate/index.ts":"520","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.const.ts":"521","/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-main.ts":"522","/home/paul/projects/protocol/src/const/const-helpers.ts":"523","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-main.ts":"524","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.types.ts":"525","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-common/index.ts":"526","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-common/swarm-message-utils-common-decrypted.ts":"527","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/index.ts":"528","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.const.ts":"529","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.ts":"530","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.types.ts":"531","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.utils.ts":"532","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/abstractions/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.ts":"533","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/abstractions/swarm-messages-database-messages-cached-store-temp/swarm-messages-database-messages-cached-store-temp.ts":"534","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/implementations/swarm-messages-database-messages-cached-store-core/swarm-messages-database-messages-cached-store-core.ts":"535","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/implementations/swarm-messages-database-messages-cached-store-feed/index.ts":"536","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/implementations/swarm-messages-database-messages-cached-store-feed/swarm-messages-database-messages-cached-store-feed.ts":"537","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/implementations/swarm-messages-database-messages-cached-store-keyvalue/index.ts":"538","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/implementations/swarm-messages-database-messages-cached-store-keyvalue/swarm-messages-database-messages-cached-store-keyvalue.ts":"539","/home/paul/projects/protocol/src/utils/common-utils/common-utils-sets.ts":"540","/home/paul/projects/protocol/src/utils/common-utils/commom-utils.promies.ts":"541","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/index.ts":"542","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter/index.ts":"543","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter.ts":"544","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter.types.ts":"545","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/index.ts":"546","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.ts":"547","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.types.ts":"548","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclasses-cache.const.ts":"549","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclasses-cache.types.ts":"550","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-utils/index.ts":"551","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-utils/swarm-store-connector-orbit-db-utils-address/index.ts":"552","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-utils/swarm-store-connector-orbit-db-utils-address/swarm-store-connector-orbit-db-utils-address.const.ts":"553","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-utils/swarm-store-connector-orbit-db-utils-address/swarm-store-connector-orbit-db-utils-address.ts":"554","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-utils/swarm-store-connector-orbit-db-utils-address/swarm-store-connector-orbit-db-utils-address.types.ts":"555","/home/paul/projects/protocol/src/types/orbit-db-address.d.ts":"556","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-concurent/async-queue-concurent.ts":"557","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-concurent/async-queue-concurent.types.ts":"558","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-concurent/async-queue-concurent.utils.ts":"559","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-concurent/index.ts":"560","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database-classes-extended/swarm-store-connector-orbit-db-subclass-database-queued/index.ts":"561","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database-classes-extended/swarm-store-connector-orbit-db-subclass-database-queued/swarm-store-connector-orbit-db-subclass-database-queued.ts":"562","/home/paul/projects/protocol/src/types/promise.types.ts":"563","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.utils.ts":"564","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database-classes-extended/swarm-store-connector-orbit-db-subclass-database-queued-items-counted/index.ts":"565","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database-classes-extended/swarm-store-connector-orbit-db-subclass-database-queued-items-counted/swarm-store-connector-orbit-db-subclass-database-queued-items-counted.ts":"566","/home/paul/projects/protocol/src/types/swarm-store-connector.types.ts":"567","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-extended/swarm-message-store-with-entries-count/index.ts":"568","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-extended/swarm-message-store-with-entries-count/swarm-message-store-with-entries-count.ts":"569","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class-extended/index.ts":"570","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class-extended/swarm-store-class-with-entries-count/index.ts":"571","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class-extended/swarm-store-class-with-entries-count/swarm-store-class-with-entries-count.ts":"572","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-extended/index.ts":"573","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-extended/swarm-store-connector-orbit-db-with-entries-count/index.ts":"574","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-extended/swarm-store-connector-orbit-db-with-entries-count/swarm-store-connector-orbit-db-with-entries-count.ts":"575","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.test.ts":"576","/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/queued-encryption-class-base.test.ts":"577","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/swarm-message-subclass-validator-signature-validator.test.ts":"578","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class-extended/swarm-store-class-with-entries-count/swarm-store-class-with-entries-count-mixin.ts":"579","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class-extended/swarm-store-class-with-entries-count/swarm-store-class-with-entries-count.types.ts":"580","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-credentials/index.ts":"581","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-credentials/secret-storage-class-utils-credentials.ts":"582","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge-fabric/connection-bridge-fabric.ts":"583","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge-fabric/index.ts":"584","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge-fabric/connection-bridge-fabric.types.ts":"585","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-fabric/swarm-messages-database-fabric.ts":"586","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-fabric/index.ts":"587","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-fabric/swarm-messages-database-fabric.types.ts":"588","/home/paul/projects/protocol/src/types/credentials.types.ts":"589","/home/paul/projects/protocol/src/components/const/connect-to-swarm-immediate.const.ts":"590","/home/paul/projects/protocol/src/components/const/connect-to-swarm.const.ts":"591","/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils-libp2p/index.ts":"592"},{"size":315454,"mtime":1596130938122,"results":"593","hashOfConfig":"594"},{"size":3256798,"mtime":1596130938134,"results":"595","hashOfConfig":"594"},{"size":44,"mtime":1594985692484,"results":"596","hashOfConfig":"594"},{"size":2379,"mtime":1594985692484,"results":"597","hashOfConfig":"594"},{"size":33,"mtime":1605967486756,"results":"598","hashOfConfig":"599"},{"size":581,"mtime":1605967486756,"results":"600","hashOfConfig":"599"},{"size":43,"mtime":1605967486756,"results":"601","hashOfConfig":"599"},{"size":163,"mtime":1605967486756,"results":"602","hashOfConfig":"599"},{"size":93,"mtime":1605967486756,"results":"603","hashOfConfig":"599"},{"size":216,"mtime":1605967486756,"results":"604","hashOfConfig":"599"},{"size":3197,"mtime":1605968829338,"results":"605","hashOfConfig":"599"},{"size":1917,"mtime":1605967486756,"results":"606","hashOfConfig":"599"},{"size":545,"mtime":1605967486756,"results":"607","hashOfConfig":"599"},{"size":140,"mtime":1605967486756,"results":"608","hashOfConfig":"599"},{"size":603,"mtime":1605967486756,"results":"609","hashOfConfig":"599"},{"size":588,"mtime":1605967486756,"results":"610","hashOfConfig":"599"},{"size":52,"mtime":1605967486756,"results":"611","hashOfConfig":"599"},{"size":368,"mtime":1605967486756,"results":"612","hashOfConfig":"599"},{"size":44,"mtime":1605967486756,"results":"613","hashOfConfig":"599"},{"size":2748,"mtime":1605967486756,"results":"614","hashOfConfig":"599"},{"size":1648,"mtime":1605968964505,"results":"615","hashOfConfig":"599"},{"size":4229,"mtime":1605967486756,"results":"616","hashOfConfig":"599"},{"size":4309,"mtime":1605967486756,"results":"617","hashOfConfig":"599"},{"size":1310,"mtime":1605967486756,"results":"618","hashOfConfig":"599"},{"size":8180,"mtime":1605968305372,"results":"619","hashOfConfig":"599"},{"size":1846,"mtime":1605967486756,"results":"620","hashOfConfig":"599"},{"size":2574,"mtime":1605967486756,"results":"621","hashOfConfig":"599"},{"size":193,"mtime":1605967486756,"results":"622","hashOfConfig":"599"},{"size":89,"mtime":1605967486756,"results":"623","hashOfConfig":"599"},{"size":712,"mtime":1605967486756,"results":"624","hashOfConfig":"599"},{"size":1648,"mtime":1605967486756,"results":"625","hashOfConfig":"599"},{"size":146,"mtime":1605967486756,"results":"626","hashOfConfig":"599"},{"size":191,"mtime":1605967486756,"results":"627","hashOfConfig":"599"},{"size":2570,"mtime":1605967486756,"results":"628","hashOfConfig":"599"},{"size":971,"mtime":1605967486756,"results":"629","hashOfConfig":"599"},{"size":103,"mtime":1605967486756,"results":"630","hashOfConfig":"599"},{"size":4732,"mtime":1605967486756,"results":"631","hashOfConfig":"599"},{"size":2627,"mtime":1605967486756,"results":"632","hashOfConfig":"599"},{"size":125,"mtime":1605967486756,"results":"633","hashOfConfig":"599"},{"size":58,"mtime":1605967486756,"results":"634","hashOfConfig":"599"},{"size":2069,"mtime":1605967486756,"results":"635","hashOfConfig":"599"},{"size":216,"mtime":1605967486756,"results":"636","hashOfConfig":"599"},{"size":2021,"mtime":1605967486756,"results":"637","hashOfConfig":"599"},{"size":765,"mtime":1605967486756,"results":"638","hashOfConfig":"599"},{"size":66,"mtime":1605967486756,"results":"639","hashOfConfig":"599"},{"size":185,"mtime":1605967486756,"results":"640","hashOfConfig":"599"},{"size":3003,"mtime":1605967486756,"results":"641","hashOfConfig":"599"},{"size":895,"mtime":1605967486756,"results":"642","hashOfConfig":"599"},{"size":881,"mtime":1605967486756,"results":"643","hashOfConfig":"599"},{"size":187,"mtime":1605967486756,"results":"644","hashOfConfig":"599"},{"size":237,"mtime":1605967486756,"results":"645","hashOfConfig":"599"},{"size":1560,"mtime":1605967486760,"results":"646","hashOfConfig":"599"},{"size":81,"mtime":1605967486760,"results":"647","hashOfConfig":"599"},{"size":360,"mtime":1605967486760,"results":"648","hashOfConfig":"599"},{"size":1767,"mtime":1605967486760,"results":"649","hashOfConfig":"599"},{"size":169,"mtime":1605967486760,"results":"650","hashOfConfig":"599"},{"size":738,"mtime":1605967486760,"results":"651","hashOfConfig":"599"},{"size":224,"mtime":1605967486760,"results":"652","hashOfConfig":"599"},{"size":369,"mtime":1605967486760,"results":"653","hashOfConfig":"599"},{"size":2614,"mtime":1605967486760,"results":"654","hashOfConfig":"599"},{"size":293,"mtime":1605967486760,"results":"655","hashOfConfig":"599"},{"size":777,"mtime":1605967486760,"results":"656","hashOfConfig":"599"},{"size":1848,"mtime":1605967486760,"results":"657","hashOfConfig":"599"},{"size":157,"mtime":1605967486760,"results":"658","hashOfConfig":"599"},{"size":1075,"mtime":1605967486760,"results":"659","hashOfConfig":"599"},{"size":1904,"mtime":1605967486760,"results":"660","hashOfConfig":"599"},{"size":157,"mtime":1605967486760,"results":"661","hashOfConfig":"599"},{"size":671,"mtime":1605967486760,"results":"662","hashOfConfig":"599"},{"size":215,"mtime":1605967486760,"results":"663","hashOfConfig":"599"},{"size":340,"mtime":1605967486760,"results":"664","hashOfConfig":"599"},{"size":3758,"mtime":1605967486760,"results":"665","hashOfConfig":"599"},{"size":281,"mtime":1605967486760,"results":"666","hashOfConfig":"599"},{"size":1670,"mtime":1605967486760,"results":"667","hashOfConfig":"599"},{"size":70,"mtime":1605967486760,"results":"668","hashOfConfig":"599"},{"size":1692,"mtime":1605967486760,"results":"669","hashOfConfig":"599"},{"size":70,"mtime":1605967486760,"results":"670","hashOfConfig":"599"},{"size":676,"mtime":1605967486760,"results":"671","hashOfConfig":"599"},{"size":224,"mtime":1605967486760,"results":"672","hashOfConfig":"599"},{"size":76,"mtime":1605967486760,"results":"673","hashOfConfig":"599"},{"size":3884,"mtime":1605967486760,"results":"674","hashOfConfig":"599"},{"size":293,"mtime":1605967486760,"results":"675","hashOfConfig":"599"},{"size":1023,"mtime":1605967486760,"results":"676","hashOfConfig":"599"},{"size":7240,"mtime":1605967486760,"results":"677","hashOfConfig":"599"},{"size":2886,"mtime":1605967486760,"results":"678","hashOfConfig":"599"},{"size":185,"mtime":1605967486760,"results":"679","hashOfConfig":"599"},{"size":2192,"mtime":1605967486760,"results":"680","hashOfConfig":"599"},{"size":31829,"mtime":1605967486760,"results":"681","hashOfConfig":"599"},{"size":6892,"mtime":1605967486760,"results":"682","hashOfConfig":"599"},{"size":130,"mtime":1605967486760,"results":"683","hashOfConfig":"599"},{"size":37730,"mtime":1605968520894,"results":"684","hashOfConfig":"599"},{"size":261,"mtime":1605967486764,"results":"685","hashOfConfig":"599"},{"size":62,"mtime":1605967486764,"results":"686","hashOfConfig":"599"},{"size":20746,"mtime":1605967486764,"results":"687","hashOfConfig":"599"},{"size":83,"mtime":1605967486764,"results":"688","hashOfConfig":"599"},{"size":307,"mtime":1605967486764,"results":"689","hashOfConfig":"599"},{"size":15002,"mtime":1605968305372,"results":"690","hashOfConfig":"599"},{"size":1484,"mtime":1605967486764,"results":"691","hashOfConfig":"599"},{"size":263,"mtime":1605967486764,"results":"692","hashOfConfig":"599"},{"size":145,"mtime":1605967486764,"results":"693","hashOfConfig":"599"},{"size":4331,"mtime":1605967486764,"results":"694","hashOfConfig":"599"},{"size":151,"mtime":1605967486764,"results":"695","hashOfConfig":"599"},{"size":622,"mtime":1605967486764,"results":"696","hashOfConfig":"599"},{"size":730,"mtime":1605967486764,"results":"697","hashOfConfig":"599"},{"size":155,"mtime":1605967486764,"results":"698","hashOfConfig":"599"},{"size":231,"mtime":1605967486764,"results":"699","hashOfConfig":"599"},{"size":79,"mtime":1605967486764,"results":"700","hashOfConfig":"599"},{"size":110,"mtime":1605967486764,"results":"701","hashOfConfig":"599"},{"size":77,"mtime":1605967486764,"results":"702","hashOfConfig":"599"},{"size":75,"mtime":1605967486764,"results":"703","hashOfConfig":"599"},{"size":285,"mtime":1605967486764,"results":"704","hashOfConfig":"599"},{"size":713,"mtime":1605967486764,"results":"705","hashOfConfig":"599"},{"size":306,"mtime":1605967486764,"results":"706","hashOfConfig":"599"},{"size":346,"mtime":1605967486764,"results":"707","hashOfConfig":"599"},{"size":385,"mtime":1605967486764,"results":"708","hashOfConfig":"599"},{"size":333,"mtime":1605967486764,"results":"709","hashOfConfig":"599"},{"size":130,"mtime":1605967486764,"results":"710","hashOfConfig":"599"},{"size":186,"mtime":1605967486764,"results":"711","hashOfConfig":"599"},{"size":25560,"mtime":1605967486764,"results":"712","hashOfConfig":"599"},{"size":3994,"mtime":1605967486764,"results":"713","hashOfConfig":"599"},{"size":115,"mtime":1605967486764,"results":"714","hashOfConfig":"599"},{"size":758,"mtime":1605967486764,"results":"715","hashOfConfig":"599"},{"size":846,"mtime":1605967486764,"results":"716","hashOfConfig":"599"},{"size":181,"mtime":1605967486764,"results":"717","hashOfConfig":"599"},{"size":188,"mtime":1605967486764,"results":"718","hashOfConfig":"599"},{"size":1258,"mtime":1605967486764,"results":"719","hashOfConfig":"599"},{"size":123,"mtime":1605967486764,"results":"720","hashOfConfig":"599"},{"size":575,"mtime":1605967486764,"results":"721","hashOfConfig":"599"},{"size":5177,"mtime":1605967486764,"results":"722","hashOfConfig":"599"},{"size":111,"mtime":1605967486764,"results":"723","hashOfConfig":"599"},{"size":894,"mtime":1605967486764,"results":"724","hashOfConfig":"599"},{"size":18952,"mtime":1605967486764,"results":"725","hashOfConfig":"599"},{"size":2022,"mtime":1605967486764,"results":"726","hashOfConfig":"599"},{"size":224,"mtime":1605967486764,"results":"727","hashOfConfig":"599"},{"size":70,"mtime":1605967486764,"results":"728","hashOfConfig":"599"},{"size":1586,"mtime":1605967486764,"results":"729","hashOfConfig":"599"},{"size":15257,"mtime":1605968305372,"results":"730","hashOfConfig":"599"},{"size":3658,"mtime":1605967486764,"results":"731","hashOfConfig":"599"},{"size":248,"mtime":1605967486764,"results":"732","hashOfConfig":"599"},{"size":78,"mtime":1605967486764,"results":"733","hashOfConfig":"599"},{"size":126,"mtime":1605967486764,"results":"734","hashOfConfig":"599"},{"size":15730,"mtime":1605967486764,"results":"735","hashOfConfig":"599"},{"size":1936,"mtime":1605967486764,"results":"736","hashOfConfig":"599"},{"size":135,"mtime":1605967486764,"results":"737","hashOfConfig":"599"},{"size":3898,"mtime":1605967486764,"results":"738","hashOfConfig":"599"},{"size":3583,"mtime":1605967486764,"results":"739","hashOfConfig":"599"},{"size":7530,"mtime":1605967486764,"results":"740","hashOfConfig":"599"},{"size":4884,"mtime":1605967486764,"results":"741","hashOfConfig":"599"},{"size":451,"mtime":1605967486764,"results":"742","hashOfConfig":"599"},{"size":310,"mtime":1605967486764,"results":"743","hashOfConfig":"599"},{"size":365,"mtime":1605967486764,"results":"744","hashOfConfig":"599"},{"size":3176,"mtime":1605967486768,"results":"745","hashOfConfig":"599"},{"size":255,"mtime":1605967486768,"results":"746","hashOfConfig":"599"},{"size":14511,"mtime":1605968305372,"results":"747","hashOfConfig":"599"},{"size":206,"mtime":1605967486768,"results":"748","hashOfConfig":"599"},{"size":117,"mtime":1605967486768,"results":"749","hashOfConfig":"599"},{"size":3750,"mtime":1605967486768,"results":"750","hashOfConfig":"599"},{"size":65,"mtime":1605967486768,"results":"751","hashOfConfig":"599"},{"size":652,"mtime":1605967486768,"results":"752","hashOfConfig":"599"},{"size":4604,"mtime":1605967486768,"results":"753","hashOfConfig":"599"},{"size":129,"mtime":1605967486768,"results":"754","hashOfConfig":"599"},{"size":1576,"mtime":1605967486768,"results":"755","hashOfConfig":"599"},{"size":500,"mtime":1605967486768,"results":"756","hashOfConfig":"599"},{"size":115,"mtime":1605967486768,"results":"757","hashOfConfig":"599"},{"size":180,"mtime":1605967486768,"results":"758","hashOfConfig":"599"},{"size":243,"mtime":1605967486768,"results":"759","hashOfConfig":"599"},{"size":2559,"mtime":1605967486768,"results":"760","hashOfConfig":"599"},{"size":46013,"mtime":1605968993513,"results":"761","hashOfConfig":"599"},{"size":16004,"mtime":1605967486768,"results":"762","hashOfConfig":"599"},{"size":37,"mtime":1605967486768,"results":"763","hashOfConfig":"599"},{"size":250,"mtime":1605967486768,"results":"764","hashOfConfig":"599"},{"size":2852,"mtime":1605967486768,"results":"765","hashOfConfig":"599"},{"size":401,"mtime":1605967486768,"results":"766","hashOfConfig":"599"},{"size":296,"mtime":1605967486768,"results":"767","hashOfConfig":"599"},{"size":352,"mtime":1605967486768,"results":"768","hashOfConfig":"599"},{"size":7019,"mtime":1605967486768,"results":"769","hashOfConfig":"599"},{"size":1529,"mtime":1605967486768,"results":"770","hashOfConfig":"599"},{"size":296,"mtime":1605967486768,"results":"771","hashOfConfig":"599"},{"size":51,"mtime":1605967486768,"results":"772","hashOfConfig":"599"},{"size":1361,"mtime":1605967486768,"results":"773","hashOfConfig":"599"},{"size":4910,"mtime":1605967486768,"results":"774","hashOfConfig":"599"},{"size":8293,"mtime":1605967486768,"results":"775","hashOfConfig":"599"},{"size":125,"mtime":1605967486768,"results":"776","hashOfConfig":"599"},{"size":381,"mtime":1605967486768,"results":"777","hashOfConfig":"599"},{"size":110,"mtime":1605967486768,"results":"778","hashOfConfig":"599"},{"size":46,"mtime":1605967486768,"results":"779","hashOfConfig":"599"},{"size":6712,"mtime":1605968305372,"results":"780","hashOfConfig":"599"},{"size":1259,"mtime":1605967486768,"results":"781","hashOfConfig":"599"},{"size":165,"mtime":1605967486768,"results":"782","hashOfConfig":"599"},{"size":839,"mtime":1605967486768,"results":"783","hashOfConfig":"599"},{"size":15097,"mtime":1605969023453,"results":"784","hashOfConfig":"599"},{"size":3114,"mtime":1605967486772,"results":"785","hashOfConfig":"599"},{"size":496,"mtime":1605967486772,"results":"786","hashOfConfig":"599"},{"size":128,"mtime":1605967486772,"results":"787","hashOfConfig":"599"},{"size":1488,"mtime":1605967486772,"results":"788","hashOfConfig":"599"},{"size":31555,"mtime":1605969079136,"results":"789","hashOfConfig":"599"},{"size":1455,"mtime":1605967486772,"results":"790","hashOfConfig":"599"},{"size":181,"mtime":1605967486772,"results":"791","hashOfConfig":"599"},{"size":160,"mtime":1605967486772,"results":"792","hashOfConfig":"599"},{"size":111,"mtime":1605967486772,"results":"793","hashOfConfig":"599"},{"size":296,"mtime":1605967486772,"results":"794","hashOfConfig":"599"},{"size":1469,"mtime":1605967486772,"results":"795","hashOfConfig":"599"},{"size":51,"mtime":1605967486772,"results":"796","hashOfConfig":"599"},{"size":1376,"mtime":1605967486772,"results":"797","hashOfConfig":"599"},{"size":55,"mtime":1605967486772,"results":"798","hashOfConfig":"599"},{"size":557,"mtime":1605967486772,"results":"799","hashOfConfig":"599"},{"size":363,"mtime":1605967486772,"results":"800","hashOfConfig":"599"},{"size":30435,"mtime":1605967486772,"results":"801","hashOfConfig":"599"},{"size":4388,"mtime":1605967486772,"results":"802","hashOfConfig":"599"},{"size":50,"mtime":1605967486772,"results":"803","hashOfConfig":"599"},{"size":198,"mtime":1605967486772,"results":"804","hashOfConfig":"599"},{"size":4859,"mtime":1605969102088,"results":"805","hashOfConfig":"599"},{"size":1186,"mtime":1605967486772,"results":"806","hashOfConfig":"599"},{"size":325,"mtime":1605967486772,"results":"807","hashOfConfig":"599"},{"size":111,"mtime":1605967486772,"results":"808","hashOfConfig":"599"},{"size":80,"mtime":1605967486772,"results":"809","hashOfConfig":"599"},{"size":6198,"mtime":1605968305372,"results":"810","hashOfConfig":"599"},{"size":119,"mtime":1605967486772,"results":"811","hashOfConfig":"599"},{"size":212,"mtime":1605967486772,"results":"812","hashOfConfig":"599"},{"size":6978,"mtime":1605968305372,"results":"813","hashOfConfig":"599"},{"size":57,"mtime":1605967486772,"results":"814","hashOfConfig":"599"},{"size":3081,"mtime":1605968305372,"results":"815","hashOfConfig":"599"},{"size":1153,"mtime":1605967486772,"results":"816","hashOfConfig":"599"},{"size":620,"mtime":1605967486772,"results":"817","hashOfConfig":"599"},{"size":2230,"mtime":1605967486772,"results":"818","hashOfConfig":"599"},{"size":59,"mtime":1605967486772,"results":"819","hashOfConfig":"599"},{"size":3075,"mtime":1605968305376,"results":"820","hashOfConfig":"599"},{"size":234,"mtime":1605967486772,"results":"821","hashOfConfig":"599"},{"size":2052,"mtime":1605967486772,"results":"822","hashOfConfig":"599"},{"size":13556,"mtime":1605969162195,"results":"823","hashOfConfig":"599"},{"size":8748,"mtime":1605967486776,"results":"824","hashOfConfig":"599"},{"size":157,"mtime":1605967486776,"results":"825","hashOfConfig":"599"},{"size":105,"mtime":1605967486776,"results":"826","hashOfConfig":"599"},{"size":6865,"mtime":1605967486776,"results":"827","hashOfConfig":"599"},{"size":2524,"mtime":1605967486776,"results":"828","hashOfConfig":"599"},{"size":173,"mtime":1605967486776,"results":"829","hashOfConfig":"599"},{"size":76,"mtime":1605967486776,"results":"830","hashOfConfig":"599"},{"size":11437,"mtime":1605967486776,"results":"831","hashOfConfig":"599"},{"size":4923,"mtime":1605967486776,"results":"832","hashOfConfig":"599"},{"size":313,"mtime":1605967486776,"results":"833","hashOfConfig":"599"},{"size":226,"mtime":1605967486776,"results":"834","hashOfConfig":"599"},{"size":714,"mtime":1605967486776,"results":"835","hashOfConfig":"599"},{"size":163,"mtime":1605967486776,"results":"836","hashOfConfig":"599"},{"size":308,"mtime":1605967486776,"results":"837","hashOfConfig":"599"},{"size":773,"mtime":1605967486776,"results":"838","hashOfConfig":"599"},{"size":165,"mtime":1605967486776,"results":"839","hashOfConfig":"599"},{"size":129,"mtime":1605967486776,"results":"840","hashOfConfig":"599"},{"size":820,"mtime":1605967486776,"results":"841","hashOfConfig":"599"},{"size":203,"mtime":1605967486776,"results":"842","hashOfConfig":"599"},{"size":547,"mtime":1605967486776,"results":"843","hashOfConfig":"599"},{"size":54,"mtime":1605967486776,"results":"844","hashOfConfig":"599"},{"size":201,"mtime":1605967486776,"results":"845","hashOfConfig":"599"},{"size":548,"mtime":1605967486776,"results":"846","hashOfConfig":"599"},{"size":53,"mtime":1605967486776,"results":"847","hashOfConfig":"599"},{"size":275,"mtime":1605967486776,"results":"848","hashOfConfig":"599"},{"size":494,"mtime":1605967486776,"results":"849","hashOfConfig":"599"},{"size":2266,"mtime":1605967486776,"results":"850","hashOfConfig":"599"},{"size":237,"mtime":1605967486776,"results":"851","hashOfConfig":"599"},{"size":281,"mtime":1605967486776,"results":"852","hashOfConfig":"599"},{"size":801,"mtime":1605967486776,"results":"853","hashOfConfig":"599"},{"size":1843,"mtime":1605967486776,"results":"854","hashOfConfig":"599"},{"size":214,"mtime":1605967486776,"results":"855","hashOfConfig":"599"},{"size":175,"mtime":1605967486776,"results":"856","hashOfConfig":"599"},{"size":884,"mtime":1605967486776,"results":"857","hashOfConfig":"599"},{"size":49,"mtime":1605967486776,"results":"858","hashOfConfig":"599"},{"size":299,"mtime":1605967486776,"results":"859","hashOfConfig":"599"},{"size":260,"mtime":1605967486776,"results":"860","hashOfConfig":"599"},{"size":1860,"mtime":1605967486776,"results":"861","hashOfConfig":"599"},{"size":60,"mtime":1605967486776,"results":"862","hashOfConfig":"599"},{"size":13673,"mtime":1605967486776,"results":"863","hashOfConfig":"599"},{"size":3819,"mtime":1605967486776,"results":"864","hashOfConfig":"599"},{"size":151,"mtime":1605967486776,"results":"865","hashOfConfig":"599"},{"size":6420,"mtime":1605967486776,"results":"866","hashOfConfig":"599"},{"size":1539,"mtime":1605967486776,"results":"867","hashOfConfig":"599"},{"size":760,"mtime":1605967486776,"results":"868","hashOfConfig":"599"},{"size":3379,"mtime":1605967486776,"results":"869","hashOfConfig":"599"},{"size":2146,"mtime":1605967486776,"results":"870","hashOfConfig":"599"},{"size":271,"mtime":1605967486780,"results":"871","hashOfConfig":"599"},{"size":109,"mtime":1605967486780,"results":"872","hashOfConfig":"599"},{"size":185,"mtime":1605967486780,"results":"873","hashOfConfig":"599"},{"size":201,"mtime":1605967486780,"results":"874","hashOfConfig":"599"},{"size":117,"mtime":1605967486780,"results":"875","hashOfConfig":"599"},{"size":205,"mtime":1605967486780,"results":"876","hashOfConfig":"599"},{"size":205,"mtime":1605967486780,"results":"877","hashOfConfig":"599"},{"size":115,"mtime":1605967486780,"results":"878","hashOfConfig":"599"},{"size":197,"mtime":1605967486780,"results":"879","hashOfConfig":"599"},{"size":205,"mtime":1605967486780,"results":"880","hashOfConfig":"599"},{"size":123,"mtime":1605967486780,"results":"881","hashOfConfig":"599"},{"size":217,"mtime":1605967486780,"results":"882","hashOfConfig":"599"},{"size":209,"mtime":1605967486780,"results":"883","hashOfConfig":"599"},{"size":159,"mtime":1605967486780,"results":"884","hashOfConfig":"599"},{"size":97,"mtime":1605967486780,"results":"885","hashOfConfig":"599"},{"size":708,"mtime":1605967486780,"results":"886","hashOfConfig":"599"},{"size":199,"mtime":1605967486780,"results":"887","hashOfConfig":"599"},{"size":177,"mtime":1605967486772,"results":"888","hashOfConfig":"599"},{"size":125,"mtime":1605967486772,"results":"889","hashOfConfig":"599"},{"size":52,"mtime":1605967486772,"results":"890","hashOfConfig":"599"},{"size":4693,"mtime":1605968305376,"results":"891","hashOfConfig":"599"},{"size":72,"mtime":1605967486772,"results":"892","hashOfConfig":"599"},{"size":12610,"mtime":1605967486772,"results":"893","hashOfConfig":"599"},{"size":2655,"mtime":1605967486772,"results":"894","hashOfConfig":"599"},{"size":45067,"mtime":1605967486772,"results":"895","hashOfConfig":"599"},{"size":19917,"mtime":1605967486772,"results":"896","hashOfConfig":"599"},{"size":105,"mtime":1605967486780,"results":"897","hashOfConfig":"599"},{"size":2896,"mtime":1605967486780,"results":"898","hashOfConfig":"599"},{"size":312,"mtime":1605967486780,"results":"899","hashOfConfig":"599"},{"size":6410,"mtime":1605967486780,"results":"900","hashOfConfig":"599"},{"size":4105,"mtime":1605967486780,"results":"901","hashOfConfig":"599"},{"size":215,"mtime":1605967486780,"results":"902","hashOfConfig":"599"},{"size":3773,"mtime":1605967486780,"results":"903","hashOfConfig":"599"},{"size":23951,"mtime":1605969833234,"results":"904","hashOfConfig":"599"},{"size":22483,"mtime":1605967486780,"results":"905","hashOfConfig":"599"},{"size":50,"mtime":1605967486780,"results":"906","hashOfConfig":"599"},{"size":286,"mtime":1605967486780,"results":"907","hashOfConfig":"599"},{"size":582,"mtime":1605967486784,"results":"908","hashOfConfig":"599"},{"size":245,"mtime":1605967486784,"results":"909","hashOfConfig":"599"},{"size":268,"mtime":1605967486784,"results":"910","hashOfConfig":"599"},{"size":7411,"mtime":1605968305376,"results":"911","hashOfConfig":"599"},{"size":2918,"mtime":1605967486784,"results":"912","hashOfConfig":"599"},{"size":327,"mtime":1605967486784,"results":"913","hashOfConfig":"599"},{"size":1313,"mtime":1605967486784,"results":"914","hashOfConfig":"599"},{"size":41258,"mtime":1605971489344,"results":"915","hashOfConfig":"599"},{"size":6558,"mtime":1605967486784,"results":"916","hashOfConfig":"599"},{"size":161,"mtime":1605967486784,"results":"917","hashOfConfig":"599"},{"size":124,"mtime":1605967486784,"results":"918","hashOfConfig":"599"},{"size":2864,"mtime":1605967486784,"results":"919","hashOfConfig":"599"},{"size":218,"mtime":1605967486784,"results":"920","hashOfConfig":"599"},{"size":157,"mtime":1605967486784,"results":"921","hashOfConfig":"599"},{"size":674,"mtime":1605967486784,"results":"922","hashOfConfig":"599"},{"size":1514,"mtime":1605967486784,"results":"923","hashOfConfig":"599"},{"size":73,"mtime":1605967486784,"results":"924","hashOfConfig":"599"},{"size":811,"mtime":1605967486784,"results":"925","hashOfConfig":"599"},{"size":155,"mtime":1605967486784,"results":"926","hashOfConfig":"599"},{"size":7711,"mtime":1605967486784,"results":"927","hashOfConfig":"599"},{"size":1443,"mtime":1605967486784,"results":"928","hashOfConfig":"599"},{"size":1172,"mtime":1605967486784,"results":"929","hashOfConfig":"599"},{"size":42613,"mtime":1605970394487,"results":"930","hashOfConfig":"599"},{"size":3340,"mtime":1605967486784,"results":"931","hashOfConfig":"599"},{"size":260,"mtime":1605967486784,"results":"932","hashOfConfig":"599"},{"size":2188,"mtime":1605967486784,"results":"933","hashOfConfig":"599"},{"size":17952,"mtime":1605970544260,"results":"934","hashOfConfig":"599"},{"size":1228,"mtime":1605967486784,"results":"935","hashOfConfig":"599"},{"size":129,"mtime":1605967486784,"results":"936","hashOfConfig":"599"},{"size":3882,"mtime":1605970559296,"results":"937","hashOfConfig":"599"},{"size":1039,"mtime":1605967486784,"results":"938","hashOfConfig":"599"},{"size":38,"mtime":1605967486784,"results":"939","hashOfConfig":"599"},{"size":42,"mtime":1605967486784,"results":"940","hashOfConfig":"599"},{"size":1397,"mtime":1605967486784,"results":"941","hashOfConfig":"599"},{"size":72,"mtime":1605967486788,"results":"942","hashOfConfig":"599"},{"size":434,"mtime":1605967486788,"results":"943","hashOfConfig":"599"},{"size":54,"mtime":1605967486788,"results":"944","hashOfConfig":"599"},{"size":148,"mtime":1605967486788,"results":"945","hashOfConfig":"599"},{"size":27,"mtime":1605967486788,"results":"946","hashOfConfig":"599"},{"size":226,"mtime":1605967486788,"results":"947","hashOfConfig":"599"},{"size":71,"mtime":1605967486788,"results":"948","hashOfConfig":"599"},{"size":78,"mtime":1605967486788,"results":"949","hashOfConfig":"599"},{"size":206,"mtime":1605967486788,"results":"950","hashOfConfig":"599"},{"size":37,"mtime":1605967486788,"results":"951","hashOfConfig":"599"},{"size":1745,"mtime":1605967486788,"results":"952","hashOfConfig":"599"},{"size":49,"mtime":1605967486788,"results":"953","hashOfConfig":"599"},{"size":1713,"mtime":1605967486788,"results":"954","hashOfConfig":"599"},{"size":455,"mtime":1605967486788,"results":"955","hashOfConfig":"599"},{"size":56,"mtime":1605967486788,"results":"956","hashOfConfig":"599"},{"size":153,"mtime":1605967486788,"results":"957","hashOfConfig":"599"},{"size":1258,"mtime":1605967486788,"results":"958","hashOfConfig":"599"},{"size":58,"mtime":1605967486788,"results":"959","hashOfConfig":"599"},{"size":592,"mtime":1605967486788,"results":"960","hashOfConfig":"599"},{"size":118,"mtime":1605970415252,"results":"961","hashOfConfig":"599"},{"size":118,"mtime":1605970758069,"results":"962","hashOfConfig":"599"},{"size":27,"mtime":1605967486788,"results":"963","hashOfConfig":"599"},{"size":40,"mtime":1605967486788,"results":"964","hashOfConfig":"599"},{"size":528,"mtime":1605967486788,"results":"965","hashOfConfig":"599"},{"size":444,"mtime":1605967486788,"results":"966","hashOfConfig":"599"},{"size":205,"mtime":1605967486788,"results":"967","hashOfConfig":"599"},{"size":1509,"mtime":1605967486788,"results":"968","hashOfConfig":"599"},{"size":422,"mtime":1605967486788,"results":"969","hashOfConfig":"599"},{"size":23,"mtime":1605967486788,"results":"970","hashOfConfig":"599"},{"size":11264,"mtime":1605967486788,"results":"971","hashOfConfig":"599"},{"size":35,"mtime":1605967486788,"results":"972","hashOfConfig":"599"},{"size":51,"mtime":1605967486788,"results":"973","hashOfConfig":"599"},{"size":48,"mtime":1605967486788,"results":"974","hashOfConfig":"599"},{"size":35,"mtime":1605967486788,"results":"975","hashOfConfig":"599"},{"size":33,"mtime":1605967486788,"results":"976","hashOfConfig":"599"},{"size":1466,"mtime":1605967486788,"results":"977","hashOfConfig":"599"},{"size":31,"mtime":1605967486788,"results":"978","hashOfConfig":"599"},{"size":30,"mtime":1605967486788,"results":"979","hashOfConfig":"599"},{"size":245,"mtime":1605967486788,"results":"980","hashOfConfig":"599"},{"size":227,"mtime":1605967486788,"results":"981","hashOfConfig":"599"},{"size":85,"mtime":1605967486788,"results":"982","hashOfConfig":"599"},{"size":37,"mtime":1605967486788,"results":"983","hashOfConfig":"599"},{"size":40,"mtime":1605967486788,"results":"984","hashOfConfig":"599"},{"size":263,"mtime":1605967486788,"results":"985","hashOfConfig":"599"},{"size":25,"mtime":1605967486788,"results":"986","hashOfConfig":"599"},{"size":393,"mtime":1605967486788,"results":"987","hashOfConfig":"599"},{"size":28,"mtime":1605967486788,"results":"988","hashOfConfig":"599"},{"size":2965,"mtime":1605967486788,"results":"989","hashOfConfig":"599"},{"size":261,"mtime":1605967486788,"results":"990","hashOfConfig":"599"},{"size":1309,"mtime":1605967486788,"results":"991","hashOfConfig":"599"},{"size":43,"mtime":1605967486788,"results":"992","hashOfConfig":"599"},{"size":29,"mtime":1605967486788,"results":"993","hashOfConfig":"599"},{"size":248,"mtime":1605967486788,"results":"994","hashOfConfig":"599"},{"size":338,"mtime":1605967486788,"results":"995","hashOfConfig":"599"},{"size":6284,"mtime":1605967486788,"results":"996","hashOfConfig":"599"},{"size":72,"mtime":1605967486788,"results":"997","hashOfConfig":"599"},{"size":2441,"mtime":1605967486788,"results":"998","hashOfConfig":"599"},{"size":266,"mtime":1605967486788,"results":"999","hashOfConfig":"599"},{"size":2437,"mtime":1605967486788,"results":"1000","hashOfConfig":"599"},{"size":1190,"mtime":1605967486788,"results":"1001","hashOfConfig":"599"},{"size":1530,"mtime":1605967486788,"results":"1002","hashOfConfig":"599"},{"size":345,"mtime":1605967486788,"results":"1003","hashOfConfig":"599"},{"size":521,"mtime":1605967486788,"results":"1004","hashOfConfig":"599"},{"size":38,"mtime":1605967486788,"results":"1005","hashOfConfig":"599"},{"size":573,"mtime":1605967486788,"results":"1006","hashOfConfig":"599"},{"size":66,"mtime":1605967486788,"results":"1007","hashOfConfig":"599"},{"size":3770,"mtime":1605967486792,"results":"1008","hashOfConfig":"599"},{"size":178,"mtime":1605967486792,"results":"1009","hashOfConfig":"599"},{"size":176,"mtime":1605967486792,"results":"1010","hashOfConfig":"599"},{"size":145,"mtime":1605967486792,"results":"1011","hashOfConfig":"599"},{"size":532,"mtime":1605967486792,"results":"1012","hashOfConfig":"599"},{"size":63,"mtime":1605967486792,"results":"1013","hashOfConfig":"599"},{"size":50,"mtime":1605967486792,"results":"1014","hashOfConfig":"599"},{"size":142,"mtime":1605967486792,"results":"1015","hashOfConfig":"599"},{"size":1742,"mtime":1605967486792,"results":"1016","hashOfConfig":"599"},{"size":136,"mtime":1605967486792,"results":"1017","hashOfConfig":"599"},{"size":2214,"mtime":1605967486792,"results":"1018","hashOfConfig":"599"},{"size":303,"mtime":1605967486792,"results":"1019","hashOfConfig":"599"},{"size":12744,"mtime":1605968305376,"results":"1020","hashOfConfig":"599"},{"size":497,"mtime":1605967486792,"results":"1021","hashOfConfig":"599"},{"size":1923,"mtime":1605967486792,"results":"1022","hashOfConfig":"599"},{"size":2240,"mtime":1605967486792,"results":"1023","hashOfConfig":"599"},{"size":986,"mtime":1605967486792,"results":"1024","hashOfConfig":"599"},{"size":48,"mtime":1605967486792,"results":"1025","hashOfConfig":"599"},{"size":90,"mtime":1605967486792,"results":"1026","hashOfConfig":"599"},{"size":281,"mtime":1605967486792,"results":"1027","hashOfConfig":"599"},{"size":6551,"mtime":1605967486792,"results":"1028","hashOfConfig":"599"},{"size":89,"mtime":1605967486792,"results":"1029","hashOfConfig":"599"},{"size":1897,"mtime":1605967486792,"results":"1030","hashOfConfig":"599"},{"size":2276,"mtime":1605967486792,"results":"1031","hashOfConfig":"599"},{"size":2279,"mtime":1605967486792,"results":"1032","hashOfConfig":"599"},{"size":4380,"mtime":1605967486792,"results":"1033","hashOfConfig":"599"},{"size":141,"mtime":1605967486792,"results":"1034","hashOfConfig":"599"},{"size":405,"mtime":1605967486792,"results":"1035","hashOfConfig":"599"},{"size":9751,"mtime":1605968305376,"results":"1036","hashOfConfig":"599"},{"size":153,"mtime":1605967486792,"results":"1037","hashOfConfig":"599"},{"size":186,"mtime":1605967486792,"results":"1038","hashOfConfig":"599"},{"size":3093,"mtime":1605967486792,"results":"1039","hashOfConfig":"599"},{"size":132,"mtime":1605967486792,"results":"1040","hashOfConfig":"599"},{"size":760,"mtime":1605967486792,"results":"1041","hashOfConfig":"599"},{"size":629,"mtime":1605967486792,"results":"1042","hashOfConfig":"599"},{"size":77,"mtime":1605967486792,"results":"1043","hashOfConfig":"599"},{"size":547,"mtime":1605967486792,"results":"1044","hashOfConfig":"599"},{"size":34,"mtime":1605967486792,"results":"1045","hashOfConfig":"599"},{"size":704,"mtime":1605967486792,"results":"1046","hashOfConfig":"599"},{"size":1468,"mtime":1605967486792,"results":"1047","hashOfConfig":"599"},{"size":91,"mtime":1605967486792,"results":"1048","hashOfConfig":"599"},{"size":75,"mtime":1605967486792,"results":"1049","hashOfConfig":"599"},{"size":34,"mtime":1605967486792,"results":"1050","hashOfConfig":"599"},{"size":672,"mtime":1605967486792,"results":"1051","hashOfConfig":"599"},{"size":67,"mtime":1605967486792,"results":"1052","hashOfConfig":"1053"},{"size":348,"mtime":1605967486792,"results":"1054","hashOfConfig":"1053"},{"size":8700,"mtime":1605967486792,"results":"1055","hashOfConfig":"1053"},{"size":3986,"mtime":1605967486792,"results":"1056","hashOfConfig":"1053"},{"size":1168,"mtime":1605967486792,"results":"1057","hashOfConfig":"1053"},{"size":38,"mtime":1605967486792,"results":"1058","hashOfConfig":"599"},{"size":554,"mtime":1605967486792,"results":"1059","hashOfConfig":"599"},{"size":702,"mtime":1605967486792,"results":"1060","hashOfConfig":"599"},{"size":3031,"mtime":1605967486792,"results":"1061","hashOfConfig":"599"},{"size":5795,"mtime":1605968305376,"results":"1062","hashOfConfig":"599"},{"size":2762,"mtime":1605967486792,"results":"1063","hashOfConfig":"599"},{"size":213,"mtime":1605967486792,"results":"1064","hashOfConfig":"599"},{"size":2106,"mtime":1605967486792,"results":"1065","hashOfConfig":"599"},{"size":461,"mtime":1605967486792,"results":"1066","hashOfConfig":"599"},{"size":575,"mtime":1605967486792,"results":"1067","hashOfConfig":"599"},{"size":428,"mtime":1605967486792,"results":"1068","hashOfConfig":"599"},{"size":3920,"mtime":1605967486792,"results":"1069","hashOfConfig":"599"},{"size":137,"mtime":1605967486792,"results":"1070","hashOfConfig":"599"},{"size":1026,"mtime":1605967486792,"results":"1071","hashOfConfig":"599"},{"size":542,"mtime":1605967486792,"results":"1072","hashOfConfig":"599"},{"size":1161,"mtime":1605967486792,"results":"1073","hashOfConfig":"599"},{"size":31,"mtime":1605967486788,"results":"1074","hashOfConfig":"599"},{"size":788,"mtime":1605967486788,"results":"1075","hashOfConfig":"599"},{"size":137,"mtime":1605967486788,"results":"1076","hashOfConfig":"599"},{"size":342,"mtime":1605967486788,"results":"1077","hashOfConfig":"599"},{"size":8236,"mtime":1605968305376,"results":"1078","hashOfConfig":"599"},{"size":3568,"mtime":1605967486788,"results":"1079","hashOfConfig":"599"},{"size":143,"mtime":1605967486780,"results":"1080","hashOfConfig":"599"},{"size":32719,"mtime":1605969807982,"results":"1081","hashOfConfig":"599"},{"size":19683,"mtime":1605967486780,"results":"1082","hashOfConfig":"599"},{"size":37,"mtime":1605967486784,"results":"1083","hashOfConfig":"599"},{"size":1360,"mtime":1605967580100,"results":"1084","hashOfConfig":"599"},{"size":53,"mtime":1605967486784,"results":"1085","hashOfConfig":"599"},{"size":12940,"mtime":1605970574448,"results":"1086","hashOfConfig":"599"},{"size":1836,"mtime":1605967486788,"results":"1087","hashOfConfig":"599"},{"size":5402,"mtime":1605967486788,"results":"1088","hashOfConfig":"599"},{"size":44,"mtime":1605967486788,"results":"1089","hashOfConfig":"599"},{"size":5997,"mtime":1605967486788,"results":"1090","hashOfConfig":"599"},{"size":185,"mtime":1605967486756,"results":"1091","hashOfConfig":"599"},{"size":46,"mtime":1605967486772,"results":"1092","hashOfConfig":"599"},{"size":3720,"mtime":1605967486772,"results":"1093","hashOfConfig":"599"},{"size":50,"mtime":1605967486772,"results":"1094","hashOfConfig":"599"},{"size":127,"mtime":1605967486772,"results":"1095","hashOfConfig":"599"},{"size":440,"mtime":1605967486772,"results":"1096","hashOfConfig":"599"},{"size":9320,"mtime":1605969212611,"results":"1097","hashOfConfig":"599"},{"size":4548,"mtime":1605967486772,"results":"1098","hashOfConfig":"599"},{"size":1264,"mtime":1605967486780,"results":"1099","hashOfConfig":"599"},{"size":92,"mtime":1605967486792,"results":"1100","hashOfConfig":"599"},{"size":164,"mtime":1605967486792,"results":"1101","hashOfConfig":"599"},{"size":144,"mtime":1605967486792,"results":"1102","hashOfConfig":"599"},{"size":1404,"mtime":1605967486792,"results":"1103","hashOfConfig":"599"},{"size":459,"mtime":1605967486792,"results":"1104","hashOfConfig":"599"},{"size":49,"mtime":1605967486780,"results":"1105","hashOfConfig":"599"},{"size":49,"mtime":1605967486780,"results":"1106","hashOfConfig":"599"},{"size":46421,"mtime":1605969504364,"results":"1107","hashOfConfig":"599"},{"size":67,"mtime":1605967486772,"results":"1108","hashOfConfig":"599"},{"size":1746,"mtime":1605967486772,"results":"1109","hashOfConfig":"599"},{"size":2069,"mtime":1605967486772,"results":"1110","hashOfConfig":"599"},{"size":216,"mtime":1605967486788,"results":"1111","hashOfConfig":"599"},{"size":790,"mtime":1605967486788,"results":"1112","hashOfConfig":"599"},{"size":1510,"mtime":1605967486792,"results":"1113","hashOfConfig":"599"},{"size":2912,"mtime":1605967486784,"results":"1114","hashOfConfig":"599"},{"size":46,"mtime":1605967486784,"results":"1115","hashOfConfig":"599"},{"size":1396,"mtime":1605967486780,"results":"1116","hashOfConfig":"599"},{"size":513,"mtime":1605967486792,"results":"1117","hashOfConfig":"599"},{"size":66,"mtime":1605967486788,"results":"1118","hashOfConfig":"599"},{"size":1503,"mtime":1605967486792,"results":"1119","hashOfConfig":"599"},{"size":7227,"mtime":1605967486780,"results":"1120","hashOfConfig":"599"},{"size":56,"mtime":1605967486780,"results":"1121","hashOfConfig":"599"},{"size":338,"mtime":1605967486780,"results":"1122","hashOfConfig":"599"},{"size":137,"mtime":1605967486780,"results":"1123","hashOfConfig":"599"},{"size":101,"mtime":1605967486780,"results":"1124","hashOfConfig":"599"},{"size":1529,"mtime":1605967486780,"results":"1125","hashOfConfig":"599"},{"size":5570,"mtime":1605967486780,"results":"1126","hashOfConfig":"599"},{"size":7850,"mtime":1605967486780,"results":"1127","hashOfConfig":"599"},{"size":7487,"mtime":1605967486780,"results":"1128","hashOfConfig":"599"},{"size":5533,"mtime":1605967486780,"results":"1129","hashOfConfig":"599"},{"size":9910,"mtime":1605967486780,"results":"1130","hashOfConfig":"599"},{"size":70,"mtime":1605967486780,"results":"1131","hashOfConfig":"599"},{"size":5160,"mtime":1605967486780,"results":"1132","hashOfConfig":"599"},{"size":74,"mtime":1605967486780,"results":"1133","hashOfConfig":"599"},{"size":6007,"mtime":1605967486780,"results":"1134","hashOfConfig":"599"},{"size":177,"mtime":1605967486788,"results":"1135","hashOfConfig":"599"},{"size":2269,"mtime":1605967486788,"results":"1136","hashOfConfig":"599"},{"size":329,"mtime":1605967486784,"results":"1137","hashOfConfig":"599"},{"size":185,"mtime":1605967486784,"results":"1138","hashOfConfig":"599"},{"size":8716,"mtime":1605967486784,"results":"1139","hashOfConfig":"599"},{"size":291,"mtime":1605967486784,"results":"1140","hashOfConfig":"599"},{"size":189,"mtime":1605967486784,"results":"1141","hashOfConfig":"599"},{"size":3832,"mtime":1605967486784,"results":"1142","hashOfConfig":"599"},{"size":295,"mtime":1605967486784,"results":"1143","hashOfConfig":"599"},{"size":489,"mtime":1605967486784,"results":"1144","hashOfConfig":"599"},{"size":798,"mtime":1605967486784,"results":"1145","hashOfConfig":"599"},{"size":109,"mtime":1605967486784,"results":"1146","hashOfConfig":"599"},{"size":135,"mtime":1605967486784,"results":"1147","hashOfConfig":"599"},{"size":731,"mtime":1605967486784,"results":"1148","hashOfConfig":"599"},{"size":5079,"mtime":1605967486784,"results":"1149","hashOfConfig":"599"},{"size":567,"mtime":1605967486784,"results":"1150","hashOfConfig":"599"},{"size":73,"mtime":1605967486788,"results":"1151","hashOfConfig":"599"},{"size":2590,"mtime":1605967486756,"results":"1152","hashOfConfig":"599"},{"size":766,"mtime":1605967486756,"results":"1153","hashOfConfig":"599"},{"size":1438,"mtime":1605967486756,"results":"1154","hashOfConfig":"599"},{"size":41,"mtime":1605967486756,"results":"1155","hashOfConfig":"599"},{"size":75,"mtime":1605967486784,"results":"1156","hashOfConfig":"599"},{"size":5205,"mtime":1605968305376,"results":"1157","hashOfConfig":"599"},{"size":836,"mtime":1605967486788,"results":"1158","hashOfConfig":"599"},{"size":10773,"mtime":1605967486768,"results":"1159","hashOfConfig":"599"},{"size":152,"mtime":1605967486784,"results":"1160","hashOfConfig":"599"},{"size":1194,"mtime":1605967486784,"results":"1161","hashOfConfig":"599"},{"size":3479,"mtime":1605967486788,"results":"1162","hashOfConfig":"599"},{"size":102,"mtime":1605967486772,"results":"1163","hashOfConfig":"599"},{"size":3035,"mtime":1605967486772,"results":"1164","hashOfConfig":"599"},{"size":56,"mtime":1605967486780,"results":"1165","hashOfConfig":"599"},{"size":259,"mtime":1605967486780,"results":"1166","hashOfConfig":"599"},{"size":1962,"mtime":1605967486780,"results":"1167","hashOfConfig":"599"},{"size":69,"mtime":1605967486780,"results":"1168","hashOfConfig":"599"},{"size":114,"mtime":1605967486784,"results":"1169","hashOfConfig":"599"},{"size":2062,"mtime":1605967486784,"results":"1170","hashOfConfig":"599"},{"size":4217,"mtime":1604678372190,"results":"1171","hashOfConfig":"1172"},{"size":7774,"mtime":1604680096306,"results":"1173","hashOfConfig":"1172"},{"size":334,"mtime":1596228865137,"results":"1174","hashOfConfig":"1172"},{"size":2877,"mtime":1605967486780,"results":"1175","hashOfConfig":"599"},{"size":5222,"mtime":1605967486780,"results":"1176","hashOfConfig":"599"},{"size":58,"mtime":1605967486772,"results":"1177","hashOfConfig":"599"},{"size":488,"mtime":1605967486772,"results":"1178","hashOfConfig":"599"},{"size":4427,"mtime":1605967486768,"results":"1179","hashOfConfig":"599"},{"size":80,"mtime":1605967486768,"results":"1180","hashOfConfig":"599"},{"size":3831,"mtime":1605967486768,"results":"1181","hashOfConfig":"599"},{"size":4324,"mtime":1605967486780,"results":"1182","hashOfConfig":"599"},{"size":146,"mtime":1605967486780,"results":"1183","hashOfConfig":"599"},{"size":6319,"mtime":1605967486780,"results":"1184","hashOfConfig":"599"},{"size":81,"mtime":1605967486788,"results":"1185","hashOfConfig":"599"},{"size":978,"mtime":1605967486784,"results":"1186","hashOfConfig":"599"},{"size":5785,"mtime":1605967486784,"results":"1187","hashOfConfig":"599"},{"size":81,"mtime":1605970659301,"results":"1188","hashOfConfig":"1053"},{"filePath":"1189","messages":"1190","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"5wmogl",{"filePath":"1191","messages":"1192","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"1193","messages":"1194","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"1195","messages":"1196","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"1197","messages":"1198","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"shnrfm",{"filePath":"1199","messages":"1200","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1201","messages":"1202","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1203","messages":"1204","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1205","messages":"1206","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1207","messages":"1208","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1209","messages":"1210","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1211"},{"filePath":"1212","messages":"1213","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1214"},{"filePath":"1215","messages":"1216","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1217"},{"filePath":"1218","messages":"1219","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1220","messages":"1221","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1222","messages":"1223","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1224"},{"filePath":"1225","messages":"1226","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1227","messages":"1228","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1229"},{"filePath":"1230","messages":"1231","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1232","messages":"1233","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1234"},{"filePath":"1235","messages":"1236","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1237"},{"filePath":"1238","messages":"1239","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1240"},{"filePath":"1241","messages":"1242","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1243"},{"filePath":"1244","messages":"1245","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1246","messages":"1247","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1248"},{"filePath":"1249","messages":"1250","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1251"},{"filePath":"1252","messages":"1253","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1254"},{"filePath":"1255","messages":"1256","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1257","messages":"1258","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1259","messages":"1260","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1261","messages":"1262","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1263"},{"filePath":"1264","messages":"1265","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1266","messages":"1267","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1268","messages":"1269","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1270"},{"filePath":"1271","messages":"1272","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1273","messages":"1274","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1275","messages":"1276","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1277"},{"filePath":"1278","messages":"1279","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1280","messages":"1281","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1282","messages":"1283","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1284","messages":"1285","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1286"},{"filePath":"1287","messages":"1288","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1289"},{"filePath":"1290","messages":"1291","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1292","messages":"1293","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1294","messages":"1295","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1296","messages":"1297","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1298","messages":"1299","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1300"},{"filePath":"1301","messages":"1302","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1303","messages":"1304","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1305","messages":"1306","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1307","messages":"1308","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1309","messages":"1310","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1311","messages":"1312","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1313","messages":"1314","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1315","messages":"1316","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1317","messages":"1318","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1319","messages":"1320","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1321","messages":"1322","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1323","messages":"1324","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1325","messages":"1326","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1327"},{"filePath":"1328","messages":"1329","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1330","messages":"1331","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1332","messages":"1333","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1334","messages":"1335","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1336","messages":"1337","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1338","messages":"1339","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1340","messages":"1341","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1342","messages":"1343","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1344","messages":"1345","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1346","messages":"1347","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1348"},{"filePath":"1349","messages":"1350","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1351","messages":"1352","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1353","messages":"1354","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1355"},{"filePath":"1356","messages":"1357","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1358","messages":"1359","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1360"},{"filePath":"1361","messages":"1362","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1363","messages":"1364","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1365","messages":"1366","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1367","messages":"1368","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1369"},{"filePath":"1370","messages":"1371","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1372"},{"filePath":"1373","messages":"1374","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1375","messages":"1376","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1377","messages":"1378","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1379"},{"filePath":"1380","messages":"1381","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1382","messages":"1383","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1384","messages":"1385","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1386","messages":"1387","errorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1388"},{"filePath":"1389","messages":"1390","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1391","messages":"1392","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1393","messages":"1394","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1395"},{"filePath":"1396","messages":"1397","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1398","messages":"1399","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1400","messages":"1401","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1402"},{"filePath":"1403","messages":"1404","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1405","messages":"1406","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1407","messages":"1408","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1409"},{"filePath":"1410","messages":"1411","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1412","messages":"1413","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1414","messages":"1415","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1416","messages":"1417","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1418"},{"filePath":"1419","messages":"1420","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1421","messages":"1422","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1423","messages":"1424","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1425"},{"filePath":"1426","messages":"1427","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1428","messages":"1429","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1430","messages":"1431","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1432","messages":"1433","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1434","messages":"1435","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1436","messages":"1437","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1438","messages":"1439","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1440","messages":"1441","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1442","messages":"1443","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1444","messages":"1445","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1446","messages":"1447","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1448","messages":"1449","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1450","messages":"1451","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1452","messages":"1453","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1454","messages":"1455","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1456"},{"filePath":"1457","messages":"1458","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1459","messages":"1460","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1461","messages":"1462","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1463","messages":"1464","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1465","messages":"1466","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1467","messages":"1468","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1469","messages":"1470","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1471"},{"filePath":"1472","messages":"1473","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1474","messages":"1475","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1476","messages":"1477","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1478","messages":"1479","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1480","messages":"1481","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1482","messages":"1483","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1484"},{"filePath":"1485","messages":"1486","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1487","messages":"1488","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1489","messages":"1490","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1491","messages":"1492","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1493","messages":"1494","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1495"},{"filePath":"1496","messages":"1497","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1498","messages":"1499","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1500","messages":"1501","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1502","messages":"1503","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1504","messages":"1505","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1506"},{"filePath":"1507","messages":"1508","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1509","messages":"1510","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1511","messages":"1512","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1513"},{"filePath":"1514","messages":"1515","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1516"},{"filePath":"1517","messages":"1518","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1519"},{"filePath":"1520","messages":"1521","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1522"},{"filePath":"1523","messages":"1524","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1525","messages":"1526","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1527","messages":"1528","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1529","messages":"1530","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1531","messages":"1532","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1533","messages":"1534","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1535"},{"filePath":"1536","messages":"1537","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1538","messages":"1539","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1540","messages":"1541","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1542"},{"filePath":"1543","messages":"1544","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1545","messages":"1546","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1547","messages":"1548","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1549"},{"filePath":"1550","messages":"1551","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1552","messages":"1553","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1554","messages":"1555","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1556"},{"filePath":"1557","messages":"1558","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1559","messages":"1560","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1561","messages":"1562","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1563","messages":"1564","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1565","messages":"1566","errorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1567"},{"filePath":"1568","messages":"1569","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":3,"source":"1570"},{"filePath":"1571","messages":"1572","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1573","messages":"1574","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1575","messages":"1576","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1577"},{"filePath":"1578","messages":"1579","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":1,"source":"1580"},{"filePath":"1581","messages":"1582","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1583","messages":"1584","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1585","messages":"1586","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1587"},{"filePath":"1588","messages":"1589","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"1590"},{"filePath":"1591","messages":"1592","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1593","messages":"1594","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1595","messages":"1596","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1597"},{"filePath":"1598","messages":"1599","errorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1600"},{"filePath":"1601","messages":"1602","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1603"},{"filePath":"1604","messages":"1605","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1606","messages":"1607","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1608","messages":"1609","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1610","messages":"1611","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1612","messages":"1613","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1614"},{"filePath":"1615","messages":"1616","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1617","messages":"1618","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1619","messages":"1620","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1621","messages":"1622","errorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1623"},{"filePath":"1624","messages":"1625","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1626"},{"filePath":"1627","messages":"1628","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1629"},{"filePath":"1630","messages":"1631","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1632","messages":"1633","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1634","messages":"1635","errorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1636"},{"filePath":"1637","messages":"1638","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1639"},{"filePath":"1640","messages":"1641","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1642","messages":"1643","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1644","messages":"1645","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1646","messages":"1647","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1648","messages":"1649","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1650"},{"filePath":"1651","messages":"1652","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1653","messages":"1654","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1655"},{"filePath":"1656","messages":"1657","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1658","messages":"1659","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1660","messages":"1661","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1662","messages":"1663","errorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1664"},{"filePath":"1665","messages":"1666","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"1667"},{"filePath":"1668","messages":"1669","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1670","messages":"1671","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1672","messages":"1673","errorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1674"},{"filePath":"1675","messages":"1676","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1677"},{"filePath":"1678","messages":"1679","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1680","messages":"1681","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1682","messages":"1683","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1684","messages":"1685","errorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1686"},{"filePath":"1687","messages":"1688","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1689","messages":"1690","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1691","messages":"1692","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1693"},{"filePath":"1694","messages":"1695","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1696","messages":"1697","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1698"},{"filePath":"1699","messages":"1700","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1701","messages":"1702","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1703","messages":"1704","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1705","messages":"1706","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1707","messages":"1708","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1709"},{"filePath":"1710","messages":"1711","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1712","messages":"1713","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1714","messages":"1715","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1716"},{"filePath":"1717","messages":"1718","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1719","messages":"1720","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1721","messages":"1722","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1723","messages":"1724","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1725"},{"filePath":"1726","messages":"1727","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1728"},{"filePath":"1729","messages":"1730","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1731","messages":"1732","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1733","messages":"1734","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1735"},{"filePath":"1736","messages":"1737","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1738"},{"filePath":"1739","messages":"1740","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1741","messages":"1742","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1743","messages":"1744","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1745","messages":"1746","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1747","messages":"1748","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1749","messages":"1750","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1751"},{"filePath":"1752","messages":"1753","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1754","messages":"1755","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1756","messages":"1757","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1758"},{"filePath":"1759","messages":"1760","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1761","messages":"1762","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1763","messages":"1764","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1765","messages":"1766","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1767","messages":"1768","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1769","messages":"1770","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1771","messages":"1772","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1773","messages":"1774","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1775","messages":"1776","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1777"},{"filePath":"1778","messages":"1779","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1780","messages":"1781","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1782","messages":"1783","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1784"},{"filePath":"1785","messages":"1786","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1787"},{"filePath":"1788","messages":"1789","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1790","messages":"1791","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1792","messages":"1793","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1794","messages":"1795","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1796","messages":"1797","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1798","messages":"1799","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1800","messages":"1801","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1802","messages":"1803","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1804","messages":"1805","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1806"},{"filePath":"1807","messages":"1808","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1809","messages":"1810","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1811","messages":"1812","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1813"},{"filePath":"1814","messages":"1815","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1816","messages":"1817","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1818","messages":"1819","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1820"},{"filePath":"1821","messages":"1822","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1823","messages":"1824","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1825","messages":"1826","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1827","messages":"1828","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1829","messages":"1830","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1831","messages":"1832","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1833","messages":"1834","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1835","messages":"1836","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1837","messages":"1838","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1839","messages":"1840","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1841","messages":"1842","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1843","messages":"1844","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1845","messages":"1846","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1847","messages":"1848","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1849","messages":"1850","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1851","messages":"1852","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1853","messages":"1854","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1855"},{"filePath":"1856","messages":"1857","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1858","messages":"1859","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1860","messages":"1861","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1862","messages":"1863","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1864","messages":"1865","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1866"},{"filePath":"1867","messages":"1868","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1869","messages":"1870","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1871"},{"filePath":"1872","messages":"1873","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1874","messages":"1875","errorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1876"},{"filePath":"1877","messages":"1878","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1879","messages":"1880","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1881","messages":"1882","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1883","messages":"1884","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1885","messages":"1886","errorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1887"},{"filePath":"1888","messages":"1889","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1890","messages":"1891","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1892","messages":"1893","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1894","messages":"1895","errorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1896"},{"filePath":"1897","messages":"1898","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":1,"source":"1899"},{"filePath":"1900","messages":"1901","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1902","messages":"1903","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1904","messages":"1905","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1906","messages":"1907","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1908","messages":"1909","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1910","messages":"1911","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1912"},{"filePath":"1913","messages":"1914","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1915","messages":"1916","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1917","messages":"1918","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1919","messages":"1920","errorCount":0,"warningCount":42,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"1921","messages":"1922","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":2,"source":"1923"},{"filePath":"1924","messages":"1925","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1926","messages":"1927","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1928","messages":"1929","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1930"},{"filePath":"1931","messages":"1932","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1933","messages":"1934","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1935","messages":"1936","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1937","messages":"1938","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1939","messages":"1940","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1941","messages":"1942","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1943","messages":"1944","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1945","messages":"1946","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1947"},{"filePath":"1948","messages":"1949","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1950","messages":"1951","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1952","messages":"1953","errorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1954"},{"filePath":"1955","messages":"1956","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"1957"},{"filePath":"1958","messages":"1959","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1960","messages":"1961","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1962"},{"filePath":"1963","messages":"1964","errorCount":0,"warningCount":38,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1965"},{"filePath":"1966","messages":"1967","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1968"},{"filePath":"1969","messages":"1970","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1971","messages":"1972","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1973"},{"filePath":"1974","messages":"1975","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1976"},{"filePath":"1977","messages":"1978","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1979","messages":"1980","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1981","messages":"1982","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"1983"},{"filePath":"1984","messages":"1985","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1986","messages":"1987","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1988","messages":"1989","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1990","messages":"1991","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1992","messages":"1993","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1994","messages":"1995","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1996","messages":"1997","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"1998","messages":"1999","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2000","messages":"2001","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2002","messages":"2003","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2004","messages":"2005","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2006","messages":"2007","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2008","messages":"2009","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2010","messages":"2011","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2012","messages":"2013","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2014","messages":"2015","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2016","messages":"2017","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2018","messages":"2019","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2020","messages":"2021","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2022","messages":"2023","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2024","messages":"2025","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2026","messages":"2027","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2028","messages":"2029","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2030","messages":"2031","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2032","messages":"2033","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2034","messages":"2035","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2036","messages":"2037","errorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2038"},{"filePath":"2039","messages":"2040","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2041","messages":"2042","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2043","messages":"2044","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2045"},{"filePath":"2046","messages":"2047","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2048","messages":"2049","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2050","messages":"2051","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2052","messages":"2053","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2054","messages":"2055","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2056","messages":"2057","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2058","messages":"2059","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2060","messages":"2061","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2062","messages":"2063","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2064"},{"filePath":"2065","messages":"2066","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2067"},{"filePath":"2068","messages":"2069","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2070","messages":"2071","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2072","messages":"2073","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2074","messages":"2075","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2076"},{"filePath":"2077","messages":"2078","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2079","messages":"2080","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2081"},{"filePath":"2082","messages":"2083","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2084","messages":"2085","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2086","messages":"2087","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2088","messages":"2089","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2090"},{"filePath":"2091","messages":"2092","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2093","messages":"2094","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2095","messages":"2096","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"2097"},{"filePath":"2098","messages":"2099","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2100","messages":"2101","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2102"},{"filePath":"2103","messages":"2104","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2105"},{"filePath":"2106","messages":"2107","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2108"},{"filePath":"2109","messages":"2110","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2111","messages":"2112","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2113"},{"filePath":"2114","messages":"2115","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2116","messages":"2117","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2118"},{"filePath":"2119","messages":"2120","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2121","messages":"2122","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2123"},{"filePath":"2124","messages":"2125","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2126","messages":"2127","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2128","messages":"2129","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2130","messages":"2131","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2132"},{"filePath":"2133","messages":"2134","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2135","messages":"2136","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2137","messages":"2138","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2139","messages":"2140","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2141","messages":"2142","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2143","messages":"2144","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2145","messages":"2146","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2147","messages":"2148","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2149","messages":"2150","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2151","messages":"2152","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2153"},{"filePath":"2154","messages":"2155","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2156","messages":"2157","errorCount":0,"warningCount":32,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2158"},{"filePath":"2159","messages":"2160","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2161"},{"filePath":"2162","messages":"2163","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2164"},{"filePath":"2165","messages":"2166","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2167"},{"filePath":"2168","messages":"2169","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2170"},{"filePath":"2171","messages":"2172","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2173","messages":"2174","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2175","messages":"2176","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2177","messages":"2178","errorCount":0,"warningCount":26,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2179"},{"filePath":"2180","messages":"2181","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2182","messages":"2183","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2184","messages":"2185","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2186"},{"filePath":"2187","messages":"2188","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2189"},{"filePath":"2190","messages":"2191","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2192"},{"filePath":"2193","messages":"2194","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2195","messages":"2196","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2197","messages":"2198","errorCount":0,"warningCount":33,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2199"},{"filePath":"2200","messages":"2201","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2202","messages":"2203","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2204","messages":"2205","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2206"},{"filePath":"2207","messages":"2208","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2209","messages":"2210","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2211"},{"filePath":"2212","messages":"2213","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2214","messages":"2215","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2216","messages":"2217","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2218","messages":"2219","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2220","messages":"2221","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2222","messages":"2223","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2224"},{"filePath":"2225","messages":"2226","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2227","messages":"2228","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2229"},{"filePath":"2230","messages":"2231","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2232","messages":"2233","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2234","messages":"2235","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1c11p7e",{"filePath":"2236","messages":"2237","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2238","messages":"2239","errorCount":0,"warningCount":31,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"2240","messages":"2241","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"2242","messages":"2243","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"2244","messages":"2245","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2246","messages":"2247","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2248","messages":"2249","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2250"},{"filePath":"2251","messages":"2252","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2253","messages":"2254","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2255"},{"filePath":"2256","messages":"2257","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2258","messages":"2259","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2260","messages":"2261","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2262","messages":"2263","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2264","messages":"2265","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2266"},{"filePath":"2267","messages":"2268","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2269","messages":"2270","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2271"},{"filePath":"2272","messages":"2273","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2274","messages":"2275","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2276","messages":"2277","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2278","messages":"2279","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2280"},{"filePath":"2281","messages":"2282","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2283","messages":"2284","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2285"},{"filePath":"2286","messages":"2287","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2288","messages":"2289","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2290","messages":"2291","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2292"},{"filePath":"2293","messages":"2294","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2295"},{"filePath":"2296","messages":"2297","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2298","messages":"2299","errorCount":0,"warningCount":23,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2300"},{"filePath":"2301","messages":"2302","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2303","messages":"2304","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2305","messages":"2306","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2307"},{"filePath":"2308","messages":"2309","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2310","messages":"2311","errorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2312"},{"filePath":"2313","messages":"2314","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2315","messages":"2316","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2317"},{"filePath":"2318","messages":"2319","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2320","messages":"2321","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2322"},{"filePath":"2323","messages":"2324","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2325"},{"filePath":"2326","messages":"2327","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2328","messages":"2329","errorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2330"},{"filePath":"2331","messages":"2332","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2333","messages":"2334","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2335","messages":"2336","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2337","messages":"2338","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2339"},{"filePath":"2340","messages":"2341","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2342","messages":"2343","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2344","messages":"2345","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2346","messages":"2347","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2348","messages":"2349","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2350","messages":"2351","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2352"},{"filePath":"2353","messages":"2354","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2355"},{"filePath":"2356","messages":"2357","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2358","messages":"2359","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2360","messages":"2361","errorCount":0,"warningCount":33,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2362"},{"filePath":"2363","messages":"2364","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2365","messages":"2366","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2367"},{"filePath":"2368","messages":"2369","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2370"},{"filePath":"2371","messages":"2372","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2373"},{"filePath":"2374","messages":"2375","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2376"},{"filePath":"2377","messages":"2378","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2379"},{"filePath":"2380","messages":"2381","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2382"},{"filePath":"2383","messages":"2384","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2385","messages":"2386","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2387","messages":"2388","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2389"},{"filePath":"2390","messages":"2391","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2392"},{"filePath":"2393","messages":"2394","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2395"},{"filePath":"2396","messages":"2397","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2398","messages":"2399","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2400","messages":"2401","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2402","messages":"2403","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2404","messages":"2405","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2406","messages":"2407","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2408"},{"filePath":"2409","messages":"2410","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2411"},{"filePath":"2412","messages":"2413","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2414"},{"filePath":"2415","messages":"2416","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2417"},{"filePath":"2418","messages":"2419","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2420"},{"filePath":"2421","messages":"2422","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2423"},{"filePath":"2424","messages":"2425","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2426","messages":"2427","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2428"},{"filePath":"2429","messages":"2430","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2431","messages":"2432","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2433"},{"filePath":"2434","messages":"2435","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2436","messages":"2437","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2438","messages":"2439","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2440","messages":"2441","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2442","messages":"2443","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2444"},{"filePath":"2445","messages":"2446","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2447","messages":"2448","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2449","messages":"2450","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2451"},{"filePath":"2452","messages":"2453","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2454","messages":"2455","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2456","messages":"2457","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2458","messages":"2459","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2460","messages":"2461","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2462","messages":"2463","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2464","messages":"2465","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2466"},{"filePath":"2467","messages":"2468","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2469","messages":"2470","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2471","messages":"2472","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2473"},{"filePath":"2474","messages":"2475","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"2476"},{"filePath":"2477","messages":"2478","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2479"},{"filePath":"2480","messages":"2481","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2482","messages":"2483","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2484","messages":"2485","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2486"},{"filePath":"2487","messages":"2488","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2489","messages":"2490","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2491"},{"filePath":"2492","messages":"2493","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2494","messages":"2495","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2496","messages":"2497","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2498"},{"filePath":"2499","messages":"2500","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2501","messages":"2502","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2503"},{"filePath":"2504","messages":"2505","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2506","messages":"2507","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2508","messages":"2509","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2510"},{"filePath":"2511","messages":"2512","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2513","messages":"2514","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2515","messages":"2516","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2517"},{"filePath":"2518","messages":"2519","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"roqksm",{"filePath":"2520","messages":"2521","errorCount":2,"warningCount":4,"fixableErrorCount":2,"fixableWarningCount":0,"source":null},{"filePath":"2522","messages":"2523","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"2524","messages":"2525","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2526","messages":"2527","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2528","messages":"2529","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2530","messages":"2531","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2532","messages":"2533","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2534"},{"filePath":"2535","messages":"2536","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2537","messages":"2538","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2539","messages":"2540","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"2541"},{"filePath":"2542","messages":"2543","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2544","messages":"2545","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2546","messages":"2547","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2548","messages":"2549","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2550","messages":"2551","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"2552","messages":"2553","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/paul/projects/protocol/docs/assets/js/main.js",["2554"],"/home/paul/projects/protocol/docs/assets/js/search.js",["2555"],"/home/paul/projects/protocol/module-build/index.js",["2556"],"/home/paul/projects/protocol/module-build/module-build.js",["2557"],"/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-class.ts",[],"/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-class.types.ts",[],"/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-connections/channel-authority-connection-with-server-api/channel-authority-connection-with-server-api.ts",[],"/home/paul/projects/protocol/src/backog-classes/channel-authority-class/channel-authority-connections/channel-authority-connection-with-server-api/channel-authority-connection-with-server-api.types.ts",[],"/home/paul/projects/protocol/src/backog-classes/channel-authority-class/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.const.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.ts",["2558","2559","2560","2561","2562","2563","2564","2565","2566","2567","2568"],"import { ASYNC_QUEUE_BASE_CLASS_OPTIONS } from './async-queue-class-base.const';\nimport { extend } from '../../../utils/common-utils/common-utils-objects';\nimport { TAsyncQueueBaseClassPromiseProviderPending, TAsyncQueueBaseClassPromiseProvider } from './async-queue-class-base.types';\nimport { TAsyncQueueBaseClass, IAsyncQueueBaseClassOptions } from './async-queue-class-base.types';\nimport { getRun } from './async-queue-class-base.utils';\nimport { delay } from '../../../utils/common-utils/common-utils-timer';\nimport { TAsyncQueueBaseClassPromiseProviderBatch } from './async-queue-class-base.types';\n\nexport class AsyncQueueClassBase extends TAsyncQueueBaseClass {\n  protected queue: TAsyncQueueBaseClassPromiseProvider<any>[] = [];\n\n  protected batch: Promise<any[]> | void = undefined;\n\n  protected runPromiseProvider?: ReturnType<typeof getRun>;\n\n  constructor(options?: Partial<IAsyncQueueBaseClassOptions>) {\n    super(extend(options || {}, ASYNC_QUEUE_BASE_CLASS_OPTIONS) as IAsyncQueueBaseClassOptions);\n    this.runPromiseProvider = getRun(this.options.promiseTimeout);\n  }\n\n  public do = async <T>(\n    promiseProvider: TAsyncQueueBaseClassPromiseProviderPending<T>\n  ): Promise<T | Error | (T extends any[] ? Array<T | Error> : never)> => {\n    return new Promise((res) => {\n      this.queue.push(() => {\n        return this.createPromise<T>(promiseProvider).then(res).catch(res);\n      });\n      void this.start();\n    });\n  };\n\n  protected async createBatch(): Promise<any[]> {\n    if (!this.queue.length) {\n      return [];\n    }\n\n    const { options } = this;\n    const promisePendingBatch = this.queue.splice(0, options.batchSize);\n\n    if (!this.runPromiseProvider) {\n      throw new Error('runPromiseProvider is not defined');\n    }\n    return Promise.all(promisePendingBatch.map(this.runPromiseProvider)).catch((err) =>\n      new Array(promisePendingBatch.length).fill(err)\n    ); // fill with an error if the batch was rejected\n  }\n\n  protected start = async () => {\n    if (this.batch) {\n      return;\n    }\n    if (!this.queue.length) {\n      return;\n    }\n    this.batch = this.createBatch();\n    try {\n      await this.batch;\n    } catch (err) {\n      console.error('AsyncQueueClassBase::error');\n      console.error(err);\n    }\n\n    const { delayMs } = this.options;\n\n    await delay(delayMs);\n    this.batch = undefined;\n    void this.start();\n  };\n\n  protected isBatch<T>(promiseProvider: any): promiseProvider is TAsyncQueueBaseClassPromiseProviderBatch<T> {\n    return promiseProvider instanceof Array;\n  }\n  protected createPromise<T>(promiseProvider: any): Promise<T | Error>;\n  protected createPromise<T>(promiseProvider: any[]): Promise<Array<T | Error>>;\n  protected createPromise<T>(\n    promiseProvider: TAsyncQueueBaseClassPromiseProviderPending<T>\n  ): Promise<Array<T | Error> | T | Error> {\n    let result;\n\n    if (!this.runPromiseProvider) {\n      throw new Error('runPromiseProvider is not defined');\n    }\n    if (this.isBatch<T>(promiseProvider)) {\n      result = Promise.all(promiseProvider.map(this.runPromiseProvider));\n    } else {\n      result = this.runPromiseProvider(promiseProvider);\n    }\n    void this.start();\n    return result;\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.types.ts",["2569","2570"],"export interface IAsyncQueueBaseClassOptions {\n  /**\n   * a number of promises in one batch\n   *\n   * @type {number}\n   * @memberof IAsyncQueueBaseClassOptions\n   */\n  batchSize: number;\n  /**\n   * timeout for a one batch\n   *\n   * @type {number}\n   * @memberof IAsyncQueueBaseClassOptions\n   */\n  promiseTimeout: number;\n  /**\n   * a delay between executing of a two batches\n   *\n   * @type {number}\n   * @memberof IAsyncQueueBaseClassOptions\n   */\n  delayMs: number;\n}\n\nexport type TAsyncQueueBaseClassPromiseProvider<T> = () => Promise<T>;\n\nexport type TAsyncQueueBaseClassPromiseProviderBatch<T> = TAsyncQueueBaseClassPromiseProvider<T>[];\n\nexport type TAsyncQueueBaseClassPromiseProviderPending<T> =\n  | TAsyncQueueBaseClassPromiseProvider<T>\n  | TAsyncQueueBaseClassPromiseProviderBatch<T>;\n\nexport interface IAsyncQueueBaseClass {\n  /**\n   * resolve promises provided in queue\n   *\n   * @template T\n   * @param {Promise<T>[]} pending\n   * @returns {(Promise<T | Error>)}\n   * @memberof IAsyncQueueBaseClass\n   */\n  do<T>(pending: TAsyncQueueBaseClassPromiseProviderBatch<T>): Promise<Array<T | Error> | Error>;\n  do<T>(pending: TAsyncQueueBaseClassPromiseProvider<T>): Promise<T | Error>;\n}\n\nexport abstract class TAsyncQueueBaseClass implements IAsyncQueueBaseClass {\n  /**\n   * queue of promises pending\n   *\n   * @protected\n   * @abstract\n   * @type {(Promise<any>[] | void)}\n   * @memberof TAsyncQueueBaseClass\n   */\n  protected abstract queue: TAsyncQueueBaseClassPromiseProvider<any>[];\n\n  /**\n   * the currently executing batch of a promises\n   *\n   * @protected\n   * @abstract\n   * @type {(Promise<any>[] | void)}\n   * @memberof TAsyncQueueBaseClass\n   */\n  protected abstract batch: Promise<any[]> | void;\n\n  constructor(protected options: IAsyncQueueBaseClassOptions) {}\n\n  public abstract async do<T>(pending: TAsyncQueueBaseClassPromiseProviderPending<T>): Promise<T | Error | Array<T | Error>>;\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.utils.ts",["2571","2572"],"import { TAsyncQueueBaseClassPromiseProvider } from './async-queue-class-base.types';\nimport { timeout } from '../../../utils/common-utils/common-utils-timer';\n\nconst returnError = (res: any) => {\n  return res instanceof Error ? res : new Error(String(res));\n};\n\nexport const getRun = (timeoutMs: number) => <T>(promiseProvider: TAsyncQueueBaseClassPromiseProvider<T>): Promise<T | Error> => {\n  try {\n    return Promise.race([promiseProvider(), timeout(timeoutMs)]).catch(returnError);\n  } catch (err) {\n    return Promise.resolve(err);\n  }\n};\n","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/error-extended-class-base/error-extended-class-base.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/error-extended-scoped-class-base/error-extended-scoped-class-base.ts",["2573"],"import ErrorExtendedBaseClass from '../error-extended-class-base/error-extended-class-base';\n\n/**\n * create error extended by the code and added\n * a prefix defined by the error scope name.\n */\nexport const getErrorScopedClass = (errorScopeName: string) => {\n  class ErrorExtendedBaseScopedClass extends ErrorExtendedBaseClass {\n    constructor(arg: Error | ErrorExtendedBaseClass | string, code?: string | number) {\n      super(`${errorScopeName}::${arg}`, code);\n    }\n  }\n\n  return ErrorExtendedBaseScopedClass as typeof ErrorExtendedBaseClass;\n};\n\nexport default getErrorScopedClass;\n","/home/paul/projects/protocol/src/classes/basic-classes/error-extended-scoped-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/event-emitter-class-base/event-emitter-class-base.ts",["2574","2575"],"import EEmitter from 'events';\nimport TypedEmitter from 'strict-event-emitter-types';\n\nexport class EventEmitter<IEvents extends Record<string, any>> extends EEmitter implements TypedEmitter<EEmitter, IEvents> {}\n\nexport function getEventEmitterInstance<IEvents extends Record<string, any>>(): TypedEmitter<EEmitter, IEvents> {\n  return new EventEmitter<IEvents>();\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/event-emitter-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-base-body-processor.ts",["2576","2577","2578","2579"],"import { IHttpRequestOptions } from '../http-request-class-base.types';\nimport { HTTP_REQUEST_METHOD, HTTP_REQUEST_CONTENT_TYPE } from '../http-request-class-base.const';\nimport {\n  objectToUrlEncodedString,\n  IParamsObject,\n  objectToFormData,\n  IParamsObjectFormData,\n} from '../http-request-class-base.utils';\n\nexport class HttpRequestBodyProcessor {\n  protected static logError(methodName: string, err: string | Error) {\n    console.error(`HttpRequestBodyProcessor::${methodName}`, err);\n  }\n\n  constructor(protected options: IHttpRequestOptions) {}\n\n  private get bodyRAW() {\n    const { options } = this;\n    const { body } = options;\n\n    return body;\n  }\n\n  private get bodyType() {\n    const { bodyRAW: body } = this;\n\n    return typeof body;\n  }\n\n  protected processBodyAsMultipart() {\n    const { bodyRAW: body, bodyType } = this;\n\n    if (body instanceof FormData) {\n      return body;\n    }\n    if (bodyType === 'object') {\n      return objectToFormData(body as IParamsObjectFormData);\n    }\n    HttpRequestBodyProcessor.logError('checkBodyIsMultipart', 'a wrong type of the body');\n    return undefined;\n  }\n\n  protected processBodyAsUrlEncoded() {\n    const { bodyRAW: body, bodyType } = this;\n\n    switch (bodyType) {\n      case 'string':\n        return encodeURI(String(body));\n      case 'object':\n        return objectToUrlEncodedString(body as IParamsObject);\n      default: {\n        HttpRequestBodyProcessor.logError('processBodyAsUrlEncoded', 'a wrong type of the body');\n        return undefined;\n      }\n    }\n  }\n\n  protected processBodyAsJSON(): string | FormData | undefined {\n    const { bodyRAW: body, bodyType } = this;\n\n    switch (bodyType) {\n      case 'string':\n        return body as string;\n      case 'number':\n      case 'object':\n        return JSON.stringify(body);\n      default:\n        return undefined;\n    }\n  }\n\n  protected preProcessBody(): string | FormData | undefined {\n    const { options } = this;\n    const { contentType } = options;\n\n    if (typeof contentType === 'string') {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      switch (contentType!) {\n        case HTTP_REQUEST_CONTENT_TYPE.JSON:\n          return this.processBodyAsJSON();\n        case HTTP_REQUEST_CONTENT_TYPE.URL_ENCODED:\n          return this.processBodyAsUrlEncoded();\n        case HTTP_REQUEST_CONTENT_TYPE.MULTIPART:\n          return this.processBodyAsMultipart();\n      }\n    }\n    return undefined;\n  }\n\n  protected getBody(): string | FormData | undefined {\n    const { options } = this;\n    const { method } = options;\n\n    if (method === HTTP_REQUEST_METHOD.GET || method === HTTP_REQUEST_METHOD.DELETE) {\n      return undefined;\n    }\n    return this.preProcessBody();\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-base-response-error.ts",["2580","2581","2582","2583","2584"],"import { isClientSideError, getNetworkError } from '../http-request-class-base-utils';\n\nexport class HttpResponseError extends Error {\n  public code?: number;\n  public error?: Error;\n  // is error code is between the 400..500\n  public isClientError: boolean = false;\n\n  protected response: Response;\n\n  constructor(response: Response) {\n    super();\n    this.response = response;\n    void this.processResponse();\n  }\n\n  setResponseCode() {\n    const { response } = this;\n    const { status } = response;\n\n    this.code = status ? Number(status) : undefined;\n  }\n\n  setIsClientSideError() {\n    const { response } = this;\n\n    this.isClientError = isClientSideError(response);\n  }\n\n  async errorMessage() {\n    const { message, response } = this;\n\n    if (message && typeof message === 'string') {\n      return message;\n    }\n    try {\n      const { statusText } = response;\n      const message = await response.text();\n\n      this.message = statusText;\n      if (message) {\n        // cached error message\n        this.message = String(message);\n        return message;\n      }\n      return statusText;\n    } catch (err) {\n      console.error(`HttpResponseError::setErrorMessage::fail`, err);\n      return err;\n    }\n  }\n\n  mergeWithNetworkError(): boolean {\n    const { response } = this;\n    const networkError = getNetworkError(response);\n\n    if (networkError instanceof Error) {\n      Object.assign(this, networkError);\n      return true;\n    }\n    return false;\n  }\n\n  async processResponse() {\n    this.setResponseCode();\n    this.setIsClientSideError();\n    if (!this.mergeWithNetworkError()) {\n      await this.errorMessage();\n    }\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-subclasses/http-request-class-response-processor.ts",["2585","2586","2587","2588","2589","2590","2591","2592"],"import { HttpResponseError } from './http-request-class-base-response-error';\nimport { THttpResponseResult } from '../http-request-class-base.types';\nimport { isSucceedResponse, getContentTypeRAW } from '../http-request-class-base-utils';\nimport { HTTP_RESPONSE_TYPES } from '../http-request-class-base.const';\nimport { MimeTypeClass } from 'classes/basic-classes/mime-types-class-base/mime-types-class-base';\nimport { getFilenameByUrl } from '../../../../utils/files-utils/files-utils-download';\n\nexport class HttpRequestResponseProcessor {\n  constructor(protected response: Response) {}\n\n  protected getHeader(name: string) {\n    return this.response.headers.get(name);\n  }\n\n  protected getFileNameByResponse(extension?: string | null) {\n    const contentDisposition = this.getHeader('content-disposition');\n    let fileName = '' as string | undefined;\n\n    if (contentDisposition) {\n      const fileNameMatch = /filename=\"(.+)\"/.exec(contentDisposition);\n\n      if (fileNameMatch?.length === 2) fileName = fileNameMatch[1];\n    }\n    if (!fileName) {\n      fileName = getFilenameByUrl(this.response.url);\n    }\n\n    if (extension) {\n      return fileName && fileName.endsWith(extension) ? fileName : `${fileName}.${extension}`;\n    }\n    return fileName;\n  }\n\n  protected logError(error: Error): Error {\n    console.error(error);\n    return error;\n  }\n\n  protected async processAsText(): Promise<string | Error> {\n    const { response } = this;\n\n    try {\n      const result = await response.text();\n\n      return result;\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processAsFormData(): Promise<Error | FormData> {\n    const { response } = this;\n    let result;\n\n    try {\n      if (typeof response.formData === 'function') {\n        result = await response.formData();\n      } else {\n      }\n\n      return new Error(\"Can't process the response as FormData\");\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processAsBlob(): Promise<Error | object> {\n    const { response } = this;\n\n    try {\n      const result = await response.blob();\n\n      return result;\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processAsFile(mimeType?: string | null, extension?: string | null): Promise<Error | object> {\n    const { response } = this;\n\n    try {\n      const result = await response.blob();\n\n      if (result instanceof Blob) {\n        return new File([result], this.getFileNameByResponse(extension) || 'unknown', {\n          type: mimeType || undefined,\n        });\n      }\n      return new Error(\"Can't process the response as a file\");\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processAsJSON(): Promise<Error | object> {\n    const { response } = this;\n\n    try {\n      const result = await response.json();\n\n      if (result && typeof result === 'object') {\n        return result;\n      }\n      return new Error(\"Can't process the response as json\");\n    } catch (err) {\n      return this.logError(err);\n    }\n  }\n\n  protected async processResponse(): Promise<Error | THttpResponseResult> {\n    const { response } = this;\n    const contentType = getContentTypeRAW(response);\n\n    if (contentType) {\n      const mimeType = new MimeTypeClass(contentType);\n\n      if (mimeType.isBlob) {\n        return this.processAsBlob();\n      }\n      if (mimeType.isJSON) {\n        return this.processAsJSON();\n      }\n      if (mimeType.isText) {\n        return this.processAsText();\n      }\n      if (mimeType.isFile) {\n        return this.processAsFile(contentType, mimeType.extension);\n      }\n      return new Error('There is unknown mime-type of the response content');\n    }\n\n    return new Error('There is no \"Content-Type\" in the response headers');\n  }\n\n  public async getResult(): Promise<Error | HttpResponseError | THttpResponseResult> {\n    const { response } = this;\n\n    if (response.type === HTTP_RESPONSE_TYPES.OPAQUE) {\n      return undefined;\n    }\n    if (response.type === HTTP_RESPONSE_TYPES.OPAQUE_REDIRECT) {\n      return undefined;\n    }\n    if (!isSucceedResponse(response)) {\n      return new HttpResponseError(response);\n    }\n    return this.processResponse();\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base-utils.ts",["2593","2594","2595","2596","2597","2598","2599"],"import {\n  HTTP_REQUEST_ERROR_CODES_RANGE,\n  HTTP_REQUEST_CONTENT_TYPE,\n  HTTP_REQUEST_HEADERS_NAMES,\n  HTTP_REQUEST_CONTENT_TYPES_KNOWN,\n  HTTP_RESPONSE_TYPES,\n} from './http-request-class-base.const';\nimport { TQueryStringParamsObject, TQueryStringAllowedParamValue, TQueryStringParams } from './http-request-class-base.types';\nimport { concatStrings } from 'utils/string-utilities';\n\nconst { NO_ERROR, CLIENT_ERROR } = HTTP_REQUEST_ERROR_CODES_RANGE;\nconst [MIN_CODE_SUCCESS, MAX_CODE_SUCCESS] = NO_ERROR;\nconst [MIN_CODE_ERROR_CLIENT, MAX_CODE_ERROR_CLIENT] = CLIENT_ERROR;\n\nexport const isSucceedResponse = (response: Response): boolean => {\n  const { status, type } = response;\n\n  if (type === HTTP_RESPONSE_TYPES.ERROR) {\n    return false;\n  }\n\n  if (!status) {\n    return false;\n  }\n  if (status >= MIN_CODE_SUCCESS && status <= MAX_CODE_SUCCESS) {\n    return true;\n  }\n  return false;\n};\n\nexport const isClientSideError = (response: Response): boolean => {\n  const { status } = response;\n\n  if (!status) {\n    return false;\n  }\n  if (status >= MIN_CODE_ERROR_CLIENT && status <= MAX_CODE_ERROR_CLIENT) {\n    return true;\n  }\n  return false;\n};\n\nexport const getContentType = (response: Response): void | string => {\n  const { headers } = response;\n\n  if (headers) {\n    const contentType = headers.get(HTTP_REQUEST_HEADERS_NAMES.CONTENT_TYPE) as HTTP_REQUEST_CONTENT_TYPE;\n\n    if (contentType && HTTP_REQUEST_CONTENT_TYPES_KNOWN.includes(contentType)) {\n      return contentType;\n    }\n  }\n  return undefined;\n};\n\nexport const getContentTypeRAW = (response: Response): void | string => {\n  const { headers } = response;\n\n  if (headers) {\n    const contentType = headers.get(HTTP_REQUEST_HEADERS_NAMES.CONTENT_TYPE);\n\n    if (typeof contentType === 'string') {\n      return contentType;\n    }\n  }\n  return undefined;\n};\n\nexport const getNetworkError = (response: Response): Error | void => {\n  if (typeof (response as any).error === 'function') {\n    const networkError = (response as any).error();\n\n    return networkError;\n  }\n  return undefined;\n};\n\n/**\n * resolve a param as a string can be used as\n * a query string param\n * @param {object | string | number | Array<object | string | number> } paramValue\n * @returns string\n */\nexport const resolveQueryStringParam = (paramValue: TQueryStringAllowedParamValue): string => {\n  if (paramValue instanceof Array) {\n    return `[${paramValue.map(resolveQueryStringParam)}]`;\n  }\n\n  const paramValueType = typeof paramValue;\n  let resolvedValue;\n\n  try {\n    switch (paramValueType) {\n      case 'string':\n        resolvedValue = paramValue as string;\n        break;\n      case 'number':\n        resolvedValue = String(paramValue);\n        break;\n      default:\n        resolvedValue = JSON.stringify(paramValue);\n        break;\n    }\n    if (resolvedValue) {\n      return encodeURIComponent(resolvedValue);\n    }\n  } catch (err) {\n    console.error(err);\n  }\n  return '';\n};\n\n/**\n *\n * @param {object} obj\n * @returns {string} - string in the format of\n * param1=value1....&paramN=valueN\n */\nexport const queryStringFromObject = (obj: TQueryStringParamsObject): string => {\n  if (obj && typeof obj === 'object') {\n    const paramNames = Object.keys(obj);\n    const paramsCount = paramNames.length;\n    const paramsLastIdx = paramsCount - 1;\n    let idx = 0;\n    let result = '';\n    let paramName;\n    let paramValue;\n    let paramValueString;\n\n    for (; idx < paramsCount; idx += 1) {\n      paramName = paramNames[idx];\n      paramValue = obj[paramName];\n      paramValueString = resolveQueryStringParam(paramValue);\n      result = `${encodeURIComponent(paramName)}=${paramValueString}${idx !== paramsLastIdx ? '&' : ''}`;\n    }\n    return result;\n  }\n  return '';\n};\n\nexport const resolveQueryStringParams = (...params: TQueryStringParams[]): string => {\n  const paramsCount = params.length;\n  let idx = 0;\n  let result = '';\n  let paramValue;\n  let paramStringValue;\n\n  for (; idx < paramsCount; idx += 1) {\n    paramValue = params[idx];\n    if (paramValue && typeof paramValue === 'object') {\n      paramStringValue = queryStringFromObject(paramValue as TQueryStringParamsObject);\n    } else {\n      paramStringValue = resolveQueryStringParam(paramValue);\n    }\n    result = concatStrings('&', result, paramStringValue);\n  }\n  return result;\n};\n","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.const.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.ts",["2600","2601","2602","2603","2604","2605","2606","2607","2608","2609","2610","2611"],"import validator from 'validator';\nimport { HttpRequestBodyProcessor } from './http-request-class-base-subclasses/http-request-class-base-body-processor';\nimport {\n  IHttpRequestOptions,\n  IHttpRequestHeaders,\n  THttpResponseResult,\n  THttpRequestToken,\n  TQueryStringParams,\n} from './http-request-class-base.types';\nimport {\n  HTTP_REQUEST_HEADERS_NAMES,\n  HTTP_REQUEST_METHOD,\n  HTTP_REQUEST_MODE,\n  HTTP_REQUEST_CONTENT_TYPE,\n  HTTP_REQUEST_MODES_SUPPORTED,\n} from './http-request-class-base.const';\nimport { HttpRequestResponseProcessor } from './http-request-class-base-subclasses/http-request-class-response-processor';\nimport { HttpResponseError } from './http-request-class-base-subclasses/http-request-class-base-response-error';\nimport { ownValueOf } from 'types/helper.types';\nimport { resolveQueryStringParams } from './http-request-class-base-utils';\nimport { prefixUrlWithHTTPProtocol } from './http-request-class-base.utils';\n\nexport class HttpRequest extends HttpRequestBodyProcessor {\n  public static ContentType = HTTP_REQUEST_CONTENT_TYPE;\n\n  public static HeaderName = HTTP_REQUEST_HEADERS_NAMES;\n\n  public static RequestMode = HTTP_REQUEST_MODE;\n\n  public static RequestMethod = HTTP_REQUEST_METHOD;\n\n  protected static baseUrl?: string;\n\n  private static token?: THttpRequestToken;\n\n  public static setBaseUrl(baseUrl: string): void | Error {\n    if (!validator.isURL(baseUrl)) {\n      return new Error('This is not a valid url');\n    }\n    HttpRequest.baseUrl = baseUrl;\n  }\n\n  public static setToken(token: THttpRequestToken): void | Error {\n    HttpRequest.token = token;\n  }\n\n  protected baseUrl?: string = HttpRequest.baseUrl;\n\n  protected url?: string;\n\n  protected method?: string;\n\n  protected mode?: RequestMode;\n\n  protected token?: THttpRequestToken = HttpRequest.token;\n\n  protected contentType?: string;\n\n  protected queryStringParams?: string;\n\n  protected credentials?: RequestCredentials;\n\n  /**\n   * Creates an instance of HttpRequest.\n   * @param {IHttpRequestOptions} options\n   * @memberof HttpRequest\n   * @throws\n   */\n  constructor(options: IHttpRequestOptions) {\n    super(options);\n\n    const resultSetOptions = this.setOptions(options);\n\n    if (resultSetOptions instanceof Error) {\n      console.error('HttpRequest::setOptions::failed', resultSetOptions, options);\n      throw resultSetOptions;\n    }\n  }\n\n  /**\n   *  /**\n   * send the request to the server\n   * on the url defined in the\n   * options\n   *\n   * @memberof HttpRequest\n   *  @returns {(Promise<string | object | Error | FormData | Blob | HttpResponseError | File | undefined>)}\n   */\n  public send = async (): Promise<string | object | Error | FormData | Blob | HttpResponseError | File | undefined> => {\n    const { url, method, credentials, mode } = this;\n    const body = this.getBody();\n    const headers = this.getRequestHeaders();\n    const cache = this.getCacheMode();\n\n    try {\n      const response = await fetch(url!, {\n        mode,\n        body,\n        headers,\n        cache,\n        method,\n        credentials,\n      });\n\n      return await this.preProcessResponse(response);\n    } catch (err) {\n      console.error(`HttpRequest::${url}::send::failed`, err);\n      return err;\n    }\n  };\n\n  protected getRequestMethod(method: string | undefined, options: IHttpRequestOptions): Error | HTTP_REQUEST_METHOD {\n    if (!method) {\n      const { body } = options;\n\n      if (body) {\n        return HTTP_REQUEST_METHOD.POST;\n      }\n      return HTTP_REQUEST_METHOD.GET;\n    }\n\n    const methodRes = method.trim().toUpperCase();\n\n    if (HTTP_REQUEST_METHOD.hasOwnProperty(methodRes)) {\n      return (HTTP_REQUEST_METHOD as any)[methodRes] as ownValueOf<typeof HTTP_REQUEST_METHOD>;\n    }\n    return new Error(`An unknown request method \"${method}\"`);\n  }\n\n  protected getCredentials(options: IHttpRequestOptions): RequestCredentials | undefined {\n    const { withCookie, credentials } = options;\n\n    if (credentials) {\n      return credentials;\n    }\n    if (withCookie) {\n      return 'same-origin';\n    }\n  }\n\n  protected getRequestMode(method: HTTP_REQUEST_METHOD, options: IHttpRequestOptions): RequestMode | Error | undefined {\n    const { mode, contentType, body, token } = options;\n\n    if (!mode) {\n      if (token) {\n        return 'cors';\n      }\n      if (method === HTTP_REQUEST_METHOD.DELETE || method === HTTP_REQUEST_METHOD.PUT) {\n        return 'cors';\n      }\n      if (\n        contentType !== HTTP_REQUEST_CONTENT_TYPE.URL_ENCODED &&\n        contentType !== HTTP_REQUEST_CONTENT_TYPE.MULTIPART &&\n        contentType !== HTTP_REQUEST_CONTENT_TYPE.PLAIN\n      ) {\n        return 'cors';\n      }\n      if (body instanceof ReadableStream) {\n        return 'cors';\n      }\n      return undefined;\n    }\n\n    if (typeof mode === 'string') {\n      const methodRes = mode.trim().toLowerCase();\n\n      if ((HTTP_REQUEST_MODES_SUPPORTED as string[]).includes(methodRes)) {\n        return methodRes as RequestMode;\n      }\n      return new Error(`An unknown request mode \"${mode}\"`);\n    }\n  }\n\n  /**\n   * resolve the url where to send the request\n   * depending on the options url\n   * base url and a query string\n   */\n  protected resolveTargetUrl(url: string): string {\n    const { baseUrl, queryStringParams } = this;\n    const urlInstance = new URL(\n      baseUrl ? url : prefixUrlWithHTTPProtocol(url),\n      baseUrl ? prefixUrlWithHTTPProtocol(baseUrl) : undefined\n    );\n\n    if (queryStringParams) {\n      urlInstance.search = queryStringParams;\n    }\n    return String(urlInstance);\n  }\n\n  protected getQueryStringParams(params: TQueryStringParams): string {\n    const { queryStringParams } = this;\n    const resolvedParams = resolveQueryStringParams(queryStringParams || '', params);\n\n    return resolvedParams;\n  }\n\n  /**\n   * @protected\n   * @param {IHttpRequestOptions} options\n   * @memberof HttpRequest\n   * @throws\n   */\n  protected setOptions(options: IHttpRequestOptions) {\n    if (!options) {\n      throw new Error('The options must be defined for the request');\n    }\n    if (typeof options !== 'object') {\n      return new Error('The options must be an object');\n    }\n    if (typeof options.url !== 'string') {\n      return new Error('The url must be defined in options');\n    }\n\n    const { url, baseUrl, method, token, queryStringParams } = options;\n\n    if (typeof url !== 'string') {\n      return new Error('The url must be defined in options');\n    }\n    if (typeof baseUrl === 'string') {\n      if (!validator.isURL(baseUrl)) {\n        return new Error('The baseUrl is not valid');\n      }\n      this.baseUrl = baseUrl;\n    } else if (!validator.isURL(url)) {\n      this.baseUrl = '';\n      try {\n        new URL(url); // maybe it's data url\n      } catch (err) {\n        return new Error('The url is not valid');\n      }\n    }\n    if (token) {\n      this.token = token;\n    }\n\n    const methodRes = this.getRequestMethod(method, options);\n\n    if (methodRes instanceof Error) {\n      return methodRes;\n    }\n    this.method = methodRes;\n\n    const modeRes = this.getRequestMode(methodRes, options);\n\n    if (modeRes instanceof Error) {\n      return modeRes;\n    }\n    this.mode = modeRes;\n    this.credentials = this.getCredentials(options);\n    if (queryStringParams) {\n      this.queryStringParams = this.getQueryStringParams(queryStringParams);\n    }\n    this.url = this.resolveTargetUrl(url);\n  }\n\n  protected getRequestHeaders(): HeadersInit {\n    const { options, token } = this;\n    const { contentType } = options;\n    const headers: IHttpRequestHeaders = {};\n\n    if (contentType) {\n      headers[HTTP_REQUEST_HEADERS_NAMES.CONTENT_TYPE] = contentType;\n    }\n    if (token) {\n      headers[HTTP_REQUEST_HEADERS_NAMES.AUTHORIZATION] = `Bearer ${token}`;\n    }\n    return headers as HeadersInit;\n  }\n\n  protected getCacheMode(): RequestCache {\n    const { options } = this;\n    const { cache } = options;\n\n    return cache as RequestCache;\n  }\n\n  protected preProcessResponse(response: Response): Promise<Error | HttpResponseError | THttpResponseResult> {\n    const responseProcessor = new HttpRequestResponseProcessor(response);\n\n    return responseProcessor.getResult();\n  }\n}\n\nexport default HttpRequest;\n","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.types.ts",["2612","2613","2614"],"import {\n  HTTP_REQUEST_CONTENT_TYPE,\n  HTTP_REQUEST_METHOD,\n  HTTP_REQUEST_MODE,\n  HTTP_REQUEST_CACHE_CONTROL,\n  HTTP_REQUEST_HEADERS_NAMES,\n} from './http-request-class-base.const';\nimport { ownValueOf } from 'types/helper.types';\n\n/**\n * allowed types for a query string params\n * it will be convertod to a string\n */\nexport type TQueryStringAllowedParamValue = string | number | string[];\n\n/**\n * will be resolved as a string like\n * &paramName=paramValue....&paramNameN=paramValueN\n * paramValueN may be an array = [paramNItem1....paramNItemN]\n */\nexport type TQueryStringParamsObject = {\n  [paramName: string]: TQueryStringAllowedParamValue;\n};\n\nexport type TQueryStringParams = TQueryStringAllowedParamValue | TQueryStringParamsObject;\n\nexport type THttpRequestUrl = string;\n\nexport type THttpRequestMethod = ownValueOf<typeof HTTP_REQUEST_METHOD>;\n\nexport type THttpRequestContentType = ownValueOf<typeof HTTP_REQUEST_CONTENT_TYPE>;\n\nexport type THttpRequestCacheControl = ownValueOf<typeof HTTP_REQUEST_CACHE_CONTROL>;\n\nexport type THttpRequestMode = ownValueOf<typeof HTTP_REQUEST_MODE>;\n\nexport type THttpRequestToken = object | string;\n\nexport interface IHttpRequestOptions {\n  method?: THttpRequestMethod;\n  contentType?: THttpRequestContentType;\n  url: THttpRequestUrl;\n  body?: string | object | number;\n  mode?: THttpRequestMode;\n  cache?: THttpRequestCacheControl;\n  token?: THttpRequestToken;\n  queryStringParams?: TQueryStringParams;\n  baseUrl?: string;\n  // set option credentials for the Fetch API request to 'same-origin'\n  withCookie?: boolean;\n  credentials?: RequestCredentials;\n}\n\nexport type THttpResponseResult = undefined | object | string | File | Blob | FormData;\n\nexport interface IHttpRequestHeaders {\n  [HTTP_REQUEST_HEADERS_NAMES.AUTHORIZATION]?: string;\n  [HTTP_REQUEST_HEADERS_NAMES.CONTENT_TYPE]?: string;\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/http-request-class-base.utils.ts",["2615","2616","2617"],"import { CONST_API_CONF_CURRENT_PROTOCOL_USED } from 'const/const-api-conf';\nimport { HTTP_REQUEST_URL_PROTOCOL_DELIIMETR_REGEXP } from './http-request-class-base.const';\n\nexport interface IParamsObject {\n  [paramName: string]: string | number | object;\n}\n/**\n * transforms object to a stirng url encoded\n * where a param names will be the object's\n * keys and it's values will be the object's\n * values\n * @param obj\n * @param {string} obj[name]\n */\nexport const objectToUrlEncodedString = (obj: IParamsObject): string => {\n  return Object.keys(obj).reduce((querystring, paramName) => {\n    const paramValue = obj[paramName] || '';\n    const paramValueType = typeof paramValue;\n    let paramValueCasted;\n\n    if (paramValueType === 'object') {\n      paramValueCasted = JSON.stringify(paramValue);\n    } else {\n      paramValueCasted = String(paramValue);\n    }\n    return `${querystring}${querystring.length ? '&' : ''}${encodeURIComponent(paramName)}=${encodeURIComponent(\n      paramValueCasted\n    )}`;\n  }, '');\n};\n\nexport interface IParamsObjectFormData {\n  [paramName: string]: string | File | Blob | object;\n}\n\nexport const objectToFormData = (obj: IParamsObjectFormData): FormData => {\n  let paramValueCasted;\n  let thirdParam;\n\n  return Object.keys(obj).reduce((formData: FormData, paramName) => {\n    const paramValue = obj[paramName] || '';\n    const paramValueType = typeof paramValue;\n\n    paramValueCasted = undefined;\n    thirdParam = undefined;\n    if (paramValue instanceof File) {\n      paramValueCasted = paramValue;\n      thirdParam = paramValueCasted.name;\n    } else if (paramValue instanceof Blob) {\n      paramValueCasted = paramValue;\n      thirdParam = 'file';\n    } else if (paramValueType === 'object') {\n      paramValueCasted = JSON.stringify(paramValue);\n    } else if (paramValueType === 'string' || paramValueType === 'number') {\n      paramValueCasted = String(paramValue);\n    }\n    if (paramValueCasted) {\n      formData.append(paramName, paramValueCasted, paramValueType);\n    } else {\n      console.error(`Can't append the ${paramName} field as the form data value`);\n    }\n    return formData;\n  }, new FormData());\n};\n\nexport const prefixUrlWithHTTPProtocol = (urlString: string): string => {\n  const urlTrimmed = urlString.trim().toLowerCase();\n\n  if (urlTrimmed.startsWith('data:')) {\n    return urlTrimmed;\n  }\n  return urlTrimmed.startsWith('http://') || urlTrimmed.startsWith('https://')\n    ? urlTrimmed\n    : `${CONST_API_CONF_CURRENT_PROTOCOL_USED}//${urlTrimmed.replace(HTTP_REQUEST_URL_PROTOCOL_DELIIMETR_REGEXP, '')}`;\n};\n","/home/paul/projects/protocol/src/classes/basic-classes/http-request-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/mime-types-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/mime-types-class-base/mime-types-class-base.const.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/mime-types-class-base/mime-types-class-base.ts",["2618","2619"],"import mime from 'mime';\nimport {\n  MIME_TYPES_CLASS_TEXT_EXTENSIONS,\n  MIME_TYPES_CLASS_TEXT_TYPES,\n  MIME_TYPES_CLASS_BLOB_TYPES,\n  MIME_TYPES_CLASS_JSON_EXTENSIONS,\n} from './mime-types-class-base.const';\n\nexport class MimeTypeClass {\n  public extension: string | null = null;\n\n  public isText: boolean = false;\n\n  public isBlob: boolean = false;\n\n  public isFile: boolean = false;\n\n  public isJSON: boolean = false;\n\n  public isUnknown: boolean = false;\n\n  constructor(protected mimeType: string) {\n    this.processMimeType();\n  }\n\n  checkIsFile(): boolean {\n    const { extension } = this;\n\n    return !!extension;\n  }\n\n  checkIsBlob(): boolean {\n    const { mimeType } = this;\n\n    return MIME_TYPES_CLASS_BLOB_TYPES.includes(mimeType);\n  }\n\n  checkIsJSON(): boolean {\n    const { extension } = this;\n\n    return !!extension && MIME_TYPES_CLASS_JSON_EXTENSIONS.includes(extension);\n  }\n\n  checkIsText(): boolean {\n    const { mimeType } = this;\n\n    if (MIME_TYPES_CLASS_TEXT_TYPES.includes(mimeType)) {\n      return true;\n    }\n\n    const { extension } = this;\n\n    if (extension) {\n      return MIME_TYPES_CLASS_TEXT_EXTENSIONS.includes(extension);\n    }\n    return false;\n  }\n\n  checkFileExtension() {\n    const { mimeType } = this;\n\n    this.extension = mime.getExtension(mimeType);\n  }\n\n  processMimeType() {\n    this.checkFileExtension();\n    if ((this.isText = this.checkIsText())) {\n      return;\n    }\n    if ((this.isBlob = this.checkIsBlob())) {\n      return;\n    }\n    if ((this.isJSON = this.checkIsJSON())) {\n      return;\n    }\n    if ((this.isFile = this.checkIsFile())) {\n      return;\n    }\n    this.isUnknown = true;\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.const.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.ts",["2620","2621","2622","2623","2624","2625","2626","2627","2628"],"import { EventEmitter } from '../event-emitter-class-base';\nimport {\n  TQueue,\n  TIntervalEmitReadyMs,\n  TLastEmitReadyTimestamp,\n  TQueueManagerEvents,\n  IQueueOptions,\n  TMaxItemsInBatch,\n} from './queue-manager-class-base.types';\nimport {\n  QUEUE_MANAGER_EVENT_START,\n  DEFAULT_INTERVAL_MS,\n  QUEUE_MANAGER_EVENT_READY,\n  QUEUE_MANAGER_EVENT_STOP,\n} from './queue-manager-class-base.const';\n\nexport class QueueManagerClassBase<T> extends EventEmitter<TQueueManagerEvents<T>> {\n  public static logError = (methodName: string, error: Error) => {\n    console.error(`QueueManagerClassBase::${methodName}`, error);\n  };\n\n  protected queue: TQueue<T> = [];\n  protected itemsInBatch?: TMaxItemsInBatch;\n  protected intervalMs: TIntervalEmitReadyMs = DEFAULT_INTERVAL_MS;\n  protected lastEmitMs: TLastEmitReadyTimestamp = 0;\n  protected interval?: NodeJS.Timer;\n\n  constructor(options: IQueueOptions) {\n    super();\n    this.setOptions(options);\n  }\n\n  setOptions(options: IQueueOptions) {\n    const { intervalMs, itemsInBatch } = options;\n\n    this.intervalMs = intervalMs;\n    this.itemsInBatch = itemsInBatch;\n  }\n\n  getTimestamp() {\n    return Date.now();\n  }\n\n  getBatchOfItems(): T[] {\n    const { queue, itemsInBatch } = this;\n\n    return queue.slice(0, itemsInBatch || undefined);\n  }\n\n  /**\n   * @memberof QueueManagerClassBase\n   * @param items - items to remove from queue\n   */\n  deleteItemsFromQueue(items: T[]): void {\n    this.queue = this.queue.filter((itemQueued) => items.includes(itemQueued));\n  }\n\n  emitEvent(event: typeof QUEUE_MANAGER_EVENT_READY | typeof QUEUE_MANAGER_EVENT_STOP) {\n    const itemsInBatch = this.getBatchOfItems();\n\n    this.lastEmitMs = this.getTimestamp();\n    try {\n      this.emit(event, itemsInBatch);\n    } catch (err) {\n      QueueManagerClassBase.logError('emitReadyEvent', err);\n    }\n    this.deleteItemsFromQueue(itemsInBatch);\n  }\n\n  /**\n   * emit 'ready' event with a next batched\n   * items, wich are will be removed from the\n   * queue if there will no errors while\n   * handling the event\n   * @memberof QueueManagerClassBase\n   */\n  emitReadyEvent = () => {\n    this.emit(QUEUE_MANAGER_EVENT_READY);\n  };\n\n  startInterval() {\n    this.interval = setInterval(this.emitReadyEvent, this.intervalMs);\n  }\n\n  clearInterval() {\n    if (this.interval) {\n      clearInterval(this.interval);\n      this.interval = undefined;\n    }\n  }\n\n  start() {\n    this.startInterval();\n    this.emit(QUEUE_MANAGER_EVENT_START);\n  }\n\n  stop() {\n    this.clearInterval();\n    this.emit(QUEUE_MANAGER_EVENT_STOP);\n    this.queue = [];\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/queue-manager-class-base/queue-manager-class-base.types.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/queued-encryption-class-base.ts",["2629","2630","2631"],"import {\n  TCRYPTO_UTIL_ENCRYPT_DATA_TYPES,\n  TCRYPTO_UTIL_DECRYPT_DATA_TYPES,\n} from '../../../utils/encryption-utils/crypto-utils.types';\nimport { AsyncQueueClassBase } from '../async-queue-class-base/async-queue-class-base';\nimport { IAsyncQueueBaseClassOptions } from '../async-queue-class-base/async-queue-class-base.types';\nimport { isCryptoKeyDataEncryption, isCryptoKeyDataDecryption } from '../../../utils/encryption-keys-utils/encryption-keys-utils';\nimport { encryptToString } from '../../../utils/encryption-utils/encrypt-data.encryption-utils';\nimport { decryptData } from '../../../utils/encryption-utils/decrypt-data.encryption-utils';\nimport {\n  TDATA_SIGN_UTIL_SIGN_DATA_TYPES,\n  TDATA_SIGN_UTIL_VERIFY_DATA_TYPES,\n  TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_EXTENDED,\n} from '../../../utils/data-sign-utils/data-sign-utils.types';\nimport { isCryptoKeyDataSign, isCryptoKeyDataVerify } from '../../../utils/encryption-keys-utils/encryption-keys-utils';\nimport { signToString } from '../../../utils/data-sign-utils/sign-data.encryption-utils';\nimport { verifyData } from '../../../utils/data-sign-utils/verify-data.encryption-utils';\nimport { IQueuedEncrypyionClassBase } from './queued-encryption-class-base.types';\nimport { IQueuedEncrypyionClassBaseOptions } from './queued-encryption-class-base.types';\n\nexport class QueuedEncryptionClassBase implements IQueuedEncrypyionClassBase {\n  protected defaultKeys: Required<IQueuedEncrypyionClassBaseOptions>['keys'] = {};\n\n  protected asyncQueue = new AsyncQueueClassBase();\n\n  constructor(options?: IQueuedEncrypyionClassBaseOptions) {\n    this.setOptions(options);\n    return this;\n  }\n\n  public encryptData = (data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES, key: CryptoKey): Promise<string | Error> => {\n    if (!isCryptoKeyDataEncryption(key)) {\n      return Promise.resolve(new Error('Crypto key is not the valid key for data encryption'));\n    }\n    return this.addInQueue(() => encryptToString(key, data));\n  };\n\n  public decryptData = (data: TCRYPTO_UTIL_DECRYPT_DATA_TYPES, key?: CryptoKey): Promise<string | Error> => {\n    if (key && !isCryptoKeyDataDecryption(key)) {\n      return Promise.resolve(new Error('Crypto key is not the valid key for data encryption'));\n    }\n\n    const keyToUse = key || this.defaultKeys.decryptKey;\n\n    if (!keyToUse) {\n      return Promise.resolve(new Error('A key must be provided cause there is no default key was set'));\n    }\n    return this.addInQueue(() => decryptData(keyToUse, data));\n  };\n\n  public signData = (data: TDATA_SIGN_UTIL_SIGN_DATA_TYPES, key?: CryptoKey): Promise<string | Error> => {\n    if (key && !isCryptoKeyDataSign(key)) {\n      return Promise.resolve(new Error('Crypto key is not the valid key for data encryption'));\n    }\n\n    const keyToUse = key || this.defaultKeys.signKey;\n\n    if (!keyToUse) {\n      return Promise.resolve(new Error('A key must be provided cause there is no default key was set'));\n    }\n    return this.addInQueue(() => signToString(keyToUse, data));\n  };\n\n  public verifyData = (\n    data: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_EXTENDED,\n    signature: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES,\n    key: CryptoKey\n  ): Promise<boolean | Error> => {\n    if (!isCryptoKeyDataVerify(key)) {\n      return Promise.resolve(new Error('A crypto key must provide a data verification functionality'));\n    }\n    return this.addInQueue(() => verifyData(key, data, signature));\n  };\n\n  protected startAsyncQueue(options?: IAsyncQueueBaseClassOptions) {\n    this.asyncQueue = new AsyncQueueClassBase(options);\n  }\n\n  /**\n   * set options provided for feature usage\n   *\n   * @protected\n   * @param {IQueuedEncrypyionClassBaseOptions} [options]\n   * @memberof QueuedEncryptionClassBase\n   */\n  protected setOptions(options?: IQueuedEncrypyionClassBaseOptions) {\n    if (options && typeof options === 'object') {\n      const { keys, queueOptions } = options;\n\n      if (keys) {\n        if (typeof keys !== 'object') {\n          throw new Error('Keys must be an object');\n        }\n\n        const { decryptKey, signKey } = keys;\n\n        if (decryptKey) {\n          // verify key for data decryption\n          if (!isCryptoKeyDataDecryption(decryptKey)) {\n            throw new Error('The decryptKey option must be a CryptoKey');\n          }\n          this.defaultKeys.decryptKey = decryptKey;\n        }\n        if (signKey) {\n          // verify key for data decryption\n          if (!isCryptoKeyDataSign(signKey)) {\n            throw new Error('The decryptKey option must be a CryptoKey');\n          }\n          this.defaultKeys.signKey = signKey;\n        }\n      }\n      this.startAsyncQueue(queueOptions);\n    }\n  }\n\n  protected addInQueue<T>(cb: () => Promise<T>) {\n    return this.asyncQueue.do<T>(cb);\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/queued-encryption-class-base.types.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/index.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/status-class-base.const.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/status-class-base.ts",["2632","2633"],"import { ownValueOf } from 'types/helper.types';\nimport { TStatusClassBaseOptions } from './status-class-base.types';\nimport { EventEmitter } from '../event-emitter-class-base/event-emitter-class-base';\nimport { STATUS_CLASS_STATUS_CHANGE_EVENT } from './status-class-base.const';\n\nexport const STATUS_EVENT = STATUS_CLASS_STATUS_CHANGE_EVENT;\n\nexport const getStatusClass = <TStatus extends object>({\n  errorStatus,\n  instanceName,\n  initialStatus,\n}: TStatusClassBaseOptions<TStatus>) =>\n  class StatusClassBase {\n    public static error(err: string | Error): Error {\n      let errorInstance: Error;\n\n      if (err instanceof Error) {\n        errorInstance = err;\n      } else {\n        errorInstance = new Error(String(err));\n      }\n      console.error(instanceName, errorInstance);\n      return errorInstance;\n    }\n    public status?: ownValueOf<TStatus> = initialStatus ? initialStatus : undefined;\n\n    public errorOccurred?: Error;\n\n    /**\n     * emit an events described in\n     * TSafeStorageEvents\n     * @public\n     * @memberof StatusClassBase\n     */\n    public statusEmitter = new EventEmitter<{\n      ['status']: TStatus;\n    }>();\n\n    public clearError() {\n      this.errorOccurred = undefined;\n    }\n\n    public clearStatus() {\n      this.status = undefined;\n    }\n\n    public clearState() {\n      this.clearStatus();\n      this.clearError();\n    }\n\n    /**\n     *\n     * @param status\n     * @returns {Function} - function to set the previous status value\n     */\n    public setStatus = (status: ownValueOf<TStatus>): (() => void) => {\n      const { statusEmitter, status: prevStatus } = this;\n\n      this.status = status;\n      statusEmitter.emit('status', status);\n      return () => {\n        this.status = prevStatus;\n      };\n    };\n\n    public setErrorStatus = (err: Error | string): Error => {\n      if (err) {\n        const errorOccurred = StatusClassBase.error(err);\n\n        this.errorOccurred = errorOccurred;\n        return errorOccurred;\n      }\n      this.setStatus(errorStatus);\n      return new Error('Unknown error');\n    };\n  };\n","/home/paul/projects/protocol/src/classes/basic-classes/status-class-base/status-class-base.types.ts",["2634"],"import { ownValueOf } from 'types/helper.types';\n\nexport type TStatusClassBaseOptions<TStatus extends object> = {\n  errorStatus: ownValueOf<TStatus>;\n  initialStatus?: ownValueOf<TStatus>;\n  instanceName: string;\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const-auth-credentials.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const-crypto-keys-usages.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/central-authority-class-const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-const/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-common.ts",["2635","2636"],"import { IUserDescription, TUesrIdentity } from 'types/users.types';\nimport { IHttpRequestOptions } from 'classes/basic-classes/http-request-class-base/http-request-class-base.types';\nimport {\n  CA_AUTH_CREDENTIALS_USER_PASSWORD_PROP_NAME,\n  CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME,\n  CA_AUTH_CREDENTIALS_USER_SECRET_LOGIN_PROP_NAME,\n} from '../central-authority-class-const/central-authority-class-const-auth-credentials';\nimport { TCACryptoKeyPairs } from './central-authority-class-types-crypto-keys';\nimport {\n  TCentralAuthorityUserCryptoCredentials,\n  TCentralAuthorityCredentialsStorageAuthCredentials,\n} from './central-authority-class-types-crypto-credentials';\nimport { ISensitiveDataSessionStorage } from 'classes/sensitive-data-session-storage/sensitive-data-session-storage.types';\n\nexport type TCentralAuthorityUserIdentity = string;\n\nexport type TCentralAuthorityUserLogin = string;\n\nexport type TCentralAuthorityUserPassword = string;\n\nexport interface ICentralAuthorityUserAuthCredentials {\n  login: TCentralAuthorityUserLogin;\n  password?: TCentralAuthorityUserPassword;\n  session?: ISensitiveDataSessionStorage;\n}\n\nexport type TCentralAuthorityUserAuthCredentialsWithPwd = Required<\n  Pick<ICentralAuthorityUserAuthCredentials, 'login' | 'password'>\n>;\n\n/**\n * this credentials used to authorize the user on a central authority\n * provider service and getting access to a local data encrypted.\n * The secret login property used to encrypt some part of a local data\n * and may be empty. If it's empty then user identity value will be used\n * for encryption. But it may take no effect cause it is public value\n * in most cases.\n */\nexport type TCentralAuthorityAuthCredentials = {\n  [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: TCentralAuthorityUserIdentity;\n  [CA_AUTH_CREDENTIALS_USER_PASSWORD_PROP_NAME]: string;\n  [CA_AUTH_CREDENTIALS_USER_SECRET_LOGIN_PROP_NAME]?: string;\n};\n\nexport interface ICentralAuthorityUserProfile {\n  name?: string | null;\n  email?: string | null;\n  phone?: string | null;\n  photoURL?: string | null;\n}\n\nexport interface ICentralAuthorityStorageCryptoCredentials {\n  connect(credentials?: TCentralAuthorityCredentialsStorageAuthCredentials): Promise<boolean | Error>;\n  setCredentials(cryptoKeyPairs: TCACryptoKeyPairs): Promise<Error | boolean>;\n  getCredentials(): Promise<TCentralAuthorityUserCryptoCredentials | Error | null>;\n  disconnect(): Promise<boolean | Error>;\n}\n\nexport interface ICentralAuthorityConnectionOptions {\n  serverUrl: string;\n  getUsersDescriptionsRequestOptions: IHttpRequestOptions;\n}\n\nexport abstract class CentralAuthorityConnection {\n  constructor() {}\n  /**\n   * request the users descriptions by the user identities\n   */\n  public abstract getUsersDescription(users: TUesrIdentity[]): Promise<(IUserDescription | null)[] | Error>;\n}\n\nexport interface ICentralAuthorityConnection {\n  new (): CentralAuthorityConnection;\n}\n\nexport type TInstanceOfCentralAuthorityConnection = InstanceType<ICentralAuthorityConnection>;\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-credentials.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-keys.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/central-authority-class-types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-types/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v1/central-authority-class-user-identity-formatters-formatter-v1.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v1/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v2/central-authority-class-user-identity-formatters-formatter-v2.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v2/central-authority-class-user-identity-formatters-formatter-v2.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters-formatter-v2/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters.utils.ts",["2637"],"import { IUserIdentityFormatter } from './central-authority-class-user-identity-formatters.types';\nimport {\n  validateUserIdentityDescriptionVersion,\n  validateUserIdentityDescription,\n} from '../central-authority-class-user-identity-validators/central-authority-class-user-identity-validators';\nimport {\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_PARSER_VERSIONS_SUPPORTED,\n} from '../central-authority-class-user-identity.const';\nimport { CA_USER_IDENTITY_FORMATTERS_BY_VERSION } from './central-authority-class-user-identity-formatters.const';\nimport { ICAUserUniqueIdentifierDescription } from '../central-authority-class-user-identity.types';\nimport { TCentralAuthorityUserIdentity } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { validateUserIdentity } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\n\nexport const getSerializerForIdentityVersion = (userIdentityVersion: string): Error | IUserIdentityFormatter => {\n  const serializerFunction = CA_USER_IDENTITY_FORMATTERS_BY_VERSION[userIdentityVersion];\n\n  if (typeof serializerFunction === 'function') {\n    return serializerFunction;\n  }\n  return new Error(`There is no serializer was found for the identity version ${userIdentityVersion}`);\n};\n\nexport const serializeIdentity = (identity: ICAUserUniqueIdentifierDescription): TCentralAuthorityUserIdentity | Error => {\n  const validationResult = validateUserIdentityDescription(identity);\n\n  if (validationResult instanceof Error) {\n    return new Error('The user identity description have a wrong format');\n  }\n\n  const { [CA_USER_IDENTITY_VERSION_PROP_NAME]: version } = identity;\n\n  if (!CA_USER_IDENTITY_PARSER_VERSIONS_SUPPORTED.includes(version)) {\n    return new Error(`The version of the user identity given is not supported`);\n  }\n\n  const serializerFunction = getSerializerForIdentityVersion(version);\n\n  if (serializerFunction instanceof Error) {\n    console.error(serializerFunction);\n    return new Error(`There is no serializer function for the user identity description version ${version}`);\n  }\n\n  const serializeResult = serializerFunction(identity);\n\n  if (serializeResult instanceof Error) {\n    return new Error(`Failed serialization for the user identity description version ${version}`);\n  }\n  if (!validateUserIdentity(serializeResult)) {\n    return new Error(`Failed serialization to the right format for the user identity description version ${version}`);\n  }\n  return serializeResult;\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-formatters/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/central-authority-class-user-identity-parsers-parser-v1.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/central-authority-class-user-identity-parsers-parser-v1.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v1/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v2/central-authority-class-user-identity-parsers-parser-v2.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v2/central-authority-class-user-identity-parsers-parser-v2.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers-parser-v2/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.types.ts",["2638"],"import { TCentralAuthorityUserIdentity } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { ICAUserIdentityDescription } from '../central-authority-class-user-identity.types';\n\nexport interface IParser {\n  (userIdentityWithoutVersion: string): ICAUserIdentityDescription | Error;\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers.utils.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-parsers/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v1/central-authority-class-user-identity-validator-v1.ts",["2639","2640"],"import { validateAuthProviderIdentity } from './../../../central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { dataValidatorUtilUUIDV4 } from 'utils/data-validators-utils/data-validators-utils';\nimport {\n  CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT,\n} from '../../central-authority-class-user-identity.const';\nimport { ICAUserUniqueIdentifierDescription } from '../../central-authority-class-user-identity.types';\n\nexport const validatorV1 = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  v: any\n): v is ICAUserUniqueIdentifierDescription => {\n  if (v && typeof v === 'object') {\n    const {\n      [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: userUniqueIdentifier,\n      [CA_USER_IDENTITY_VERSION_PROP_NAME]: version,\n      [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: authProviderURI,\n    } = v;\n\n    if (typeof version !== 'string' || version.length !== CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT) {\n      return false;\n    }\n    if (!validateAuthProviderIdentity(authProviderURI)) {\n      console.warn(`The auth provider's uri ${authProviderURI} have a wrong format`);\n      return false;\n    }\n    if (!dataValidatorUtilUUIDV4(userUniqueIdentifier)) {\n      console.warn(`The user unique identifier ${userUniqueIdentifier} have a format different from the UUIDv4`);\n      return false;\n    }\n    return true;\n  }\n  console.warn('The URI must be an object');\n  return false;\n};\n\nexport default validatorV1;\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v1/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v2/central-authority-class-user-identity-validator-v2.ts",["2641","2642"],"import { validateAuthProviderIdentity } from './../../../central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { dataValidatorUtilSafeLogin } from 'utils/data-validators-utils/data-validators-utils';\nimport {\n  CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT,\n} from '../../central-authority-class-user-identity.const';\nimport { ICAUserUniqueIdentifierDescription } from '../../central-authority-class-user-identity.types';\n\nexport const validatorV2 = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  v: any\n): v is ICAUserUniqueIdentifierDescription => {\n  if (v && typeof v === 'object') {\n    const {\n      [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: userUniqueIdentifier,\n      [CA_USER_IDENTITY_VERSION_PROP_NAME]: version,\n      [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: authProviderURI,\n    } = v;\n\n    if (typeof version !== 'string' || version.length !== CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT) {\n      return false;\n    }\n    if (!validateAuthProviderIdentity(authProviderURI)) {\n      console.warn(`The auth provider's uri ${authProviderURI} have a wrong format`);\n      return false;\n    }\n    if (!dataValidatorUtilSafeLogin(userUniqueIdentifier)) {\n      console.warn(`The user unique identifier ${userUniqueIdentifier} have a format different from the user login safe format`);\n      return false;\n    }\n    return true;\n  }\n  console.warn('The URI must be an object');\n  return false;\n};\n\nexport default validatorV2;\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validator-v2/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.types.ts",["2643"],"export interface IUserIdentityDescriptionValidator {\n  (v: any): boolean;\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators.utils.ts",["2644","2645","2646","2647","2648","2649","2650"],"import { CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME } from './../central-authority-class-user-identity.const';\nimport { CA_USER_IDENTITY_VALIDATORS_BY_VERSION } from './central-authority-class-user-identity-validators.const';\nimport { IUserIdentityDescriptionValidator } from './central-authority-class-user-identity-validators.types';\nimport {\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT,\n  CA_USER_IDENTITY_PARSER_VERSIONS_SUPPORTED,\n} from '../central-authority-class-user-identity.const';\nimport { ICAUserUniqueIdentifierMetadata } from '../central-authority-class-user-identity.types';\nimport { dataValidatorUtilURL } from 'utils/data-validators-utils/data-validators-utils';\n\nexport const validateIdentityDescriptionVersion = (version: any): version is string => {\n  if (typeof version !== 'string') {\n    console.error('An identity description version must be a string');\n    return false;\n  }\n  if (version.length !== CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT) {\n    console.error(`An identity description version length must be a ${CA_USER_IDENTITY_VERSION_CHARACTERS_COUNT} characters`);\n    return false;\n  }\n  if (!CA_USER_IDENTITY_PARSER_VERSIONS_SUPPORTED.includes(version)) {\n    console.error(`The version ${version} is not supported`);\n    return false;\n  }\n  return true;\n};\n\nexport const getValidatorByIdentityVersion = (identityVersion: string): IUserIdentityDescriptionValidator | Error => {\n  const validator = CA_USER_IDENTITY_VALIDATORS_BY_VERSION[identityVersion];\n\n  if (typeof validator === 'function') {\n    return validator;\n  }\n  return new Error(`There is no validator for the identity version ${identityVersion}`);\n};\n\nexport const validateUserIdentityDescriptionVersion = (\n  identityVersion: string,\n  userIdentityDescription: any\n): boolean | Error => {\n  const validatorForVersion = getValidatorByIdentityVersion(identityVersion);\n\n  if (validatorForVersion instanceof Error) {\n    console.error(validatorForVersion);\n    return new Error(`Can't define a validator for the user's identity version ${validatorForVersion}`);\n  }\n\n  const validationResult = validatorForVersion(userIdentityDescription);\n\n  if (validationResult !== true) {\n    return new Error(\"There is a wrong format of user's identity\");\n  }\n  return true;\n};\n\nexport const validateUserIdentityDescription = (userIdetnityDescription: any): boolean | Error => {\n  if (userIdetnityDescription && typeof userIdetnityDescription === 'object') {\n    const { [CA_USER_IDENTITY_VERSION_PROP_NAME]: version } = userIdetnityDescription;\n\n    if (!version) {\n      return new Error('There is no version defined in the user identity description object');\n    }\n    if (validateIdentityDescriptionVersion(version)) {\n      return validateUserIdentityDescriptionVersion(version, userIdetnityDescription);\n    }\n    return new Error('There is a wrong version in the user identity description object');\n  }\n  return new Error('There is a wrong format of the user identity description');\n};\n\nexport const checkIsValidUserIdentityMetadata = (identityMetadata: ICAUserUniqueIdentifierMetadata): boolean | Error => {\n  if (typeof identityMetadata !== 'object') {\n    return new Error('Identity metadata must be an object');\n  }\n  if (identityMetadata instanceof Error) {\n    return identityMetadata;\n  }\n  if (!identityMetadata) {\n    return new Error('Identity metadata must not be empty');\n  }\n\n  const {\n    [CA_USER_IDENTITY_VERSION_PROP_NAME]: version,\n    [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: authorityProviderURI,\n  } = identityMetadata;\n\n  if (version && !validateIdentityDescriptionVersion(version)) {\n    return new Error('Version in Identity metadata have a wrong format');\n  }\n  if (!dataValidatorUtilURL(authorityProviderURI)) {\n    return new Error('The URL of an authority provider is not valid');\n  }\n  return true;\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.ts",["2651","2652","2653","2654"],"import {\n  ICAUserUniqueIdentifierDescription,\n  ICAUserUniqueIdentifierDescriptionWithOptionalVersion,\n  ICAIdentityCommonInstance,\n  TUserIdentityVersion,\n  TCAUserIdentityRawTypes,\n} from './central-authority-class-user-identity.types';\nimport { TCentralAuthorityUserIdentity } from '../central-authority-class-types/central-authority-class-types';\nimport { validateUserIdentitySilent } from '../central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { parseIdentity } from './central-authority-class-user-identity-parsers/central-authority-class-user-identity-parsers';\nimport { serializeIdentity } from './central-authority-class-user-identity-formatters/central-authority-class-user-identity-formatters';\nimport {\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_CURRENT,\n  CA_USER_IDENTITY_AUTH_PROVIDER_URL_DELIMETER,\n} from './central-authority-class-user-identity.const';\nimport { CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME } from '../central-authority-class-const/central-authority-class-const';\n\nexport class CentralAuthorityIdentity implements ICAIdentityCommonInstance {\n  protected _userIdentitySerialized?: Error | TCentralAuthorityUserIdentity;\n\n  protected _userIdentityParsed?: Error | ICAUserUniqueIdentifierDescription;\n\n  public isValid?: boolean;\n\n  constructor(protected _userIdentity: TCAUserIdentityRawTypes) {\n    if (_userIdentity instanceof CentralAuthorityIdentity) {\n      return _userIdentity;\n    }\n    if (!_userIdentity) {\n      return;\n    }\n\n    let identity = _userIdentity;\n\n    if (typeof _userIdentity === 'object') {\n      //check may be it is a crypto credentials object\n      const identityVal = ((_userIdentity as unknown) as any)[CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME];\n\n      if (typeof identityVal === 'string') {\n        identity = identityVal;\n      }\n    }\n    if (validateUserIdentitySilent(identity)) {\n      this.parseUserIdentity(identity);\n    } else {\n      const userIdentityDescription = this.extendDescriptionWithVersion(\n        identity as ICAUserUniqueIdentifierDescriptionWithOptionalVersion\n      );\n\n      this.serializeUserIdentityDescription(userIdentityDescription);\n    }\n  }\n\n  protected extendDescriptionWithVersion(\n    _userIdentityDescription: ICAUserUniqueIdentifierDescriptionWithOptionalVersion\n  ): ICAUserUniqueIdentifierDescription {\n    const { [CA_USER_IDENTITY_VERSION_PROP_NAME]: version } = _userIdentityDescription;\n\n    if (!version) {\n      // extend the description with the\n      // current version\n      const result = {\n        ..._userIdentityDescription,\n        [CA_USER_IDENTITY_VERSION_PROP_NAME]: CA_USER_IDENTITY_VERSION_CURRENT,\n      };\n\n      this._userIdentity = result;\n      return result as ICAUserUniqueIdentifierDescription;\n    }\n    return _userIdentityDescription as ICAUserUniqueIdentifierDescription;\n  }\n\n  public get identityDescription(): ICAUserUniqueIdentifierDescription | Error {\n    const res = this.checkUserIdentityDescriptionIsValid();\n\n    if (res instanceof Error) {\n      return res;\n    }\n\n    const { _userIdentityParsed } = this;\n\n    if (!_userIdentityParsed) {\n      return new Error('Failed to parse the user identity');\n    }\n    return _userIdentityParsed;\n  }\n\n  public get identityDescritptionSerialized(): TCentralAuthorityUserIdentity | Error {\n    const res = this.checkUserIdentityDescriptionIsValid();\n\n    if (res instanceof Error) {\n      return res;\n    }\n\n    const { _userIdentitySerialized } = this;\n\n    if (!_userIdentitySerialized) {\n      return new Error('Failed to serialize the user identity');\n    }\n    return _userIdentitySerialized;\n  }\n\n  /**\n   * uniquely identifies the user\n   */\n  public get id(): string | Error {\n    const res = this.checkUserIdentityDescriptionIsValid();\n\n    if (res instanceof Error) {\n      return res;\n    }\n\n    const { authorityProviderURI, userUniqueIdentifier } = this.identityDescription as ICAUserUniqueIdentifierDescription;\n\n    return `${authorityProviderURI}${CA_USER_IDENTITY_AUTH_PROVIDER_URL_DELIMETER}${userUniqueIdentifier}`;\n  }\n\n  public get version(): TUserIdentityVersion | Error {\n    const res = this.checkUserIdentityDescriptionIsValid();\n\n    if (res instanceof Error) {\n      return res;\n    }\n\n    return (((this.identityDescription as ICAUserUniqueIdentifierDescription).version ||\n      CA_USER_IDENTITY_VERSION_CURRENT) as unknown) as TUserIdentityVersion;\n  }\n\n  public toString(): TCentralAuthorityUserIdentity {\n    const res = this.checkUserIdentityDescriptionIsValid();\n\n    if (res instanceof Error) {\n      return '';\n    }\n    return this.identityDescritptionSerialized as string;\n  }\n\n  protected checkUserIdentityDescriptionIsValid = (): Error | void => {\n    const { _userIdentitySerialized, isValid, _userIdentityParsed } = this;\n    let err: Error | void;\n\n    if (!isValid) {\n      err = new Error('The identity is not valid');\n    }\n    if (!_userIdentityParsed) {\n      err = new Error('There is no user identity parsed');\n    }\n    if (_userIdentityParsed instanceof Error) {\n      err = _userIdentityParsed;\n    }\n    if (!_userIdentitySerialized) {\n      err = new Error('The identity description serialized is not defined');\n    }\n    if (_userIdentitySerialized instanceof Error) {\n      err = _userIdentitySerialized;\n    }\n    if (err instanceof Error) {\n      console.error(err);\n      return err;\n    }\n  };\n\n  protected setIdentityIsValid(): void {\n    if (this.isValid !== false) {\n      this.isValid = true;\n    }\n  }\n\n  protected parseUserIdentity(userIdentity: TCentralAuthorityUserIdentity): void {\n    if (userIdentity) {\n      const parsedUserIdentity = parseIdentity(userIdentity);\n      if (parsedUserIdentity instanceof Error) {\n        console.error(parsedUserIdentity);\n        this._userIdentityParsed = parsedUserIdentity;\n        this._userIdentitySerialized = new Error('Failed to parse the user identity');\n      } else {\n        this._userIdentityParsed = parsedUserIdentity;\n        this._userIdentitySerialized = userIdentity;\n        this.setIdentityIsValid();\n        return;\n      }\n    } else {\n      const err = new Error('The user identity serialized is not defined');\n\n      this._userIdentityParsed = err;\n      this._userIdentitySerialized = err;\n    }\n    this.isValid = false;\n  }\n\n  protected serializeUserIdentityDescription(userIdentityDescription: ICAUserUniqueIdentifierDescription) {\n    if (userIdentityDescription) {\n      const serializedDescription = serializeIdentity(userIdentityDescription);\n\n      if (serializedDescription instanceof Error) {\n        this._userIdentityParsed = new Error('Failed to serialize the user identity description');\n        this._userIdentitySerialized = serializedDescription;\n      } else {\n        this._userIdentityParsed = userIdentityDescription;\n        this._userIdentitySerialized = serializedDescription;\n        this.setIdentityIsValid();\n        return;\n      }\n    } else {\n      const err = new Error('The user identifier description is not defined');\n\n      this._userIdentitySerialized = err;\n      this._userIdentityParsed = err;\n    }\n    this.isValid = false;\n  }\n}\n\nexport default CentralAuthorityIdentity;\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class-user-identity/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class.ts",["2655","2656","2657","2658","2659","2660","2661","2662","2663","2664","2665","2666","2667","2668"],"import { checkIsError } from '../../utils/common-utils/common-utils-check-value';\nimport { dataCachingUtilsCachingDecorator } from '../../utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator';\nimport { validateVerboseBySchema } from './../../utils/validation-utils/validation-utils';\nimport { getErrorScopedClass } from './../basic-classes/error-extended-scoped-class-base/error-extended-scoped-class-base';\nimport {\n  ICentralAuthorityUserProfile,\n  TCentralAuthorityUserIdentity,\n} from './central-authority-class-types/central-authority-class-types-common';\nimport { TCentralAuthorityUserCryptoCredentials } from './central-authority-class-types/central-authority-class-types-crypto-credentials';\nimport {\n  TCAUserIdentityRawTypes,\n  TCAuthProviderIdentifier,\n} from './central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport {\n  CENTRAL_AUTHORITY_CLASS_ERRORS_PREFIX,\n  CENTRAL_AUTHORITY_CLASS_OPTIONS_SCHEMA,\n  CENTRAL_AUTHORITY_CLASS_SWARM_CREDENTIALS_STORAGE_DB_NAME,\n  CENTRAL_AUTHORITY_CLASS_SWARM_CREDENTIALS_SWARM_USERS_CREDENTIALS_CACHE_CAPACITY,\n} from './central-authority-class.const';\nimport {\n  ICentralAuthority,\n  ICentralAuthorityAuthProvidersOptions,\n  ICentralAuthorityOptions,\n  ICentralAuthorityUser,\n} from './central-authority-class.types';\nimport { CAConnectionsPool } from './central-authority-connections/central-authority-connections-pool/central-authority-connections-pool';\nimport {\n  ICAConnectionPool,\n  ICAConnectionPoolAuthResult,\n  ICAConnectionsPoolOptions,\n} from './central-authority-connections/central-authority-connections-pool/central-authority-connections-pool.types';\nimport {\n  ICAConnectionSignUpCredentials,\n  TCAAuthProviderIdentity,\n} from './central-authority-connections/central-authority-connections.types';\nimport { CentralAuthorityStorageCurrentUserCredentials } from './central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials';\nimport {\n  ICAStorageCurrentUserCredentials,\n  ICAStorageCurrentUserCredentialsOptions,\n} from './central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.types';\nimport { CASwarmCredentialsProvider } from './central-authority-swarm-credentials-provider/central-authority-swarm-credentials-provider';\nimport {\n  ICASwarmCredentialsProvider,\n  ICASwarmCredentialsProviderOptions,\n} from './central-authority-swarm-credentials-provider/central-authority-swarm-credentials-provider.types';\nimport {\n  compareCryptoCredentials,\n  exportCryptoCredentialsToString,\n} from './central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\nimport {\n  getDataEncryptionKeyPairByCryptoCredentials,\n  getDataEncryptionPubKeyByCryptoCredentials,\n  getDataSignKeyPairByCryptoCredentials,\n  getDataSignPubKeyByCryptoCredentials,\n  getUserIdentityFromCryptoCredentials,\n} from './central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials-crypto-keys';\nimport { checkIsValidCryptoCredentials } from './central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport { ISecretStoreCredentialsSession, ISecretStoreCredentials } from '../secret-storage-class/secret-storage-class.types';\n\nconst CAError = getErrorScopedClass(CENTRAL_AUTHORITY_CLASS_ERRORS_PREFIX);\n\n/**\n * Used to get and approve the\n * user's credentials stored by\n * an authorization provider.\n * It's necessary to allow each user\n * can connect and get info from\n * all authorization providers.\n * This class used to authorize the user\n * in the SWARM. User must register on one of\n * authority providers services with a\n * public credentials which used by another\n * to authorize the user and approve him\n * to access on the data.\n *\n * @export\n * @class CentralAuthority\n */\nexport class CentralAuthority implements ICentralAuthority {\n  public get isRunning(): boolean {\n    return this.isRunningInstance;\n  }\n\n  protected isRunningInstance: boolean = false;\n  /**\n   * an identity of auth provider the user is authorized on\n   *\n   * @protected\n   * @type {TCAuthProviderIdentifier}\n   * @memberof CentralAuthority\n   */\n  protected authProviderId?: TCAuthProviderIdentifier;\n  /**\n   * crypto credentials of the user, for the auth provider\n   * the user is authorized on\n   *\n   * @protected\n   * @type {TCentralAuthorityUserCryptoCredentials}\n   * @memberof CentralAuthority\n   */\n  protected remoteProvidedUserCryptoCredntials?: TCentralAuthorityUserCryptoCredentials;\n  protected locallyStoredUserCryptoCredntials?: TCentralAuthorityUserCryptoCredentials;\n  protected userProfileOnAuthService?: ICentralAuthorityUserProfile;\n  protected authProvidersPoolConfiguration?: ICentralAuthorityAuthProvidersOptions;\n  protected connectionAuthProvidersPool?: ICAConnectionPool;\n  protected connectionStorageCurrentUserCrdentials?: ICAStorageCurrentUserCredentials;\n  protected connectionSwarmCredentialsProvider?: ICASwarmCredentialsProvider;\n\n  protected get errorNotRunning() {\n    return new CAError('The instance is not running');\n  }\n\n  public async connect(options: ICentralAuthorityOptions): Promise<Error | void> {\n    if (this.isRunning) {\n      console.warn('This instance is already running');\n    }\n    const setOptionsResult = this.setOptions(options);\n\n    if (setOptionsResult instanceof Error) {\n      return setOptionsResult;\n    }\n    // TODO - it's necessary to user credentials by getByAuthProvider\n    // and compare it with credentials provided in options\n    // and compare it by credentials provided from connection to\n    // auth provider\n    const [resultUserCredentialsStorage, resultCAAuthProvidersConnectionsPool] = await Promise.all([\n      this.connectToUserCredentialsStorage(options.user),\n      this.connectToAuthProvidersPool(options.authProvidersPool, options.user),\n    ]);\n    let isError = false;\n\n    if (resultUserCredentialsStorage instanceof Error) {\n      console.error(resultUserCredentialsStorage);\n      isError = true;\n    }\n    if (resultCAAuthProvidersConnectionsPool instanceof Error) {\n      // TODO - this is important to preserve this error, to\n      // notify the users with the error same as returned by the\n      // central authority. Cause the user may need to verify\n      // his email address or make another action.\n      return this.handleFailAndClose(resultCAAuthProvidersConnectionsPool);\n    }\n    if (isError) {\n      return this.handleFailAndClose('There is an error occurred while connecting to the providers');\n    }\n\n    const setLocallyStoredCredentialsResult = await this.readAndSetLocallyStoredUserCredentials();\n\n    if (setLocallyStoredCredentialsResult instanceof Error) {\n      console.error(setLocallyStoredCredentialsResult);\n      return this.handleFailAndClose('Failed to read the locally stored credentials for the current user');\n    }\n\n    const checkUserCredentialsResult = await this.compareLocalAndRemoteCredentials();\n\n    if (checkUserCredentialsResult instanceof Error) {\n      console.error(checkUserCredentialsResult);\n      return this.handleFailAndClose('The user credentials stored locally and provided by the auth provided are not same');\n    }\n\n    const storeCredentialsLocallyResult = await this.storeCryptoCredentialsFromAuthProvider();\n\n    if (storeCredentialsLocallyResult instanceof Error) {\n      console.error(storeCredentialsLocallyResult);\n      return this.handleFailAndClose('Failed to store the credentials for the user locally');\n    }\n\n    const createConnectionToSwarmCredentialsStorageResult = await this.connectToSwarmCredentialsStorage();\n\n    if (createConnectionToSwarmCredentialsStorageResult instanceof Error) {\n      console.error(createConnectionToSwarmCredentialsStorageResult);\n      return this.handleFailAndClose('Failed to connect to the swarm credentials storage provider');\n    }\n    this.setIsRunning();\n  }\n\n  /**\n   * close all existings connections and unset all\n   * options\n   *\n   * @returns {(Promise<Error | void>)}\n   * @memberof CentralAuthority\n   */\n  public async disconnect(): Promise<Error | void> {\n    this.unsetOptions();\n    if (!this.isRunning) {\n      console.warn('The user is already not connected to the central authority');\n      return;\n    }\n\n    const result = await this.disconnectAll();\n\n    if (result instanceof Error) {\n      console.error(result);\n      return new CAError('Failed to close all the connections');\n    }\n  }\n\n  /**\n   * read credentials of the user connected to the swarm\n   * from a local cache or, if it's not found, in the local\n   * cache, from the swarm auth provider.\n   *\n   * @param {TCAUserIdentityRawTypes} identity\n   * @returns {(Promise<TCentralAuthorityUserCryptoCredentials | Error | null>)}\n   * @memberof CentralAuthority\n   */\n  public async getSwarmUserCredentials(\n    identity: TCAUserIdentityRawTypes\n  ): Promise<TCentralAuthorityUserCryptoCredentials | Error | null> {\n    if (!this.isRunning) {\n      return this.errorNotRunning;\n    }\n    return this.readSwarmUserCredentials(identity);\n  }\n\n  /**\n   * return crypto key of the swarm user if exists\n   * in the local cache or in the swarm providers\n   * the current user is connected to\n   *\n   * @param {TCAUserIdentityRawTypes} identity\n   * @returns {(Promise<Error | null | CryptoKey>)}\n   * @memberof CentralAuthority\n   */\n  public async getSwarmUserEncryptionPubKey(identity: TCAUserIdentityRawTypes): Promise<Error | null | CryptoKey> {\n    if (!this.isRunning) {\n      return this.errorNotRunning;\n    }\n\n    const swarmUserCredentials = await this.readSwarmUserCredentials(identity);\n\n    if (swarmUserCredentials instanceof Error) {\n      console.error(swarmUserCredentials);\n      return new CAError('Failed to get a credentials of the swarm user');\n    }\n    return getDataEncryptionPubKeyByCryptoCredentials(swarmUserCredentials);\n  }\n\n  /**\n   * return crypto key of the swarm user if exists\n   * in the local cache or in the swarm providers\n   * the current user is connected to\n   *\n   * @param {TCAUserIdentityRawTypes} identity\n   * @returns {(Promise<Error | null | CryptoKey>)}\n   * @memberof CentralAuthority\n   */\n  public async getSwarmUserSignPubKey(identity: TCAUserIdentityRawTypes): Promise<Error | null | CryptoKey> {\n    if (!this.isRunning) {\n      return this.errorNotRunning;\n    }\n\n    const swarmUserCredentials = await this.readSwarmUserCredentials(identity);\n\n    if (swarmUserCredentials instanceof Error) {\n      console.error(swarmUserCredentials);\n      return new CAError('Failed to get a credentials of the swarm user');\n    }\n    return getDataSignPubKeyByCryptoCredentials(swarmUserCredentials);\n  }\n\n  /**\n   * return the identity of the current user\n   *\n   * @returns {(Promise<Error | TCentralAuthorityUserIdentity>)}\n   * @memberof ICentralAuthority\n   */\n  public getUserIdentity(): Error | TCentralAuthorityUserIdentity {\n    const userCryptoCredentials = this.getCurrentUserCryptoCredentials();\n\n    if (userCryptoCredentials instanceof Error) {\n      return userCryptoCredentials;\n    }\n    return (\n      getUserIdentityFromCryptoCredentials(userCryptoCredentials) || new CAError('there is no credentials of the current user')\n    );\n  }\n  /**\n   * retutn a crypto key pair of the current user\n   * for a data encryption\n   *\n   * @returns\n   * @memberof CentralAuthority\n   */\n  public getUserEncryptionKeyPair(): Error | CryptoKeyPair {\n    const userCryptoCredentials = this.getCurrentUserCryptoCredentials();\n\n    if (userCryptoCredentials instanceof Error) {\n      return userCryptoCredentials;\n    }\n    return (\n      getDataEncryptionKeyPairByCryptoCredentials(userCryptoCredentials) ||\n      new CAError('there is no credentials of the current user')\n    );\n  }\n\n  /**\n   * retutn a crypto key pair of the current user\n   * for a data encryption\n   *\n   * @returns\n   * @memberof CentralAuthority\n   */\n  public getUserDataSignKeyPair(): Error | CryptoKeyPair {\n    const userCryptoCredentials = this.getCurrentUserCryptoCredentials();\n\n    if (userCryptoCredentials instanceof Error) {\n      return userCryptoCredentials;\n    }\n    return (\n      getDataSignKeyPairByCryptoCredentials(userCryptoCredentials) || new CAError('there is no credentials of the current user')\n    );\n  }\n\n  /**\n   * Reads the user's profile from the CA service\n   * the user is authrorized on and return it if exists.\n   * If the user is not authorized on a CA then undefined\n   * will be returned.\n   *\n   * @returns {(Promise<ICentralAuthorityUserProfile | undefined>)}\n   * @memberof CentralAuthority\n   */\n  public async getCAUserProfile(): Promise<ICentralAuthorityUserProfile | undefined> {\n    return this.connectionAuthProvidersPool?.getCAUserProfile();\n  }\n\n  // TODO - set the user profile in the CA service\n\n  /**\n   * export crypto credentials of the current user\n   *\n   * @returns {(Promise<string | Error>)}\n   * @memberof CentralAuthority\n   */\n  public async exportCryptoCredentials(): Promise<string | Error> {\n    const userCryptoCredentials = this.getCurrentUserCryptoCredentials();\n\n    if (userCryptoCredentials instanceof Error) {\n      return userCryptoCredentials;\n    }\n    return exportCryptoCredentialsToString(userCryptoCredentials);\n  }\n\n  protected validateOptions(options: ICentralAuthorityOptions): Error | void {\n    if (!options) {\n      return new CAError('Options must be provided');\n    }\n\n    const validationResult = validateVerboseBySchema(CENTRAL_AUTHORITY_CLASS_OPTIONS_SCHEMA, options);\n\n    if (validationResult instanceof Error) {\n      return new CAError(validationResult);\n    }\n  }\n\n  protected setOptions(options: ICentralAuthorityOptions): Error | void {\n    const optionsValidationResult = this.validateOptions(options);\n\n    if (optionsValidationResult) {\n      return optionsValidationResult;\n    }\n    this.authProvidersPoolConfiguration = options.authProvidersPool;\n    if (options.user.credentials.cryptoCredentials) {\n      this.remoteProvidedUserCryptoCredntials = options.user.credentials.cryptoCredentials;\n    }\n  }\n\n  protected unsetOptions() {\n    this.authProvidersPoolConfiguration = undefined;\n    this.remoteProvidedUserCryptoCredntials = undefined;\n  }\n\n  protected setIsRunning() {\n    this.isRunningInstance = true;\n  }\n\n  protected unsetIsRunning() {\n    this.isRunningInstance = false;\n  }\n\n  protected async closeConnectionToAuthProvidersPool(): Promise<Error | void> {\n    const { connectionAuthProvidersPool } = this;\n\n    this.unsetConnectionToAuthProvidersPool();\n    if (connectionAuthProvidersPool) {\n      const res = await connectionAuthProvidersPool.close();\n\n      if (res instanceof Error) {\n        console.error(res);\n        return new CAError('Failed to disconnect from auth providers pool');\n      }\n    }\n  }\n\n  protected async closeConnectionToCurrentUserCredentialsStorage(): Promise<Error | void> {\n    const { connectionStorageCurrentUserCrdentials } = this;\n\n    this.unsetConnectionToCurrentUserCredentialsStorage();\n    if (connectionStorageCurrentUserCrdentials) {\n      const res = await connectionStorageCurrentUserCrdentials.disconnect();\n\n      if (res instanceof Error) {\n        console.error(res);\n        return new CAError('Failed to disconnect from current user credentials storage');\n      }\n    }\n  }\n\n  protected async closeConnectionSwarmCredentialsProvider(): Promise<Error | void> {\n    const { connectionSwarmCredentialsProvider } = this;\n\n    this.unsetConnectionToSwarmCredentialsStorage();\n    if (connectionSwarmCredentialsProvider) {\n      const res = await connectionSwarmCredentialsProvider.disconnect();\n\n      if (res instanceof Error) {\n        console.error(res);\n        return new CAError('Failed to disconnect from swarm credentials provider');\n      }\n    }\n  }\n\n  /**\n   * close all the existing connections\n   *\n   * @protected\n   * @returns {(Promise<Error | void>)}\n   * @memberof CentralAuthority\n   */\n  protected async closeAllConnections(): Promise<Error | void> {\n    const results = await Promise.all([\n      this.closeConnectionToAuthProvidersPool(),\n      this.closeConnectionToCurrentUserCredentialsStorage(),\n      this.closeConnectionSwarmCredentialsProvider(),\n    ]);\n    const isErrorExists = results.some(checkIsError);\n\n    if (isErrorExists) {\n      return new CAError('Failed to close one of the exising connections');\n    }\n  }\n\n  protected unsetPropsOnClose() {\n    this.unsetIsRunning();\n    this.unsetLocallyStoredCredentials();\n    this.unsetUserOnAuthResult();\n  }\n\n  /**\n   * close and unset all connections\n   *\n   * @protected\n   * @returns {(Promise<Error | void>)}\n   * @memberof CentralAuthority\n   */\n  protected async disconnectAll(): Promise<Error | void> {\n    this.unsetPropsOnClose();\n\n    const closeConnectionsResult = await this.closeAllConnections();\n\n    if (closeConnectionsResult instanceof Error) {\n      console.error(closeConnectionsResult);\n      return closeConnectionsResult;\n    }\n  }\n\n  /**\n   * close the instance and emit an error\n   *\n   * @protected\n   * @param {(string | Error)} [error]\n   * @returns {Promise<Error>}\n   * @memberof CentralAuthority\n   */\n  protected async handleFailAndClose(error?: string | Error): Promise<Error> {\n    const closeConnectionsResult = await this.disconnectAll();\n\n    if (closeConnectionsResult instanceof Error) {\n      console.error(closeConnectionsResult);\n      console.error(new CAError('handleFailAndClose::failed to close the instance'));\n    }\n    return new CAError(error || 'handleFailAndClose::an unknown error caused the instance close');\n  }\n\n  protected getOptionsForAuthProvidersConnectionsPool(options: ICentralAuthorityAuthProvidersOptions): ICAConnectionsPoolOptions {\n    return {\n      providers: options.providersConfigurations,\n    };\n  }\n\n  protected getOptionsToAuthorizeUserOnAuthConnection(\n    optionsUserCredentials: ICentralAuthorityUser\n  ): [TCAAuthProviderIdentity, ICAConnectionSignUpCredentials, Partial<ICentralAuthorityUserProfile> | undefined] {\n    return [optionsUserCredentials.authProviderUrl, optionsUserCredentials.credentials, optionsUserCredentials.profile];\n  }\n\n  /**\n   * set the user profile and crypto keys after he was authorized\n   * on the auth provider service.\n   *\n   * @protected\n   * @param {ICAConnectionUserAuthorizedResult} caSwarmConnectionsPoolAuthResult\n   * @memberof CentralAuthority\n   */\n  protected setUserOnAuthResult(caSwarmConnectionsPoolAuthResult: ICAConnectionPoolAuthResult) {\n    this.remoteProvidedUserCryptoCredntials = caSwarmConnectionsPoolAuthResult.cryptoCredentials;\n    this.userProfileOnAuthService = caSwarmConnectionsPoolAuthResult.profile;\n    this.authProviderId = caSwarmConnectionsPoolAuthResult.authProviderId;\n  }\n\n  protected unsetUserOnAuthResult() {\n    this.remoteProvidedUserCryptoCredntials = undefined;\n    this.userProfileOnAuthService = undefined;\n  }\n\n  protected setConnectionToAuthProvidersPool(connectionSwarmPool: ICAConnectionPool) {\n    this.connectionAuthProvidersPool = connectionSwarmPool;\n  }\n\n  protected unsetConnectionToAuthProvidersPool() {\n    this.connectionAuthProvidersPool = undefined;\n  }\n\n  /**\n   * create connection of the CAConnectionsPool and authorize\n   * on auth provider specified by the user.\n   *\n   * @protected\n   * @param {ICentralAuthorityAuthProvidersOptions} optionsConnectionPool\n   * @param {ICentralAuthorityUser} optionsUserCredentials\n   * @returns {(Promise<Error | void>)}\n   * @memberof CentralAuthority\n   */\n  protected async connectToAuthProvidersPool(\n    optionsConnectionPool: ICentralAuthorityAuthProvidersOptions,\n    optionsUserCredentials: ICentralAuthorityUser\n  ): Promise<Error | void> {\n    const optionsAuthProvidersPool = this.getOptionsForAuthProvidersConnectionsPool(optionsConnectionPool);\n    let connectionToAuthProvidersPool: CAConnectionsPool;\n\n    try {\n      connectionToAuthProvidersPool = new CAConnectionsPool(optionsAuthProvidersPool);\n    } catch (err) {\n      console.error(err);\n      return new CAError('Failed to create an instance of CAConnectionsPool');\n    }\n\n    const authorizationResult = await connectionToAuthProvidersPool.authorize(\n      ...this.getOptionsToAuthorizeUserOnAuthConnection(optionsUserCredentials)\n    );\n\n    if (authorizationResult instanceof Error) {\n      console.error(authorizationResult);\n      return authorizationResult;\n    }\n\n    const { userAuthResult } = connectionToAuthProvidersPool;\n\n    if (!userAuthResult) {\n      return new CAError('There is no user credntials and profile provided after authorization on auth service');\n    }\n    if (userAuthResult.authProviderId !== optionsUserCredentials.authProviderUrl) {\n      return new Error(\n        `The auth provider id ${userAuthResult.authProviderId} returned in the crypto credentials is not equals to the auth provider url user want to authorized on ${optionsUserCredentials.authProviderUrl}`\n      );\n    }\n    this.setConnectionToAuthProvidersPool(connectionToAuthProvidersPool);\n    this.setUserOnAuthResult(userAuthResult);\n  }\n\n  protected getOptionsForCAStorageCurrentUserCredentials(\n    optionsUser: ICentralAuthorityUser\n  ): ICAStorageCurrentUserCredentialsOptions {\n    const { credentials } = optionsUser;\n    let userCredentials: ISecretStoreCredentialsSession | ISecretStoreCredentials;\n\n    if (!credentials.password) {\n      userCredentials = {\n        login: credentials.login,\n        session: credentials.session,\n      } as ISecretStoreCredentialsSession;\n    } else {\n      userCredentials = {\n        login: credentials.login,\n        password: credentials.password,\n        session: credentials.session,\n      } as ISecretStoreCredentials;\n    }\n    return {\n      credentials: userCredentials,\n    };\n  }\n\n  protected setConnectionToCurrentUserCredentialsStorage(connection: CentralAuthorityStorageCurrentUserCredentials) {\n    this.connectionStorageCurrentUserCrdentials = connection;\n  }\n\n  protected unsetConnectionToCurrentUserCredentialsStorage() {\n    this.connectionStorageCurrentUserCrdentials = undefined;\n  }\n\n  protected async connectToUserCredentialsStorage(optionsUser: ICentralAuthorityUser): Promise<Error | void> {\n    const caStorageCurrentUserCredentials = new CentralAuthorityStorageCurrentUserCredentials();\n    const optionsCAStorageCurrentUserCredentials = this.getOptionsForCAStorageCurrentUserCredentials(optionsUser);\n    const caStorageCurrentUserCredentialsConnectionResult = await caStorageCurrentUserCredentials.connect(\n      optionsCAStorageCurrentUserCredentials\n    );\n\n    if (caStorageCurrentUserCredentialsConnectionResult instanceof Error) {\n      console.error(caStorageCurrentUserCredentialsConnectionResult);\n      return new CAError('Failed to connect to the storage of the user credentials');\n    }\n    this.setConnectionToCurrentUserCredentialsStorage(caStorageCurrentUserCredentials);\n  }\n\n  /**\n   *\n   *\n   * @param {*} cryptoCredentials\n   * @returns {<void | Error>}\n   * @memberof CentralAuthority\n   */\n  protected setLocallyStoredCredentials(cryptoCredentials: TCentralAuthorityUserCryptoCredentials): void | Error {\n    const validateResult = checkIsValidCryptoCredentials(cryptoCredentials);\n\n    if (!validateResult) {\n      return new CAError('The locally stored crypto credentials is not valid');\n    }\n    this.locallyStoredUserCryptoCredntials = cryptoCredentials;\n  }\n\n  protected unsetLocallyStoredCredentials() {\n    this.locallyStoredUserCryptoCredntials = undefined;\n  }\n\n  /**\n   * Set a locally stored credentials of the user by the credentials\n   * got from the swarm auth provider connected to.\n   *\n   * @protected\n   * @memberof CentralAuthority\n   * @returns {(Promise<void | Error>)}\n   */\n  protected async readAndSetLocallyStoredUserCredentials(): Promise<Error | void> {\n    if (!this.connectionStorageCurrentUserCrdentials) {\n      return new CAError('There is no connection to the storage of the user credntials');\n    }\n    if (!this.authProviderId) {\n      return new CAError(\n        \"The auth provider's identifier, the user was authorized on, is not defined to check the user's crypto credntials for it\"\n      );\n    }\n    if (!this.remoteProvidedUserCryptoCredntials) {\n      return new CAError('The user crypto credentials returned by the auth provider are not defined');\n    }\n\n    let cryptoCredentials = await this.connectionStorageCurrentUserCrdentials.get(\n      this.remoteProvidedUserCryptoCredntials.userIdentity\n    );\n\n    if (cryptoCredentials instanceof Error) {\n      console.error(cryptoCredentials);\n      console.error(\n        new CAError(\n          `Failed to read credentials for the user identity ${this.remoteProvidedUserCryptoCredntials.userIdentity}. Try to read it for the auth provider identity ${this.authProviderId}`\n        )\n      );\n      cryptoCredentials = undefined;\n    }\n    if (!cryptoCredentials) {\n      cryptoCredentials = await this.connectionStorageCurrentUserCrdentials.getByAuthProvider(this.authProviderId);\n      if (cryptoCredentials instanceof Error) {\n        console.error(cryptoCredentials);\n        return new CAError(`Failed to read crypto credentials for the auth provider ${this.authProviderId}`);\n      }\n    }\n    if (!cryptoCredentials) {\n      console.warn('There is no credentials stored locally for the current user');\n      return;\n    }\n    return this.setLocallyStoredCredentials(cryptoCredentials);\n  }\n\n  /**\n   * compare the user's credentials got from the user\n   * credentials storage and the swarm provider\n   * user is authorized on.\n   *\n   * @protected\n   * @memberof CentralAuthority\n   */\n  protected async compareLocalAndRemoteCredentials(): Promise<Error | void> {\n    if (!this.remoteProvidedUserCryptoCredntials) {\n      return new CAError('There is no credntials for the user provided by the auth provider the user is authentificated on');\n    }\n    if (!this.locallyStoredUserCryptoCredntials) {\n      console.warn(\n        'There is no crypto credentials stored for the user identity and the current auth provider id. Nothing to check.'\n      );\n      return;\n    }\n\n    const comparationResult = await compareCryptoCredentials(\n      this.locallyStoredUserCryptoCredntials,\n      this.remoteProvidedUserCryptoCredntials\n    );\n\n    if (comparationResult instanceof Error) {\n      console.error(comparationResult);\n      return new CAError('Failed to compare crypto credentials stored locally and got by the auth provider');\n    }\n    if (comparationResult !== true) {\n      return new CAError(\n        'The crypto credentials stored in the credentials storage does not equals to the credentials provided be the auth provider'\n      );\n    }\n  }\n\n  /**\n   * Stores the crypto credentials to the current user credentials storage\n   * connection.\n   *\n   * @protected\n   * @returns {(Promise<Error | void>)}\n   * @memberof CentralAuthority\n   */\n  protected async storeCryptoCredentialsFromAuthProvider(): Promise<Error | void> {\n    const {\n      connectionStorageCurrentUserCrdentials,\n      locallyStoredUserCryptoCredntials,\n      remoteProvidedUserCryptoCredntials,\n    } = this;\n\n    if (locallyStoredUserCryptoCredntials) {\n      console.warn('storeCryptoCredentialsFromAuthProvider:: locally stored credentials for the current user is already exists');\n      return;\n    }\n    if (!remoteProvidedUserCryptoCredntials) {\n      return new CAError('There was no credentials provided by the auth provider the user is authorized on');\n    }\n    if (!connectionStorageCurrentUserCrdentials) {\n      return new CAError('There is no connection to the storage of the current user credentials');\n    }\n\n    const setRemoteCredentialsResult = await connectionStorageCurrentUserCrdentials.set(remoteProvidedUserCryptoCredntials);\n\n    if (setRemoteCredentialsResult instanceof Error) {\n      console.error(setRemoteCredentialsResult);\n      return new CAError('Failed to store locally the current user credentials provided by the auth provided');\n    }\n  }\n\n  /**\n   * create instance\n   *\n   * @protected\n   * @returns {(Error | ICASwarmCredentialsProvider)}\n   * @memberof CentralAuthority\n   */\n  protected createConnectionToSwarmCredentialsStorage(): Error | ICASwarmCredentialsProvider {\n    try {\n      return new CASwarmCredentialsProvider();\n    } catch (err) {\n      console.error(err);\n      return new CAError('Failed to create instance of the Swarm credentials storage');\n    }\n  }\n\n  /**\n   * get options to establish a new connection to the\n   * swarm credentials storage\n   *\n   * @protected\n   * @returns {(Error\n   *     | ICASwarmCredentialsProviderOptions)}\n   * @memberof CentralAuthority\n   */\n  protected getOptionsForSwarmCredentialsStorageConnection(): Error | ICASwarmCredentialsProviderOptions {\n    if (!this.connectionAuthProvidersPool) {\n      return new CAError('A connection to the swarm pool must be provided for the swarm credentials storage');\n    }\n    return {\n      connections: {\n        swarmConnectionPool: this.connectionAuthProvidersPool,\n      },\n      storageDb: CENTRAL_AUTHORITY_CLASS_SWARM_CREDENTIALS_STORAGE_DB_NAME,\n    };\n  }\n\n  protected setConnectionToSwarmCredentialsStorage(connection: ICASwarmCredentialsProvider) {\n    this.connectionSwarmCredentialsProvider = connection;\n  }\n\n  protected unsetConnectionToSwarmCredentialsStorage() {\n    this.connectionSwarmCredentialsProvider = undefined;\n  }\n\n  /**\n   * establish connection to the swarm storage credentials provider\n   *\n   * @protected\n   * @returns {(Promise<Error | void>)}\n   * @memberof CentralAuthority\n   */\n  protected async connectToSwarmCredentialsStorage(): Promise<Error | void> {\n    const connectionToSwarmCredentialsStorage = this.createConnectionToSwarmCredentialsStorage();\n\n    if (connectionToSwarmCredentialsStorage instanceof Error) {\n      console.error(connectionToSwarmCredentialsStorage);\n      return connectionToSwarmCredentialsStorage;\n    }\n\n    const options = this.getOptionsForSwarmCredentialsStorageConnection();\n\n    if (options instanceof Error) {\n      console.error(options);\n      return options;\n    }\n\n    const connectionResult = await connectionToSwarmCredentialsStorage.connect(options);\n\n    if (connectionResult instanceof Error) {\n      console.error(connectionResult);\n      return new CAError('Failed to connect to the swarm credentials storage');\n    }\n    return this.setConnectionToSwarmCredentialsStorage(connectionToSwarmCredentialsStorage);\n  }\n\n  /**\n   * read credentials of the user connected to the swarm\n   * from a local cache or, if not found in the local\n   * cache, from the swarm auth provider.\n   *\n   * @param {TCAUserIdentityRawTypes} identity\n   * @returns {(Promise<TCentralAuthorityUserCryptoCredentials | Error | null>)}\n   * @memberof CentralAuthority\n   */\n  @dataCachingUtilsCachingDecorator(CENTRAL_AUTHORITY_CLASS_SWARM_CREDENTIALS_SWARM_USERS_CREDENTIALS_CACHE_CAPACITY)\n  protected async readSwarmUserCredentials(\n    identity: TCAUserIdentityRawTypes\n  ): Promise<TCentralAuthorityUserCryptoCredentials | Error | null> {\n    const { connectionSwarmCredentialsProvider } = this;\n\n    if (!connectionSwarmCredentialsProvider) {\n      return new CAError('There is no connection to the swarm credentials provider');\n    }\n    return connectionSwarmCredentialsProvider.get(identity);\n  }\n\n  protected getCurrentUserCryptoCredentials(): Error | TCentralAuthorityUserCryptoCredentials {\n    if (!this.isRunning) {\n      return this.errorNotRunning;\n    }\n    if (!this.remoteProvidedUserCryptoCredntials) {\n      return new CAError('There is no user crypyo credentials');\n    }\n    return this.remoteProvidedUserCryptoCredntials;\n  }\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-class.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/central-authority-connection-firebase-base.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/central-authority-connection-firebase-base.ts",["2669","2670","2671","2672","2673","2674","2675","2676","2677","2678","2679","2680","2681","2682","2683","2684","2685","2686"],"/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport * as firebase from 'firebase/app';\nimport 'firebase/auth';\nimport { ICAConnectionSignUpCredentials, ICAConnectionUserAuthorizedResult } from '../../central-authority-connections.types';\nimport {\n  ICAConnectionConfigurationFirebase,\n  ICAConnectionFirebaseUserProfile,\n} from '../central-authority-connection-firebase.types.configuration';\nimport {\n  ICentralAuthorityUserAuthCredentials,\n  TCentralAuthorityUserCryptoCredentials,\n  ICentralAuthorityUserProfile,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { isEmptyObject } from 'utils/common-utils/common-utils-objects';\nimport { validateUserProfileData } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user';\nimport { dataValidatorUtilEmail, dataValidatorUtilURL } from 'utils/data-validators-utils/data-validators-utils';\nimport { checkIsValidCryptoCredentials } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport { generateCryptoCredentialsWithUserIdentityV1 } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport CentralAuthorityIdentity from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport { CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport { CAConnectionFirestoreUtilsCredentialsStrorage } from '../central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage';\nimport { CA_CONNECTION_FIREBASE_CREDENTIALS_GENERATION_MAX_ATTEMPTS } from '../central-authority-connection-firebase.const/central-authority-connection-firebase.const.restrictions';\nimport { validatePassword } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport ErrorExtendedBaseClass from 'classes/basic-classes/error-extended-class-base/error-extended-class-base';\nimport {\n  CA_CONNECTION_ERROR_ACCOUNT_NOT_VERIFIED_CODE,\n  CA_CONNECTION_ERROR_ACCOUNT_CAN_NOT_BE_USED_ANYMORE,\n} from '../../central-authority-connections-const/central-authority-connections-const';\nimport { valiateCAAuthConnectionFirebaseUtilsConnetionConfiguration } from '../central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators';\nimport { timeout } from 'utils';\nimport { CA_CONNECTION_FIREBASE_AUTH_WITH_SESSION_TOKEN_TIMEOUT_MS } from '../central-authority-connection-firebase.const';\nimport { ISensitiveDataSessionStorage } from '../../../../sensitive-data-session-storage/sensitive-data-session-storage.types';\nimport { CENTRAL_AUTHORITY_CONNECTION_FIREBASE_BASE_SESSION_KEY } from './central-authority-connection-firebase-base.const';\nimport { ICAConnectionFirebaseBaseSessionData } from './central-authority-connection-firebase-base.types';\nimport assert from 'assert';\nimport {\n  importCryptoCredentialsFromAString,\n  exportCryptoCredentialsToString,\n} from '../../../central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\n\n/**\n *\n * This is the class realized the basic functions\n * allows to connect with the Firebase.\n *\n * @export\n * @class CAConnectionWithFirebase\n */\nexport class CAConnectionWithFirebaseBase {\n  public static validateConfiguration = valiateCAAuthConnectionFirebaseUtilsConnetionConfiguration;\n\n  // if the application is connected with the remote Firebase\n  public isConnected: boolean = false;\n\n  public get isUserSignedIn(): boolean {\n    const { isConnected, isVerifiedAccount } = this;\n\n    if (!isConnected) {\n      return false;\n    }\n    // according to the https://firebase.google.com/docs/auth/web/manage-users\n    return isVerifiedAccount;\n  }\n\n  public get isAuthorized(): boolean {\n    const { isUserSignedIn, valueofCredentialsSignUpOnAuthorizedSuccess: credentialsAuthorizedSuccess } = this;\n\n    if (!isUserSignedIn) {\n      return false;\n    }\n    // according to the https://firebase.google.com/docs/auth/web/manage-users\n    return !!credentialsAuthorizedSuccess;\n  }\n\n  public get authResult(): ICAConnectionUserAuthorizedResult | void {\n    return this.valueofCredentialsSignUpOnAuthorizedSuccess;\n  }\n\n  protected configuration?: ICAConnectionConfigurationFirebase;\n\n  protected isAuthorizedWithCredentials: boolean = false;\n\n  protected valueofCredentialsSignUpOnAuthorizedSuccess?: ICAConnectionUserAuthorizedResult;\n\n  protected connectionWithCredentialsStorage?: CAConnectionFirestoreUtilsCredentialsStrorage;\n\n  protected get currentUser(): firebase.User | null {\n    const { isConnected } = this;\n\n    return isConnected ? this.app?.auth().currentUser : null;\n  }\n\n  protected get isVerifiedAccount(): boolean {\n    const { isConnected, currentUser: currentUserData } = this;\n    if (!isConnected) {\n      return false;\n    }\n    if (!currentUserData) {\n      return false;\n    }\n    if (!currentUserData.emailVerified) {\n      return false;\n    }\n    return true;\n  }\n\n  protected get databaseURL(): Error | string {\n    const { configuration } = this;\n\n    if (!configuration) {\n      return new Error('There is no url specified for the Firebase authority provided');\n    }\n\n    const { databaseURL } = configuration;\n\n    if (dataValidatorUtilURL(databaseURL)) {\n      return databaseURL;\n    }\n    return new Error('An invalid URL provided for the Firebase authority provider');\n  }\n\n  protected get app(): firebase.app.App {\n    return firebase.app(this.databaseURL as string);\n  }\n\n  // return the firebase application\n  public getApp(): void | firebase.app.App {\n    return this.app;\n  }\n\n  /**\n   * sign out if authorized before\n   *\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof CAConnectionWithFirebaseBase\n   */\n  public async signOut(): Promise<boolean | Error> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    // disconnect the strage cause it's necessary\n    // that the user was authorized\n    const disconnectFromStorageResult = await this.disconnectCredentialsStorage();\n\n    if (disconnectFromStorageResult instanceof Error) {\n      return disconnectFromStorageResult;\n    }\n    try {\n      await this.app.auth().signOut();\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to sign out');\n    }\n    this.handleUnauthorized();\n\n    return true;\n  }\n\n  /**\n   * connect to the Firebase database. To authorize\n   * in the database to set credentials it is necesssry\n   * to authorize in.\n   *\n   * @param {ICAConnectionConfigurationFirebase} configuration\n   * @param {string} name - name of the application,\n   * it's necessary to provide a name string if more than one Firebase\n   * applications will be used simultaneousely. But at the first time\n   * no name must be provided, cause it means that the DEFAULT application\n   * will be created, which is required by the Firebase.\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof CAConnectionWithFirebaseBase\n   */\n  public async connect(configuration: ICAConnectionConfigurationFirebase, name?: string): Promise<boolean | Error> {\n    let app;\n\n    try {\n      const appName = name || configuration.databaseURL;\n      const existingApp = firebase.apps.find((app) => app.name);\n\n      app = existingApp || firebase.initializeApp(configuration, appName);\n      this.configuration = configuration;\n    } catch (err) {\n      console.error(err);\n      this.setConnectedStatus(false);\n      return new Error('Failed to initialize the application with the given configuration');\n    }\n    this.setConnectedStatus(app);\n    return true;\n  }\n\n  public getCAUserProfile = async (): Promise<Partial<ICentralAuthorityUserProfile> | undefined | Error> => {\n    if (this.isAuthorized) {\n      return this.getCurrentUserProfileData() || undefined;\n    }\n  };\n\n  /**\n   * Returns current authorized user's profile from\n   * the firebase.\n   *\n   * @protected\n   * @returns {(Partial<ICentralAuthorityUserProfile> | null)}\n   * @memberof CAConnectionWithFirebaseBase\n   */\n  protected getCurrentUserData(): firebase.User | null {\n    return this.app?.auth().currentUser;\n  }\n\n  /**\n   * Map the user's Firebase data to the user's\n   * Central Authority profile data.\n   *\n   * @protected\n   * @param {firebase.User} userData\n   * @memberof CAConnectionWithFirebaseBase\n   * @returns {Partial<ICentralAuthorityUserProfile>}\n   */\n  protected mapUserFirebaseDataToCAUserProfileData(userData: firebase.User): Partial<ICentralAuthorityUserProfile> {\n    return {\n      name: userData.displayName,\n      email: userData.email,\n      phone: userData.phoneNumber,\n      photoURL: userData.photoURL,\n    };\n  }\n\n  /**\n   * Map the user's Firabase access provider's data to the\n   * Central Authority profile data.\n   *\n   * @protected\n   * @param {firebase.UserInfo} userData\n   * @returns {Partial<ICentralAuthorityUserProfile>}\n   * @memberof CAConnectionWithFirebaseBase\n   */\n  protected mapUserProviderDataToCAUserProfileData(userData: firebase.UserInfo): Partial<ICentralAuthorityUserProfile> {\n    return {\n      name: userData.displayName,\n      email: userData.email,\n      phone: userData.phoneNumber,\n      photoURL: userData.photoURL,\n    };\n  }\n\n  /**\n   * Returns current authorized user's profile from\n   * the firebase.\n   *\n   * @protected\n   * @returns {(Partial<ICentralAuthorityUserProfile> | null)}\n   * @memberof CAConnectionWithFirebaseBase\n   */\n  protected getCurrentUserProfileData(): Partial<ICentralAuthorityUserProfile> | undefined {\n    const userData = this.getCurrentUserData();\n\n    if (userData) {\n      const userDataFromAuthProvider = userData?.providerData?.[0];\n\n      if (userDataFromAuthProvider) {\n        return this.mapUserProviderDataToCAUserProfileData(userDataFromAuthProvider);\n      }\n      return this.mapUserProviderDataToCAUserProfileData(userData);\n    }\n  }\n\n  /**\n   * This method may be substituted by firebase\n   * connection implementation to be compilant\n   * to an CA identifier version.\n   * When call the method createOrSetCredentialsInDB\n   * functions to generate credentials and store\n   * it in the database may be substitudet by\n   * an implementation of it compolant to the\n   * identifier version.\n   * Thi version is compilant to the identity v1.\n   *\n   * @param signUpCredentials\n   */\n  protected async generateAndSetCredentialsForTheCurrentUser(\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials> {\n    const credentialsProvidedCheckResult = this.checkSignUpCredentials(signUpCredentials);\n\n    if (credentialsProvidedCheckResult instanceof Error) {\n      console.error(credentialsProvidedCheckResult);\n      return credentialsProvidedCheckResult;\n    }\n\n    return this.createOrSetCredentialsInDB(signUpCredentials);\n  }\n\n  protected setConnectedStatus(isConnected: false | firebase.app.App) {\n    this.isConnected = !!isConnected;\n  }\n\n  protected setAuthorizedStatus(isAuthorized: boolean) {\n    this.isAuthorizedWithCredentials = isAuthorized;\n  }\n\n  protected checkIfConnected(): boolean | Error {\n    const { isConnected, connectionWithCredentialsStorage } = this;\n\n    if (!connectionWithCredentialsStorage || !connectionWithCredentialsStorage.isConnected) {\n      return false;\n    }\n    return !isConnected ? new Error('There is no active connection with the Firebase') : true;\n  }\n\n  protected checkSignUpCredentials(signUpCredentials: ICAConnectionSignUpCredentials): boolean | Error {\n    if (!signUpCredentials) {\n      return new Error('Sign up credentials must be provided');\n    }\n    if (typeof signUpCredentials !== 'object') {\n      return new Error('Sign up credentials must be an object');\n    }\n\n    const { cryptoCredentials: credentialsGiven, login, password } = signUpCredentials;\n\n    if (credentialsGiven) {\n      const resultCheckCredentialsGiven = this.checkUserIdentityIsValidForConfigurationProvided(credentialsGiven);\n\n      if (resultCheckCredentialsGiven instanceof Error) {\n        console.error(resultCheckCredentialsGiven);\n        return new Error('Credentials given is not valid for the Firebase auth provider');\n      }\n    }\n    if (!dataValidatorUtilEmail(login)) {\n      return new Error('The login must be an email valid');\n    }\n    if (!validatePassword(password)) {\n      return new Error('The password provided is not valid');\n    }\n    return true;\n  }\n\n  protected setConnectionWithCredentialsStorage(connectionWithCredentialsStorage: CAConnectionFirestoreUtilsCredentialsStrorage) {\n    this.connectionWithCredentialsStorage = connectionWithCredentialsStorage;\n  }\n\n  protected async startConnectionWithCredentialsStorage(): Promise<boolean | Error> {\n    if (this.connectionWithCredentialsStorage) {\n      // if already connected with the credentials storage\n      return true;\n    }\n\n    const connectionWithCredentialsStorage = new CAConnectionFirestoreUtilsCredentialsStrorage(this);\n    const storageConnectionResult = await connectionWithCredentialsStorage.connect();\n\n    if (storageConnectionResult instanceof Error) {\n      console.error(storageConnectionResult);\n      return new Error('Failed connect to the Firebase credentials storage');\n    }\n    if (!connectionWithCredentialsStorage.isConnected) {\n      return new Error('Connection to the Firebase credentials storage was not succeed');\n    }\n    this.setConnectionWithCredentialsStorage(connectionWithCredentialsStorage);\n    return true;\n  }\n\n  protected async waitingUserInit(): Promise<void | firebase.User | Error> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return new Error('The connection is not established');\n    }\n    if (!this.app) {\n      return new Error('The Firebase app is not defined');\n    }\n    return new Promise((res) => {\n      this.app.auth().onAuthStateChanged((user) => {\n        if (user && user.email) {\n          res(user);\n        }\n      });\n    });\n  }\n\n  protected handleUnauthorized() {\n    this.setAuthorizedStatus(false);\n    this.valueofCredentialsSignUpOnAuthorizedSuccess = undefined;\n  }\n\n  // handle an authorization attemp failed\n  protected onAuthorizationFailed(error: Error | string): Error {\n    const err = error instanceof Error ? error : new Error(String(error));\n\n    console.error(err);\n    console.error('Authorization failed on remote Firebase server');\n    this.handleUnauthorized();\n    return err;\n  }\n\n  protected async singUpWithAuthCredentials(authCredentials: ICentralAuthorityUserAuthCredentials): Promise<boolean | Error> {\n    const checkSignUpCredentialsResult = this.checkSignUpCredentials(authCredentials);\n\n    if (checkSignUpCredentialsResult instanceof Error) {\n      console.error(checkSignUpCredentialsResult);\n      return this.onAuthorizationFailed(checkSignUpCredentialsResult);\n    }\n\n    const { login, password } = authCredentials;\n\n    try {\n      await this.app.auth().createUserWithEmailAndPassword(login, password as string);\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to sign up to the Firebase with the given credentials');\n    }\n    return true;\n  }\n\n  /**\n   * sign in under the login\n   * provided by the user\n   * @param authCredentials\n   * @param {string} authCredentials.login\n   * @param {string} authCredentials.password\n   */\n  protected async singInWithAuthCredentials(authCredentials: ICentralAuthorityUserAuthCredentials): Promise<boolean | Error> {\n    const { login, password } = authCredentials;\n\n    try {\n      if (password) {\n        await this.app.auth().signInWithEmailAndPassword(login, password);\n      }\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to sign up to the Firebase with the given credentials');\n    }\n    return true;\n  }\n\n  /**\n   * firebase.auth.Auth.Persistence.SESSION\t'session'\tIndicates that the state will only persist in the current session or tab, and will be cleared when the tab or window in which the user authenticated is closed. Applies only to web apps.\n   * firebase.auth.Auth.Persistence.LOCAL\t'local'\tIndicates that the state will be persisted even when the browser window is closed or the activity is destroyed in React Native. An explicit sign out is needed to clear that state. Note that Firebase Auth web sessions are single host origin and will be persisted for a single domain only.\n   * firebase.auth.Auth.Persistence.NONE\t'none'\tIndicates that the state will only be stored in memory and will be cleared when the window or activity is refreshed.\n   *\n   * @protected\n   * @memberof CAConnectionWithFirebaseBase\n   */\n  protected async setSessionPersistance() {\n    try {\n      await this.app.auth().setPersistence(firebase.auth.Auth.Persistence.SESSION);\n    } catch (err) {\n      console.error('Failed to set Session persistance for the Firebase');\n    }\n  }\n\n  // TODO - add to the CentralAuthrotity methods\n  // the ability to get swarm users profiles data\n  protected async getUserProfileData(): Promise<Error | ICentralAuthorityUserProfile> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { currentUser: currentUserData } = this;\n\n    // current user is instance\n    // of the firebase current user\n    if (!currentUserData) {\n      // if there is no profile data\n      return {};\n    }\n\n    const { displayName, photoURL, phoneNumber, email } = currentUserData;\n\n    return {\n      name: displayName || null,\n      email: email || null,\n      phone: phoneNumber || null,\n      photoURL: photoURL || null,\n    };\n  }\n\n  protected async returnOnAuthorizedResult(\n    cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): Promise<ICAConnectionUserAuthorizedResult | Error> {\n    const userProfile = await this.getUserProfileData();\n\n    if (userProfile instanceof Error) {\n      console.error(userProfile);\n      return new Error('Failed to get profile data');\n    }\n    return {\n      cryptoCredentials,\n      profile: userProfile,\n    };\n  }\n\n  protected mapAppProfileToFirebaseProfileWithoutEmail(\n    profile: Partial<ICentralAuthorityUserProfile>\n  ): ICAConnectionFirebaseUserProfile {\n    return {\n      displayName: (profile && profile.name) || null,\n      photoURL: (profile && profile.photoURL) || null,\n    };\n  }\n\n  protected async setProfileDataEmail(email: string): Promise<Error | boolean> {\n    const checkIsConnectedResult = this.checkIfConnected();\n\n    if (checkIsConnectedResult instanceof Error) {\n      return checkIsConnectedResult;\n    }\n    if (!dataValidatorUtilEmail(email)) {\n      return new Error('The email is not valid');\n    }\n\n    const { currentUser } = this;\n\n    if (!currentUser) {\n      return new Error('Failed to get the user profile data');\n    }\n    if (currentUser.email !== email) {\n      try {\n        await currentUser.updateEmail(email);\n      } catch (err) {\n        console.error(err);\n        return new Error('Failed to update the email address');\n      }\n\n      const sendEmailVerificationResult = await this.handleAuthEmailNotVerified();\n\n      if (sendEmailVerificationResult instanceof Error) {\n        console.error(sendEmailVerificationResult);\n        return new Error('Failed to update the email address');\n      }\n      // TODO - if the user was authentificated by OAuth\n      // it is necessary to invoke the reauthentificate method\n      // of the Firebase\n      const logOutResult = await this.signOut();\n\n      if (logOutResult instanceof Error) {\n        console.error(logOutResult);\n        return new Error('Failed to log out');\n      }\n      return true;\n    }\n    return true;\n  }\n\n  /**\n   * At no a phone number can't be updated\n   * @param profileDataPartialWithoutPhoneNumber\n   */\n  protected async setProfileDataWithFirebase(\n    profileDataPartialWithoutPhoneNumber: Partial<ICentralAuthorityUserProfile>\n  ): Promise<Error | boolean> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { currentUser } = this;\n\n    if (!currentUser) {\n      return new Error('There is no current user profile');\n    }\n\n    const profileMappedForFirebaseWithoutEmail = this.mapAppProfileToFirebaseProfileWithoutEmail(\n      profileDataPartialWithoutPhoneNumber\n    );\n\n    try {\n      await currentUser.updateProfile(profileMappedForFirebaseWithoutEmail);\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to set the Firebase profile data');\n    }\n    // TODO - what to do with a phone number\n    return true;\n  }\n\n  // TODO - test it and change to private method\n  protected async setProfileData(profile: Partial<ICentralAuthorityUserProfile>): Promise<Error | ICentralAuthorityUserProfile> {\n    if (isEmptyObject(profile)) {\n      return this.getUserProfileData();\n    }\n    if (!validateUserProfileData(profile)) {\n      return new Error('The profile is not valid');\n    }\n\n    const resultUpdateProfile = await this.setProfileDataWithFirebase(profile);\n\n    if (resultUpdateProfile instanceof Error) {\n      return resultUpdateProfile;\n    }\n\n    const updatedProfile = await this.getUserProfileData();\n\n    if (updatedProfile instanceof Error) {\n      console.error(updatedProfile);\n      return new Error('Failed to read the updated profile data');\n    }\n\n    const { email } = profile;\n\n    if (email) {\n      // if it is necessary to update email value\n      // it will cause that user must authentificate\n      // once again\n      const updateEmailResult = await this.setProfileDataEmail(email);\n\n      if (updateEmailResult instanceof Error) {\n        return updateEmailResult;\n      }\n      return {\n        ...updatedProfile,\n        email,\n      };\n    }\n    return updatedProfile;\n  }\n\n  protected async handleAuthEmailNotVerified(): Promise<boolean | Error> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { currentUser } = this;\n\n    if (!currentUser) {\n      return new Error('There is no user authorized');\n    }\n\n    try {\n      await currentUser.sendEmailVerification();\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to send the email verification link');\n    }\n    return true;\n  }\n\n  /**\n   * check if an account of the user\n   * was verified or not.\n   * If it wasn't, then send an email\n   * to verify it.\n   * @protected\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof CAConnectionWithFirebase\n   */\n  protected async chekIfVerifiedAccount(): Promise<boolean | Error> {\n    // if the account was validated by email\n    if (this.isVerifiedAccount) {\n      return true;\n    }\n\n    // if the account was not validated by email\n    // send the verification email\n    const sendVerificationEmailResult = await this.handleAuthEmailNotVerified();\n\n    if (sendVerificationEmailResult instanceof Error) {\n      console.error(sendVerificationEmailResult);\n      return new Error('Failed to send the email verification');\n    }\n    return new ErrorExtendedBaseClass('Please verify the email address', CA_CONNECTION_ERROR_ACCOUNT_NOT_VERIFIED_CODE);\n  }\n\n  protected generateNewCryptoCredentialsForConfigurationProvided = async (): Promise<\n    Error | TCentralAuthorityUserCryptoCredentials\n  > => {\n    const { databaseURL } = this;\n\n    if (databaseURL instanceof Error) {\n      return databaseURL;\n    }\n\n    const cryptoCredentials = await generateCryptoCredentialsWithUserIdentityV1({\n      authorityProviderURI: databaseURL,\n    });\n\n    if (cryptoCredentials instanceof Error) {\n      console.error(cryptoCredentials);\n      return new Error('Failed to generate a new crypto credentials');\n    }\n    return cryptoCredentials;\n  };\n\n  protected checkUserIdentityIsValidForConfigurationProvided(\n    cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): Error | TCentralAuthorityUserCryptoCredentials {\n    const { databaseURL } = this;\n\n    if (databaseURL instanceof Error) {\n      return databaseURL;\n    }\n    if (!checkIsValidCryptoCredentials(cryptoCredentials)) {\n      return new Error('The crypto credentials value is not valid');\n    }\n\n    const caUserIdentity = new CentralAuthorityIdentity(cryptoCredentials);\n\n    if (!caUserIdentity.isValid) {\n      return new Error('User identity is not valid');\n    }\n\n    const { identityDescription: identityDescriptionParsed } = caUserIdentity;\n\n    if (identityDescriptionParsed instanceof Error) {\n      console.error(identityDescriptionParsed);\n      return new Error('Failed to get description by identity string');\n    }\n    if (identityDescriptionParsed[CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME] !== databaseURL) {\n      return new Error('Wrong authority provider url got from the identity string');\n    }\n    return cryptoCredentials;\n  }\n\n  protected async readCryptoCredentialsForTheUserFromDatabase(\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials | null> {\n    const isConnected = this.checkIfConnected();\n\n    if (!isConnected) {\n      return new Error('There is no active connection to the Firebase auth provider');\n    }\n\n    const { connectionWithCredentialsStorage } = this;\n    const credentialsForTheCurrentUser = await connectionWithCredentialsStorage!.getCredentialsForTheCurrentUser(\n      signUpCredentials\n    );\n\n    if (credentialsForTheCurrentUser instanceof Error) {\n      console.error(credentialsForTheCurrentUser);\n      return new Error('Failed to read credentials of the current user');\n    }\n    return credentialsForTheCurrentUser;\n  }\n\n  protected setCryptoCredentialsForTheUserToDatabase = async (\n    cryptoCredentials: TCentralAuthorityUserCryptoCredentials,\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials> => {\n    const isConnected = this.checkIfConnected();\n    const { connectionWithCredentialsStorage } = this;\n\n    if (!isConnected) {\n      return new Error('There is no active connection to the Firebase auth provider');\n    }\n    // set the new generated credentials forcely\n    // and rewrite the existing\n    // cause it is not valid\n    const setCredentialsResult = await connectionWithCredentialsStorage!.setUserCredentials(cryptoCredentials, signUpCredentials);\n\n    if (setCredentialsResult instanceof Error) {\n      return setCredentialsResult;\n    }\n    // if not an error then return\n    // a crypto credentials\n    return setCredentialsResult;\n  };\n\n  protected async createOrSetCredentialsInDB(\n    signUpCredentials: ICAConnectionSignUpCredentials,\n    generateNewCryptoCredentialsForConfigurationProvided: () => Promise<Error | TCentralAuthorityUserCryptoCredentials> = this\n      .generateNewCryptoCredentialsForConfigurationProvided,\n    setCryptoCredentialsForTheUserToDatabase: (\n      cryptoCredentials: TCentralAuthorityUserCryptoCredentials,\n      signUpCredentials: ICAConnectionSignUpCredentials\n    ) => Promise<Error | TCentralAuthorityUserCryptoCredentials> = this.setCryptoCredentialsForTheUserToDatabase\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials> {\n    let attempt = 0;\n    let cryptoCredentials: TCentralAuthorityUserCryptoCredentials | Error = new Error(\n      'Failed to generate and set a crypto credentials for the user because of unknown reason'\n    );\n    let isSuccess: boolean = false;\n\n    if (typeof generateNewCryptoCredentialsForConfigurationProvided !== 'function') {\n      return new Error('The generateNewCryptoCredentialsForConfigurationProvided argument must be a function');\n    }\n    if (typeof setCryptoCredentialsForTheUserToDatabase !== 'function') {\n      return new Error('The setCryptoCredentialsForTheUserToDatabase argument must be a function');\n    }\n    const credentialsGiven = signUpCredentials.cryptoCredentials;\n\n    // try a multiple times cause may be\n    // a network errors or user id\n    // is already exists in the database\n    while (attempt < CA_CONNECTION_FIREBASE_CREDENTIALS_GENERATION_MAX_ATTEMPTS && !isSuccess) {\n      cryptoCredentials = credentialsGiven\n        ? // if a credentials provided, then use it\n          credentialsGiven\n        : // if a credentials not provided, generate a new one\n          await generateNewCryptoCredentialsForConfigurationProvided();\n\n      if (cryptoCredentials instanceof Error) {\n        // fialed to generate a new crypto credentials\n        console.error(cryptoCredentials);\n      } else {\n        const setCredentialsResult = await setCryptoCredentialsForTheUserToDatabase(cryptoCredentials, signUpCredentials);\n\n        if (setCredentialsResult instanceof Error) {\n          console.error(setCredentialsResult);\n          cryptoCredentials = new Error('Failed to store credentials for the user in the database');\n        } else {\n          cryptoCredentials = setCredentialsResult;\n          isSuccess = true;\n        }\n      }\n      attempt += 1;\n    }\n    return cryptoCredentials;\n  }\n\n  /**\n   * check if a credentials are already exists\n   * in the remote storage for the user.\n   *\n   * @protected\n   * @returns\n   * @memberof CAConnectionWithFirebaseBase\n   */\n  protected async checkIfCredentialsExistsForTheUser(\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | void | TCentralAuthorityUserCryptoCredentials> {\n    const credentialsExistingForTheCurrentUser = await this.readCryptoCredentialsForTheUserFromDatabase(signUpCredentials);\n\n    if (credentialsExistingForTheCurrentUser instanceof Error) {\n      // if something was going wrong when reading\n      // a credentials for the current user\n      // return an Error, because if ignore\n      // and set a new credentials in storage\n      // the data may become inconsistent, cause\n      // credentials is already exists in the database\n      // but an error has occurred once for a some reason.\n      console.error(credentialsExistingForTheCurrentUser);\n      return new Error('Failed to read credentials for the user from the Firebase database');\n    }\n\n    if (credentialsExistingForTheCurrentUser) {\n      const credentialsValidationResult = this.checkUserIdentityIsValidForConfigurationProvided(\n        credentialsExistingForTheCurrentUser\n      );\n\n      if (credentialsValidationResult instanceof Error) {\n        console.error(credentialsValidationResult);\n        console.error('The credentials stored for the user is not valid');\n        // if credentials exists for the user but invalid at now\n        // return an error to inform that the user can't user\n        // this account for authorization.\n        // Credentials was already read by another users\n        // and if we set a new one in the storage it may\n        // cause inconsistency.\n        return new ErrorExtendedBaseClass(\n          \"Sorry, you can't use this account anymore, cause a credentials existing for the account exists and not valid\",\n          CA_CONNECTION_ERROR_ACCOUNT_CAN_NOT_BE_USED_ANYMORE\n        );\n      }\n\n      // if the credentials read from the\n      // Firebase storage is valid\n      // for the current configuration return it\n      return credentialsExistingForTheCurrentUser;\n    }\n  }\n\n  protected async setSessionData(session: ISensitiveDataSessionStorage, sessionData: object): Promise<Error | undefined> {\n    try {\n      assert(sessionData, 'A session data must not be empty');\n      assert(typeof sessionData === 'object', 'A session data must an object');\n      await session.setItem(CENTRAL_AUTHORITY_CONNECTION_FIREBASE_BASE_SESSION_KEY, sessionData);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected async setCurrentUserCryptoCredentialsInSession(\n    session: ISensitiveDataSessionStorage,\n    cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): Promise<Error | undefined> {\n    try {\n      assert(cryptoCredentials, 'Crypto credenitials must be provided');\n      assert(typeof cryptoCredentials === 'object', 'Crypto credentials must be an object');\n\n      const credentialsExported = await exportCryptoCredentialsToString(cryptoCredentials);\n\n      if (credentialsExported instanceof Error) {\n        throw credentialsExported;\n      }\n      return await this.setSessionData(session, {\n        credentials: credentialsExported,\n      });\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected async readSessionData(\n    session: ISensitiveDataSessionStorage\n  ): Promise<Error | undefined | ICAConnectionFirebaseBaseSessionData> {\n    try {\n      const sessionData = await session.getItem(CENTRAL_AUTHORITY_CONNECTION_FIREBASE_BASE_SESSION_KEY);\n\n      if (sessionData) {\n        assert(typeof sessionData === 'object', 'session data is not an object');\n        return sessionData;\n      }\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected async readCryptoCrdentialsFromSession(\n    session: ISensitiveDataSessionStorage\n  ): Promise<undefined | Error | TCentralAuthorityUserCryptoCredentials> {\n    const sessionData = await this.readSessionData(session);\n\n    if (!sessionData) {\n      return;\n    }\n    if (sessionData instanceof Error) {\n      return sessionData;\n    }\n\n    const { credentials } = sessionData;\n\n    if (credentials) {\n      try {\n        if (typeof credentials !== 'string') {\n          return new Error('Credentials stored in session have a wrong format');\n        }\n        return await importCryptoCredentialsFromAString(credentials);\n      } catch (err) {\n        return err;\n      }\n    }\n  }\n\n  protected async createOrReturnExistingCredentialsForUser(\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials> {\n    const credentialsExistingForTheCurrentUser = await this.checkIfCredentialsExistsForTheUser(signUpCredentials);\n\n    if (credentialsExistingForTheCurrentUser instanceof Error) {\n      return credentialsExistingForTheCurrentUser;\n    }\n    if (credentialsExistingForTheCurrentUser != null) {\n      // if an existing credentials returned\n      return credentialsExistingForTheCurrentUser;\n    }\n    // if there is no credentials stored for the user\n\n    // generate a new credentials for the user and\n    // set it in the storage. If a credentials was\n    // provided into signUpCredentials and valid, it will be used\n    // instead of generating a new one.\n    const newCredentialsGenerated = await this.generateAndSetCredentialsForTheCurrentUser(signUpCredentials);\n\n    if (newCredentialsGenerated instanceof Error) {\n      console.error(newCredentialsGenerated);\n      return new Error('Failed to generate or set a crypto credentials for the user');\n    }\n    return newCredentialsGenerated;\n  }\n\n  /**\n   * try to authorize with session saved in session storage\n   *\n   * @protected\n   * @returns\n   * @memberof CAConnectionWithFirebaseBase\n   */\n  protected async signInWithSessionPersisted() {\n    try {\n      await Promise.race([\n        timeout(CA_CONNECTION_FIREBASE_AUTH_WITH_SESSION_TOKEN_TIMEOUT_MS),\n        new Promise((res, rej) => {\n          this.app.auth().onAuthStateChanged(function (user) {\n            if (user) {\n              res(user);\n            } else {\n              rej(user);\n            }\n          });\n        }),\n      ]);\n      return true;\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  protected async signIn(firebaseCredentials: ICAConnectionSignUpCredentials): Promise<boolean | Error> {\n    if (!firebaseCredentials.password && firebaseCredentials.session) {\n      return this.signInWithSessionPersisted();\n    }\n\n    const checkSignUpCredentialsResult = this.checkSignUpCredentials(firebaseCredentials);\n\n    if (checkSignUpCredentialsResult instanceof Error) {\n      console.error(checkSignUpCredentialsResult);\n      return this.onAuthorizationFailed(checkSignUpCredentialsResult);\n    }\n\n    // try to sign in with the credentials, then try to sign up\n    const authResult = await this.singInWithAuthCredentials(firebaseCredentials);\n\n    if (authResult === true && firebaseCredentials.session) {\n      await this.setSessionPersistance();\n    }\n    return authResult;\n  }\n\n  protected async signUp(signUpCredentials: ICAConnectionSignUpCredentials): Promise<Error | boolean> {\n    // if failed to sign in with the\n    // credentials, then try to\n    // sign up\n    const signUpResult = await this.singUpWithAuthCredentials(signUpCredentials);\n\n    if (signUpResult instanceof Error) {\n      // if sign up failed then return\n      // error that the authorization\n      // failed\n      return this.onAuthorizationFailed('Failed to authorize on Firebase remote server with the credentials');\n    }\n    return true;\n  }\n\n  protected async disconnectCredentialsStorage(): Promise<Error | boolean> {\n    const { connectionWithCredentialsStorage } = this;\n\n    if (connectionWithCredentialsStorage && connectionWithCredentialsStorage.isConnected) {\n      const res = await connectionWithCredentialsStorage.disconnect();\n\n      if (res instanceof Error) {\n        console.error(res);\n        return new Error('Failed to disconnect from the Firebase credentials storage');\n      }\n    }\n\n    this.connectionWithCredentialsStorage = undefined;\n    return true;\n  }\n}\n\nexport default CAConnectionWithFirebaseBase;\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/central-authority-connection-firebase-base.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-base/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-connection-implementation/central-authority-connection-firebase-connection-implementation.ts",["2687","2688","2689","2690","2691","2692","2693","2694","2695","2696","2697"],"import firebase from 'firebase';\nimport 'firebase/auth';\nimport memoize from 'lodash.memoize';\nimport CAConnectionWithFirebaseBase from '../central-authority-connection-firebase-base/central-authority-connection-firebase-base';\nimport {\n  ICAConnection,\n  ICAConnectionSignUpCredentials,\n  ICAConnectionUserAuthorizedResult,\n} from '../../central-authority-connections.types';\nimport { isEmptyObject } from 'utils/common-utils/common-utils-objects';\nimport {\n  ICentralAuthorityUserProfile,\n  TCentralAuthorityUserCryptoCredentials,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { getVersionOfCryptoCredentials } from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\nimport {\n  CA_USER_IDENTITY_VERSIONS,\n  CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME,\n  CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_CURRENT,\n} from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport { generateCryptoCredentialsWithUserIdentityV2 } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport { validateUserIdentityVersion } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { TUserIdentityVersion } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { ICAConnectionConfigurationFirebase } from '../central-authority-connection-firebase.types.configuration';\nimport { CA_CONNECTION_STATUS } from '../../central-authority-connections-const/central-authority-connections-const';\nimport { TSwarmMessageUserIdentifierSerialized } from '../../../../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\n\n/**\n *\n * This is the class realized connection with the Firebase.\n * It allows to sign up and authorize on it, set a crypto credentials\n * for the user and read credentials for another users.\n * The versions of a connections to the Firebase must\n * extends this class. This implementation is compilant\n * to the V1 and V2 of the user identity.\n *\n * @export\n * @class CAConnectionWithFirebase\n * @implements {ICAConnection}\n */\nexport class CAConnectionWithFirebaseImplementation extends CAConnectionWithFirebaseBase implements ICAConnection {\n  public get cryptoCredentials(): TCentralAuthorityUserCryptoCredentials | undefined {\n    const { valueofCredentialsSignUpOnAuthorizedSuccess } = this;\n\n    if (valueofCredentialsSignUpOnAuthorizedSuccess) {\n      const { cryptoCredentials } = valueofCredentialsSignUpOnAuthorizedSuccess;\n\n      return cryptoCredentials;\n    }\n  }\n\n  public get authProviderURL() {\n    const { databaseURL } = this;\n\n    return databaseURL instanceof Error ? undefined : databaseURL;\n  }\n\n  /**\n   * the current status of the connection\n   * to the Firebase remote database\n   *\n   * @readonly\n   * @type {CA_CONNECTION_STATUS}\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  public get status(): CA_CONNECTION_STATUS {\n    const { isConnected, isAuthorized, isAnonymousely } = this;\n\n    if (!isConnected) {\n      return CA_CONNECTION_STATUS.DISCONNECTED;\n    }\n    if (isAuthorized) {\n      return CA_CONNECTION_STATUS.AUTHORIZED;\n    }\n    if (isAnonymousely) {\n      return CA_CONNECTION_STATUS.CONNECTED;\n    }\n    return CA_CONNECTION_STATUS.DISCONNECTED;\n  }\n\n  /**\n   * whether the user is connected anonymousely\n   * or not. User must be authorized or connected\n   * anonymousely\n   *\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected isAnonymousely = false;\n\n  protected userLogin?: string;\n\n  /**\n   * list with identity versions supported by the connection\n   *\n   * @type {Array<TUserIdentityVersion>}\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected readonly supportedVersions: Array<TUserIdentityVersion> = [\n    CA_USER_IDENTITY_VERSIONS['01'],\n    CA_USER_IDENTITY_VERSIONS['02'],\n  ];\n\n  /**\n   * checks whether the identity version\n   * is supported by the connection\n   *\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  public isVersionSupported = memoize((version: TUserIdentityVersion): boolean => this.supportedVersions.includes(version));\n\n  /**\n   * connect to the Firebase database. To authorize\n   * in the database to set credentials it is necesssry\n   * to authorize in.\n   * To read credentials of another user authorization is not\n   * necessary.\n   * Connection will be established in the anonymous mode\n   *\n   * @param {ICAConnectionConfigurationFirebase} configuration\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof CAConnectionWithFirebaseBase\n   */\n  public async connect(configuration: ICAConnectionConfigurationFirebase): Promise<boolean | Error> {\n    // if there is an active apps exists then it is necessary\n    // to provide the app name, elswere the Firebase will throw\n    // an error.\n    const appName = firebase.apps.length ? configuration.databaseURL : undefined;\n    const resultConnection = await super.connect(configuration, appName);\n\n    if (resultConnection instanceof Error) {\n      return resultConnection;\n    }\n    return true;\n  }\n\n  public async signInAnonymousely(): Promise<Error | void> {\n    try {\n      // may be authentificated with session\n      //await this.signInWithSessionPersisted();\n      const connectAnonymouselyResult = await this.app.auth().signInAnonymously();\n      if (connectAnonymouselyResult instanceof Error) {\n        return connectAnonymouselyResult;\n      }\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to connect anonymousely');\n    }\n\n    const connectWithStorageResult = await this.startConnectionWithCredentialsStorage();\n\n    if (connectWithStorageResult instanceof Error) {\n      console.error(connectWithStorageResult);\n      return new Error('Failed to connect to the credentials storage');\n    }\n    this.setIsAnonymousely();\n  }\n\n  /**\n   * return a credentials for the user\n   * with the id = userId.\n   * For the v1 the user id must be a uuidV4.\n   * For the v2 the user id must be a login/email/uuid.\n   * under which the user was registered the\n   * Firebase account.\n   *\n   * @param {string} userId\n   * @returns {(Promise<Error | null | TCentralAuthorityUserCryptoCredentials>)}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  public async getUserCredentials(\n    userId: TSwarmMessageUserIdentifierSerialized\n  ): Promise<Error | null | TCentralAuthorityUserCryptoCredentials> {\n    const { status } = this;\n\n    if (status !== CA_CONNECTION_STATUS.DISCONNECTED) {\n      const { connectionWithCredentialsStorage } = this;\n\n      return connectionWithCredentialsStorage!.getUserCredentials(userId);\n    }\n    return new Error('Not connected to the Firebase');\n  }\n\n  /**\n   * @param {ICAConnectionSignUpCredentials} firebaseCredentials\n   * @param firebaseCredentials.login - there must be an email to authorize with a Firebase account\n   * @param firebaseCredentials.password - password used for encrypt a sensitive data and authorize\n   * in the Firebase account\n   * @param profile - if provided then the user profile will be set in firebase\n   */\n  public async authorize(\n    firebaseCredentials: ICAConnectionSignUpCredentials,\n    profile?: Partial<ICentralAuthorityUserProfile>\n  ): Promise<ICAConnectionUserAuthorizedResult | Error> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return this.onAuthorizationFailed(isConnected);\n    }\n\n    let authHandleResult;\n    const { isAuthorized } = this;\n\n    if (isAuthorized) {\n      authHandleResult = this.valueofCredentialsSignUpOnAuthorizedSuccess!;\n    } else {\n      // try to sign in with the credentials, then try to sign up\n      // const userLoggedPromise = this.waitingUserInit();\n      const signInResult = await this.signIn(firebaseCredentials);\n\n      if (signInResult instanceof Error) {\n        console.warn('Failed to sign in with the credentials given');\n\n        if (!firebaseCredentials.password) {\n          // if there is no password provided, return the error\n          return signInResult;\n        }\n\n        // if failed to sign in with the credentials\n        // try to sign up\n        const signUpResult = await this.signUp(firebaseCredentials);\n\n        if (signUpResult instanceof Error) {\n          console.error('The user was failed to sign up');\n          return this.onAuthorizationFailed(signUpResult);\n        }\n      }\n      // const user = await userLoggedPromise;\n      // if (!user) {\n      //   return new Error('Failed to get the user authorized');\n      // }\n      // if (user instanceof Error) {\n      //   return new Error('Error on login');\n      // }\n      // if (!user.emailVerified) {\n\n      // check if the account was verfied by the user\n      const isVerifiedResult = await this.chekIfVerifiedAccount();\n\n      if (isVerifiedResult instanceof Error) {\n        console.error('The account is not verified');\n        return this.onAuthorizationFailed(isVerifiedResult);\n      }\n      //}\n\n      const connectWithStorageResult = await this.startConnectionWithCredentialsStorage();\n\n      if (connectWithStorageResult instanceof Error) {\n        console.error(connectWithStorageResult);\n        return new Error('Failed to connect to the credentials storage');\n      }\n      // set the user login to use it to generate\n      // crypto credentials\n      this.setUserLogin(firebaseCredentials.login);\n\n      let cryptoCredentials: TCentralAuthorityUserCryptoCredentials | Error | undefined;\n\n      if (firebaseCredentials.session) {\n        const sessionCryptoCredentials = await this.readCryptoCrdentialsFromSession(firebaseCredentials.session);\n\n        if (sessionCryptoCredentials instanceof Error) {\n          console.error('Failed to get credentials from the session cause the error', sessionCryptoCredentials);\n        }\n        cryptoCredentials = sessionCryptoCredentials;\n      }\n      // create a new credentnials for the user or return\n      // an existing.\n      // if a crytpto credentials provided in signUpCredentials\n      // it will be used to set in the Firebase credentials\n      // storage\n      if (!cryptoCredentials || cryptoCredentials instanceof Error) {\n        cryptoCredentials = await this.createOrReturnExistingCredentialsForUser(firebaseCredentials);\n      }\n      if (cryptoCredentials instanceof Error) {\n        console.error('Failed to get a crypto credentials valid for the user');\n        return this.onAuthorizationFailed(cryptoCredentials);\n      }\n\n      // give user's profile\n      // with a credentials\n      authHandleResult = await this.returnOnAuthorizedResult(cryptoCredentials);\n      if (firebaseCredentials.session) {\n        const setCredentialsInSessionResult = await this.setCurrentUserCryptoCredentialsInSession(\n          firebaseCredentials.session,\n          cryptoCredentials\n        );\n\n        if (setCredentialsInSessionResult instanceof Error) {\n          console.error('Failed to set the credentials in the user session', setCredentialsInSessionResult);\n        }\n      }\n    }\n\n    if (authHandleResult instanceof Error) {\n      return this.onAuthorizationFailed(authHandleResult);\n    }\n    // if a profile data is necessary to be set\n    // by a profile data from the arguments given\n    if (profile && !isEmptyObject(profile)) {\n      const setProfileResult = await this.setProfileData(profile);\n\n      if (setProfileResult instanceof Error) {\n        console.error(setProfileResult);\n        return this.onAuthorizationFailed('Failed to set the profile data');\n      }\n\n      // set porofile is the user's profile\n      // data stored in the firebase\n      authHandleResult = {\n        profile: setProfileResult,\n        // TODO it is necessry to set this credentials in the database\n        cryptoCredentials: authHandleResult.cryptoCredentials,\n      };\n    }\n    // set the authentification success\n    // result. To return it on the second authorization\n    // request\n    this.valueofCredentialsSignUpOnAuthorizedSuccess = authHandleResult;\n    this.setValueofCredentialsSignUpOnAuthorizedSuccess(authHandleResult);\n    this.unsetIsAnonymousely();\n    return authHandleResult;\n  }\n\n  /**\n   * disconnect from the app and sign out\n   * if authorized\n   *\n   * @returns\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  public async disconnect() {\n    const { app } = this;\n    if (!app) {\n      return;\n    }\n    if ((app as any).isDeleted_) {\n      return;\n    }\n    if (this.status === CA_CONNECTION_STATUS.AUTHORIZED) {\n      const signOutResult = await this.signOut();\n\n      if (signOutResult instanceof Error) {\n        return signOutResult;\n      }\n      if (signOutResult !== true) {\n        return new Error('An unknown error has occurred while sign out');\n      }\n    }\n    return this.disconnectFromTheApp();\n  }\n\n  public async delete(firebaseCredentials: ICAConnectionSignUpCredentials): Promise<Error | boolean> {\n    const isConnected = this.checkIfConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { currentUser } = this;\n\n    if (currentUser instanceof Error) {\n      console.error(currentUser);\n      return new Error('Failed to read the current user');\n    }\n    if (currentUser == null) {\n      return new Error('There is no current user');\n    }\n\n    // try to sign in with the credentials.\n    // it is required by the firebase to sign in before\n    // delete the user.\n    const signInResult = await this.signIn(firebaseCredentials);\n\n    if (signInResult instanceof Error) {\n      console.error('Failed to sign in before the user deletion');\n      return signInResult;\n    }\n\n    try {\n      const result = (await currentUser.delete()) as unknown; // or maybe deleteWithCompletion method\n\n      if (result instanceof Error) {\n        console.error(result);\n        return new Error('Failed to delete the user from the firebase');\n      }\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to delete the user from the authority');\n    }\n\n    // disconnection from the firebase\n    // is not necessry cause the firebase\n    // disconnects automatically if the user\n    // delete himself\n    return true;\n  }\n\n  /**\n   * set that connected anonymousely\n   * to the Firebase\n   *\n   * @protected\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected setIsAnonymousely() {\n    this.isAnonymousely = true;\n  }\n\n  /**\n   * unset that connected to the Firebase\n   * anonymousely\n   *\n   * @protected\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected unsetIsAnonymousely() {\n    this.isAnonymousely = false;\n  }\n\n  protected setValueofCredentialsSignUpOnAuthorizedSuccess(authResult: ICAConnectionUserAuthorizedResult) {\n    this.valueofCredentialsSignUpOnAuthorizedSuccess = authResult;\n  }\n\n  protected unsetValueofCredentialsSignUpOnAuthorizedSuccess() {\n    this.valueofCredentialsSignUpOnAuthorizedSuccess = undefined;\n  }\n\n  /**\n   * set identity versions which are\n   * supported by the connection\n   * instance\n   *\n   * @protected\n   * @param {Array<TUserIdentityVersion>} [supportedVersions]\n   * @returns {(Error | void)}\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected setVersionsSupported(supportedVersions?: Array<TUserIdentityVersion>): Error | void {\n    if (supportedVersions instanceof Array) {\n      const len = supportedVersions.length;\n      let idx = 0;\n      let version;\n\n      for (; idx++; len < idx) {\n        version = supportedVersions[idx];\n        if (validateUserIdentityVersion(version)) {\n          this.supportedVersions.push(version);\n        }\n        return new Error('The version is not supproted');\n      }\n    }\n    return new Error('The argument must be an Array');\n  }\n\n  protected setUserLogin(login: string) {\n    this.userLogin = login;\n  }\n\n  /**\n   * this method generates credentials compilant to the version\n   * version 2 of the user identity. The firebase app user uid\n   * is used as the user id.\n   *\n   * @protected\n   * @returns {(Promise<\n   *     Error | TCentralAuthorityUserCryptoCredentials\n   *   >)}\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected generateNewCryptoCredentialsForConfigurationProvidedV2 = async (): Promise<\n    Error | TCentralAuthorityUserCryptoCredentials\n  > => {\n    const { databaseURL, currentUser } = this;\n\n    if (!currentUser) {\n      return new Error('The user is not defined');\n    }\n    if (databaseURL instanceof Error) {\n      return databaseURL;\n    }\n\n    const cryptoCredentials = await generateCryptoCredentialsWithUserIdentityV2({\n      [CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]: databaseURL,\n      [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: currentUser.uid,\n    });\n\n    if (cryptoCredentials instanceof Error) {\n      console.error(cryptoCredentials);\n      return new Error('Failed to generate a new crypto credentials');\n    }\n    return cryptoCredentials;\n  };\n\n  /**\n   * substitute the method to support v2 identity\n   *\n   * @protected\n   * @param {ICAConnectionSignUpCredentials} signUpCredentials\n   * @returns {(Promise<Error | TCentralAuthorityUserCryptoCredentials>)}\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected async generateAndSetCredentialsForTheCurrentUser(\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials> {\n    const credentialsProvidedCheckResult = this.checkSignUpCredentials(signUpCredentials);\n\n    if (credentialsProvidedCheckResult instanceof Error) {\n      console.error(credentialsProvidedCheckResult);\n      return credentialsProvidedCheckResult;\n    }\n\n    const { cryptoCredentials } = signUpCredentials;\n    const V1 = CA_USER_IDENTITY_VERSIONS['01'];\n    let credentialsForV1 = false;\n\n    if (this.isVersionSupported(V1)) {\n      credentialsForV1 = CA_USER_IDENTITY_VERSION_CURRENT === CA_USER_IDENTITY_VERSIONS['01'];\n\n      if (cryptoCredentials) {\n        // check a version of the credentials\n        // to decide what to do next\n        const cryptoCredentialsVersion = getVersionOfCryptoCredentials(cryptoCredentials);\n\n        if (cryptoCredentialsVersion instanceof Error) {\n          console.error(cryptoCredentialsVersion);\n          return new Error('Failed to define a version of the crypto credentials');\n        }\n        if (cryptoCredentialsVersion === CA_USER_IDENTITY_VERSIONS['01']) {\n          // if the credentials version is 01 we may use the\n          // current implementation cause it is fully\n          // compilant to that version\n          credentialsForV1 = true;\n        } else {\n          credentialsForV1 = false;\n        }\n      }\n      // if a credentials for the V1 must be generated and set\n      if (credentialsForV1 === true) {\n        return this.createOrSetCredentialsInDB(signUpCredentials);\n      }\n    }\n    // if the version is not 01, then provide another implementations\n    // of the methods to generate and set the crypto credentials\n    return this.createOrSetCredentialsInDB(signUpCredentials, this.generateNewCryptoCredentialsForConfigurationProvidedV2);\n  }\n\n  /**\n   * disconnect from the Firebase app\n   *\n   * @protected\n   * @returns {(Promise<Error | void>)}\n   * @memberof CAConnectionWithFirebaseImplementation\n   */\n  protected async disconnectFromTheApp(): Promise<Error | void> {\n    this.unsetIsAnonymousely();\n    this.unsetValueofCredentialsSignUpOnAuthorizedSuccess();\n\n    const disconnectFromStorageResult = await this.disconnectCredentialsStorage();\n\n    if (disconnectFromStorageResult instanceof Error) {\n      return disconnectFromStorageResult;\n    }\n\n    const { app } = this;\n\n    if (app) {\n      try {\n        // delete the application to allow connect to the Firebase with the same settings\n        await app.delete();\n      } catch (err) {\n        console.error(err);\n        return new Error('Failed to disconnect from the Firebase app');\n      }\n    } else {\n      return new Error('There is no active Firebase App instance to close');\n    }\n  }\n}\n\nexport default CAConnectionWithFirebaseImplementation;\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-connection-implementation/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.ts",["2698","2699","2700","2701","2702","2703","2704","2705","2706","2707"],"import { CAConnectionWithFirebaseUtilDatabase } from '../central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database';\nimport {\n  getUserIdentityByCryptoCredentials,\n  exportCryptoCredentialsToString,\n  importCryptoCredentialsFromAString,\n} from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\nimport {\n  CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_KEY_PREFIX,\n  CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY,\n  CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_MAXIMUM_STORED_VALUES_CHECK,\n} from './central-authority-connection-firebase-utils.credentials-storage.const';\nimport {\n  ICAConnectionFirebase,\n  ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure,\n} from './central-authority-connection-firebase-utils.credentials-storage.types';\nimport { encodeForFirebaseKey } from 'utils/firebase-utils/firebase-utils';\nimport { validateUserIdentity } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { TCentralAuthorityUserCryptoCredentials } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { checkIsValidExportedCryptoCredentialsToString } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport { ICAConnectionSignUpCredentials } from '../../../central-authority-connections.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../../../../../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\n\n/**\n * This class is used for storing\n * and reading the user's credentials.\n * It also used for reading\n * credentials of another user from the\n * Firebase remote database.\n * @export\n * @class CAConnectionFirestoreUtilsCredentialsStrorage\n * @extends {CAConnectionWithFirebaseUtilDatabase}\n */\nexport class CAConnectionFirestoreUtilsCredentialsStrorage extends CAConnectionWithFirebaseUtilDatabase {\n  protected connectionToFirebase?: ICAConnectionFirebase;\n\n  protected get firebaseUserData(): firebase.User | null | Error {\n    const isConnected = this.checkIsConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { app } = this;\n\n    try {\n      return app!.auth().currentUser;\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to get the user id for firebase');\n    }\n  }\n\n  protected get firebaseUserId(): string | Error {\n    const { firebaseUserData: userData } = this;\n\n    if (userData instanceof Error) {\n      console.error(userData);\n      return new Error('Failed to read the user data from a firebase');\n    }\n    if (userData == null) {\n      return new Error('There is no user data');\n    }\n    try {\n      return userData.uid;\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to get the user id for firebase');\n    }\n  }\n\n  constructor(connectionToFirebase: ICAConnectionFirebase) {\n    super();\n\n    this.setUpConnection(connectionToFirebase);\n  }\n\n  /**\n   * returns a string will used to store/read value of\n   * the user credentials\n   * @protected\n   * @param {string} userId\n   * @returns {string}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  protected getCredentialsKeyByUserId(userId: TSwarmMessageUserIdentifierSerialized): string {\n    return `${CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_KEY_PREFIX}${encodeForFirebaseKey(userId)}`;\n  }\n\n  protected checkIsConnected(): boolean | Error {\n    const isConnectedToDatabase = super.checkIsConnected();\n\n    if (isConnectedToDatabase instanceof Error) {\n      return isConnectedToDatabase;\n    }\n\n    const { app, connectionToFirebase } = this;\n\n    if (!connectionToFirebase) {\n      return new Error('There is no instance implements a connection to the Firebase application');\n    }\n    if (!connectionToFirebase.isConnected) {\n      return new Error('There is no active connection to the firebase appliction');\n    }\n    if (!app) {\n      return new Error('There is no app connection');\n    }\n    return true;\n  }\n\n  protected checkIsAuthorized(): boolean | Error {\n    const isConnectedToDatabase = this.checkIsConnected();\n\n    if (isConnectedToDatabase instanceof Error) {\n      return isConnectedToDatabase;\n    }\n\n    const { firebaseUserId, connectionToFirebase } = this;\n\n    if (!connectionToFirebase || !connectionToFirebase.isUserSignedIn) {\n      return new Error('The user is not authorized in the Firebase application');\n    }\n    if (firebaseUserId instanceof Error) {\n      console.error(firebaseUserId);\n      return new Error('The user is not authorized');\n    }\n    return true;\n  }\n\n  protected setUpConnection(connectionToFirebase: ICAConnectionFirebase) {\n    this.connectionToFirebase = connectionToFirebase;\n\n    const app = connectionToFirebase.getApp();\n\n    if (!app) {\n      throw new Error('There is no insatnce which implements a connection to the Firebase app');\n    }\n    this.app = app;\n  }\n\n  /**\n   *\n   * check if a credentials set in the storage\n   * are in the valid format\n   * @protected\n   * @param {*} storedCredentialsValue\n   * @returns {storedCredentialsValue is ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  protected checkStoredCredentialsFormat(\n    storedCredentialsValue: any\n  ): storedCredentialsValue is ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure {\n    if (storedCredentialsValue instanceof Error) {\n      console.error(storedCredentialsValue);\n      return false;\n    }\n    if (storedCredentialsValue && typeof storedCredentialsValue === 'object') {\n      const {\n        credentials,\n        [CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY]: firebaseId,\n      } = storedCredentialsValue;\n\n      // an id set for the user by the Firebase\n      if (typeof firebaseId === 'string') {\n        if (checkIsValidExportedCryptoCredentialsToString(credentials)) {\n          return true;\n        }\n        console.error(\"Credentials are't exists or invalid in the stored credentials\");\n      } else {\n        console.error('Firebase user id is not valid in the stored credentials');\n      }\n    }\n    return false;\n  }\n\n  protected async getCredentialsByValueStored(\n    storedCredentialsValue: any,\n    signUpCredentials?: ICAConnectionSignUpCredentials\n  ): Promise<TCentralAuthorityUserCryptoCredentials | null | Error> {\n    if (storedCredentialsValue == null) {\n      return null;\n    }\n    if (storedCredentialsValue instanceof Error) {\n      return storedCredentialsValue;\n    }\n    if (!this.checkStoredCredentialsFormat(storedCredentialsValue)) {\n      return new Error('the value stored have an unknown format');\n    }\n\n    const { credentials: exportedCredentials } = storedCredentialsValue;\n    const importedCredentials = await importCryptoCredentialsFromAString(exportedCredentials, signUpCredentials?.password);\n\n    if (importedCredentials instanceof Error) {\n      console.error(importedCredentials);\n      return new Error('Failed to import credentials value stored');\n    }\n    return importedCredentials;\n  }\n\n  /**\n   *\n   * filter a value stored for the user key\n   * to get a value of the credentials\n   * for the user\n   * @protected\n   * @param {{\n   *     [key: string]: any;\n   *   }} [valueStored]\n   * @returns {(Promise<TCentralAuthorityUserCryptoCredentials | null | Error>)}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  protected async filterCredentialsValues(\n    valueStored: Record<string, any>,\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<TCentralAuthorityUserCryptoCredentials | null | Error> {\n    if (!valueStored) {\n      return null;\n    }\n    if (valueStored instanceof Error) {\n      return valueStored;\n    }\n\n    const keys = Object.keys(valueStored);\n\n    // if an empty object\n    if (keys.length === 0) {\n      return null;\n    }\n\n    const len = Math.min(keys.length, CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_MAXIMUM_STORED_VALUES_CHECK);\n    let idx = 0;\n    let keyValueStored;\n    let valueValueStored;\n    let credentialsImported;\n\n    // for each property of the value stored\n    // check wherether it is a valid\n    // crypto credentials\n    for (; idx < len; idx++) {\n      keyValueStored = keys[idx];\n      valueValueStored = valueStored[keyValueStored];\n      credentialsImported = await this.getCredentialsByValueStored(valueValueStored, signUpCredentials);\n\n      if (!(credentialsImported instanceof Error)) {\n        return credentialsImported;\n      }\n    }\n    return null;\n  }\n\n  // check if there is a credentials for the current user is exists\n  // and return it if exists\n  public async getCredentialsForTheCurrentUser(\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | null | TCentralAuthorityUserCryptoCredentials> {\n    const isAuthorizedResult = this.checkIsAuthorized();\n\n    if (isAuthorizedResult instanceof Error) {\n      console.error(isAuthorizedResult);\n      return new Error('The user is not authorized');\n    }\n\n    const { firebaseUserId } = this;\n\n    if (firebaseUserId instanceof Error) {\n      console.error(firebaseUserId);\n      return new Error('Failed to get user id of the firebase user');\n    }\n\n    const { database } = this;\n\n    if (!database) {\n      return new Error('There is no connection to the database server');\n    }\n    try {\n      // read a value storerd as user's\n      // credentials in the database\n      const snapshot = await database\n        .ref(CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_KEY_PREFIX)\n        .orderByChild(CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY)\n        .equalTo(firebaseUserId)\n        .once('value');\n      if (snapshot.exists()) {\n        const valueStored = snapshot.val();\n        return await this.filterCredentialsValues(valueStored, signUpCredentials);\n      }\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to read the user data from the database');\n    }\n    return null;\n  }\n\n  // store the credentials value\n  // for the current user\n  public async setUserCredentials(\n    credentials: TCentralAuthorityUserCryptoCredentials,\n    signUpCredentials: ICAConnectionSignUpCredentials\n  ): Promise<Error | TCentralAuthorityUserCryptoCredentials> {\n    const isAuthorizedResult = this.checkIsAuthorized();\n\n    if (isAuthorizedResult instanceof Error) {\n      console.error(isAuthorizedResult);\n      return new Error('The user is not authorized');\n    }\n\n    const { firebaseUserId } = this;\n\n    if (firebaseUserId instanceof Error) {\n      console.error(firebaseUserId);\n      return new Error('Failed to get user id of the firebase user');\n    }\n\n    // check if a credentials value is\n    // already exists for the user\n    const credentialsForTheCurrentUser = await this.getCredentialsForTheCurrentUser(signUpCredentials);\n\n    if (credentialsForTheCurrentUser != null && !(credentialsForTheCurrentUser instanceof Error)) {\n      // if a credentials are already stored for the user\n      // return it\n      return credentialsForTheCurrentUser;\n    }\n\n    const userId = getUserIdentityByCryptoCredentials(credentials);\n\n    if (userId instanceof Error) {\n      console.error(userId);\n      return new Error(\"Failed to get a user's identity from the credentials\");\n    }\n    if (!signUpCredentials.password) {\n      return new Error('The password is required to encrypt the private keys');\n    }\n\n    const exportedCryptoCredentials = await exportCryptoCredentialsToString(credentials, undefined, signUpCredentials.password);\n\n    if (exportedCryptoCredentials instanceof Error) {\n      console.error(exportedCryptoCredentials);\n      return new Error('Failed to export the crypto credentials value');\n    }\n\n    // check if the user id is not exists in the database\n    // user id is a user identity\n    // TODO - it's necessary to implement on the Firebase server to check whether the user can update credentials for the userid\n    const credentialsForTheUserId = await this.getUserCredentials(userId);\n\n    if (credentialsForTheUserId != null && !(credentialsForTheUserId instanceof Error)) {\n      return new Error('A crypto credentials is already exists for the user id');\n    }\n\n    const keyForValue = this.getCredentialsKeyByUserId(userId);\n    const storeResult = await this.setValue<ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure>(keyForValue, {\n      credentials: exportedCryptoCredentials,\n      [CA_CONNECTION_FIREBASE_UTILS_STORAGE_CREDENTIALS_FIREBASE_USER_ID_PROPERTY]: firebaseUserId,\n    });\n\n    if (storeResult instanceof Error) {\n      console.error(storeResult);\n      return new Error('Failed to store the credentials in the database');\n    }\n    return credentials;\n  }\n\n  /**\n   *\n   * return a credentials for the user\n   * with the id = userId.\n   * For the v1 the user id must be a uuidV4.\n   * For the v2 the user id must be a login(email)\n   * under which the user was registered the\n   * Firebase account.\n   *\n   * @param {string} userId\n   * @returns {(Promise<Error | null | TCentralAuthorityUserCryptoCredentials>)}\n   * @memberof CAConnectionFirestoreUtilsCredentialsStrorage\n   */\n  public async getUserCredentials(\n    userId: TSwarmMessageUserIdentifierSerialized\n  ): Promise<Error | null | TCentralAuthorityUserCryptoCredentials> {\n    if (!this.checkIsConnected()) {\n      return new Error('There is no active connection to the Firebase');\n    }\n    if (!validateUserIdentity(userId)) {\n      return new Error('The user identity is not valid');\n    }\n\n    const keyForValue = this.getCredentialsKeyByUserId(userId);\n    const storedCredentialsValue = await this.getValue<ICAConnectionFirestoreUtilsCredentialsStrorageCredentialsSaveStructure>(\n      keyForValue\n    );\n\n    return this.getCredentialsByValueStored(storedCredentialsValue);\n  }\n\n  // disconnect from the database\n  public async disconnect(): Promise<Error | boolean> {\n    const isConnected = this.checkIsConnected();\n\n    if (!isConnected) {\n      return true;\n    }\n    const { database } = this;\n\n    if (!database) {\n      return new Error('There is no active database connection');\n    }\n    try {\n      await database.goOffline();\n    } catch (err) {\n      console.error();\n      return new Error('Failed to disconnect from the databases');\n    }\n    return true;\n  }\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/central-authority-connection-firebase-utils.credentials-storage.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.credentials-storage/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/central-authority-connection-firebase-utils.database.ts",["2708","2709","2710","2711","2712","2713","2714"],"import * as firebase from 'firebase';\nimport {\n  CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MAX_LENGTH,\n  CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MIN_LENGTH,\n} from './central-authority-connection-firebase-utils.database.const';\n\nexport class CAConnectionWithFirebaseUtilDatabase {\n  protected app?: firebase.app.App;\n\n  protected database?: firebase.database.Database;\n\n  protected wasConnected: boolean = false;\n\n  public get isConnected(): boolean {\n    const { wasConnected, database } = this;\n\n    return wasConnected && !!database;\n  }\n\n  protected setWasConnectedStatus(wasConnected = false) {\n    this.wasConnected = !!wasConnected;\n  }\n\n  protected setDatabaseInstance(db: firebase.database.Database) {\n    this.database = db;\n  }\n\n  protected checkIsConnected(): Error | boolean {\n    const { isConnected } = this;\n\n    if (!isConnected) {\n      return new Error('There is no connection with the remote database');\n    }\n    return true;\n  }\n\n  protected checkKeyValue(key: any): key is string {\n    if (typeof key !== 'string') {\n      console.error('Key must be a string');\n      return false;\n    }\n\n    const keyLen = key.length;\n\n    if (keyLen > CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MAX_LENGTH) {\n      console.error(\n        `Key must be less than ${CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MAX_LENGTH}, but the value is ${keyLen} characters len`\n      );\n      return false;\n    }\n    if (keyLen < CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MIN_LENGTH) {\n      console.error(\n        `Key must be greater than ${CA_CONNECTION_FIREBASE_UTILS_DATABASE_KEY_MAX_LENGTH}, but the value is ${keyLen} characters len`\n      );\n      return false;\n    }\n    return true;\n  }\n\n  public async connect(): Promise<boolean | Error> {\n    const { isConnected, app } = this;\n\n    if (isConnected) {\n      return true;\n    }\n    if (!app) {\n      return new Error('The app is not defined');\n    }\n    try {\n      const database = app.database();\n\n      await database.goOnline();\n      this.setDatabaseInstance(database);\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to connect to the Database server');\n    }\n    this.setWasConnectedStatus(true);\n    return true;\n  }\n\n  /**\n   * This method destroys the\n   * application instance, Not just\n   * go offline. This means that\n   * the reconnection with calling of\n   * the 'connect' method will failed\n   * and therefore is not allowed.\n   *\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof CAConnectionWithFirebaseUtilDatabase\n   */\n  public async disconnect(): Promise<boolean | Error> {\n    const isConnected = this.checkIsConnected();\n\n    if (isConnected instanceof Error) {\n      return isConnected;\n    }\n\n    const { database } = this;\n\n    try {\n      await database!.goOffline();\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to go offline before destroy the application');\n    }\n    this.setWasConnectedStatus(false);\n    return true;\n  }\n\n  protected checkBeforeReadWrite(key: string): Error | boolean {\n    const isConnectedResult = this.checkIsConnected();\n\n    if (isConnectedResult instanceof Error) {\n      return isConnectedResult;\n    }\n    if (!this.checkKeyValue(key)) {\n      return new Error('The key value is not valid');\n    }\n    return true;\n  }\n\n  public async setValue<T>(key: string, value: T): Promise<Error | boolean> {\n    const canWrite = this.checkBeforeReadWrite(key);\n\n    if (canWrite instanceof Error) {\n      return canWrite;\n    }\n\n    const { database } = this;\n\n    try {\n      await database!.ref(key).set(value);\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to store the value in the database');\n    }\n    return true;\n  }\n\n  public async getValue<T>(key: string): Promise<Error | null | T> {\n    const canRead = this.checkBeforeReadWrite(key);\n\n    if (canRead instanceof Error) {\n      return canRead;\n    }\n\n    const { database } = this;\n\n    try {\n      const snapshot = await database!.ref(key).once('value');\n      const isExists = snapshot.exists();\n\n      if (!isExists) {\n        return null;\n      }\n      return snapshot.val() as T;\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to read the value from the storage');\n    }\n  }\n}\n\nexport default CAConnectionWithFirebaseUtilDatabase;\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.database/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators/central-authority-connection-firebase-utils.validators.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators/central-authority-connection-firebase-utils.validators.ts",["2715","2716","2717","2718","2719","2720"],"import { validateBySchema } from 'utils/validation-utils/validation-utils';\nimport { ICAConnectionConfigurationFirebase } from '../../central-authority-connection-firebase.types.configuration';\nimport { CA_AUTH_CONNECTION_FIREBASE_UTILS_VALIDATOR_SCHEME_CONNECTION_OPTIONS } from './central-authority-connection-firebase-utils.validators.const';\nimport validator from 'validator';\n\nexport const valiateCAAuthConnectionFirebaseUtilsConnetionConfiguration = (\n  configuration: any\n): configuration is ICAConnectionConfigurationFirebase => {\n  if (!validateBySchema(CA_AUTH_CONNECTION_FIREBASE_UTILS_VALIDATOR_SCHEME_CONNECTION_OPTIONS, configuration)) {\n    return false;\n  }\n  return validator.isURL(configuration.databaseURL);\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/central-authority-connection-firebase-utils.validators/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase-utils/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.auth.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.error-codes.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.restrictions.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/central-authority-connection-firebase.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.const/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/central-authority-connection-firebase.types.configuration.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connection-firebase/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const-error-codes.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const-status.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/central-authority-connections-const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-const/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-pool/central-authority-connections-pool.ts",["2721","2722","2723","2724","2725","2726","2727"],"import { normalizeUrl } from 'utils/common-utils/common-utils-url';\nimport {\n  ICAConnectionsPoolOptions,\n  ICAConnectionsPoolConnections,\n  IAuthProviderConnectionConfiguration,\n  ICAConnectionsPoolCurrentConnections,\n  ICAConnectionPool,\n} from './central-authority-connections-pool.types';\nimport {\n  normalizeCAConnectionAuthProviderURL,\n  validateCAConnectionAuthProviderType,\n  validateCAConnectionAuthProviderConnectionConfiguration,\n  validateCAConnectionAuthProviderUrl,\n} from '../central-authority-connections-utils/central-authority-connections-utils';\nimport { ICAConnection, TCAAuthProviderIdentity, ICAConnectionSignUpCredentials } from '../central-authority-connections.types';\nimport { getConnectionConstructorAuthProviderType } from '../central-authority-connections-utils/central-authority-connections-utils.common/central-authority-connections-utils.common';\nimport { ICentralAuthorityUserProfile } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { CA_CONNECTION_STATUS } from '../central-authority-connections-const/central-authority-connections-const';\nimport { ICAConnectionUserAuthorizedResult } from '../central-authority-connections.types';\nimport { TCAuthProviderIdentifier } from '../../central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { ICAConnectionPoolAuthResult } from './central-authority-connections-pool.types';\nimport { checkIsValidCryptoCredentials } from '../../central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport CentralAuthorityIdentity from '../../central-authority-class-user-identity/central-authority-class-user-identity';\nimport { CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME } from '../../central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport { compareAuthProvidersIdentities } from '../../central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\n\n/**\n * This is used to establish connections\n * with auth providers to collect a\n * crypto keys of swarm users.\n *\n * @export\n * @class CAConnectionsPool\n */\nexport class CAConnectionsPool implements ICAConnectionPool {\n  public userAuthResult?: ICAConnectionPoolAuthResult;\n\n  /**\n   * States of connections to auth\n   * providers\n   *\n   * @protected\n   * @type {ICAConnectionsPoolConnections}\n   * @memberof CAConnectionsPool\n   */\n  protected providersConnectionState: ICAConnectionsPoolConnections = {};\n\n  /**\n   * connection throught which the user\n   * is authorized on auth provider service.\n   * Search trought all the connections\n   * connection with the auth flag.\n   *\n   * @readonly\n   * @protected\n   * @type {(ICAConnection | void)}\n   * @memberof CAConnectionsPool\n   */\n  protected get authConnection(): {\n    connection: ICAConnection;\n    authProviderId: TCAuthProviderIdentifier;\n  } | void {\n    const { providersConnectionState } = this;\n    const providersConnectionsStates = Object.values(providersConnectionState);\n    let idx = 0;\n    let authProviderConnection;\n    let authProviderUrl;\n    const len = providersConnectionsStates.length;\n\n    while (idx < len) {\n      ({ connection: authProviderConnection, caProviderUrl: authProviderUrl } = providersConnectionsStates[idx++]);\n      if (authProviderConnection && authProviderConnection.status === CA_CONNECTION_STATUS.AUTHORIZED) {\n        return {\n          connection: authProviderConnection,\n          authProviderId: authProviderUrl || (authProviderConnection.authProviderURL as string),\n        };\n      }\n    }\n  }\n\n  /**\n   * Creates an instance of CAConnectionsPool.\n   * @param {ICAConnectionsPoolOptions} options\n   * @memberof CAConnectionsPool\n   * @throws\n   */\n  constructor(options: ICAConnectionsPoolOptions) {\n    this.setOptions(options);\n  }\n\n  /**\n   * at now it is alias for the connect method\n   *\n   * @param {TCAAuthProviderIdentity} authProvider\n   * @returns\n   * @memberof CAConnectionsPool\n   */\n  public getConnection(authProvider: TCAAuthProviderIdentity) {\n    return this.connect(authProvider);\n  }\n\n  /**\n   * establish a new connection with the auth\n   * provider or returns an existing connection\n   * if it is active(status !== DISCONNECTED)\n   *\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @returns {(Promise<ICAConnection | Error>)}\n   * @memberof CAConnectionsPool\n   */\n  public async connect(\n    authProviderUrl: TCAAuthProviderIdentity,\n    isAuthentificateAnonymousely: boolean = true\n  ): Promise<ICAConnection | Error> {\n    if (!validateCAConnectionAuthProviderUrl(authProviderUrl)) {\n      return new Error('The url provided as the auth provider service url is not valid');\n    }\n\n    const currentConnectionWithAuthProvider = this.getActiveConnectionWithAuthProvider(authProviderUrl);\n\n    if (currentConnectionWithAuthProvider instanceof Error) {\n      console.error(currentConnectionWithAuthProvider);\n      return new Error(`Failed to resolve an active connection with the provider ${authProviderUrl}`);\n    }\n    if (currentConnectionWithAuthProvider) {\n      return currentConnectionWithAuthProvider;\n    }\n\n    const connectionWithAuthProvider = await this.connectWithAuthProvider(authProviderUrl);\n\n    if (connectionWithAuthProvider instanceof Error) {\n      return connectionWithAuthProvider;\n    }\n    if (isAuthentificateAnonymousely) {\n      const ananymousResult = await connectionWithAuthProvider.signInAnonymousely();\n\n      if (ananymousResult instanceof Error) {\n        return ananymousResult;\n      }\n      return this.addConectionWithProvider(authProviderUrl, connectionWithAuthProvider);\n    }\n    return connectionWithAuthProvider;\n  }\n\n  /**\n   * authorize on the service or return an existing\n   * connection which is the user authorized through\n   *\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @param {ICAConnectionSignUpCredentials} signUpCredentials\n   * @param {Partial<ICentralAuthorityUserProfile>} [profile]\n   * @returns {(Promise<Error | ICAConnection>)}\n   * @memberof CAConnectionsPool\n   */\n  public async authorize(\n    authProviderUrl: TCAAuthProviderIdentity,\n    signUpCredentials: ICAConnectionSignUpCredentials,\n    profile?: Partial<ICentralAuthorityUserProfile>\n  ): Promise<Error | ICAConnection> {\n    if (!validateCAConnectionAuthProviderUrl(authProviderUrl)) {\n      return new Error('The url provided as the auth provider service url is not valid');\n    }\n    if (this.userAuthResult) {\n      // if the user is already authorized on auth provider service\n      const signOutResult = await this.signOut();\n\n      if (signOutResult instanceof Error) {\n        console.error(signOutResult);\n        return new Error('The user is already authorized on the auth provider service, and failed to sign out from it');\n      }\n    }\n\n    const currentConnectionWithProviderAuthOn = this.authConnection;\n    const normalizedUrl = normalizeUrl(authProviderUrl);\n\n    if (normalizedUrl instanceof Error) {\n      console.error(normalizedUrl);\n      return new Error('Failed to normalize the url of the auth provider');\n    }\n    if (currentConnectionWithProviderAuthOn) {\n      const { authProviderId: currentAuthProviderUrl, connection } = currentConnectionWithProviderAuthOn;\n      const normalizedUrlAuthProviderCurrent = normalizeUrl(currentAuthProviderUrl);\n\n      if (normalizedUrlAuthProviderCurrent !== normalizedUrl) {\n        return new Error(\n          `Already authorized on the ${normalizedUrlAuthProviderCurrent} service, differ from the requested ${authProviderUrl}`\n        );\n      }\n      return connection;\n    }\n\n    const connectionWithAuthProvider = await this.connect(authProviderUrl, false);\n\n    if (connectionWithAuthProvider instanceof Error) {\n      console.error(connectionWithAuthProvider);\n      return new Error(`Failed to connect with the auth provider ${authProviderUrl}`);\n    }\n\n    const authResult = await connectionWithAuthProvider.authorize(signUpCredentials, profile);\n\n    if (authResult instanceof Error) {\n      const disconnectFromTheConnectionResult = await connectionWithAuthProvider.disconnect();\n\n      if (disconnectFromTheConnectionResult instanceof Error) {\n        console.error(disconnectFromTheConnectionResult);\n        console.error(new Error('Failed to disconnect form the auth provider which failed to authorize on'));\n      }\n      console.error(`Failed to authorize with the auth provider ${authProviderUrl}`);\n      return authResult;\n    }\n\n    const addConnectionResult = await this.addConectionWithProvider(authProviderUrl, connectionWithAuthProvider);\n\n    if (addConnectionResult instanceof Error) {\n      try {\n        await connectionWithAuthProvider.disconnect();\n      } catch (err) {\n        console.error('Failed to disconnect', err);\n      }\n      return addConnectionResult;\n    }\n    this.setAuthResult(authProviderUrl, authResult);\n    return connectionWithAuthProvider;\n  }\n\n  /**\n   * disconnect from the auth provider.\n   * succed even if not connected to.\n   *\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @returns {(Promise<void | Error>)}\n   * @memberof CAConnectionsPool\n   */\n  public async disconnect(authProviderUrl: TCAuthProviderIdentifier): Promise<void | Error> {\n    const currentConnectionWithAuthProvider = this.getConnectionWithAuthProvider(authProviderUrl);\n\n    if (currentConnectionWithAuthProvider instanceof Error) {\n      return currentConnectionWithAuthProvider;\n    }\n    if (currentConnectionWithAuthProvider) {\n      const disconnectionResult = await currentConnectionWithAuthProvider.disconnect();\n\n      if (disconnectionResult instanceof Error) {\n        console.error(disconnectionResult);\n        return new Error(`Failed to disconnect from the auth provider ${authProviderUrl}`);\n      }\n    }\n    return this.unsetConnectionWithAuthProvider(authProviderUrl);\n  }\n\n  /**\n   * disconnect from all the active connections\n   *\n   * @returns {(Promise<Error | void>)}\n   * @memberof CAConnectionsPool\n   */\n  public async close(): Promise<Error | void> {\n    const { providersConnectionState } = this;\n    const providerConnectionStateValues = Object.values(providersConnectionState);\n    const disconnectResults = [];\n    const len = providerConnectionStateValues.length;\n    let idx = 0;\n    let connectionToAuthProviderStateDesc;\n    let connectionToAuthProvider;\n    let errorMessage = '';\n\n    while (idx < len) {\n      connectionToAuthProviderStateDesc = providerConnectionStateValues[idx++];\n      ({ connection: connectionToAuthProvider } = connectionToAuthProviderStateDesc);\n      idx += 1;\n      if (connectionToAuthProvider) {\n        const connectionToAuthProviderUrl = connectionToAuthProviderStateDesc.caProviderUrl;\n\n        if (connectionToAuthProvider.status !== CA_CONNECTION_STATUS.DISCONNECTED) {\n          disconnectResults.push(\n            connectionToAuthProvider\n              .disconnect()\n              .then((result) => {\n                if (result instanceof Error) {\n                  console.error(result);\n                  errorMessage += `/nThe error has occured when disconnect from the auth provider ${connectionToAuthProviderUrl}`;\n                } else {\n                  this.unsetConnectionWithAuthProvider(connectionToAuthProviderUrl);\n                }\n              })\n              .catch((err) => {\n                console.error(err);\n                errorMessage += `/nCrashed while disconnect from the auth provider ${connectionToAuthProviderUrl}`;\n              })\n          );\n        }\n        this.unsetConnectionWithAuthProvider(connectionToAuthProviderUrl);\n      }\n    }\n    // wait till all connections will be pro\n    await Promise.all(disconnectResults);\n    if (errorMessage) {\n      return new Error(errorMessage);\n    }\n  }\n\n  /**\n   * sign out from the auth provider service\n   * which is currently authorized on and close the connection\n   *\n   * @returns {(Promise<Error | void>)}\n   * @memberof CAConnectionsPool\n   */\n  public async signOut(): Promise<Error | void> {\n    const { authConnection } = this;\n\n    this.unsetAuthResult();\n    if (authConnection) {\n      const { connection, authProviderId: authProviderUrl } = authConnection;\n\n      if (connection) {\n        const disconnectResult = await this.disconnect(authProviderUrl);\n\n        if (disconnectResult instanceof Error) {\n          console.error(disconnectResult);\n          return new Error(`Failed to disconnect from the auth procider ${authProviderUrl} on sign out from it`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns user's profile stored by the CA\n   * provider on which the user is authorized on.\n   * If the user is not authorized on a CA\n   * then undefined will be returned.\n   *\n   * @memberof CAConnectionsPool\n   */\n  public getCAUserProfile = async () => {\n    const authConnection = this.authConnection;\n    if (!authConnection) {\n      return;\n    }\n    return authConnection.connection?.getCAUserProfile();\n  };\n\n  /**\n   * set the auth result and check the auth provider\n   * in the result is equals to the auth provider id.\n   *\n   * @protected\n   * @param {TCAAuthProviderIdentity} authProviderId\n   * @param {ICAConnectionUserAuthorizedResult} authResult\n   * @returns {(Error | void)}\n   * @memberof CAConnectionsPool\n   */\n  protected setAuthResult(authProviderId: TCAAuthProviderIdentity, authResult: ICAConnectionUserAuthorizedResult): Error | void {\n    const { cryptoCredentials } = authResult;\n    const validationResult = checkIsValidCryptoCredentials(cryptoCredentials);\n\n    if (!validationResult) {\n      return new Error('The crypto credentials are not valid');\n    }\n\n    const userIdentity = new CentralAuthorityIdentity(cryptoCredentials.userIdentity);\n\n    if (userIdentity.identityDescription instanceof Error) {\n      return new Error('The user identity is not valid');\n    }\n    if (\n      !compareAuthProvidersIdentities(\n        userIdentity.identityDescription[CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME],\n        authProviderId\n      )\n    ) {\n      return new Error(`\n        The auth provider url from the auth crdentials ${userIdentity.identityDescription[CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME]} is not equals to the provider the user authorized on ${authProviderId}\n      `);\n    }\n\n    this.userAuthResult = {\n      ...authResult,\n      authProviderId,\n    };\n  }\n\n  protected unsetAuthResult() {\n    this.userAuthResult = undefined;\n  }\n\n  /**\n   * returns the current state of a connection\n   * to the auth provider.\n   *\n   * @protected\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @returns {(ICAConnectionsPoolCurrentConnections | undefined | Error)}\n   * @memberof CAConnectionsPool\n   */\n  protected getAuthProviderStateDesc(\n    authProviderUrl: TCAAuthProviderIdentity\n  ): ICAConnectionsPoolCurrentConnections | undefined | Error {\n    const normalizedUrl = normalizeUrl(authProviderUrl);\n\n    if (normalizedUrl instanceof Error) {\n      console.error(normalizedUrl);\n      return new Error('The url is not valid');\n    }\n\n    const { providersConnectionState } = this;\n\n    return providersConnectionState[normalizedUrl];\n  }\n\n  protected async addConectionWithProvider(\n    authProviderUrl: string,\n    connectionWithAuthProvider: ICAConnection\n  ): Promise<ICAConnection | Error> {\n    const setConnectionInAuhProviderConnectionStatesStore = this.setConnectionWithAuthProvider(\n      authProviderUrl,\n      connectionWithAuthProvider\n    );\n\n    if (setConnectionInAuhProviderConnectionStatesStore instanceof Error) {\n      console.error(setConnectionInAuhProviderConnectionStatesStore);\n\n      const disconnectResult = await connectionWithAuthProvider.disconnect();\n\n      if (disconnectResult instanceof Error) {\n        console.error(disconnectResult);\n      }\n      return new Error('Failed to set connection with auth provider');\n    }\n    return connectionWithAuthProvider;\n  }\n\n  /**\n   * returns connection which is active\n   * and the status !== DISCONNECTED\n   *\n   * @protected\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @returns {(ICAConnection | void | Error)}\n   * @memberof CAConnectionsPool\n   */\n  protected getActiveConnectionWithAuthProvider(authProviderUrl: TCAAuthProviderIdentity): ICAConnection | void | Error {\n    const authProviderState = this.getAuthProviderStateDesc(authProviderUrl);\n\n    if (authProviderState instanceof Error) {\n      return authProviderState;\n    }\n    if (authProviderState) {\n      const { connection } = authProviderState;\n\n      if (connection && connection.status !== CA_CONNECTION_STATUS.DISCONNECTED) {\n        return connection;\n      }\n    }\n  }\n\n  /**\n   * returns any connection\n   *\n   * @protected\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @returns {(ICAConnection | void | Error)}\n   * @memberof CAConnectionsPool\n   */\n  protected getConnectionWithAuthProvider(authProviderUrl: TCAAuthProviderIdentity): ICAConnection | void | Error {\n    const authProviderState = this.getAuthProviderStateDesc(authProviderUrl);\n\n    if (authProviderState instanceof Error) {\n      return authProviderState;\n    }\n    if (authProviderState) {\n      return authProviderState.connection;\n    }\n  }\n\n  /**\n   * updates the current state of connection\n   * with the auth provider.\n   *\n   * @protected\n   * @param {ICAConnectionsPoolCurrentConnections} authProviderConnectionState\n   * @memberof CAConnectionsPool\n   */\n  protected updateStateAuthProvider(\n    authProviderConnectionState: Partial<ICAConnectionsPoolCurrentConnections> & {\n      caProviderUrl: ICAConnectionsPoolCurrentConnections['caProviderUrl'];\n    }\n  ) {\n    const { caProviderUrl } = authProviderConnectionState;\n\n    if (!caProviderUrl) {\n      return new Error('An url of the auth provider must be specified');\n    }\n\n    const authProviderUrlNormalized = normalizeCAConnectionAuthProviderURL(caProviderUrl);\n\n    if (authProviderUrlNormalized instanceof Error) {\n      return authProviderUrlNormalized;\n    }\n\n    const { providersConnectionState } = this;\n    const existingState = providersConnectionState[authProviderUrlNormalized];\n\n    if (!existingState) {\n      providersConnectionState[caProviderUrl] = authProviderConnectionState as ICAConnectionsPoolCurrentConnections;\n    } else {\n      Object.assign(existingState, authProviderConnectionState);\n    }\n  }\n\n  /**\n   * set an active connection with an\n   * auth provider in the auth\n   * providers state.\n   *\n   * @protected\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @param {ICAConnection} connection\n   * @returns\n   * @memberof CAConnectionsPool\n   */\n  protected setConnectionWithAuthProvider(authProviderUrl: TCAAuthProviderIdentity, connection: ICAConnection) {\n    const authProviderUrlNormalized = normalizeUrl(authProviderUrl);\n\n    if (authProviderUrlNormalized instanceof Error) {\n      console.error(authProviderUrlNormalized);\n      return new Error('The url is not valid');\n    }\n\n    if (!connection) {\n      return new Error(`Connection with the auth provider ${authProviderUrl} must be specified`);\n    }\n    if (typeof connection.authorize !== 'function' || typeof connection.connect !== 'function') {\n      return new Error('The instance of the CAConnection is not valid');\n    }\n    if (connection.status === CA_CONNECTION_STATUS.DISCONNECTED) {\n      return new Error('The connection must be in active state');\n    }\n\n    const existingConnection = this.getActiveConnectionWithAuthProvider(authProviderUrl);\n\n    if (existingConnection instanceof Error) {\n      return existingConnection;\n    }\n    if (existingConnection) {\n      return new Error(`Connection with the ${authProviderUrl} is already exists`);\n    }\n    return this.updateStateAuthProvider({\n      connection,\n      caProviderUrl: authProviderUrl,\n    });\n  }\n\n  /**\n   * unset the current connection in the auth provider\n   * connections states store\n   *\n   * @protected\n   * @memberof CAConnectionsPool\n   */\n  protected unsetConnectionWithAuthProvider(authProviderUrl: TCAAuthProviderIdentity): Error | void {\n    return this.updateStateAuthProvider({\n      caProviderUrl: authProviderUrl,\n      connection: undefined,\n    });\n  }\n\n  /**\n   * establish a new connection with the auth\n   * provider.\n   *\n   * @protected\n   * @param {TCAAuthProviderIdentity} authProviderUrl\n   * @returns {(Promise<Error | ICAConnection>)}\n   * @memberof CAConnectionsPool\n   */\n  protected async connectWithAuthProvider(authProviderUrl: TCAAuthProviderIdentity): Promise<Error | ICAConnection> {\n    const normalizedAuthProviderUrl = normalizeUrl(authProviderUrl);\n\n    if (normalizedAuthProviderUrl instanceof Error) {\n      console.error(normalizedAuthProviderUrl);\n      return new Error('The url provided for the auth provider is not valid');\n    }\n\n    const stateOfAuthProvider = this.getAuthProviderStateDesc(authProviderUrl);\n\n    if (stateOfAuthProvider instanceof Error) {\n      console.error(stateOfAuthProvider);\n      return new Error(`The configuration for the ${authProviderUrl} is not valid`);\n    }\n    if (!stateOfAuthProvider) {\n      return new Error(`The url provided ${authProviderUrl} is not known`);\n    }\n\n    const { options, caProvider } = stateOfAuthProvider;\n\n    if (!options) {\n      return new Error(`Connection options is not specified for the auth provider ${authProviderUrl}`);\n    }\n    if (caProvider == null) {\n      return new Error('Auth provider type is not specified in the current state');\n    }\n\n    const ConnectionConstructor = getConnectionConstructorAuthProviderType(caProvider);\n\n    if (!ConnectionConstructor) {\n      return new Error(`There is no constructor class for the auth provider ${authProviderUrl}`);\n    }\n    if (ConnectionConstructor instanceof Error) {\n      console.error(ConnectionConstructor);\n      return new Error(`An error has occurred on define constructor class for the auth provider ${authProviderUrl}`);\n    }\n\n    let connectionWithAuthProvider;\n    try {\n      connectionWithAuthProvider = new ConnectionConstructor();\n    } catch (err) {\n      console.error(err);\n      return new Error('The error has occurred when construct the connection');\n    }\n\n    const connectionResult = await connectionWithAuthProvider.connect(options);\n\n    if (connectionResult instanceof Error) {\n      console.error(connectionResult);\n      return new Error(`Failed to connect with the auth provider ${authProviderUrl}`);\n    }\n    return connectionWithAuthProvider;\n  }\n\n  /**\n   * add auth provider in the description\n   * of a state of connections\n   *\n   * @protected\n   * @param {IAuthProviderConnectionConfiguration} authProviderConnectionConfiguration\n   * @memberof CAConnectionsPool\n   * @throws\n   */\n  protected addAuthProvider = (authProviderConnectionConfiguration: IAuthProviderConnectionConfiguration): void => {\n    if (!authProviderConnectionConfiguration) {\n      throw new Error('Configuration for the auth provider is not defined');\n    }\n    if (typeof authProviderConnectionConfiguration !== 'object') {\n      throw new Error('Configuration must be an object');\n    }\n\n    const { caProvider, caProviderUrl, options } = authProviderConnectionConfiguration;\n\n    if (caProvider == null) {\n      throw new Error('Provider type must be defined');\n    }\n    if (!validateCAConnectionAuthProviderType(caProvider)) {\n      throw new Error('The auth provider type is wrong');\n    }\n\n    const authProviderUrlNormalized = normalizeCAConnectionAuthProviderURL(caProviderUrl);\n    const { providersConnectionState } = this;\n\n    if (authProviderUrlNormalized instanceof Error) {\n      throw authProviderUrlNormalized;\n    }\n    if (providersConnectionState[authProviderUrlNormalized]) {\n      throw new Error(`Configuration was already set for the auth provider ${authProviderUrlNormalized}`);\n    }\n    if (!options) {\n      throw new Error(`Configuration for the auth provider ${authProviderUrlNormalized} is not specified`);\n    }\n    if (!validateCAConnectionAuthProviderConnectionConfiguration(caProvider, options)) {\n      throw new Error(`The configuration for the auth provider ${authProviderUrlNormalized} is not valid`);\n    }\n\n    const setAuthProviderConnectionStateResult = this.updateStateAuthProvider({\n      caProvider,\n      caProviderUrl,\n      options,\n    });\n\n    if (setAuthProviderConnectionStateResult instanceof Error) {\n      throw setAuthProviderConnectionStateResult;\n    }\n  };\n\n  /**\n   * set options for auth providers connections constructors\n   *\n   * @protected\n   * @param {IAuthProviderConnectionConfiguration[]} providers\n   * @memberof CAConnectionsPool\n   * @throws\n   */\n  protected setOptionsOfAuthProviders(providers: IAuthProviderConnectionConfiguration[]): void {\n    if (!providers) {\n      throw new Error('Providers property must be specified');\n    }\n    if (!(providers instanceof Array)) {\n      throw new Error('Providers must be an instance of Array');\n    }\n    if (!providers.length) {\n      throw new Error('Providers property must not be an empty array');\n    }\n    // add each auth provider configuration\n    // to connect on in a feature\n    providers.forEach(this.addAuthProvider);\n  }\n\n  /**\n   * set options for the instance.\n   *\n   * @protected\n   * @param {ICAConnectionsPoolOptions} options\n   * @memberof CAConnectionsPool\n   * @throws\n   */\n  protected setOptions(options: ICAConnectionsPoolOptions): void {\n    const { providers } = options;\n\n    this.setOptionsOfAuthProviders(providers);\n  }\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-pool/central-authority-connections-pool.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-pool/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.common/central-authority-connections-utils.common.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.normalizers.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.validators/central-authority-connections-utils.validators.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/central-authority-connections-utils.validators/central-authority-connections-utils.validators.ts",["2728","2729","2730","2731","2732","2733","2734"],"import {\n  CA_CONNECTION_AUTH_PROVIDERS,\n  CA_CONNECTIONS_POOL_AUTH_PROVIDERS_CONNECTION_CONSTRUCTORS,\n} from '../../central-authority-connections.const';\nimport { CA_CONNECTIONS_AUTH_PROVIDERS_VALUES } from './central-authority-connections-utils.validators.const';\nimport validator from 'validator';\nimport { TCAAuthProviderIdentity } from '../../central-authority-connections.types';\n\nexport const validateCAConnectionAuthProviderType = (caAuthProvider: any): caAuthProvider is CA_CONNECTION_AUTH_PROVIDERS =>\n  CA_CONNECTIONS_AUTH_PROVIDERS_VALUES.includes(caAuthProvider);\n\nexport const validateCAConnectionAuthProviderUrl = (caAuthProviderUrl: string): caAuthProviderUrl is TCAAuthProviderIdentity => {\n  try {\n    return validator.isURL(caAuthProviderUrl);\n  } catch {\n    return false;\n  }\n};\n\nexport const validateCAConnectionAuthProviderConnectionConfiguration = (\n  authProviderType: CA_CONNECTION_AUTH_PROVIDERS,\n  connectionConf: any\n): boolean => {\n  if (validateCAConnectionAuthProviderType(authProviderType)) {\n    const AuthProviderConnectionConstructor = CA_CONNECTIONS_POOL_AUTH_PROVIDERS_CONNECTION_CONSTRUCTORS[authProviderType];\n\n    return AuthProviderConnectionConstructor.validateConfiguration(connectionConf);\n  }\n  return false;\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections-utils/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/central-authority-connections.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-connections/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.ts",["2735","2736","2737","2738","2739","2740"],"import { getUserIdentityByCryptoCredentials } from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\nimport { validateAuthProviderIdentity } from './../../../central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { TCentralAuthorityUserIdentity } from './../../../central-authority-class-types/central-authority-class-types-common';\nimport {\n  exportCryptoCredentialsToString,\n  importCryptoCredentialsFromAString,\n} from './../../../central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\nimport { ICAUserUniqueIdentifierDescription } from './../../../central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { CentralAuthorityIdentity } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport { checkIsValidCryptoCredentials } from './../../../central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport { TCentralAuthorityUserCryptoCredentials } from './../../../central-authority-class-types/central-authority-class-types-crypto-credentials';\nimport { ISecretStoreCredentials, ISecretStoreCredentialsSession } from 'classes/secret-storage-class/secret-storage-class.types';\nimport {\n  CA_STORAGE_CURRENT_USER_CREDENTIALS_SECRET_STORAGE_CONFIGURATION,\n  CA_STORAGE_CURRENT_USER_CREDENTIALS_SECRET_STORAGE_DATABASE_NAME,\n  CA_STORAGE_CURRENT_USER_CREDENTIALS_SECRET_STORAGE_OPTIONS,\n  CA_STORAGE_CURRENT_USER_CREDENTIALS_SESSION_KEY,\n} from './central-authority-storage-current-user-credentials.const';\nimport { SecretStorage } from 'classes/secret-storage-class';\nimport { TCAuthProviderIdentifier } from '../../../central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport {\n  ICAStorageCurrentUserCredentials,\n  ICAStorageCurrentUserCredentialsOptions,\n  TCAStorageCurrentUserCredentials,\n} from './central-authority-storage-current-user-credentials.types';\nimport { ISensitiveDataSessionStorage } from 'classes/sensitive-data-session-storage/sensitive-data-session-storage.types';\nimport { exportPasswordKeyAsString, importPasswordKeyFromString } from 'utils';\n\n/**\n * This storage is used to store the user's\n * public and private keys along with the\n * user's identity\n */\nexport class CentralAuthorityStorageCurrentUserCredentials implements ICAStorageCurrentUserCredentials {\n  protected static async authorizeInStorage(secretStorageConnection: SecretStorage, cryptoKey: CryptoKey): Promise<Error | void> {\n    if (!(cryptoKey instanceof CryptoKey)) {\n      return new Error('Crypto key must be an instance of the Crypto key');\n    }\n    if (!(secretStorageConnection instanceof SecretStorage)) {\n      return new Error('The secret storage connection must be an instance of the SecretStorage');\n    }\n\n    const authorizeByKeyResult = await secretStorageConnection.authorizeByKey(\n      {\n        key: cryptoKey,\n      },\n      CA_STORAGE_CURRENT_USER_CREDENTIALS_SECRET_STORAGE_OPTIONS\n    );\n\n    if (authorizeByKeyResult instanceof Error) {\n      return authorizeByKeyResult;\n    }\n  }\n\n  protected get isSecretStorageActive(): boolean {\n    return !this.isDisconnected && !!this.secretStorageConnection && this.secretStorageConnection.isActive;\n  }\n\n  private isDisconnected: boolean = false;\n\n  private secretStorageEncryptionKey?: CryptoKey;\n\n  private secretStorageConnection?: SecretStorage;\n\n  /**\n   * connect to the SecretStorage\n   *\n   * @memberof CentralAuthorityStorageCurrentUserCredentials\n   */\n  public connect = async (options: ICAStorageCurrentUserCredentialsOptions): Promise<Error | void> => {\n    const { isSecretStorageActive } = this;\n\n    if (isSecretStorageActive) {\n      return new Error('The instance is already connected to the secret storage');\n    }\n\n    const { credentials } = options;\n    const connectToSecretStorageResult = await this.createSecretStorageConnection(credentials);\n\n    if (connectToSecretStorageResult instanceof Error) {\n      return connectToSecretStorageResult;\n    }\n    this.unsetIsDisconnected();\n  };\n\n  public disconnect = async (): Promise<Error | void> => {\n    const disconnectFromSecretStorageResult = await this.disconnectFromSecretStorage();\n\n    if (disconnectFromSecretStorageResult instanceof Error) {\n      return disconnectFromSecretStorageResult;\n    }\n    this.unsetSecretStorageCryptoKey();\n    this.setIsDisconnected();\n  };\n\n  /**\n   * set the user's crypto keys for the user identity and\n   * the user auth provider identity\n   *\n   * @memberof CentralAuthorityStorageCurrentUserCredentials\n   */\n  public set = async (userCryptoCredentials: TCentralAuthorityUserCryptoCredentials): Promise<void | Error> => {\n    const connectionCheckResult = await this.checkConnectionAndReconnect();\n\n    if (connectionCheckResult instanceof Error) {\n      return connectionCheckResult;\n    }\n\n    const credentialsExportedToString = await this.exportCredentialsToString(userCryptoCredentials);\n\n    if (credentialsExportedToString instanceof Error) {\n      return credentialsExportedToString;\n    }\n\n    const [resultSetWithUserId, resultSetWithAuthProvider] = await Promise.all([\n      this.setCredentialsForUserIdentity(userCryptoCredentials, credentialsExportedToString),\n      this.setCredentialsForAuthProvider(userCryptoCredentials, credentialsExportedToString),\n    ]);\n\n    let err = false;\n    if (resultSetWithUserId instanceof Error) {\n      console.error(resultSetWithUserId);\n      console.error(new Error('Failed to set credentials for the user id'));\n      err = true;\n    }\n    if (resultSetWithAuthProvider instanceof Error) {\n      console.error(resultSetWithAuthProvider);\n      console.error(new Error('Failed to set credentials for the auth provider'));\n      err = true;\n    }\n    if (err) {\n      const resultUnsetAll = await this.unsetCredentialsForUser(userCryptoCredentials);\n\n      if (resultUnsetAll instanceof Error) {\n        console.error(resultUnsetAll);\n        console.error(new Error('Failed to unset credentials for the user identity'));\n      }\n      return new Error('Failed to store credentials');\n    }\n  };\n\n  /**\n   * return credentials by the user identity\n   *\n   * @memberof CentralAuthorityStorageCurrentUserCredentials\n   */\n  public get = async (\n    userIdentity: TCentralAuthorityUserIdentity\n  ): Promise<TCentralAuthorityUserCryptoCredentials | Error | void> => {\n    if (!this.validateUserIdentity(userIdentity)) {\n      return new Error('The user identity is not valid');\n    }\n    return this.getCredentials(userIdentity);\n  };\n\n  /**\n   * unset the user crypto credentials for the user identity\n   * and the auth provider\n   *\n   * @memberof CentralAuthorityStorageCurrentUserCredentials\n   */\n  public unset = async (userIdentity: TCentralAuthorityUserIdentity): Promise<Error | void> => {\n    return this.unsetCredentialsForUser(userIdentity);\n  };\n\n  /**\n   * return the credentials by the auth provider\n   *\n   * @memberof CentralAuthorityStorageCurrentUserCredentials\n   */\n  public getByAuthProvider = async (\n    authProviderIdentity: TCAuthProviderIdentifier\n  ): Promise<TCentralAuthorityUserCryptoCredentials | Error | void> => {\n    const connectionCheckResult = await this.checkConnectionAndReconnect();\n\n    if (connectionCheckResult instanceof Error) {\n      return connectionCheckResult;\n    }\n\n    const validationResult = this.validateAuthProviderId(authProviderIdentity);\n\n    if (validationResult instanceof Error) {\n      return validationResult;\n    }\n    return this.getCredentials(authProviderIdentity);\n  };\n\n  protected async reconnect(): Promise<Error | void> {\n    const { secretStorageEncryptionKey, isDisconnected } = this;\n\n    if (isDisconnected) {\n      return new Error(\n        'The instance was disconnected from the secret storage from the outside by calling the \"disconnect\" method'\n      );\n    }\n    if (!secretStorageEncryptionKey) {\n      return new Error('There is no encryption key');\n    }\n\n    const disconnectResult = await this.disconnectFromSecretStorage();\n\n    if (disconnectResult instanceof Error) {\n      console.error(disconnectResult);\n      return new Error('Failed to disconnect');\n    }\n\n    const secretStorageConnection = this.createConnectionToSecretStorage();\n    const authToSecretStorageResult = await CentralAuthorityStorageCurrentUserCredentials.authorizeInStorage(\n      secretStorageConnection,\n      secretStorageEncryptionKey\n    );\n\n    if (authToSecretStorageResult instanceof Error) {\n      console.error(authToSecretStorageResult);\n      return new Error('Failed to authorize in the SecretStorage');\n    }\n  }\n\n  /**\n   * returns key with prefix of the CAStorageCurrentUserCredentials\n   *\n   * @protected\n   * @param {string} key\n   * @returns {string}\n   * @memberof CentralAuthorityStorageCurrentUserCredentials\n   */\n  protected keyWithPrefix(key: string): string {\n    return `${CA_STORAGE_CURRENT_USER_CREDENTIALS_SECRET_STORAGE_DATABASE_NAME}_${key}`;\n  }\n\n  protected async getCredentials(key: string): Promise<TCentralAuthorityUserCryptoCredentials | Error | void> {\n    const connectionCheckResult = await this.checkConnectionAndReconnect();\n\n    if (connectionCheckResult instanceof Error) {\n      return connectionCheckResult;\n    }\n\n    const { secretStorageConnection } = this;\n\n    if (!secretStorageConnection) {\n      return new Error('There is no active connection with the SecretStorage');\n    }\n\n    const keyPrefixed = this.keyWithPrefix(key);\n    const val = await secretStorageConnection.get(keyPrefixed);\n\n    if (!val) {\n      return undefined;\n    }\n    if (val instanceof Error) {\n      return val;\n    }\n\n    const credentialsImported = await importCryptoCredentialsFromAString(val);\n\n    if (credentialsImported instanceof Error) {\n      console.error(credentialsImported);\n      return new Error('Failed to import the credentials');\n    }\n    return credentialsImported;\n  }\n\n  protected validateAuthProviderId(authProviderURL: string): Error | void {\n    const validationResult = validateAuthProviderIdentity(authProviderURL);\n\n    if (!validationResult) {\n      return new Error('The auth provider identity is not valid');\n    }\n  }\n\n  protected validateUserIdentity(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    userIdentity: any\n  ): userIdentity is TCentralAuthorityUserIdentity {\n    const caUserIdentity = new CentralAuthorityIdentity(userIdentity);\n\n    return !!caUserIdentity.isValid;\n  }\n\n  protected getAuthProviderIdentityByUserId(userIdentity: string): Error | string {\n    const caUserIdentity = new CentralAuthorityIdentity(userIdentity);\n\n    if (!caUserIdentity.isValid) {\n      return new Error('The user identity is not valid');\n    }\n    return (caUserIdentity.identityDescription as ICAUserUniqueIdentifierDescription).authorityProviderURI;\n  }\n\n  protected async exportCredentialsToString(\n    userCryptoCredentials: TCentralAuthorityUserCryptoCredentials\n  ): Promise<string | Error> {\n    // on export validation has occurred\n    const userCredentialsExported = exportCryptoCredentialsToString(userCryptoCredentials);\n\n    if (userCredentialsExported instanceof Error) {\n      console.error(userCredentialsExported);\n      return new Error('Failed to export credentials to string');\n    }\n    return userCredentialsExported;\n  }\n\n  protected async setCredentialsForUserIdentity(\n    userCryptoCredentials: TCentralAuthorityUserCryptoCredentials,\n    userCryptoCredentialsExported: string\n  ): Promise<void | Error> {\n    const connectionCheckResult = await this.checkConnectionAndReconnect();\n\n    if (connectionCheckResult instanceof Error) {\n      return connectionCheckResult;\n    }\n\n    const { secretStorageConnection } = this;\n\n    if (!secretStorageConnection) {\n      return new Error('There is no active connection with the SecretStorage');\n    }\n\n    const userIdentity = getUserIdentityByCryptoCredentials(userCryptoCredentials);\n    const resultSetInStorage = await secretStorageConnection.set(\n      this.keyWithPrefix(userIdentity as string),\n      userCryptoCredentialsExported\n    );\n\n    if (resultSetInStorage instanceof Error) {\n      console.error(resultSetInStorage);\n      return new Error('Failed to set credentials in the storage');\n    }\n  }\n\n  protected async setCredentialsForAuthProvider(\n    userCryptoCredentials: TCentralAuthorityUserCryptoCredentials,\n    userCryptoCredentialsExported: string\n  ): Promise<Error | void> {\n    const connectionCheckResult = await this.checkConnectionAndReconnect();\n\n    if (connectionCheckResult instanceof Error) {\n      return connectionCheckResult;\n    }\n\n    const { secretStorageConnection } = this;\n\n    if (!secretStorageConnection) {\n      return new Error('There is no active connection with the SecretStorage');\n    }\n\n    const userIdentity = getUserIdentityByCryptoCredentials(userCryptoCredentials);\n    const authorityProviderURL = this.getAuthProviderIdentityByUserId(userIdentity as string);\n\n    if (authorityProviderURL instanceof Error) {\n      return authorityProviderURL;\n    }\n\n    const resultSetInStorage = await secretStorageConnection.set(\n      this.keyWithPrefix(authorityProviderURL),\n      userCryptoCredentialsExported\n    );\n\n    if (resultSetInStorage instanceof Error) {\n      console.error(resultSetInStorage);\n      return new Error('Failed to set credentials in the storage');\n    }\n  }\n\n  protected async unsetCredentialsForUser(\n    identityOrCredentials: string | TCentralAuthorityUserCryptoCredentials\n  ): Promise<Error | void> {\n    const connectionCheckResult = await this.checkConnectionAndReconnect();\n\n    if (connectionCheckResult instanceof Error) {\n      return connectionCheckResult;\n    }\n\n    const { secretStorageConnection } = this;\n\n    if (!secretStorageConnection) {\n      return new Error('There is no active connection with the SecretStorage');\n    }\n\n    const userIdentity =\n      typeof identityOrCredentials === 'string'\n        ? identityOrCredentials\n        : getUserIdentityByCryptoCredentials(identityOrCredentials);\n\n    if (userIdentity instanceof Error) {\n      console.error(userIdentity);\n      return new Error('Failed to get the user identity by the crypto credentials value');\n    }\n\n    const authorityProviderURL = this.getAuthProviderIdentityByUserId(userIdentity);\n\n    if (authorityProviderURL instanceof Error) {\n      return authorityProviderURL;\n    }\n    return secretStorageConnection.unset([this.keyWithPrefix(userIdentity), this.keyWithPrefix(authorityProviderURL)]);\n  }\n\n  protected validateCryptoCredentials(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    cryptoCredentials: any\n  ): cryptoCredentials is TCentralAuthorityUserCryptoCredentials {\n    return checkIsValidCryptoCredentials(cryptoCredentials);\n  }\n\n  private setIsDisconnected() {\n    this.isDisconnected = true;\n  }\n\n  private unsetIsDisconnected() {\n    this.isDisconnected = false;\n  }\n\n  private async setSecretStorageCryptoKey(key: CryptoKey, session?: ISensitiveDataSessionStorage) {\n    this.secretStorageEncryptionKey = key;\n    if (session) {\n      const result = await this.setSecretStorageCryptoKeyInSession(session, key);\n\n      if (result instanceof Error) {\n        console.error('\"createSecretStorageConnection\"::failed to set key in session', result);\n      }\n    }\n  }\n\n  private unsetSecretStorageCryptoKey() {\n    this.secretStorageEncryptionKey = undefined;\n  }\n\n  private setSecretStorageConnection(secretStorage: SecretStorage) {\n    this.secretStorageConnection = secretStorage;\n  }\n\n  private unsetSecretStorageConnection() {\n    this.secretStorageConnection = undefined;\n  }\n\n  private createConnectionToSecretStorage(): SecretStorage {\n    return new SecretStorage(CA_STORAGE_CURRENT_USER_CREDENTIALS_SECRET_STORAGE_CONFIGURATION);\n  }\n\n  private async readSecretStorageCryptoKeyFromSession(\n    session: ISensitiveDataSessionStorage\n  ): Promise<Error | CryptoKey | undefined> {\n    try {\n      const k = await session.getItem(CA_STORAGE_CURRENT_USER_CREDENTIALS_SESSION_KEY);\n\n      if (k) {\n        return await importPasswordKeyFromString(k);\n      }\n    } catch (err) {\n      return err;\n    }\n  }\n\n  private async setSecretStorageCryptoKeyInSession(session: ISensitiveDataSessionStorage, key: CryptoKey) {\n    try {\n      return await session.setItem(CA_STORAGE_CURRENT_USER_CREDENTIALS_SESSION_KEY, await exportPasswordKeyAsString(key));\n    } catch (err) {\n      return err;\n    }\n  }\n\n  private async createSecretStorageConnection(credentials: TCAStorageCurrentUserCredentials): Promise<Error | void> {\n    let { secretStorageEncryptionKey } = this;\n    const secretStorageConnection = this.createConnectionToSecretStorage();\n    const session = (credentials as ISecretStoreCredentialsSession).session;\n\n    if (!secretStorageEncryptionKey && session) {\n      const k = await this.readSecretStorageCryptoKeyFromSession((credentials as ISecretStoreCredentialsSession).session);\n\n      if (k && !(k instanceof Error)) {\n        secretStorageEncryptionKey = k;\n      }\n    }\n\n    const cryptoKey =\n      secretStorageEncryptionKey || (await secretStorageConnection.generateCryptoKey(credentials as ISecretStoreCredentials));\n\n    if (cryptoKey instanceof Error) {\n      return new Error('Failed to generate crypto key by the credentials');\n    }\n    if (!secretStorageEncryptionKey) {\n      await this.setSecretStorageCryptoKey(cryptoKey, session);\n    }\n\n    const authToSecretStorageResult = await CentralAuthorityStorageCurrentUserCredentials.authorizeInStorage(\n      secretStorageConnection,\n      cryptoKey\n    );\n\n    if (authToSecretStorageResult instanceof Error) {\n      console.error(authToSecretStorageResult);\n      return new Error('Failed to authorize in the SecretStorage');\n    }\n    this.setSecretStorageConnection(secretStorageConnection);\n  }\n\n  private async disconnectFromSecretStorage(): Promise<Error | void> {\n    const { isSecretStorageActive, secretStorageConnection } = this;\n\n    if (isSecretStorageActive && secretStorageConnection) {\n      const disconnectResult = await secretStorageConnection.disconnect();\n\n      if (disconnectResult instanceof Error) {\n        console.error(disconnectResult);\n        return new Error('Failed to disconnect from the secret storage');\n      }\n    }\n    this.unsetSecretStorageConnection();\n  }\n\n  private async checkConnectionAndReconnect(): Promise<void | Error> {\n    const { isSecretStorageActive } = this;\n\n    if (!isSecretStorageActive) {\n      const reconnect = await this.reconnect();\n\n      if (reconnect instanceof Error) {\n        console.error(reconnect);\n        return new Error('Connection to the SecretStorage is not active and failed to reconnect');\n      }\n    }\n  }\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/central-authority-storage-current-user-credentials.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/central-authority-storage-current-user-credentials/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-current-user-auth/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.ts",["2741","2742","2743","2744","2745"],"import { TCAUserIdentityRawTypes } from './../../../central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { OpenStorage } from './../../../../open-storage/open-storage';\nimport { getStatusClass } from 'classes/basic-classes/status-class-base/status-class-base';\nimport {\n  CA_IDENTITY_CREDENTIALS_STORAGE_STATUS,\n  CA_IDENTITY_CREDENTIALS_STORAGE_CONFIGURATION,\n  CA_IDENTITY_CREDENTIALS_STORAGE_READ_CACHE_CAPACITY,\n  CA_IDENTITY_CREDENTIALS_STORAGE_READ_RAW_CACHE_CAPACITY,\n  CA_IDENTITY_CREDENTIALS_STORAGE_NAME_OPTIONS_MAX_LENGTH,\n  CA_IDENTITY_CREDENTIALS_STORAGE_FULL_NAME,\n} from './central-authority-storage-swarm-users-identity-credentials.const';\nimport {\n  ICAIdentityCredentialsStorage,\n  ICAIdentityCredentialsStorageConntionOptions,\n} from './central-authority-storage-swarm-users-identity-credentials.types';\nimport {\n  TCentralAuthorityUserIdentity,\n  TCACryptoKeyPairs,\n  TCentralAuthorityUserCryptoCredentials,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport CentralAuthorityIdentity from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport {\n  getExportedCryptoCredentialsByCAIdentity,\n  replaceCryptoCredentialsIdentity,\n  importCryptoCredentialsFromAString,\n  getUserIdentityByCryptoCredentials,\n  getCryptoKeyPairsByCryptoCredentials,\n} from 'classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials';\nimport { dataCachingUtilsCachingDecorator as caching } from 'utils/data-cache-utils';\nimport {\n  checkIsValidExportedCryptoCredentialsToString,\n  checkIsValidCryptoCredentials,\n} from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\n\n/**\n * This is storage to cache swarm users credentials locally.\n * To do not request it each time from the auth provider.\n */\n// TODO -use open storage instead of the SecretStorage\nexport class CentralAuthorityIdentityCredentialsStorage\n  extends getStatusClass<typeof CA_IDENTITY_CREDENTIALS_STORAGE_STATUS>({\n    errorStatus: CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.ERROR,\n    initialStatus: CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.NEW,\n    instanceName: 'CentralAuthorityIdentityCredentialsStorage',\n  })\n  implements ICAIdentityCredentialsStorage {\n  public get isActive(): boolean {\n    const { status, storageConnection } = this;\n\n    return status === CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.CONNECTED && !!storageConnection && storageConnection.isActive;\n  }\n\n  protected storageConnection?: OpenStorage;\n\n  protected storageName?: string;\n\n  /**\n   * connect to the SecretStorage with\n   * the user's credentials\n   * @param storageCredentials\n   */\n  public async connect(options?: ICAIdentityCredentialsStorageConntionOptions): Promise<boolean | Error> {\n    const resultSetOptions = this.setOptions(options);\n\n    if (resultSetOptions instanceof Error) {\n      console.error(resultSetOptions);\n      return new Error('Failed to set options');\n    }\n\n    const connection = this.createConnectionToStorage();\n\n    if (connection instanceof Error) {\n      console.error(connection);\n      return this.setErrorStatus('Failed to create an instance of SecretStorage');\n    }\n    this.setStatus(CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.CONNECTING);\n\n    const connectionResult = await connection.connect(CA_IDENTITY_CREDENTIALS_STORAGE_CONFIGURATION);\n\n    if (connectionResult instanceof Error) {\n      console.error(connectionResult);\n      this.setStatus(CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.CONNECTION_FAILED);\n      return new Error('Failed to authorize');\n    }\n    this.setStatus(CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.CONNECTED);\n    this.storageConnection = connection;\n    return true;\n  }\n\n  /**\n   * get credentials stored for the identity\n   * in the local storage\n   *\n   * @param {TCentralAuthorityUserIdentity} identity\n   * @returns {(Promise<TCentralAuthorityUserCryptoCredentials | Error | null>)}\n   * @memberof CentralAuthorityIdentityCredentialsStorage\n   */\n  public async getCredentials(\n    identity: TCentralAuthorityUserIdentity\n  ): Promise<TCentralAuthorityUserCryptoCredentials | Error | null> {\n    const { isActive } = this;\n\n    if (!isActive) {\n      return new Error('The storage is not active');\n    }\n    return this.getCredentialsCached(identity);\n  }\n\n  /**\n   * set the credentials (identity + crypto keys)\n   * in the local secret storage\n   *\n   * @param {[]} args\n   * @param {string} args[0] - CAIdentity seriazlized\n   * @param {TCACryptoKeyPairs} args[1] - crypto key pairs\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof CentralAuthorityIdentityCredentialsStorage\n   */\n  /**\n   * @param {...any[]} args\n   * @param {string | } args[1] - Crypto credentials (CAIdentity + TACryptoKeyPairs) serialized or deserialized\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof CentralAuthorityIdentityCredentialsStorage\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public async setCredentials(...args: any[]): Promise<boolean | Error> {\n    const argsLenght = args.length;\n    const withCheckPrivateFlag = typeof args[1] === 'boolean';\n    const checkPrivateKey = !withCheckPrivateFlag || args[1] !== false;\n\n    if (argsLenght === 2 && !withCheckPrivateFlag) {\n      return this.setCredentialsByIdentity(args[0], args[1], checkPrivateKey);\n    } else if (argsLenght === 1 || withCheckPrivateFlag) {\n      const caCryptoCredentials = args[0];\n\n      if (checkIsValidExportedCryptoCredentialsToString(caCryptoCredentials)) {\n        return this.setCredentialsByCACryptoCredentialsExportedToString(caCryptoCredentials, checkPrivateKey);\n      } else if (checkIsValidCryptoCredentials(caCryptoCredentials, checkPrivateKey)) {\n        return this.setCredentialsByCACryptoCredentials(caCryptoCredentials, checkPrivateKey);\n      }\n    }\n    return new Error('An unknown arguments');\n  }\n\n  public setCredentialsNoCheckPrivateKey(cryptoCredentials: TCAUserIdentityRawTypes | string) {\n    return this.setCredentials(cryptoCredentials, false);\n  }\n\n  /**\n   * disconnect from the local secret storage\n   *\n   * @returns {(Promise<Error | boolean>)}\n   * @memberof CentralAuthorityIdentityCredentialsStorage\n   */\n  public async disconnect(): Promise<Error | boolean> {\n    const { status, storageConnection } = this;\n\n    if (status === CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.DISCONNECTED) {\n      console.error(new Error('The instance is already disconnected from the storage'));\n      // return false cause already disconnected\n      return false;\n    }\n    if (status !== CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.CONNECTED || status === CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.ERROR) {\n      return this.setErrorStatus(new Error(\"Can't disconnect cause the instance is not in the Connected state\"));\n    }\n    if (!(storageConnection instanceof OpenStorage)) {\n      return this.setErrorStatus('There is no connection to the SecretStorage');\n    }\n\n    const disconnectionResult = await storageConnection.disconnect();\n\n    if (disconnectionResult instanceof Error) {\n      console.error(disconnectionResult);\n      return this.setErrorStatus('SecretStorage failed to disconnect');\n    }\n    this.setStatus(CA_IDENTITY_CREDENTIALS_STORAGE_STATUS.DISCONNECTED);\n    return true;\n  }\n\n  protected getKeyNameWithPrefix(key: string): string {\n    return `${this.storageName}_${key}`;\n  }\n\n  protected setStorageName(postfix: string = '') {\n    this.storageName = `${CA_IDENTITY_CREDENTIALS_STORAGE_FULL_NAME}_${postfix}`;\n  }\n\n  protected setDefaultOptions() {\n    this.setStorageName();\n  }\n\n  protected setOptions(options?: ICAIdentityCredentialsStorageConntionOptions): void | Error {\n    this.setDefaultOptions();\n    if (!options) {\n      return;\n    }\n    if (options.storageName) {\n      if (typeof options.storageName !== 'string') {\n        return new Error('The storage name must be a string');\n      }\n      if (options.storageName.length > CA_IDENTITY_CREDENTIALS_STORAGE_NAME_OPTIONS_MAX_LENGTH) {\n        return new Error(`The maximum length of a storage name is ${CA_IDENTITY_CREDENTIALS_STORAGE_NAME_OPTIONS_MAX_LENGTH}`);\n      }\n      this.setStorageName(options.storageName);\n    }\n  }\n\n  protected createConnectionToStorage(): OpenStorage | Error {\n    try {\n      const connection = new OpenStorage();\n\n      return connection;\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  /**\n   * returns a string as a key under which the\n   * identity will be stored in the key-value\n   * storage.\n   *\n   * @protected\n   * @param {CentralAuthorityIdentity} identity\n   * @returns {(string | Error)}\n   * @memberof CentralAuthorityIdentityCredentialsStorage\n   */\n  protected getStorageKeyByCAIdentity(identity: TCAUserIdentityRawTypes): string | Error {\n    if (!(identity instanceof CentralAuthorityIdentity)) {\n      return new Error('The argument must be an instance of CentralAuthorityIdentity');\n    }\n    if (!identity.isValid) {\n      return new Error('The CA identity is not valid');\n    }\n\n    const { id } = identity;\n\n    // the id - is a unique string which identifies the user\n    // in the swarm\n    if (id instanceof Error) {\n      console.error(id);\n      return new Error('Failed to get the unique identifier of the user');\n    }\n    return this.getKeyNameWithPrefix(id);\n  }\n\n  @caching(CA_IDENTITY_CREDENTIALS_STORAGE_READ_RAW_CACHE_CAPACITY)\n  protected async getCredentialsRaw(identityKey: string): Promise<string | Error | undefined> {\n    const { isActive, storageConnection } = this;\n\n    if (!isActive || !storageConnection) {\n      return new Error('The storage is not active');\n    }\n    try {\n      const caCryptoCredentials = await storageConnection.get(identityKey);\n\n      if (caCryptoCredentials instanceof Error) {\n        console.error(caCryptoCredentials);\n        return new Error('Failed to read credentials from the storage');\n      }\n      return caCryptoCredentials ? caCryptoCredentials : undefined;\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to read a credentials for identity from the storage');\n    }\n  }\n\n  protected setCredentialsByIdentity = async (\n    identity: TCAUserIdentityRawTypes,\n    cryptoKeyPairs: TCACryptoKeyPairs,\n    checkPrivateKey: boolean = true\n  ): Promise<boolean | Error> => {\n    const { isActive, storageConnection } = this;\n    if (!isActive || !storageConnection) {\n      return new Error('The storage is not active');\n    }\n    try {\n      // parse the identity\n      const caIdentity = new CentralAuthorityIdentity(identity);\n      const caIdentityStorageKey = this.getStorageKeyByCAIdentity(caIdentity);\n\n      if (caIdentityStorageKey instanceof Error) {\n        console.error(caIdentityStorageKey);\n        return new Error('The identity is not valid');\n      }\n\n      const cryptoCredentialsExported = await getExportedCryptoCredentialsByCAIdentity(\n        caIdentity,\n        cryptoKeyPairs,\n        checkPrivateKey\n      );\n\n      if (cryptoCredentialsExported instanceof Error) {\n        console.error(cryptoCredentialsExported);\n        return new Error('Failed to export the credentials to a string');\n      }\n\n      const credentialsStoredForIdentity = await this.getCredentialsRaw(caIdentityStorageKey);\n\n      // if a credentials was already\n      // stored for the identity\n      // do not modify it.\n      // Cause it's value\n      // must be immutable\n      if (credentialsStoredForIdentity && !(credentialsStoredForIdentity instanceof Error)) {\n        return false;\n      }\n\n      // if the given values are valid\n      // then can put it to the storage\n      // connected to\n      return await storageConnection.set(caIdentityStorageKey, cryptoCredentialsExported);\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to store the credentials');\n    }\n  };\n\n  protected async setCredentialsByCACryptoCredentials(\n    caCryptoCredentials: TCentralAuthorityUserCryptoCredentials,\n    checkPrivateKey: boolean = true\n  ): Promise<boolean | Error> {\n    const identity = getUserIdentityByCryptoCredentials(caCryptoCredentials);\n\n    if (identity instanceof Error) {\n      console.error(identity);\n      return new Error('The user identity is not valid or have an unknown format');\n    }\n\n    const cryptoKeyPairs = getCryptoKeyPairsByCryptoCredentials(caCryptoCredentials, checkPrivateKey);\n\n    if (cryptoKeyPairs instanceof Error) {\n      console.error(cryptoKeyPairs);\n      return new Error('The crypto key pairs are not valid or have an unknown format');\n    }\n\n    return this.setCredentialsByIdentity(identity, cryptoKeyPairs, checkPrivateKey);\n  }\n\n  protected async setCredentialsByCACryptoCredentialsExportedToString(\n    caCryptoCredentialsExportedToString: string,\n    checkPrivateKey: boolean = true\n  ): Promise<boolean | Error> {\n    const cryptoCredentials = await importCryptoCredentialsFromAString(caCryptoCredentialsExportedToString);\n\n    if (cryptoCredentials instanceof Error) {\n      console.error(cryptoCredentials);\n      return new Error('Failed to import crypto credentials from the string');\n    }\n    return this.setCredentialsByCACryptoCredentials(cryptoCredentials, checkPrivateKey);\n  }\n\n  @caching(CA_IDENTITY_CREDENTIALS_STORAGE_READ_CACHE_CAPACITY)\n  protected async getCredentialsCached(\n    identity: TCAUserIdentityRawTypes\n  ): Promise<TCentralAuthorityUserCryptoCredentials | Error | null> {\n    try {\n      // parse the identity\n      const caIdentity = new CentralAuthorityIdentity(identity);\n      const credentialsKey = this.getStorageKeyByCAIdentity(caIdentity);\n\n      if (credentialsKey instanceof Error) {\n        console.error(credentialsKey);\n        return new Error('The identity has a wrong format');\n      }\n\n      const caCryptoCredentials = await this.getCredentialsRaw(credentialsKey);\n\n      if (caCryptoCredentials instanceof Error) {\n        console.error(caCryptoCredentials);\n        return new Error('Failed to read credentials from the storage');\n      }\n      if (!caCryptoCredentials) {\n        return null;\n      }\n\n      const importedCryptoCredentials = await importCryptoCredentialsFromAString(caCryptoCredentials);\n\n      if (importedCryptoCredentials instanceof Error) {\n        console.error(importedCryptoCredentials);\n        return new Error('Failed to import the value read');\n      }\n\n      // replace the existing value\n      // of the user identity\n      // by a requested value.\n      // Because the stored identity\n      // version may be different\n      // from the requested. It may\n      // cause an unexpected issues\n      const resultedValue = replaceCryptoCredentialsIdentity(importedCryptoCredentials, String(caIdentity), false);\n\n      if (resultedValue instanceof Error) {\n        console.error(resultedValue);\n        return new Error('Failed to replace the identity in the credentials read from the storage');\n      }\n      return resultedValue;\n    } catch (err) {\n      console.error(err);\n      return new Error('Failed to read a credentials for identity from the storage');\n    }\n  }\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-storage-local/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-swarm-credentials-provider/central-authority-swarm-credentials-provider.ts",["2746","2747","2748","2749","2750"],"import { CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport { CentralAuthorityIdentity } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport { TCentralAuthorityUserCryptoCredentials } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport {\n  TCAuthProviderIdentifier,\n  TCAUserIdentityRawTypes,\n} from './../central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { CentralAuthorityIdentityCredentialsStorage } from 'classes/central-authority-class/central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials';\nimport {\n  ICAIdentityCredentialsStorage,\n  ICAIdentityCredentialsStorageConntionOptions,\n} from './../central-authority-storage-local/central-authority-storage-swarm-users-auth/central-authority-storage-swarm-users-identity-credentials/central-authority-storage-swarm-users-identity-credentials.types';\nimport { ICAConnectionPool } from './../central-authority-connections/central-authority-connections-pool/central-authority-connections-pool.types';\nimport {\n  ICASwarmCredentialsProvider,\n  ICASwarmCredentialsProviderOptions,\n  ICASwarmCredentialsProviderOptionsConnections,\n} from './central-authority-swarm-credentials-provider.types';\n\n/**\n * This class is necessary to resolve crypto credentials\n * of another users by user identity values of them.\n * This class used to get credentials of the users by\n * connection to the swarm, and store it in the local\n * cache or from the local cache.\n */\nexport class CASwarmCredentialsProvider implements ICASwarmCredentialsProvider {\n  protected isRunning: boolean = false;\n\n  protected options?: ICASwarmCredentialsProviderOptions;\n\n  protected connectionSwarmConnectionPool?: ICAConnectionPool;\n\n  protected connectionLocalCredentialsStorage?: ICAIdentityCredentialsStorage;\n\n  /**\n   * connect with a storages and a swarm\n   *\n   * @param {ICASwarmCredentialsProviderOptions} options\n   * @returns {(Promise<void | Error>)}\n   * @memberof CASwarmCredentialsProvider\n   */\n  public connect = async (options: ICASwarmCredentialsProviderOptions): Promise<void | Error> => {\n    if (this.isRunning) {\n      console.warn('The instance is already running');\n      return;\n    }\n\n    const setOptionsResult = this.setOptions(options);\n\n    if (setOptionsResult instanceof Error) {\n      return setOptionsResult;\n    }\n\n    const { connections } = options;\n\n    await this.runConnections(connections);\n    this.setRunningFlag();\n    this.options = options;\n  };\n\n  /**\n   * close connection with the local credentials\n   * storage and unset the current connection\n   * with the swarm\n   *\n   * @returns {(Promise<Error | void>)}\n   * @memberof CASwarmCredentialsProvider\n   */\n  public disconnect = async (): Promise<Error | void> => {\n    if (!this.isRunning) {\n      return;\n    }\n\n    const [resDisconnectFromCredentialsStorage, resultDisconnectFromSwarmConnectionsPool] = await Promise.all([\n      this.disconnectFromCredentialsStorage(),\n      this.disconnectFromSwarmConnectionsPool(),\n    ]);\n    let error: string = '';\n\n    if (resDisconnectFromCredentialsStorage instanceof Error) {\n      console.error(resDisconnectFromCredentialsStorage);\n      error = 'Failed to disconnect from the credentials storage';\n    }\n    if (resultDisconnectFromSwarmConnectionsPool instanceof Error) {\n      console.error(resultDisconnectFromSwarmConnectionsPool);\n      error = `${error}/nFailed to disconnect from the swarm connections pool`;\n    }\n    this.unsetConnectionsUsed();\n    this.unsetRunningFlag();\n    if (error) {\n      return new Error(error);\n    }\n  };\n\n  /**\n   * read the user's credentials from the local credentials storage\n   * if there is no one, then read credentials from the swarm.\n   * If credentials were read from the swarm it will set it\n   * in the local credentials storage to cahe the value locally.\n   *\n   * @param {TCAUserIdentityRawTypes} identity - identity of the user of which is necessary to get credentials of\n   * @returns {(Promise<TCentralAuthorityUserCryptoCredentials | Error | null>)}\n   * @memberof CASwarmCredentialsProvider\n   */\n  public async get(identity: TCAUserIdentityRawTypes): Promise<TCentralAuthorityUserCryptoCredentials | Error | null> {\n    if (!this.isRunning) {\n      return new Error('The instance is not running');\n    }\n\n    const identityInstance = this.getUserIdentityInstance(identity);\n\n    if (identityInstance instanceof Error) {\n      return identityInstance;\n    }\n\n    const credentialsFromLocalCredentialsStorage = await this.readCredentialsFromLocalCredentialsStorage(identityInstance);\n\n    if (credentialsFromLocalCredentialsStorage instanceof Error) {\n      console.error(credentialsFromLocalCredentialsStorage);\n      console.error(new Error('Failed to read credentials from the local credentials storage'));\n    }\n    if (credentialsFromLocalCredentialsStorage) {\n      return credentialsFromLocalCredentialsStorage;\n    }\n\n    const crdentialsFromSwarm = await this.readCredentialsFromTheSwarm(identityInstance);\n\n    if (crdentialsFromSwarm instanceof Error) {\n      console.error(crdentialsFromSwarm);\n      return new Error('Failed to get credentials from the credentials provider');\n    }\n    // set the crdentials read from the swarm in the local credentials storage\n    if (crdentialsFromSwarm) {\n      const result = await this.setCredentialsInCredentialsStorageNoCheckPrivateKey(crdentialsFromSwarm);\n\n      if (result instanceof Error) {\n        console.error(result);\n      }\n    }\n    return crdentialsFromSwarm;\n  }\n\n  protected validateOptions(options: ICASwarmCredentialsProviderOptions): Error | void {\n    if (!options) {\n      return new Error('An options must be provided');\n    }\n    if (typeof options !== 'object') {\n      return new Error('The options provided must be an object');\n    }\n\n    const { connections, storageDb } = options;\n\n    if (!connections) {\n      return new Error('The connections parameter is absent in the options object');\n    }\n    if (!connections.swarmConnectionPool) {\n      return new Error('Connection to the swarm connections pool is not provided in the options');\n    }\n    if (storageDb && typeof storageDb !== 'string') {\n      return new Error('The storage db name must be a string');\n    }\n  }\n\n  protected setOptions(options: ICASwarmCredentialsProviderOptions): Error | void {\n    const validationResult = this.validateOptions(options);\n\n    if (validationResult instanceof Error) {\n      return validationResult;\n    }\n    this.options = options;\n  }\n\n  /**\n   * set the flag that the instance is running\n   *\n   * @protected\n   * @memberof CASwarmCredentialsProvider\n   */\n  protected setRunningFlag() {\n    this.isRunning = true;\n  }\n\n  /**\n   * unset the flag that the instance is running\n   *\n   * @protected\n   * @memberof CASwarmCredentialsProvider\n   */\n  protected unsetRunningFlag() {\n    this.isRunning = false;\n  }\n\n  /**\n   * Gets auth provider url by user identity\n   * @param userIdentity\n   * @returns auth provider id by user identity\n   */\n  protected getAuthProviderIdByUserIdentity(userIdentity: CentralAuthorityIdentity): TCAuthProviderIdentifier | Error {\n    const { identityDescription } = userIdentity;\n\n    if (identityDescription instanceof Error) {\n      return new Error('The identity is not valid');\n    }\n    return identityDescription[CA_USER_IDENTITY_AUTH_PROVIDER_IDENTIFIER_PROP_NAME];\n  }\n\n  /**\n   * unset connections to the local credentials\n   * storage and the swarm\n   *\n   * @protected\n   * @memberof CASwarmCredentialsProvider\n   */\n  protected unsetConnectionsUsed() {\n    this.connectionSwarmConnectionPool = undefined;\n    this.connectionLocalCredentialsStorage = undefined;\n  }\n\n  protected async connectToTheLocalCredentialsStorage(): Promise<Error | void> {\n    const localCredentialsStorageInstance = await this.startConnectionLocalCredentialsStorage();\n\n    if (localCredentialsStorageInstance instanceof Error) {\n      console.error(localCredentialsStorageInstance);\n      return new Error('Failed to start an instance of the Local credentials storage');\n    }\n    this.connectionLocalCredentialsStorage = localCredentialsStorageInstance;\n  }\n\n  /**\n   * start or use connections to the swarm and\n   * the local credentials storage(used for caching)\n   *\n   * @protected\n   * @param {ICASwarmCredentialsProviderOptionsConnections} connections\n   * @returns {(Promise<Error | void>)}\n   * @memberof CASwarmCredentialsProvider\n   */\n  protected async runConnections(connections: ICASwarmCredentialsProviderOptionsConnections): Promise<Error | void> {\n    const { swarmConnectionPool, localCredentialsStorage } = connections;\n\n    if (!swarmConnectionPool) {\n      return new Error('A connection to the Swarm connections pool must be provided in the options');\n    }\n    this.connectionSwarmConnectionPool = swarmConnectionPool;\n    if (!localCredentialsStorage) {\n      return this.connectToTheLocalCredentialsStorage();\n    }\n  }\n\n  protected getOptionsForLocalCredentialsStorage(): ICAIdentityCredentialsStorageConntionOptions | undefined {\n    if (this.options && this.options.storageDb) {\n      return {\n        storageName: this.options.storageDb || '',\n      };\n    }\n  }\n\n  protected async startConnectionLocalCredentialsStorage(): Promise<Error | ICAIdentityCredentialsStorage> {\n    try {\n      const connectionLocalCredentialsStorage = new CentralAuthorityIdentityCredentialsStorage();\n      const connectToCredentialsStorageResult = await connectionLocalCredentialsStorage.connect(\n        this.getOptionsForLocalCredentialsStorage()\n      );\n\n      if (connectToCredentialsStorageResult instanceof Error) {\n        console.error(connectToCredentialsStorageResult);\n        return new Error('Failed to connect with the local credentials storage');\n      }\n      return connectionLocalCredentialsStorage;\n    } catch (err) {\n      console.error(err);\n      return new Error('An unknown error has thrown on starting a new connection to the local credentials storage');\n    }\n  }\n\n  /**\n   * disconnect from the credentials storage\n   *\n   * @protected\n   * @returns {(Promise<Error | void>)}\n   * @memberof CASwarmCredentialsProvider\n   */\n  protected async disconnectFromCredentialsStorage(): Promise<Error | void> {\n    const connection = this.connectionLocalCredentialsStorage;\n\n    if (!connection) {\n      console.warn('There is no active connection to the credentials storage');\n      return;\n    }\n\n    const disconnectResult = await connection.disconnect();\n\n    if (disconnectResult instanceof Error) {\n      return disconnectResult;\n    }\n  }\n\n  /**\n   * at now this method do nothing cause the connetion\n   * to the swarm may be used in another places\n   *\n   * @protected\n   * @returns {(Promise<Error | void>)}\n   * @memberof CASwarmCredentialsProvider\n   */\n  protected async disconnectFromSwarmConnectionsPool(): Promise<Error | void> {\n    const connection = this.connectionSwarmConnectionPool;\n\n    if (!connection) {\n      console.warn('There is no active connection to the swarm connections pool');\n      return;\n    }\n    // do not disconnect from the connections swarm connection pool cause\n    // it may be used outside of the class\n  }\n\n  /**\n   * validate and return the user identity to use it\n   * to read the user credentials from the local\n   * storage or from the swarm\n   *\n   * @protected\n   * @param {TCAUserIdentityRawTypes} userIdentity\n   * @returns {(Error | CentralAuthorityIdentity)}\n   * @memberof CASwarmCredentialsProvider\n   */\n  protected getUserIdentityInstance(userIdentity: TCAUserIdentityRawTypes): Error | CentralAuthorityIdentity {\n    const identityInstance = new CentralAuthorityIdentity(userIdentity);\n\n    if (!identityInstance.isValid) {\n      return new Error('The identity provided is not valid');\n    }\n    return identityInstance;\n  }\n\n  /**\n   * read user credentials form the local credentials storage\n   *\n   * @protected\n   * @param {CentralAuthorityIdentity} userIdentity\n   * @returns {(Promise<Error | undefined | TCentralAuthorityUserCryptoCredentials>)}\n   * @memberof CASwarmCredentialsProvider\n   */\n  protected async readCredentialsFromLocalCredentialsStorage(\n    userIdentity: CentralAuthorityIdentity\n  ): Promise<Error | null | TCentralAuthorityUserCryptoCredentials> {\n    if (!this.connectionLocalCredentialsStorage) {\n      console.warn('There is no connection to the local credentials storage - start a new one');\n      const connectionResult = await this.connectToTheLocalCredentialsStorage();\n\n      if (connectionResult instanceof Error || !this.connectionLocalCredentialsStorage) {\n        console.error(connectionResult);\n        return new Error('Failed to start a new connection to the local credentials storage');\n      }\n    }\n    return this.connectionLocalCredentialsStorage.getCredentials(userIdentity);\n  }\n\n  /**\n   * get auth provider identity by the user identity\n   * connect to it and request the credentials\n   * for the identity\n   *\n   * @protected\n   * @param {CentralAuthorityIdentity} userIdentity\n   * @returns {(Promise<Error | null | TCentralAuthorityUserCryptoCredentials>)}\n   * @memberof CASwarmCredentialsProvider\n   */\n  protected async readCredentialsFromTheSwarm(\n    userIdentity: CentralAuthorityIdentity\n  ): Promise<Error | null | TCentralAuthorityUserCryptoCredentials> {\n    const connectionSwarm = this.connectionSwarmConnectionPool;\n\n    if (!connectionSwarm) {\n      return new Error('There is no connection to the swarm');\n    }\n\n    const authProviderId = this.getAuthProviderIdByUserIdentity(userIdentity);\n\n    if (authProviderId instanceof Error) {\n      return authProviderId;\n    }\n\n    const connection = await connectionSwarm.connect(authProviderId);\n\n    if (connection instanceof Error) {\n      console.error(connection);\n      return new Error(`Failed to connect to the auth provider ${authProviderId}`);\n    }\n    return connection.getUserCredentials(String(userIdentity));\n  }\n\n  /**\n   * set the credentials in the local credentials\n   * storage\n   *\n   * @protected\n   * @param {CentralAuthorityIdentity} userIdentity\n   * @param {TCentralAuthorityUserCryptoCredentials} credentials\n   * @returns {(Promsie<void | Error>)}\n   * @memberof CASwarmCredentialsProvider\n   */\n  protected async setCredentialsInCredentialsStorage(\n    credentials: TCentralAuthorityUserCryptoCredentials,\n    isCheckPrivateKey: boolean = true\n  ): Promise<void | Error> {\n    if (!this.connectionLocalCredentialsStorage) {\n      console.warn('There is no connection to the local credentials storage - start a new one');\n      const connectionResult = await this.connectToTheLocalCredentialsStorage();\n\n      if (connectionResult instanceof Error || !this.connectionLocalCredentialsStorage) {\n        console.error(connectionResult);\n        return new Error('Failed to start a new connection to the local credentials storage');\n      }\n    }\n\n    const setCredntialsResult = await this.connectionLocalCredentialsStorage.setCredentialsNoCheckPrivateKey(credentials);\n\n    if (setCredntialsResult instanceof Error) {\n      console.error(setCredntialsResult);\n      return new Error('Failed to store crdentials got from the swarm');\n    }\n  }\n\n  protected setCredentialsInCredentialsStorageNoCheckPrivateKey(credentials: TCentralAuthorityUserCryptoCredentials) {\n    return this.setCredentialsInCredentialsStorage(credentials, false);\n  }\n}\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-swarm-credentials-provider/central-authority-swarm-credentials-provider.types.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-swarm-credentials-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-common.ts",["2751","2752","2753","2754","2755","2756","2757","2758","2759","2760","2761","2762"],"import { isCryptoKeyPair, isCryptoKey, isCryptoKeyPairExportedAsString } from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport {\n  TCACryptoKeyPairs,\n  TCACryptoPubilicKeys,\n  TCACryptoKeyPairsExported,\n} from '../../central-authority-class-types/central-authority-class-types';\nimport {\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_STRINGIFIED_MIN_LENGTH,\n} from './central-authority-util-crypto-keys.const';\n\nexport const checkIsCryptoKeyPairsExportedAsString = (v: any): boolean => {\n  return typeof v === 'string' && v.length >= CA_CRYPTO_KEY_PAIRS_STRINGIFIED_MIN_LENGTH;\n};\n\n/**\n * check is a given value\n * have a key pairs in a\n * raw format\n * @param keyPairs\n * @returns {boolean}\n */\nexport const checkIsCryptoKeyPairs = (keyPairs: any, checkPrivateKeys: boolean = true): keyPairs is TCACryptoKeyPairs => {\n  if (keyPairs && typeof keyPairs === 'object') {\n    const {\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signKeyPair,\n    } = keyPairs;\n\n    if (!isCryptoKeyPair(encryptionKeyPair, checkPrivateKeys)) {\n      console.error('Encryption key pair is not valid');\n      return false;\n    }\n    if (!isCryptoKeyPair(signKeyPair, checkPrivateKeys)) {\n      console.error('Data sign key pair is not valid');\n      return false;\n    }\n    return true;\n  }\n  console.error('A wrong format of the keyPairs');\n  return false;\n};\n\n/**\n * check is a given value\n * have a key pairs in an\n * exported format\n * @param keyPairs\n * @returns {boolean}\n */\nexport const checkIsCryptoKeyPairsExported = (keyPairs: any): keyPairs is TCACryptoKeyPairsExported => {\n  if (keyPairs && typeof keyPairs === 'object') {\n    const {\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPairExported,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signKeyPairExported,\n    } = keyPairs;\n\n    if (!isCryptoKeyPairExportedAsString(encryptionKeyPairExported)) {\n      console.error('Encryption key pair exported is not valid');\n      return false;\n    }\n    if (!isCryptoKeyPairExportedAsString(signKeyPairExported)) {\n      console.error('Data sign key pair exported is not valid');\n      return false;\n    }\n    return true;\n  }\n  console.error('A wrong format of the keyPairs exported');\n  return false;\n};\n\nexport const checkIsPublicKeys = (keysPublic: any): keysPublic is TCACryptoPubilicKeys => {\n  if (keysPublic && typeof keysPublic === 'object') {\n    if (!isCryptoKey(keysPublic[CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME])) {\n      console.error('Encryption public key is not valid');\n      return false;\n    }\n    if (!isCryptoKey(keysPublic[CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME])) {\n      console.error('Sign data public key is not valid');\n      return false;\n    }\n    return true;\n  }\n  console.error('A wrong format for the keysPublic');\n  return false;\n};\n\n/**\n * returns only a public keys\n * from a key pairs object\n * @param keyPairs\n * @returns {Error | object}\n */\nexport const getPublicKeysFromCryptoKeyPairs = (keyPairs: TCACryptoKeyPairs): TCACryptoPubilicKeys | Error => {\n  if (!checkIsCryptoKeyPairs(keyPairs)) {\n    return new Error('There is a wrong format of the key pairs');\n  }\n\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: dataSignKeyPair,\n  }: TCACryptoKeyPairs = keyPairs;\n  const publicKeys = {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]: encryptionKeyPair.publicKey,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: dataSignKeyPair.publicKey,\n  };\n\n  if (checkIsPublicKeys(publicKeys)) {\n    return publicKeys;\n  }\n  return new Error('Failed to receive a valid public keys from the encryption key pairs');\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-export.ts",["2763","2764","2765"],"import {\n  exportKeyPairAsString as exportKeyPairDataEncryptAsString,\n  exportKeyAsString as exportPublicKeyDataEncryptAsString,\n} from 'utils/encryption-utils';\nimport {\n  dataSignExportKeyPairAsString as exportKeyPairDataSignAsString,\n  dataSignExportKeyAsString as exportPublicKeyDataSignAsString,\n} from 'utils/data-sign-utils';\nimport { TCACryptoKeyPairs, TCACryptoPubilicKeys } from '../../central-authority-class-types/central-authority-class-types';\nimport {\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME,\n} from './central-authority-util-crypto-keys.const';\nimport { checkIsCryptoKeyPairs, getPublicKeysFromCryptoKeyPairs } from './central-authority-util-crypto-keys-common';\nimport { compressString } from 'utils/data-compression-utils/data-compression-utils-strings';\nimport { stringify } from 'utils/main-utils';\n\n/**\n * export two key pairs\n * (data sign and data encryption)\n * as a one string\n * @param {object} cryptoKeyPairs\n * @returns {Promise<string | Error>}\n */\nexport const exportKeyPairsAsString = async (cryptoKeyPairs: TCACryptoKeyPairs, password?: string): Promise<string | Error> => {\n  if (!checkIsCryptoKeyPairs(cryptoKeyPairs, !!password)) {\n    return new Error('The keypair is not valid');\n  }\n\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signDataKeyPair,\n  } = cryptoKeyPairs;\n  const [encryptionKeyPairString, signDataKeyPairString] = await Promise.all([\n    exportKeyPairDataEncryptAsString(encryptionKeyPair, password),\n    exportKeyPairDataSignAsString(signDataKeyPair, password),\n  ]);\n\n  if (encryptionKeyPairString instanceof Error) {\n    return encryptionKeyPairString;\n  }\n  if (signDataKeyPairString instanceof Error) {\n    return signDataKeyPairString;\n  }\n  try {\n    const stringifyResult = stringify({\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPairString,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signDataKeyPairString,\n    });\n\n    if (stringifyResult instanceof Error) {\n      return stringifyResult;\n    }\n    return compressString(stringifyResult);\n  } catch (err) {\n    return err;\n  }\n};\n\n/**\n * export a public keys only\n * from a keyPairs as a string\n * @param {object} keyPairs\n * @returns {string | Error}\n */\nexport const exportPublicKeysAsString = async (keyPairs: TCACryptoKeyPairs): Promise<string | Error> => {\n  const publicKeys = getPublicKeysFromCryptoKeyPairs(keyPairs);\n\n  if (publicKeys instanceof Error) {\n    return publicKeys;\n  }\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]: encryptionPublicKey,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: signPublicKey,\n  } = publicKeys;\n\n  const [encryptionPublicKeyExported, signPublicKeyExported] = await Promise.all([\n    exportPublicKeyDataEncryptAsString(encryptionPublicKey),\n    exportPublicKeyDataSignAsString(signPublicKey),\n  ]);\n\n  if (encryptionPublicKeyExported instanceof Error) {\n    console.error('export of the encryptionPublicKey was failed');\n    return encryptionPublicKeyExported;\n  }\n  if (signPublicKeyExported instanceof Error) {\n    console.error('export of the signPublicKeyExported was failed');\n    return signPublicKeyExported;\n  }\n  try {\n    return stringify({\n      [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]: encryptionPublicKeyExported,\n      [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: signPublicKeyExported,\n    });\n  } catch (err) {\n    return err;\n  }\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-generate.ts",["2766","2767"],"import { CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME } from './../../central-authority-class-const/central-authority-class-const-auth-credentials';\nimport { CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME } from 'classes/central-authority-class/central-authority-class-const/central-authority-class-const';\nimport { generateKeyPair as generateKeyPairDataEncryption } from 'utils/encryption-utils';\nimport { dataSignGenerateKeyPair as generateKeyPairSignData } from 'utils/data-sign-utils';\nimport { isCryptoKeyPair } from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport {\n  TCACryptoKeyPairs,\n  TCentralAuthorityUserCryptoCredentials,\n} from '../../central-authority-class-types/central-authority-class-types';\nimport {\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME,\n} from './central-authority-util-crypto-keys.const';\nimport { checkIsCryptoKeyPairs } from './central-authority-util-crypto-keys-common';\nimport { generateUUID } from 'utils/identity-utils/identity-utils';\nimport {\n  ICAUserUniqueIdentifierMetadata,\n  ICAUserUniqueIdentifierDescriptionWithOptionalVersion,\n} from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { checkIsValidUserIdentityMetadata } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity-validators/central-authority-class-user-identity-validators';\nimport {\n  CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME,\n  CA_USER_IDENTITY_VERSION_PROP_NAME,\n  CA_USER_IDENTITY_VERSIONS,\n} from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport CentralAuthorityIdentity from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport validator from 'validator';\nimport { dataValidatorUtilSafeLogin } from 'utils/data-validators-utils/data-validators-utils';\n\n/**\n * generate a key pair, used for data encryption\n */\nexport const generateEncryptKeyPair = async (): Promise<CryptoKeyPair | Error> => {\n  const keyPair = await generateKeyPairDataEncryption();\n  const isKeyPair = isCryptoKeyPair(keyPair);\n\n  if (!isKeyPair) {\n    return new Error('Failed to generate a key pair');\n  }\n  return keyPair;\n};\n\n/**\n * generate a key pair, used for data signing\n */\nexport const generateSignKeyPair = async (): Promise<CryptoKeyPair | Error> => {\n  const keyPair = await generateKeyPairSignData();\n  const isKeyPair = isCryptoKeyPair(keyPair);\n\n  if (!isKeyPair) {\n    return new Error('Failed to generate a key pair');\n  }\n  return keyPair;\n};\n\n/**\n * generate a two key pairs\n * one is used to sign a data\n * second is used to encrypt a data\n */\nexport const generateKeyPairs = async (): Promise<TCACryptoKeyPairs | Error> => {\n  const [encryptionKeyPair, signDataKeyPair] = await Promise.all([generateEncryptKeyPair(), generateSignKeyPair()]);\n\n  if (encryptionKeyPair instanceof Error) {\n    return encryptionKeyPair;\n  }\n  if (signDataKeyPair instanceof Error) {\n    return signDataKeyPair;\n  }\n\n  const keyPairs = {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signDataKeyPair,\n  };\n\n  if (checkIsCryptoKeyPairs(keyPairs)) {\n    return keyPairs;\n  }\n  return new Error('Failed to generate a valid key pairs');\n};\n\n/**\n * generates a random crypto credentials\n * or return an Error if failed\n */\nexport const generateCryptoCredentialsV1 = async (): Promise<TCentralAuthorityUserCryptoCredentials | Error> => {\n  const cryptoKeyPair = await generateKeyPairs();\n\n  if (cryptoKeyPair instanceof Error) {\n    console.error(cryptoKeyPair);\n    return new Error('Failed to generate a valid crypto credentials');\n  }\n  return {\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: generateUUID(),\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPair,\n  };\n};\n\n/**\n * generates a random crypto credentials\n * or return an Error if failed\n */\nexport const generateCryptoCredentialsWithUserIdentityV1 = async (\n  identityMetadata: ICAUserUniqueIdentifierMetadata\n): Promise<TCentralAuthorityUserCryptoCredentials | Error> => {\n  const validationIdentityMetadataResult = checkIsValidUserIdentityMetadata(identityMetadata);\n\n  if (validationIdentityMetadataResult instanceof Error) {\n    console.error(validationIdentityMetadataResult);\n    return new Error('The identity metadata is not valid');\n  }\n\n  const uuidProvided = identityMetadata[CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME];\n  const userUUID = typeof uuidProvided === 'string' && validator.isUUID(uuidProvided) ? uuidProvided : generateUUID();\n  const userUniqueIdentityDescription: ICAUserUniqueIdentifierDescriptionWithOptionalVersion = {\n    ...identityMetadata,\n    [CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME]: userUUID,\n    [CA_USER_IDENTITY_VERSION_PROP_NAME]: CA_USER_IDENTITY_VERSIONS['01'],\n  };\n  const userUniqueIdentityInstance = new CentralAuthorityIdentity(userUniqueIdentityDescription);\n\n  if (!userUniqueIdentityInstance.isValid) {\n    return new Error('Failed to generate a valid user unique identity');\n  }\n\n  const userUniqueId = userUniqueIdentityInstance.toString();\n\n  if (!userUniqueId) {\n    return new Error('Failed to get stringified version of the user unique identity generated');\n  }\n\n  const cryptoKeyPair = await generateKeyPairs();\n\n  if (cryptoKeyPair instanceof Error) {\n    console.error(cryptoKeyPair);\n    return new Error('Failed to generate a valid crypto credentials');\n  }\n  return {\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userUniqueId,\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPair,\n  };\n};\n\n/**\n * generates a random crypto credentials\n * or return an Error if failed\n */\nexport const generateCryptoCredentialsWithUserIdentityV2 = async (\n  identityMetadata: ICAUserUniqueIdentifierMetadata\n): Promise<TCentralAuthorityUserCryptoCredentials | Error> => {\n  const validationIdentityMetadataResult = checkIsValidUserIdentityMetadata(identityMetadata);\n\n  if (validationIdentityMetadataResult instanceof Error) {\n    console.error(validationIdentityMetadataResult);\n    return new Error('The identity metadata is not valid');\n  }\n\n  const userIdentifier = identityMetadata[CA_USER_IDENTITY_USER_UNIQUE_IDENTFIER_PROP_NAME];\n\n  if (!userIdentifier) {\n    return new Error('A user identifier must be specified');\n  }\n  if (!dataValidatorUtilSafeLogin(userIdentifier)) {\n    return new Error('The user identifier provided is not valid');\n  }\n\n  const userUniqueIdentityDescription = {\n    ...identityMetadata,\n    [CA_USER_IDENTITY_VERSION_PROP_NAME]: CA_USER_IDENTITY_VERSIONS['02'],\n  } as ICAUserUniqueIdentifierDescriptionWithOptionalVersion;\n  const userUniqueIdentityInstance = new CentralAuthorityIdentity(userUniqueIdentityDescription);\n\n  if (!userUniqueIdentityInstance.isValid) {\n    return new Error('Failed to generate a valid user unique identity');\n  }\n\n  const userUniqueId = userUniqueIdentityInstance.toString();\n\n  if (!userUniqueId) {\n    return new Error('Failed to get stringified version of the user unique identity generated');\n  }\n\n  const cryptoKeyPair = await generateKeyPairs();\n\n  if (cryptoKeyPair instanceof Error) {\n    console.error(cryptoKeyPair);\n    return new Error('Failed to generate a valid crypto credentials');\n  }\n\n  return {\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userUniqueId,\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPair,\n  };\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys-import.ts",["2768","2769","2770","2771","2772","2773"],"import {\n  importKeyPairFromString as importKeyPairDataEncryptionFromString,\n  importKeyFromString as importKeyEncryptionFromString,\n} from 'utils/encryption-utils';\nimport {\n  dataSignImportKeyPairFromString as importKeyPairDataSignFromString,\n  dataSignImportKeyFromString as importKeySignFromString,\n} from 'utils/data-sign-utils';\nimport { TCACryptoKeyPairs, TCACryptoPubilicKeys } from '../../central-authority-class-types/central-authority-class-types';\nimport {\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME,\n  CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME,\n  CA_CRYPTO_KEY_PAIRS_PUBLIC_KEYS_STRINGIFIED_MIN_LENGTH,\n} from './central-authority-util-crypto-keys.const';\nimport { caValidateCryptoKeyPairExportedObject } from '../../central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport {\n  checkIsPublicKeys,\n  checkIsCryptoKeyPairs,\n  checkIsCryptoKeyPairsExportedAsString,\n} from './central-authority-util-crypto-keys-common';\nimport { decompressString } from 'utils/data-compression-utils/data-compression-utils-strings';\n\n/**\n * import an exported key pair\n * and returs it a crypto key pair\n * @param {string} keyPairsString\n * @returns {Promise<Error | object>}\n */\nexport const importKeyPairsFromString = async (keyPairsString: string, password?: string): Promise<TCACryptoKeyPairs | Error> => {\n  if (!checkIsCryptoKeyPairsExportedAsString(keyPairsString)) {\n    return new Error('This is a wrong type of exported crypto keys');\n  }\n\n  let parsedKeyPairsObject;\n\n  const decompressedValue = decompressString(keyPairsString);\n\n  if (decompressedValue instanceof Error) {\n    console.error(decompressedValue);\n    return new Error('Failed to decompress key pairs');\n  }\n\n  try {\n    parsedKeyPairsObject = JSON.parse(decompressedValue);\n  } catch (err) {\n    return err;\n  }\n  if (!caValidateCryptoKeyPairExportedObject(parsedKeyPairsObject)) {\n    return new Error('There is a wrong format of a key pairs exported');\n  }\n\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPairString,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: signDataKeyPairString,\n  } = parsedKeyPairsObject;\n  const [encryptionKeyPair, dataSignKeyPair] = await Promise.all([\n    importKeyPairDataEncryptionFromString(encryptionKeyPairString, password),\n    importKeyPairDataSignFromString(signDataKeyPairString, password),\n  ]);\n\n  if (encryptionKeyPair instanceof Error) {\n    return encryptionKeyPair;\n  }\n  if (dataSignKeyPair instanceof Error) {\n    return dataSignKeyPair;\n  }\n\n  const encryptionKeyPairs = {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_KEY_PAIR_NAME]: encryptionKeyPair,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_KEY_PAIR_NAME]: dataSignKeyPair,\n  };\n\n  if (checkIsCryptoKeyPairs(encryptionKeyPairs, !!password)) {\n    return encryptionKeyPairs;\n  }\n  return new Error('Failed to import key pairs');\n};\n\nexport const importPublicKeyPairsFromString = async (publicKeyPairsString: string): Promise<Error | TCACryptoPubilicKeys> => {\n  let publicKeyPairsImport;\n  try {\n    publicKeyPairsImport = JSON.parse(publicKeyPairsString);\n  } catch (err) {\n    return err;\n  }\n\n  const {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]: importedStringEncryptionPublicKey,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: importedStringSignPublicKey,\n  } = publicKeyPairsImport;\n\n  if (\n    typeof importedStringEncryptionPublicKey !== 'string' ||\n    importedStringEncryptionPublicKey.length < CA_CRYPTO_KEY_PAIRS_PUBLIC_KEYS_STRINGIFIED_MIN_LENGTH\n  ) {\n    const err = new Error('Encryption public key import as a string was failed');\n\n    console.error(err);\n    return err;\n  }\n  if (\n    typeof importedStringSignPublicKey !== 'string' ||\n    importedStringSignPublicKey.length < CA_CRYPTO_KEY_PAIRS_PUBLIC_KEYS_STRINGIFIED_MIN_LENGTH\n  ) {\n    const err = new Error('Sign public key import as a string was failed');\n\n    console.error(err);\n    return err;\n  }\n\n  const [importedEncryptionPublicKey, importedSignPublicKey] = await Promise.all([\n    importKeyEncryptionFromString(importedStringEncryptionPublicKey),\n    importKeySignFromString(importedStringSignPublicKey),\n  ]);\n\n  if (importedEncryptionPublicKey instanceof Error) {\n    console.error('Failed to import encryption public key from the string');\n    return importedEncryptionPublicKey;\n  }\n  if (importedSignPublicKey instanceof Error) {\n    console.error('Failed to import sign public key from the string');\n    return importedSignPublicKey;\n  }\n\n  const publicKeys = {\n    [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME]: importedEncryptionPublicKey,\n    [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME]: importedSignPublicKey,\n  };\n\n  if (checkIsPublicKeys(publicKeys)) {\n    return publicKeys;\n  }\n  return new Error('Failed to import a public keys');\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials-crypto-keys.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials.const.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/central-authority-utils-crypto-credentials.ts",["2774","2775","2776","2777","2778"],"import { TCentralAuthorityUserCryptoCredentials } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types-crypto-credentials';\nimport {\n  checkIsCryptoKeyPairs,\n  exportKeyPairsAsString,\n  importKeyPairsFromString,\n} from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport { validateUserIdentity } from 'classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport {\n  CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME,\n  CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME,\n} from 'classes/central-authority-class/central-authority-class-const/central-authority-class-const';\nimport {\n  TCentralAuthorityUserIdentity,\n  TCACryptoKeyPairs,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { CentralAuthorityIdentity } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport {\n  checkIsValidCryptoCredentials,\n  checkIsValidCryptoCredentialsExportedFormat,\n  checkIsValidExportedCryptoCredentialsToString,\n} from 'classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys';\nimport { stringify } from 'utils/main-utils';\nimport { TUserIdentityVersion } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { calcCryptoKeyPairHash } from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport { TCAAuthProviderIdentity } from '../../central-authority-connections/central-authority-connections.types';\nimport { normalizeUrl } from '../../../../utils/common-utils/common-utils-url';\nimport { CA_UTILS_CRYPTO_CREDENTIALS_NORMALIZE_URL_OPTIONS } from './central-authority-utils-crypto-credentials.const';\n\nexport const exportCryptoCredentialsToString = async (\n  userCryptoCredentials: TCentralAuthorityUserCryptoCredentials,\n  withoutIdentityVersion: boolean = false,\n  password?: string\n): Promise<Error | string> => {\n  if (!checkIsValidCryptoCredentials(userCryptoCredentials, !!password)) {\n    return new Error('The given value is not a valid crypto credentials');\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeys,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  } = userCryptoCredentials;\n  const exportedCryptoKeys = await exportKeyPairsAsString(cryptoKeys, password);\n\n  if (exportedCryptoKeys instanceof Error) {\n    return exportedCryptoKeys;\n  }\n\n  const cryptoCredentialsExported = {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: exportedCryptoKeys,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  };\n  if (withoutIdentityVersion) {\n    const userCAIdentity = new CentralAuthorityIdentity(userIdentity);\n    const { id } = userCAIdentity;\n\n    if (id instanceof Error) {\n      return new Error('The identity is not valid');\n    }\n    cryptoCredentialsExported[CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME] = id;\n  }\n\n  if (!checkIsValidCryptoCredentialsExportedFormat(cryptoCredentialsExported)) {\n    return new Error('Failed to create a crypto credentials in the exported format');\n  }\n  try {\n    const exportedCryptoCredentialsAsString = stringify(cryptoCredentialsExported);\n\n    if (!checkIsValidExportedCryptoCredentialsToString(exportedCryptoCredentialsAsString)) {\n      return new Error('Failed cause the crypto credentials exported as a sting have a wrong format');\n    }\n    return exportedCryptoCredentialsAsString;\n  } catch (err) {\n    console.error(err);\n    return new Error('Failed to stringify the crypto credentials');\n  }\n};\n\n// allow to absent for a private keys in a pairs\nexport const exportCryptoCredentialsToStringWithoutTheCAIdentityVersion = (\n  userCryptoCredentials: TCentralAuthorityUserCryptoCredentials\n): Promise<Error | string> => exportCryptoCredentialsToString(userCryptoCredentials, true);\n\nexport const compareAuthProvidersIdentities = (...authProvidersIds: TCAAuthProviderIdentity[]): boolean => {\n  const { length: len } = authProvidersIds;\n\n  if (len < 2) {\n    return true;\n  }\n\n  const firstAuthProviderId = normalizeUrl(authProvidersIds[0], CA_UTILS_CRYPTO_CREDENTIALS_NORMALIZE_URL_OPTIONS);\n  let idx = 0;\n\n  while (++idx < len) {\n    if (firstAuthProviderId !== normalizeUrl(authProvidersIds[idx], CA_UTILS_CRYPTO_CREDENTIALS_NORMALIZE_URL_OPTIONS)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const compareCryptoCredentials = async (\n  ...credentials: TCentralAuthorityUserCryptoCredentials[]\n): Promise<boolean | Error> => {\n  if (!(credentials instanceof Array)) {\n    return new Error('Crdentails to compare must be an array');\n  }\n\n  const cryptoCredentialsBase = credentials[0];\n\n  if (!checkIsValidCryptoCredentials(cryptoCredentialsBase)) {\n    return new Error('The crypto credentials on index 0 is not valid');\n  }\n  if (credentials.length === 1) {\n    return true;\n  }\n\n  const userIdentityBase = new CentralAuthorityIdentity(cryptoCredentialsBase[CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]);\n\n  if (!userIdentityBase.isValid) {\n    return new Error('The user identity is not valid in the crypto credentials base');\n  }\n\n  const cryptoCredentialsKeysBase = cryptoCredentialsBase[CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME];\n  const cryptoCredentialsEncryptKeyPairHashBase = await calcCryptoKeyPairHash(cryptoCredentialsKeysBase.encryptionKeyPair);\n\n  if (cryptoCredentialsEncryptKeyPairHashBase instanceof Error) {\n    return new Error('Failed to calculate hash of the encrypt key pairs base');\n  }\n\n  const cryptoCredentialsSignKeyPairHashBase = await calcCryptoKeyPairHash(cryptoCredentialsKeysBase.signDataKeyPair);\n\n  if (cryptoCredentialsSignKeyPairHashBase instanceof Error) {\n    return new Error('Failed to calculate hash of the data sign key pairs base');\n  }\n\n  let idx = 1;\n  const length = credentials.length;\n  let nextCryptoCredentials = null;\n  let keyPairs = null;\n  let userIdentity = null;\n  let encryptionKeyPairsHash = null;\n  let signPairsHash = null;\n\n  for (; idx < length; idx += 1) {\n    nextCryptoCredentials = credentials[idx];\n\n    if (!checkIsValidCryptoCredentials(nextCryptoCredentials)) {\n      return new Error(`The crypto credentials on index ${idx} is not valid`);\n    }\n\n    userIdentity = new CentralAuthorityIdentity(nextCryptoCredentials[CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]);\n\n    if (!userIdentity.isValid) {\n      return new Error(`The user identity is not valid in the crypto credentials on index ${idx}`);\n    }\n    if (userIdentity.id !== userIdentityBase.id) {\n      return new Error(`The user identity are different on index ${idx}`);\n    }\n\n    keyPairs = nextCryptoCredentials[CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME];\n    encryptionKeyPairsHash = await calcCryptoKeyPairHash(keyPairs.encryptionKeyPair);\n\n    if (cryptoCredentialsEncryptKeyPairHashBase !== encryptionKeyPairsHash) {\n      return new Error(`The encryption key pairs are different on index ${idx}`);\n    }\n\n    signPairsHash = await calcCryptoKeyPairHash(keyPairs.signDataKeyPair);\n\n    if (cryptoCredentialsSignKeyPairHashBase !== signPairsHash) {\n      return new Error(`The data sign key pairs are different on index ${idx}`);\n    }\n  }\n  return true;\n};\n\nexport const importCryptoCredentialsFromExportedFromat = async (\n  cryptoCredentialsExported: any,\n  password?: string\n): Promise<Error | TCentralAuthorityUserCryptoCredentials> => {\n  if (!checkIsValidCryptoCredentialsExportedFormat(cryptoCredentialsExported)) {\n    return new Error('The crypto credentials exported have a wrong format');\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeysExported,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentityExported,\n  } = cryptoCredentialsExported;\n  const cryptoKeysImported = await importKeyPairsFromString(cryptoKeysExported, password);\n\n  if (cryptoKeysImported instanceof Error) {\n    console.error(cryptoKeysImported);\n    return new Error('Failed to import a crypto key pairs from the given string');\n  }\n\n  const cryptoCredentials = {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeysImported,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentityExported,\n  };\n\n  if (!checkIsValidCryptoCredentials(cryptoCredentials, !!password)) {\n    return new Error('Failed to return the crypto credentials imorted in the valid format');\n  }\n  return cryptoCredentials;\n};\n\nexport const importCryptoCredentialsFromAString = async (\n  cryptoCredentialsString: any,\n  password?: string\n): Promise<Error | TCentralAuthorityUserCryptoCredentials> => {\n  const typeCryptoCredentials = typeof cryptoCredentialsString;\n\n  if (typeCryptoCredentials !== 'string') {\n    return new Error(`The cryptoCredentials value have the wrong type::${typeCryptoCredentials}::`);\n  }\n  if (!checkIsValidExportedCryptoCredentialsToString(cryptoCredentialsString)) {\n    return new Error('The cryptoCredentials value have a wrong format');\n  }\n\n  let cryptoCredentialsExported;\n\n  try {\n    cryptoCredentialsExported = JSON.parse(cryptoCredentialsString);\n  } catch (err) {\n    console.error(err);\n    return new Error('Failed to parse the given crypto credentials string');\n  }\n  return importCryptoCredentialsFromExportedFromat(cryptoCredentialsExported, password);\n};\n\nexport const getUserCredentialsByUserIdentityAndCryptoKeys = (\n  userIdentity: TCentralAuthorityUserIdentity,\n  cryptoKeyPairs: TCACryptoKeyPairs,\n  checkPrivateKey: boolean = true\n): Error | TCentralAuthorityUserCryptoCredentials => {\n  if (!validateUserIdentity(userIdentity)) {\n    return new Error('The user identity has a wrong format');\n  }\n  if (!checkIsCryptoKeyPairs(cryptoKeyPairs, checkPrivateKey)) {\n    return new Error('The crypto key pairs has a wrong format');\n  }\n\n  const cryptoCredentials = {\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPairs,\n  };\n\n  if (!checkIsValidCryptoCredentials(cryptoCredentials, checkPrivateKey)) {\n    return new Error('Failed to create a valid crypto credentials');\n  }\n  return cryptoCredentials;\n};\n\nexport const getExportedAsStringCryptoCredentials = async (\n  identity: TCentralAuthorityUserIdentity,\n  cryptoCredentialsKeyPairs: TCACryptoKeyPairs,\n  checkPrivateKey: boolean = true\n): Promise<Error | string> => {\n  try {\n    // parse the identity\n    const caIdentity = new CentralAuthorityIdentity(identity);\n    const { isValid } = caIdentity;\n\n    if (!isValid) {\n      return new Error('The identity is not valid or have an unknown format');\n    }\n    if (!checkIsCryptoKeyPairs(cryptoCredentialsKeyPairs, checkPrivateKey)) {\n      return new Error('The crypto keys are not valid or have an unknown format');\n    }\n\n    const caUserCryptoCredentials = getUserCredentialsByUserIdentityAndCryptoKeys(\n      identity,\n      cryptoCredentialsKeyPairs,\n      checkPrivateKey\n    );\n\n    if (caUserCryptoCredentials instanceof Error) {\n      console.error(caUserCryptoCredentials);\n      return new Error('Failed to get User crypto credentials');\n    }\n    return await exportCryptoCredentialsToString(caUserCryptoCredentials);\n  } catch (err) {\n    console.error(err);\n    return new Error('Failed to process the credentials or identity');\n  }\n};\n\nexport const getExportedCryptoCredentialsByCAIdentity = async (\n  caIdentity: CentralAuthorityIdentity | string,\n  cryptoCredentialsKeyPairs: TCACryptoKeyPairs,\n  checkPrivateKey: boolean = true\n): Promise<Error | string> => {\n  if (caIdentity instanceof CentralAuthorityIdentity) {\n    if (caIdentity.isValid) {\n      return getExportedAsStringCryptoCredentials(\n        String(caIdentity), // conver it to identity\n        cryptoCredentialsKeyPairs,\n        checkPrivateKey\n      );\n    }\n    return new Error('The CA identity is wrong');\n  }\n  return new Error('The CA identity must be an instance of caIdentity');\n};\n\nexport const replaceCryptoCredentialsIdentity = (\n  cryptoCredentials: TCentralAuthorityUserCryptoCredentials,\n  identity: TCentralAuthorityUserIdentity,\n  checkPrivateKey: boolean = true\n): Error | TCentralAuthorityUserCryptoCredentials => {\n  if (checkIsValidCryptoCredentials(cryptoCredentials, checkPrivateKey)) {\n    return {\n      ...cryptoCredentials,\n      [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: identity,\n    };\n  }\n  return new Error('The crypto credentials have a wrong format');\n};\n\nexport const getUserIdentityByCryptoCredentials = (\n  cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n): Error | TCentralAuthorityUserIdentity => {\n  if (typeof cryptoCredentials !== 'object') {\n    return new Error('The crypto credentials have an unknown format');\n  }\n\n  const { [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity } = cryptoCredentials;\n\n  if (validateUserIdentity(userIdentity)) {\n    return userIdentity;\n  }\n  return new Error('The user identity is not valid');\n};\n\nexport const getCryptoKeyPairsByCryptoCredentials = (\n  cryptoCredentials: TCentralAuthorityUserCryptoCredentials,\n  checkPrivateKey: boolean = true\n): Error | TCACryptoKeyPairs => {\n  if (typeof cryptoCredentials !== 'object') {\n    return new Error('The crypto credentials have an unknown format');\n  }\n\n  const { [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeyPairs } = cryptoCredentials;\n\n  if (checkIsCryptoKeyPairs(cryptoKeyPairs, checkPrivateKey)) {\n    return cryptoKeyPairs;\n  }\n  return new Error('The crypto key pairs are not valid');\n};\n\nexport const getUserIdentityVersion = (\n  userIdentity: TCentralAuthorityUserIdentity | CentralAuthorityIdentity\n): TUserIdentityVersion | Error => {\n  if (!(userIdentity instanceof CentralAuthorityIdentity) && typeof userIdentity !== 'string') {\n    return new Error('The userIdentity must be a string or an instance of the CentralAuthorityIdentity class');\n  }\n\n  const userIdentityObj = new CentralAuthorityIdentity(userIdentity);\n\n  if (!userIdentityObj.isValid) {\n    return new Error('The user identity is not valid');\n  }\n  return userIdentityObj.version;\n};\n\nexport const getVersionOfCryptoCredentials = (\n  cryptoCredentials: TCentralAuthorityUserCryptoCredentials\n): TUserIdentityVersion | Error => {\n  const userIdentity = getUserIdentityByCryptoCredentials(cryptoCredentials);\n\n  if (userIdentity instanceof Error) {\n    return userIdentity;\n  }\n  return getUserIdentityVersion(userIdentity);\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/central-authority-utils-crypto-credentials/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-utils-common/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/central-authority-validators-auth-credentials.ts",["2779","2780","2781","2782","2783","2784","2785","2786","2787","2788","2789"],"import { dataValidatorUtilURL } from './../../../../utils/data-validators-utils/data-validators-utils-common';\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  CA_USER_IDENTITY_TYPE,\n  CA_USER_IDENTITY_MIN_LENGTH,\n  CA_USER_PASSWORD_MIN_LENGTH,\n  CA_USER_PASSWORD_TYPE,\n  CA_USER_IDENTITY_MAX_LENGTH,\n  CA_USER_LOGIN_MIN_LENGTH,\n} from 'classes/central-authority-class/central-authority-class-const/central-authority-class-const';\nimport { UTILS_DATA_COMPRESSION_COMPRESSION_RATIO_MAX } from 'utils/data-compression-utils/data-compression-utils.const';\nimport {\n  TCentralAuthorityUserIdentity,\n  TCentralAuthorityUserPassword,\n  TCentralAuthorityUserLogin,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { CA_USER_IDENTITY_VERSIONS_LIST } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport { TUserIdentityVersion } from 'classes/central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.types';\nimport { dataValidatorUtilSafeLogin } from 'utils/data-validators-utils/data-validators-utils';\n\nexport const validateUserIdentityType = (v: any): boolean => typeof v === CA_USER_IDENTITY_TYPE;\n\nexport const validateUserIdentityVersion = (v: any): v is TUserIdentityVersion =>\n  typeof v === 'string' && CA_USER_IDENTITY_VERSIONS_LIST.includes(v);\n\nexport const validateUserIdentity = (v: any, isSilentMode: boolean = false): v is TCentralAuthorityUserIdentity => {\n  if (!validateUserIdentityType(v)) {\n    if (!isSilentMode) {\n      console.error('There is a wrong type of the user identity');\n    }\n    return false;\n  }\n  if (v.length < CA_USER_IDENTITY_MIN_LENGTH / UTILS_DATA_COMPRESSION_COMPRESSION_RATIO_MAX) {\n    if (!isSilentMode) {\n      console.error('There is a too small length of the user identity');\n    }\n    return false;\n  }\n  if (v.length > CA_USER_IDENTITY_MAX_LENGTH) {\n    if (!isSilentMode) {\n      console.error('There is a too big length of the user identity');\n    }\n    return false;\n  }\n  return true;\n};\n\nexport const validateUserIdentitySilent = (v: any): v is TCentralAuthorityUserIdentity => validateUserIdentity(v, true);\n\nexport const validatePassword = (v: any): v is TCentralAuthorityUserPassword => {\n  return typeof v === CA_USER_PASSWORD_TYPE && v.length >= CA_USER_PASSWORD_MIN_LENGTH;\n};\n\nexport const validateLogin = (v: any): v is TCentralAuthorityUserLogin => {\n  return typeof v === 'string' && v.length >= CA_USER_LOGIN_MIN_LENGTH;\n};\n\nexport const validateAuthCredentials = (authCredentials: any): void | Error => {\n  if (!authCredentials) {\n    return new Error('The auth credentials is not defined');\n  }\n  if (typeof authCredentials !== 'object') {\n    return new Error('The auth credentials must be an object');\n  }\n\n  const { login, password } = authCredentials;\n\n  if (!login) {\n    return new Error('The login must be defined');\n  }\n  if (!password) {\n    return new Error('The password must be defined');\n  }\n  if (!validatePassword(password)) {\n    return new Error('The password has an incorrect format');\n  }\n  if (!validateLogin(login)) {\n    return new Error('The login has an incorrect format');\n  }\n  if (!dataValidatorUtilSafeLogin(login)) {\n    return new Error('The login is not safe');\n  }\n};\n\nexport const validateAuthProviderIdentity = (authProviderId: string): boolean => {\n  if (typeof authProviderId !== 'string') {\n    console.error(new Error('The auth provider identity must be a string'));\n    return false;\n  }\n  if (!dataValidatorUtilURL(authProviderId)) {\n    console.error(new Error('The auth provider must be a valid URL address'));\n    return false;\n  }\n  return true;\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-auth-credentials/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys-schemas.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/central-authority-validators-crypto-keys.ts",["2790","2791","2792","2793","2794","2795","2796","2797","2798","2799","2800","2801","2802"],"import {\n  CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME,\n  CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME,\n  CA_CREDENTIALS_KEY_CRYPTO_CREDENTIALS_EXPORTED_AS_STRING_MIN_LENGTH,\n} from 'classes/central-authority-class/central-authority-class-const/central-authority-class-const';\nimport {\n  TCentralAuthorityUserCryptoCredentials,\n  TCentralAuthorityUserCryptoCredentialsExported,\n} from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { checkIsCryptoKeyPairs } from 'classes/central-authority-class/central-authority-utils-common/central-authority-util-crypto-keys/central-authority-util-crypto-keys';\nimport { validateBySchema } from 'utils/validation-utils/validation-utils';\n\nimport { validateUserIdentity } from '../central-authority-validators-auth-credentials/central-authority-validators-auth-credentials';\nimport { caValidatorsCryptoKeysExportedObjectValidationSchema } from './central-authority-validators-crypto-keys-schemas';\n\nexport const caValidateCryptoKeyPairExportedObject = (value: any): boolean =>\n  validateBySchema(caValidatorsCryptoKeysExportedObjectValidationSchema, value);\n\n/**\n * validate is a given value has\n * a valid crypto key pair and\n * the user identity\n * in the raw format\n * @param {any} cryptoCredentials\n */\nexport const checkIsValidCryptoCredentials = (\n  cryptoCredentials: any,\n  checkPrivateKey: boolean = true\n): cryptoCredentials is TCentralAuthorityUserCryptoCredentials => {\n  if (!cryptoCredentials || typeof cryptoCredentials !== 'object') {\n    return false;\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeys,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  } = cryptoCredentials;\n\n  if (!cryptoKeys) {\n    console.error('There is a wrong format of the crypto credentials value, case a crypto keys was not found');\n    return false;\n  }\n  if (!userIdentity) {\n    console.error('There is a wrong format of the crypto credentials value, case a user identity value was not found');\n    return false;\n  }\n  if (!validateUserIdentity(userIdentity)) {\n    console.error('There is a wrong format of the crypto credentials value, case the user identity value have a wrong type');\n    return false;\n  }\n  if (!checkIsCryptoKeyPairs(cryptoKeys, checkPrivateKey)) {\n    console.error('There is a wrong format of the crypto credentials value, case the crypto keys value have a wrong type');\n    return false;\n  }\n  return true;\n};\n\n/**\n * validate is a given value has\n * a valid crypto key pair by a function provided\n * and user's identity\n * @param {any} cryptoCredentials\n */\nexport const checkIsValidCryptoCredentialsWithFunc = (\n  cryptoCredentials: any,\n  credentialsValidationFunction: (c: any) => boolean\n): cryptoCredentials is TCentralAuthorityUserCryptoCredentialsExported => {\n  if (!cryptoCredentials || typeof cryptoCredentials !== 'object') {\n    return false;\n  }\n\n  const {\n    [CA_CREDENTIALS_CRYPTO_KEYS_KEY_NAME]: cryptoKeys,\n    [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME]: userIdentity,\n  } = cryptoCredentials;\n\n  if (!cryptoKeys) {\n    console.error('There is a wrong format of the crypto credentials value, case a crypto keys was not found');\n    return false;\n  }\n  if (!userIdentity) {\n    console.error('There is a wrong format of the crypto credentials value, cause a user identity value was not found');\n    return false;\n  }\n  if (!validateUserIdentity(userIdentity)) {\n    console.error('There is a wrong format of the crypto credentials value, cause the user identity value have a wrong type');\n    return false;\n  }\n  if (!credentialsValidationFunction(cryptoKeys)) {\n    console.error(\n      'There is a wrong format of the crypto credentials value, cause the crypto keys exported as a string value have a wrong type'\n    );\n    return false;\n  }\n  return true;\n};\n\n/**\n * validate is a given value has\n * a valid crypto key pair and\n * the user identity\n * in the exported format\n * @param {any} cryptoCredentials\n */\nexport const checkIsValidCryptoCredentialsExportedFormat = (\n  cryptoCredentials: any\n): cryptoCredentials is TCentralAuthorityUserCryptoCredentialsExported => {\n  if (!checkIsValidCryptoCredentialsWithFunc(cryptoCredentials, checkIsValidExportedCryptoCredentialsToString)) {\n    return false;\n  }\n  return true;\n};\n\nexport const checkIsValidExportedCryptoCredentialsToString = (cryptoCredentialsExportedAsString: any): boolean => {\n  return (\n    typeof cryptoCredentialsExportedAsString === 'string' &&\n    cryptoCredentialsExportedAsString.length > CA_CREDENTIALS_KEY_CRYPTO_CREDENTIALS_EXPORTED_AS_STRING_MIN_LENGTH\n  );\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-crypto-keys/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user.schemes.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/central-authority-validators-user.ts",["2803","2804"],"import { ICentralAuthorityUserProfile } from 'classes/central-authority-class/central-authority-class-types/central-authority-class-types';\nimport { validateBySchema } from 'utils/validation-utils/validation-utils';\nimport { CA_VALIDATORS_USER_PROFILE_SCHEME } from './central-authority-validators-user.schemes';\n\nexport const validateUserProfileData = (profileData: any): profileData is ICentralAuthorityUserProfile => {\n  return validateBySchema(CA_VALIDATORS_USER_PROFILE_SCHEME, profileData);\n};\n","/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/central-authority-validators-user/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/central-authority-validators/index.ts",[],"/home/paul/projects/protocol/src/classes/central-authority-class/index.ts",[],"/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.const.ts",[],"/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.ts",["2805","2806","2807","2808","2809","2810","2811","2812","2813","2814","2815","2816","2817","2818","2819","2820","2821"],"import assert from 'assert';\nimport {\n  IConnectionBridgeOptions,\n  IConnectionBridge,\n  TNativeConnectionType,\n  IConnectionBridgeOptionsAuth,\n} from './connection-bridge.types';\nimport { ESwarmStoreConnector } from '../swarm-store-class/swarm-store-class.const';\nimport {\n  ICentralAuthorityOptions,\n  ICentralAuthority,\n  ICentralAuthorityUserCredentials,\n} from '../central-authority-class/central-authority-class.types';\nimport {\n  TSwarmMessageConstructorOptions,\n  ISwarmMessageConstructor,\n  TSwarmMessageInstance,\n} from '../swarm-message/swarm-message-constructor.types';\nimport {\n  ISwarmMessageStoreOptions,\n  ISwarmMessageStore,\n  ISwarmMessageStoreEvents,\n  TSwarmMessagesStoreGrantAccessCallback,\n  ISwarmMessageStoreAccessControlOptions,\n} from '../swarm-message-store/swarm-message-store.types';\nimport { extend } from '../../utils/common-utils/common-utils-objects';\nimport {\n  CONNECTION_BRIDGE_OPTIONS_DEFAULT_AUTH_PROVIDERS_POOL,\n  CONNECTION_BRIDGE_SESSION_STORAGE_KEYS,\n  CONNECTION_BRIDGE_STORAGE_DATABASE_PREFIX,\n  CONNECTION_BRIDGE_DATA_STORAGE_DATABASE_NAME_PREFIX_DELIMETER,\n} from './connection-bridge.const';\nimport { CentralAuthority } from '../central-authority-class/central-authority-class';\nimport { SwarmMessageStore } from '../swarm-message-store/swarm-message-store';\nimport { ISensitiveDataSessionStorage } from 'classes/sensitive-data-session-storage/sensitive-data-session-storage.types';\nimport { SensitiveDataSessionStorage } from 'classes/sensitive-data-session-storage';\nimport {\n  ISwarmMessageEncryptedCacheFabric,\n  ISwarmMessageConstructorWithEncryptedCacheFabric,\n} from '../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport {\n  CONNECTION_BRIDGE_STORAGE_DATABASE_NAME,\n  CONNECTION_BRIDGE_OPTIONS_DEFAULT_USER_SENSITIVE_DATA_STORE as CONNECTION_BRIDGE_OPTIONS_DEFAULT_USER_SENSITIVE_DATA_STORE_OPTIONS,\n} from './connection-bridge.const';\nimport {\n  getSwarmMessageEncryptedCacheFabric,\n  getSwarmMessageConstructorWithCacheFabric,\n} from '../swarm-messgae-encrypted-cache/swarm-message-encrypted-cache.utils';\nimport { ISwarmMessgaeEncryptedCache } from '../swarm-messgae-encrypted-cache';\nimport { ISensitiveDataSessionStorageOptions } from '../sensitive-data-session-storage/sensitive-data-session-storage.types';\nimport {\n  ISecretStorage,\n  TSecretStorageAuthorizazionOptions,\n  TSecretStorageAuthOptionsCredentials,\n} from '../secret-storage-class/secret-storage-class.types';\nimport { SecretStorage } from '../secret-storage-class/secret-storage-class';\nimport { IStorageProviderOptions } from '../storage-providers/storage-providers.types';\nimport {\n  TSwarmStoreDatabaseType,\n  TSwarmStoreConnectorConnectionOptions,\n  TSwarmStoreOptionsOfDatabasesKnownList,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { TSwarmMessageSerialized } from '../swarm-message/swarm-message-constructor.types';\nimport {\n  IConnectionBridgeSwarmConnection,\n  TNativeConnectionOptions,\n  IConnectionBridgeOptionsGetMainConnectorFabric,\n} from './connection-bridge.types';\nimport {\n  getSwarmStoreConnectionProviderOptionsForSwarmStoreConnector,\n  createNativeConnection,\n  connectorBasicFabricOrbitDBDefault,\n} from './connection-bridge.utils';\nimport { IPFS } from 'types/ipfs.types';\nimport { ICentralAuthorityUserProfile } from '../central-authority-class/central-authority-class-types/central-authority-class-types-common';\nimport {\n  ISwarmStoreConnectorBasic,\n  ISwarmStoreConnector,\n  TSwarmStoreConnectorBasicFabric,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { ISecretStoreCredentialsSession, ISecretStoreCredentials } from '../secret-storage-class/secret-storage-class.types';\nimport { getMainConnectorFabricDefault } from './connection-bridge.utils';\nimport { TSwarmStoreConnectorConstructorOptions } from '../swarm-store-class/swarm-store-class.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { PromiseResolveType } from '../../types/helper.types';\nimport { TConnectionBridgeCFODefault } from './connection-bridge.types';\nimport {\n  ISwarmMessageDatabaseConstructors,\n  ISwarmMessageStoreOptionsWithConnectorFabric,\n} from '../swarm-message-store/swarm-message-store.types';\nimport {\n  TSwarmStoreDatabaseOptions,\n  ISwarmStoreProviderOptions,\n  ISwarmStoreOptionsConnectorFabric,\n} from '../swarm-store-class/swarm-store-class.types';\n\n/**\n * this class used if front of connection\n * to the swarm, swarm database and\n * central authority, to simplify connection\n * process.\n *\n * @export\n * @class ConnectionBridge\n */\nexport class ConnectionBridge<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, PO>,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> | undefined,\n  CBFO extends TSwarmStoreConnectorBasicFabric<P, T, DbType, DBO, ConnectorBasic> | undefined,\n  MSI extends TSwarmMessageInstance | T,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, T, MSI, GAC> | undefined,\n  O extends ISwarmMessageStoreOptionsWithConnectorFabric<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n    MSI,\n    GAC,\n    MCF,\n    ACO\n  >,\n  CD extends boolean,\n  CBO extends IConnectionBridgeOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    CFO,\n    CBFO,\n    CD\n  >,\n  E extends ISwarmMessageStoreEvents<P, T, DbType, DBO> = ISwarmMessageStoreEvents<P, T, DbType, DBO>,\n  DBL extends TSwarmStoreOptionsOfDatabasesKnownList<P, T, DbType, DBO> = TSwarmStoreOptionsOfDatabasesKnownList<\n    P,\n    T,\n    DbType,\n    DBO\n  >,\n  NC extends TNativeConnectionType<P> = TNativeConnectionType<P>\n> implements\n    IConnectionBridge<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO, CBFO, MSI, GAC, MCF, ACO, O, CD, CBO> {\n  public centralAuthorityConnection?: ICentralAuthority;\n\n  public swarmMessageStore?: ISwarmMessageStore<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    O\n  >;\n\n  public messageConstructor?: PromiseResolveType<ReturnType<NonNullable<MCF>>>;\n\n  public swarmMessageEncryptedCacheFabric?: ISwarmMessageEncryptedCacheFabric;\n\n  public swarmMessageConstructorFabric: MCF = undefined as MCF;\n\n  public get secretStorage() {\n    return this._secretStorage;\n  }\n\n  protected options?: CBO;\n\n  protected get swarmStoreConnectorType(): P | undefined {\n    return this.options?.swarmStoreConnectorType;\n  }\n\n  protected optionsCentralAuthority?: ICentralAuthorityOptions;\n\n  protected optionsMessageConstructor?: TSwarmMessageConstructorOptions;\n\n  protected optionsSwarmConnection?: TNativeConnectionOptions<P>;\n\n  protected optionsMessageStorage?: ISwarmMessageStoreOptions<P, T, DbType, DBO, ConnectorBasic, PO, MSI, GAC, MCF, ACO>;\n\n  protected sessionSensitiveStorage?: ISensitiveDataSessionStorage;\n\n  protected userSensitiveDataStore?: ISensitiveDataSessionStorage;\n\n  protected swarmMessageEncryptedCache?: ISwarmMessgaeEncryptedCache;\n\n  protected _secretStorage?: ISecretStorage;\n\n  protected swarmConnection: IConnectionBridgeSwarmConnection<P, NC> | undefined;\n\n  protected get sensitiveDataStorageOptions(): ISensitiveDataSessionStorageOptions | undefined {\n    return this.options?.auth.session;\n  }\n\n  /**\n   * Connect to the central authority,\n   * create the message constructor,\n   * create swarm connection, start\n   * connection with the swarm message storage.\n   *\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  public async connect(options: CBO): Promise<void> {\n    await this.createAndSetSessionSensitiveDataStoreForConnectionBridgeSessionIfNotExists();\n    try {\n      await this.validateAndSetOptions(options);\n\n      const { sensitiveDataStorageOptions } = this;\n\n      if (sensitiveDataStorageOptions) {\n        await this.createAndSetSensitiveDataStorageForMainSession(sensitiveDataStorageOptions, this.getUserLoginFromOptions());\n      }\n      await this.createAndSetSequentlyDependenciesInstances();\n      if (sensitiveDataStorageOptions) {\n        await this.markSessionAsStartedInStorageForSession();\n      }\n      this.setCurrentSecretStorageInstance(await this.createAndAutorizeInSecretStorage());\n    } catch (err) {\n      console.error('connection to the swarm failed', err);\n      await this.close();\n      throw err;\n    }\n  }\n\n  /**\n   * @param {ISensitiveDataSessionStorageOptions} sessionParams\n   * @returns\n   * @memberof ConnectionBridge\n   */\n  public async checkSessionAvailable(options?: ISensitiveDataSessionStorageOptions | CBO) {\n    const sessionParams = this.getSessionParamsOrUndefinedFromConnectionBridgeOrSensitiveDataSessionStorageOptions(options);\n\n    if (!sessionParams) {\n      return false;\n    }\n\n    const connectionBridgeSessionDataStore = await this.createSessionSensitiveDataStoreForConnectionBridgeSession();\n    const userLogin = await this.readUserLoginKeyValueFromConnectionBridgeSessionDataStore(connectionBridgeSessionDataStore);\n\n    // check whether the user login value set for a previous session by this Connection bridge instance\n    if (!this.isUserLogin(userLogin)) {\n      return false;\n    }\n\n    // check any data exists in the main session data store\n    const mainSessionDataStore = await this.createMainSensitiveDataStorageForSession(\n      {\n        ...sessionParams,\n        // do not clear data from the storage becuse it can be used later\n        clearStorageAfterConnect: false,\n      },\n      userLogin\n    );\n\n    return this.whetherAnySessionDataExistsInSensitiveDataSessionStorage(mainSessionDataStore);\n  }\n\n  /**\n   * close all the connections and\n   * release all instances\n   *\n   * @returns {Promise<void>}\n   * @memberof ConnectionBridge\n   */\n  public async close(): Promise<void> {\n    await this.closeStorage();\n    await this.closeMessageConstructor();\n    await this.closeSwarmConnection();\n    await this.closeSwarmMessageEncryptedCacheFabric();\n    await this.closeSwarmMessageConstructorFabric();\n    await this.closeCurrentCentralAuthorityConnection();\n  }\n\n  protected isUserLogin(userLogin: unknown): userLogin is string {\n    return userLogin && typeof userLogin === 'string';\n  }\n\n  protected checkCurrentOptionsIsDefined(): this is {\n    options: CBO;\n  } {\n    if (!this.options) {\n      throw new Error('Options should be defined');\n    }\n    return true;\n  }\n\n  protected getOptions(): CBO {\n    if (this.checkCurrentOptionsIsDefined()) {\n      return this.options;\n    }\n    throw new Error('Current options are not defined');\n  }\n\n  protected validateCurrentAuthOptions(): void {\n    const { auth: authOptions } = this.getOptions();\n\n    assert(authOptions, 'Authorization options must be defined');\n    assert(typeof authOptions === 'object', 'Authorization options must be an object');\n  }\n\n  protected validatetCurrentUserOptions() {\n    const { user: userOptions } = this.getOptions();\n\n    assert(userOptions, 'User options must be defined');\n    assert(typeof userOptions === 'object', 'User options must be an object');\n  }\n\n  protected createOptionsForCentralAuthority(\n    authOptions: IConnectionBridgeOptionsAuth<CD>,\n    userOptions: { profile?: Partial<ICentralAuthorityUserProfile> | undefined }\n  ): ICentralAuthorityOptions {\n    const authProvidersPool: ICentralAuthorityOptions['authProvidersPool'] = extend(\n      authOptions.authProvidersPool,\n      CONNECTION_BRIDGE_OPTIONS_DEFAULT_AUTH_PROVIDERS_POOL\n    );\n    return {\n      user: {\n        profile: userOptions.profile,\n        authProviderUrl: authOptions.providerUrl,\n        credentials: {\n          ...authOptions.credentials,\n          session: this.sessionSensitiveStorage,\n        },\n      },\n      authProvidersPool,\n    };\n  }\n\n  protected setOptionsCentralAuthority(optionsCentralAuthority: ICentralAuthorityOptions) {\n    this.optionsCentralAuthority = optionsCentralAuthority;\n  }\n\n  protected createOptionsForCentralAuthorityWithCurrentConnectionBridgeOptions(): ICentralAuthorityOptions {\n    const { auth: authOptions, user: userOptions } = this.getOptions();\n    return this.createOptionsForCentralAuthority(authOptions, userOptions);\n  }\n\n  /**\n   * set options for the CentralAuthority connection.\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected createOptionsCentralAuthority(): ICentralAuthorityOptions {\n    if (!this.checkCurrentOptionsIsDefined()) {\n      throw new Error('Options must be defined');\n    }\n    this.validateCurrentAuthOptions();\n    this.validatetCurrentUserOptions();\n\n    const optionsCentralAuthority = this.createOptionsForCentralAuthorityWithCurrentConnectionBridgeOptions();\n\n    return optionsCentralAuthority;\n  }\n\n  /**\n   * Options for message contrustor by the current options\n   *\n   * @protected\n   * @returns {TSwarmMessageConstructorOptions}\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected createOptionsMessageConstructor(): TSwarmMessageConstructorOptions {\n    const { centralAuthorityConnection: caConnection } = this;\n\n    if (!caConnection) {\n      throw new Error('There is no connection to the central authoriry');\n    }\n    return {\n      caConnection,\n      instances: {\n        encryptedCache: this.swarmMessageEncryptedCache,\n      },\n    };\n  }\n\n  protected getConnectorBasicFabricToUseInSwarmStoreConnectionProviderOptionsForSwarmStoreConnector(): TSwarmStoreConnectorBasicFabric<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic\n  > {\n    return (this.options?.storage.connectorBasicFabric ?? connectorBasicFabricOrbitDBDefault) as TSwarmStoreConnectorBasicFabric<\n      P,\n      T,\n      DbType,\n      DBO,\n      ConnectorBasic\n    >;\n  }\n\n  protected getSwarmStoreConnectionProviderOptions<SC extends IConnectionBridgeSwarmConnection<P, NC>>(swarmConnection: SC): PO {\n    const { swarmStoreConnectorType } = this;\n\n    if (!swarmStoreConnectorType) {\n      throw new Error('Uknown connector type');\n    }\n\n    const connectorBasicFabric = this.getConnectorBasicFabricToUseInSwarmStoreConnectionProviderOptionsForSwarmStoreConnector();\n    const swarmStoreConnectionProviderOptions = getSwarmStoreConnectionProviderOptionsForSwarmStoreConnector<\n      P,\n      T,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      NC,\n      SC\n    >(swarmStoreConnectorType, swarmConnection, connectorBasicFabric);\n\n    return swarmStoreConnectionProviderOptions as PO;\n  }\n\n  protected getCurrentUserIdentityFromCurrentConnectionToCentralAuthority(): TSwarmMessageUserIdentifierSerialized {\n    const { centralAuthorityConnection: caConnection } = this;\n    if (!caConnection) {\n      throw new Error('There is no message central authority connection defined');\n    }\n    const userId = caConnection.getUserIdentity();\n\n    if (userId instanceof Error) {\n      throw userId;\n    }\n    return userId;\n  }\n\n  protected getMessageStorageDatabasesListStorage = (): Promise<ISwarmMessgaeEncryptedCache> => {\n    return this.startEncryptedCache(CONNECTION_BRIDGE_STORAGE_DATABASE_PREFIX.DATABASE_LIST_STORAGE);\n  };\n\n  protected getSwarmStoreConnectionProviderOptionsFromCurrentOptions(): PO {\n    const { swarmConnection } = this;\n\n    if (!swarmConnection) {\n      throw new Error('There is no swarm connection provider');\n    }\n    return this.getSwarmStoreConnectionProviderOptions(swarmConnection);\n  }\n\n  protected getMessageConstructorOptionsForMessageStoreFromCurrentOptions(): ISwarmMessageDatabaseConstructors<\n    PromiseResolveType<ReturnType<NonNullable<MCF>>>\n  > {\n    const { messageConstructor } = this;\n    if (!messageConstructor) {\n      throw new Error('There is no message constructor defined');\n    }\n    return {\n      default: messageConstructor,\n    };\n  }\n\n  protected getSecretStoreCredentialsOptionsForMessageStoreFromCurrentOptions(): TSecretStorageAuthorizazionOptions {\n    return this.getSecretStorageAuthorizationOptions();\n  }\n\n  protected getSwarmStoreOrbitDbConnectorConstructorOptionsByConnectionBridgeOptions(\n    userId: TSwarmMessageUserIdentifierSerialized,\n    credentials: TSecretStorageAuthorizazionOptions,\n    storageOptions: CBO['storage']\n  ): TSwarmStoreConnectorConstructorOptions<ESwarmStoreConnector.OrbitDB, T, DbType> {\n    return {\n      userId,\n      credentials,\n      databases: storageOptions.databases,\n      directory: storageOptions.directory,\n    };\n  }\n\n  protected getSwarmStoreConnectorConstructorOptionsByConnectionBridgeOptions = (\n    userId: TSwarmMessageUserIdentifierSerialized,\n    credentials: TSecretStorageAuthorizazionOptions\n  ): TSwarmStoreConnectorConstructorOptions<P, T, DbType> => {\n    const options = this.getOptions();\n\n    switch (options.swarmStoreConnectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        return this.getSwarmStoreOrbitDbConnectorConstructorOptionsByConnectionBridgeOptions(\n          userId,\n          credentials,\n          options.storage\n        ) as TSwarmStoreConnectorConstructorOptions<P, T, DbType>;\n      default:\n        throw new Error('Unsupported connector type');\n    }\n  };\n\n  protected getConnectorMainFabricFromCurrentOptionsIfExists(): CFO | undefined {\n    return this.getOptions().storage.connectorMainFabric;\n  }\n\n  protected getMainConnectorFabricUtilFromCurrentOptionsIfExists():\n    | IConnectionBridgeOptionsGetMainConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>\n    | undefined {\n    return this.getOptions().storage.getMainConnectorFabric;\n  }\n\n  protected getUtilGetMainConnectorFabricForMessageStore(): IConnectionBridgeOptionsGetMainConnectorFabric<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain\n  > {\n    return this.getMainConnectorFabricUtilFromCurrentOptionsIfExists() || getMainConnectorFabricDefault;\n  }\n\n  protected createMainConnectorFabricForMessageStoreByCurrentOptions(\n    userId: TSwarmMessageUserIdentifierSerialized,\n    credentials: TSecretStorageAuthorizazionOptions\n  ): ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> {\n    if (!this.swarmStoreConnectorType) {\n      throw new Error('Swarm store connector type should be defined');\n    }\n    const swarmStoreConnectorOptions = this.getSwarmStoreConnectorConstructorOptionsByConnectionBridgeOptions(\n      userId,\n      credentials\n    );\n\n    return this.getUtilGetMainConnectorFabricForMessageStore()(swarmStoreConnectorOptions) as TConnectionBridgeCFODefault<\n      P,\n      T,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      CFO\n    >;\n  }\n\n  protected getMainConnectorFabricForSwarmMessageStore(\n    userId: TSwarmMessageUserIdentifierSerialized,\n    credentials: TSecretStorageAuthorizazionOptions\n  ): CFO | ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> {\n    return (\n      this.getConnectorMainFabricFromCurrentOptionsIfExists() ||\n      this.createMainConnectorFabricForMessageStoreByCurrentOptions(userId, credentials)\n    );\n  }\n\n  protected async getSwarmMessageStoreOptions(): Promise<\n    ISwarmMessageStoreOptionsWithConnectorFabric<\n      P,\n      T,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n      MSI,\n      GAC,\n      MCF,\n      ACO\n    >\n  > {\n    const { swarmStoreConnectorType } = this;\n\n    if (!swarmStoreConnectorType) {\n      throw new Error('Connector type is not defined');\n    }\n\n    const { storage: storageOptions } = this.getOptions();\n    const { accessControl, directory, databases } = storageOptions;\n    const credentials = this.getSecretStoreCredentialsOptionsForMessageStoreFromCurrentOptions();\n    const userId = this.getCurrentUserIdentityFromCurrentConnectionToCentralAuthority();\n\n    return {\n      provider: swarmStoreConnectorType,\n      directory,\n      databases,\n      credentials,\n      userId,\n      accessControl,\n      messageConstructors: this.getMessageConstructorOptionsForMessageStoreFromCurrentOptions(),\n      databasesListStorage: await this.startEncryptedCache(CONNECTION_BRIDGE_STORAGE_DATABASE_PREFIX.DATABASE_LIST_STORAGE),\n      swarmMessageConstructorFabric: this.swarmMessageConstructorFabric,\n      providerConnectionOptions: this.getSwarmStoreConnectionProviderOptionsFromCurrentOptions(),\n      connectorFabric: this.getMainConnectorFabricForSwarmMessageStore(userId, credentials) as TConnectionBridgeCFODefault<\n        P,\n        T,\n        DbType,\n        DBO,\n        ConnectorBasic,\n        PO,\n        CO,\n        ConnectorMain,\n        CFO\n      >,\n    };\n  }\n\n  /**\n   * set options for the message storage\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected async getOptionsMessageStorage(): Promise<O> {\n    const optionsStorage = await this.getSwarmMessageStoreOptions();\n\n    return optionsStorage as O;\n  }\n\n  protected createSensitiveDataStorageInstance(): ISensitiveDataSessionStorage {\n    return new SensitiveDataSessionStorage();\n  }\n\n  protected async connectSensitiveDataStoreConnectionBridgeSession(userDataStore: ISensitiveDataSessionStorage) {\n    await userDataStore.connect(CONNECTION_BRIDGE_OPTIONS_DEFAULT_USER_SENSITIVE_DATA_STORE_OPTIONS);\n  }\n\n  protected async createSessionSensitiveDataStoreForConnectionBridgeSession(): Promise<ISensitiveDataSessionStorage> {\n    const connectionBridgeSessoinSensitiveDataStore = this.createSensitiveDataStorageInstance();\n    await this.connectSensitiveDataStoreConnectionBridgeSession(connectionBridgeSessoinSensitiveDataStore);\n    return connectionBridgeSessoinSensitiveDataStore;\n  }\n\n  protected async createAndSetSessionSensitiveDataStoreForConnectionBridgeSessionIfNotExists() {\n    if (!this.userSensitiveDataStore) {\n      this.userSensitiveDataStore = await this.createSessionSensitiveDataStoreForConnectionBridgeSession();\n    }\n  }\n\n  protected setOptions(options: CBO): void {\n    this.options = options;\n  }\n\n  protected checkUserDataStoreIsReady(): this is {\n    userSensitiveDataStore: ISensitiveDataSessionStorage;\n  } {\n    const { userSensitiveDataStore: userDataStore } = this;\n    if (!userDataStore) {\n      throw new Error('User data store is not initialized');\n    }\n    return true;\n  }\n\n  protected getAcitveUserSensitiveDataStore(): ISensitiveDataSessionStorage {\n    if (this.checkUserDataStoreIsReady()) {\n      return this.userSensitiveDataStore;\n    }\n    throw new Error('User sensitive data store is not initialized');\n  }\n\n  protected async setValueInCurrentActiveUserSensitiveDataStore(\n    key: CONNECTION_BRIDGE_SESSION_STORAGE_KEYS,\n    value: unknown\n  ): Promise<void> {\n    return this.getAcitveUserSensitiveDataStore().setItem(key, value);\n  }\n\n  protected readUserLoginKeyValueFromConnectionBridgeSessionDataStore(\n    userSensitiveDataStore: ISensitiveDataSessionStorage\n  ): unknown {\n    return userSensitiveDataStore.getItem(CONNECTION_BRIDGE_SESSION_STORAGE_KEYS.USER_LOGIN);\n  }\n\n  protected async readUserLoginFromConnectionBridgeSessionStore(): Promise<string | undefined> {\n    const userLogin = await this.readUserLoginKeyValueFromConnectionBridgeSessionDataStore(\n      this.getAcitveUserSensitiveDataStore()\n    );\n\n    if (!this.isUserLogin(userLogin)) {\n      return;\n    }\n    return userLogin;\n  }\n\n  protected async getUserLoginFromConnectionBridgeSessionDataStore(): Promise<string> {\n    const login = await this.readUserLoginFromConnectionBridgeSessionStore();\n\n    if (!login) {\n      throw new Error('There is no login provided in options and no session data found to get it');\n    }\n    return login;\n  }\n\n  protected validateOptions(options: unknown): options is CBO {\n    assert(options, 'Options must be provided');\n    assert(typeof options === 'object', 'Options must be an object');\n    assert((options as CBO).swarmStoreConnectorType, 'swarmStoreConnectorType should be defined');\n    return true;\n  }\n\n  protected isOptionsWithCredentials(\n    options: IConnectionBridgeOptions<\n      P,\n      T,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      MSI,\n      GAC,\n      MCF,\n      ACO,\n      CFO,\n      CBFO,\n      any\n    >\n  ): options is IConnectionBridgeOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    CFO,\n    CBFO,\n    true\n  > {\n    return !!options.auth.credentials?.login;\n  }\n\n  protected async setOptionsWithUserCredentialsProvided(\n    options: IConnectionBridgeOptions<\n      P,\n      T,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      MSI,\n      GAC,\n      MCF,\n      ACO,\n      CFO,\n      CBFO,\n      true\n    >\n  ): Promise<void> {\n    await this.setValueInCurrentActiveUserSensitiveDataStore(\n      CONNECTION_BRIDGE_SESSION_STORAGE_KEYS.USER_LOGIN,\n      options.auth.credentials.login\n    );\n    this.setOptions(options as CBO);\n  }\n\n  protected async setCurrentOptionsWithoutUserCredentials(\n    options: IConnectionBridgeOptions<\n      P,\n      T,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      MSI,\n      GAC,\n      MCF,\n      ACO,\n      CFO,\n      CBFO,\n      false\n    >\n  ): Promise<void> {\n    assert(options.auth.session, 'A session must be started if there is no credentials provided');\n\n    const login = await this.getUserLoginFromConnectionBridgeSessionDataStore();\n\n    if (!login) {\n      throw new Error('There is no login provided in options and no session data found to get it');\n    }\n    this.options = {\n      ...options,\n      auth: {\n        ...options.auth,\n        credentials: {\n          ...options.auth.credentials,\n          login,\n        },\n      },\n    } as CBO;\n  }\n\n  /**\n   *\n   *\n   * @protected\n   * @param {IConnectionBridgeOptions<P>} options\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected async validateAndSetOptions(options: CBO): Promise<void> {\n    this.validateOptions(options);\n    if (this.isOptionsWithCredentials(options)) {\n      await this.setOptionsWithUserCredentialsProvided(options);\n    } else {\n      await this.setCurrentOptionsWithoutUserCredentials(\n        options as IConnectionBridgeOptions<\n          P,\n          T,\n          DbType,\n          DBO,\n          ConnectorBasic,\n          PO,\n          CO,\n          ConnectorMain,\n          MSI,\n          GAC,\n          MCF,\n          ACO,\n          CFO,\n          CBFO,\n          false\n        >\n      );\n    }\n  }\n\n  protected getSensitiveDataStoragePrefixForSession(\n    sessionParams: ISensitiveDataSessionStorageOptions,\n    userLogin: string\n  ): string | undefined {\n    return sessionParams.storagePrefix\n      ? `${sessionParams.storagePrefix}${CONNECTION_BRIDGE_DATA_STORAGE_DATABASE_NAME_PREFIX_DELIMETER}${userLogin}`\n      : undefined;\n  }\n\n  protected async connectToSensitiveDataStorage(\n    sensitiveDataStorageParams: ISensitiveDataSessionStorageOptions,\n    userLogin: string\n  ): Promise<ISensitiveDataSessionStorage> {\n    const sessionDataStorage = this.createSensitiveDataStorageInstance();\n    await sessionDataStorage.connect({\n      ...sensitiveDataStorageParams,\n      storagePrefix: this.getSensitiveDataStoragePrefixForSession(sensitiveDataStorageParams, userLogin),\n    });\n    return sessionDataStorage;\n  }\n\n  protected setCurrentSessionSensitiveDataStorage(sessionSensitiveStorage: ISensitiveDataSessionStorage): void {\n    this.sessionSensitiveStorage = sessionSensitiveStorage;\n  }\n\n  protected async createMainSensitiveDataStorageForSession(\n    sensitiveDataStorageOptions: ISensitiveDataSessionStorageOptions,\n    userLogin: string\n  ): Promise<ISensitiveDataSessionStorage> {\n    if (!sensitiveDataStorageOptions) {\n      throw new Error('Params for the sensitive data storage should be defined to start the session');\n    }\n    return this.connectToSensitiveDataStorage(sensitiveDataStorageOptions, userLogin);\n  }\n\n  /**\n   * start session if options provided\n   *\n   * @protected\n   * @param {ISensitiveDataSessionStorageOptions} sessionParams\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected async createAndSetSensitiveDataStorageForMainSession(\n    sensitiveDataStorageOptions: ISensitiveDataSessionStorageOptions,\n    userLogin: string\n  ): Promise<void> {\n    this.setCurrentSessionSensitiveDataStorage(\n      await this.createMainSensitiveDataStorageForSession(sensitiveDataStorageOptions, userLogin)\n    );\n  }\n\n  protected async createCentralAuthorityInstnace(optionsCentralAuthority: ICentralAuthorityOptions): Promise<ICentralAuthority> {\n    const centralAuthority = new CentralAuthority();\n    const connectionResult = await centralAuthority.connect(optionsCentralAuthority);\n\n    if (connectionResult instanceof Error) {\n      throw connectionResult;\n    }\n    return centralAuthority;\n  }\n\n  protected setCurrentCentralAuthorityConnection(centralAuthority: ICentralAuthority) {\n    this.centralAuthorityConnection = centralAuthority;\n  }\n\n  /**\n   *\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected async createAndStartConnectionWithCentralAuthority(): Promise<ICentralAuthority> {\n    const optioinsCA = this.createOptionsCentralAuthority();\n\n    this.setOptionsCentralAuthority(optioinsCA);\n    return this.createCentralAuthorityInstnace(optioinsCA);\n  }\n\n  protected setCurrentSwarmMessageConstructor(swarmMessageConstructor: ISwarmMessageConstructor): void {\n    this.messageConstructor = swarmMessageConstructor as PromiseResolveType<ReturnType<NonNullable<MCF>>>;\n  }\n\n  /**\n   * create the default message construtor\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected async createSwarmMessageConstructor(): Promise<ISwarmMessageConstructor> {\n    if (!this.swarmMessageConstructorFabric) {\n      throw new Error('Swarm message constructor fabric must be created before');\n    }\n    return this.swarmMessageConstructorFabric(this.createOptionsMessageConstructor());\n  }\n\n  protected createNativeConnection = (): Promise<TNativeConnectionType<P>> => {\n    if (!this.swarmStoreConnectorType) {\n      throw new Error('Swarm store connector type should be defined');\n    }\n    if (!this.options?.nativeConnection) {\n      throw new Error('There is no options for the native connection');\n    }\n\n    return createNativeConnection(this.swarmStoreConnectorType, this.options.nativeConnection);\n  };\n\n  protected setCurrentSwarmConnection = (swarmConnection: IConnectionBridgeSwarmConnection<P, NC>): void => {\n    this.swarmConnection = swarmConnection;\n  };\n\n  /**\n   * create connection to the swarm through the\n   * provider.\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   */\n  protected async createSwarmConnection(): Promise<IConnectionBridgeSwarmConnection<P, NC>> {\n    const nativeConnection = await this.createNativeConnection();\n\n    return {\n      getNativeConnection() {\n        return nativeConnection;\n      },\n    } as IConnectionBridgeSwarmConnection<P, NC>;\n  }\n\n  protected getUserCredentialsFromOptions(): Pick<ICentralAuthorityUserCredentials, 'cryptoCredentials' | 'login' | 'password'> {\n    const { auth } = this.getOptions();\n    const { credentials } = auth;\n\n    if (!credentials) {\n      throw new Error('Credentials should be defined');\n    }\n    return credentials as Pick<ICentralAuthorityUserCredentials, 'cryptoCredentials' | 'login' | 'password'>;\n  }\n\n  protected getUserLoginFromOptions(): string {\n    return this.getUserCredentialsFromOptions().login;\n  }\n\n  protected getUserPasswordFromOptions(): string | undefined {\n    return this.getUserCredentialsFromOptions().password;\n  }\n\n  protected getOptionsSwarmMessageEncryptedCache(userLogin: string): TSecretStorageAuthOptionsCredentials {\n    const userPassword = this.getUserPasswordFromOptions();\n\n    if (!userPassword && !this.sessionSensitiveStorage) {\n      throw new Error('Session with user secret key or password shoul exists');\n    }\n    return {\n      login: userLogin,\n      password: userPassword,\n      session: this.sessionSensitiveStorage,\n    } as TSecretStorageAuthOptionsCredentials;\n  }\n\n  protected getDatabaseNamePrefixForEncryptedCahce(userLogin: string): string {\n    return `__${CONNECTION_BRIDGE_STORAGE_DATABASE_PREFIX.MESSAGE_CACHE_STORAGE}${CONNECTION_BRIDGE_DATA_STORAGE_DATABASE_NAME_PREFIX_DELIMETER}${userLogin}`;\n  }\n\n  protected setCurrentSwarmMessageEncryptedCacheFabric(\n    swarmMessageEncryptedCacheFabric: ISwarmMessageEncryptedCacheFabric\n  ): void {\n    this.swarmMessageEncryptedCacheFabric = swarmMessageEncryptedCacheFabric;\n  }\n\n  protected async createSwarmMessageEncryptedCacheFabric(): Promise<ISwarmMessageEncryptedCacheFabric> {\n    const userLogin = this.getUserLoginFromOptions();\n    return getSwarmMessageEncryptedCacheFabric(\n      this.getOptionsSwarmMessageEncryptedCache(userLogin),\n      this.getDatabaseNamePrefixForEncryptedCahce(userLogin)\n    );\n  }\n\n  protected getSwarmMessageConstructorOptions() {\n    if (!this.centralAuthorityConnection) {\n      throw new Error('Connection to the Central authority should exists');\n    }\n    return {\n      caConnection: this.centralAuthorityConnection,\n      instances: {},\n    };\n  }\n\n  protected setCurrentSwarmMessageConstructorFabric(\n    swarmMessageConstructorFabric: ISwarmMessageConstructorWithEncryptedCacheFabric\n  ): void {\n    this.swarmMessageConstructorFabric = swarmMessageConstructorFabric as MCF;\n  }\n\n  protected async createSwarmMessageConstructorFabric(): Promise<ISwarmMessageConstructorWithEncryptedCacheFabric> {\n    const userLogin = this.getUserLoginFromOptions();\n    return getSwarmMessageConstructorWithCacheFabric(\n      this.getOptionsSwarmMessageEncryptedCache(userLogin),\n      this.getSwarmMessageConstructorOptions(),\n      this.getDatabaseNamePrefixForEncryptedCahce(userLogin)\n    );\n  }\n\n  protected getDatabaseNameForEncryptedCacheInstance(dbNamePrefix: string): string {\n    const userLogin = this.getUserLoginFromOptions();\n    return `${dbNamePrefix}${CONNECTION_BRIDGE_DATA_STORAGE_DATABASE_NAME_PREFIX_DELIMETER}${userLogin}`;\n  }\n\n  protected getOptionsForSwarmMessageEncryptedFabric(dbNamePrefix: string) {\n    return {\n      dbName: this.getDatabaseNameForEncryptedCacheInstance(dbNamePrefix),\n    };\n  }\n\n  protected startEncryptedCache(dbNamePrefix: string): Promise<ISwarmMessgaeEncryptedCache> {\n    if (!this.swarmMessageEncryptedCacheFabric) {\n      throw new Error('Encrypted cache fabric must be started before');\n    }\n\n    const optionsForSwarmMessageEncryptedCacheFabric = this.getOptionsForSwarmMessageEncryptedFabric(dbNamePrefix);\n\n    return this.swarmMessageEncryptedCacheFabric(optionsForSwarmMessageEncryptedCacheFabric);\n  }\n\n  protected setCurrentSwarmMessageEncryptedCache(swarmMessageEncryptedCache: ISwarmMessgaeEncryptedCache): void {\n    this.swarmMessageEncryptedCache = swarmMessageEncryptedCache;\n  }\n\n  protected async createSwarmMessageEncryptedCache(): Promise<ISwarmMessgaeEncryptedCache> {\n    if (!this.swarmMessageEncryptedCacheFabric) {\n      throw new Error('Encrypted cache fabric must be started before');\n    }\n    return this.startEncryptedCache(CONNECTION_BRIDGE_STORAGE_DATABASE_NAME.MESSAGE_CACHE_STORAGE);\n  }\n\n  protected createSwarmMessageStoreInstance = (): ISwarmMessageStore<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    O\n  > => {\n    return new SwarmMessageStore<\n      P,\n      T,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n      MSI,\n      GAC,\n      MCF,\n      ACO,\n      O,\n      E,\n      DBL\n    >();\n  };\n\n  protected connectToSwarmMessageStore = async (\n    swarmMessageStorage: ISwarmMessageStore<\n      P,\n      T,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n      MSI,\n      GAC,\n      MCF,\n      ACO,\n      O\n    >\n  ): Promise<void> => {\n    const swarmMessageStorageOptions = await this.getOptionsMessageStorage();\n    const result = await swarmMessageStorage.connect(swarmMessageStorageOptions);\n\n    if (result instanceof Error) {\n      throw result;\n    }\n  };\n\n  protected setCurrentSwarmMessageStorage = (\n    swarmMessageStorage: ISwarmMessageStore<\n      P,\n      T,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n      MSI,\n      GAC,\n      MCF,\n      ACO,\n      O\n    >\n  ): void => {\n    this.swarmMessageStore = swarmMessageStorage;\n  };\n\n  /**\n   * start connection with the SwarmMessage storage\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   * @throws\n   */\n  protected async createAndStartSwarmMessageStorageConnection(): Promise<\n    ISwarmMessageStore<\n      P,\n      T,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n      MSI,\n      GAC,\n      MCF,\n      ACO,\n      O\n    >\n  > {\n    const swarmMessageStorage = this.createSwarmMessageStoreInstance();\n\n    await this.connectToSwarmMessageStore(swarmMessageStorage);\n    return swarmMessageStorage;\n  }\n\n  /**\n   * close the connection with the swarm message storage\n   * and release the instance and options;\n   *\n   * @protected\n   * @returns {Promise<void>}\n   * @memberof ConnectionBridge\n   */\n  protected async closeStorage(): Promise<void> {\n    const { swarmMessageStore: storage } = this;\n\n    if (storage) {\n      try {\n        await storage.close();\n      } catch (err) {\n        console.error('Failed to close the connection to the swarm message storage', err);\n      }\n    } else {\n      console.warn('closeSwarmMessageStorage - there is no connection');\n    }\n    this.swarmMessageStore = undefined;\n    this.optionsMessageStorage = undefined;\n  }\n\n  /**\n   * close the default constructor of a swarm messages,\n   * release it's options and the instance.\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   */\n  protected async closeMessageConstructor(): Promise<void> {\n    this.messageConstructor = undefined;\n    this.optionsMessageConstructor = undefined;\n  }\n\n  /**\n   * close the connection to the swarm and release the instance\n   * and settings.\n   *\n   * @protected\n   * @returns {Promise<void>}\n   * @memberof ConnectionBridge\n   */\n  protected async closeSwarmConnection(): Promise<void> {\n    const { swarmConnection } = this;\n\n    if (swarmConnection) {\n      const nativeConnection = swarmConnection.getNativeConnection();\n\n      try {\n        await (nativeConnection as IPFS).stop();\n      } catch (error) {\n        console.error('closeSwarmConnection failed to stop the ipfs node!', error);\n      }\n    }\n    this.swarmConnection = undefined;\n    this.optionsSwarmConnection = undefined;\n  }\n\n  /**\n   * close the instance of the fabric\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   */\n  protected async closeSwarmMessageEncryptedCacheFabric() {\n    this.swarmMessageEncryptedCacheFabric = undefined;\n  }\n\n  /**\n   * close the instance of the fabric\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   */\n  protected async closeSwarmMessageConstructorFabric() {\n    this.swarmMessageConstructorFabric = undefined as MCF;\n  }\n\n  /**\n   * close the connection to the central authority\n   *\n   * @protected\n   * @returns {Promise<void>}\n   * @memberof ConnectionBridge\n   */\n  protected async closeCurrentCentralAuthorityConnection(): Promise<void> {\n    const { centralAuthorityConnection: caConnection } = this;\n\n    if (caConnection) {\n      try {\n        await caConnection.disconnect();\n      } catch (err) {\n        console.error('closeCentralAuthorityConnection failed to close the connection to the central authority', err);\n      }\n    }\n    this.centralAuthorityConnection = undefined;\n    this.optionsCentralAuthority = undefined;\n  }\n\n  protected async setFlagInSessionStorageSessionDataIsExists(): Promise<void> {\n    if (!this.sessionSensitiveStorage) {\n      throw new Error('Session sensitive storage is not exists for the current session');\n    }\n    await this.sessionSensitiveStorage.setItem(CONNECTION_BRIDGE_SESSION_STORAGE_KEYS.SESSION_DATA_AVAILABLE, true);\n  }\n\n  /**\n   * set that authorized before in the session\n   * data, if it's available\n   *\n   * @protected\n   * @memberof ConnectionBridge\n   */\n  protected async markSessionAsStartedInStorageForSession() {\n    await this.setFlagInSessionStorageSessionDataIsExists();\n  }\n\n  protected getSecretStorageDBName(): string {\n    const userLogin = this.getUserLoginFromOptions();\n    return `${CONNECTION_BRIDGE_STORAGE_DATABASE_PREFIX.SECRET_STORAGE}${CONNECTION_BRIDGE_DATA_STORAGE_DATABASE_NAME_PREFIX_DELIMETER}${userLogin}`;\n  }\n\n  protected getSecretStorageDBOptions(): Partial<IStorageProviderOptions> {\n    return {\n      dbName: this.getSecretStorageDBName(),\n    };\n  }\n\n  protected getSecretStorageSessionOptions(): ISecretStoreCredentialsSession {\n    const { sessionSensitiveStorage } = this;\n\n    if (!sessionSensitiveStorage) {\n      throw new Error('sessionSensitiveStorage is not defined');\n    }\n    return {\n      session: sessionSensitiveStorage,\n    };\n  }\n\n  protected getSecretStorageCredentials(options: CBO): ISecretStoreCredentials {\n    const {\n      auth: { credentials },\n    } = options;\n\n    if (!credentials) {\n      throw new Error('Credentials should be defined to authorize in SecretStorage');\n    }\n    if (!credentials.login) {\n      throw new Error('Login must be provided to authorize in SecretStorage');\n    }\n    if (!credentials.password) {\n      throw new Error('Password must be provided to authorize in SecretStorage');\n    }\n    return credentials as ISecretStoreCredentials;\n  }\n\n  protected getSecretStorageAuthorizationOptions(): TSecretStorageAuthorizazionOptions {\n    if (!this.checkCurrentOptionsIsDefined()) {\n      throw new Error('Options should be defined');\n    }\n\n    const { options } = this;\n\n    if (!this.isOptionsWithCredentials(options)) {\n      return this.getSecretStorageSessionOptions();\n    }\n    return this.getSecretStorageCredentials(options);\n  }\n\n  protected createSecretStorageInstance(): ISecretStorage {\n    return new SecretStorage();\n  }\n\n  protected async authorizeInSecretStorage(secretStorage: ISecretStorage): Promise<void> {\n    const authResult = await secretStorage.authorize(\n      this.getSecretStorageAuthorizationOptions(),\n      this.getSecretStorageDBOptions()\n    );\n    if (authResult !== true) {\n      throw authResult === false ? new Error('Conntection to the secret storage failed') : authResult;\n    }\n  }\n\n  protected setCurrentSecretStorageInstance(secretStorage: ISecretStorage): void {\n    this._secretStorage = secretStorage;\n  }\n\n  protected async createAndAutorizeInSecretStorage(): Promise<ISecretStorage> {\n    const secretStorage = this.createSecretStorageInstance();\n\n    await this.authorizeInSecretStorage(secretStorage);\n    return secretStorage;\n  }\n\n  protected isConnectionBridgeOptionsWithSession(options: ISensitiveDataSessionStorageOptions | CBO): options is CBO {\n    return !!(options as CBO).auth?.session;\n  }\n\n  protected getSessionParamsOrUndefinedFromConnectionBridgeOrSensitiveDataSessionStorageOptions(\n    options?: ISensitiveDataSessionStorageOptions | CBO\n  ): ISensitiveDataSessionStorageOptions | undefined {\n    if (!options) {\n      return undefined;\n    }\n    return this.isConnectionBridgeOptionsWithSession(options) ? options.auth.session : options;\n  }\n\n  protected async whetherAnySessionDataExistsInSensitiveDataSessionStorage(\n    sensitiveDataStorage: ISensitiveDataSessionStorage\n  ): Promise<boolean> {\n    return !!(await sensitiveDataStorage.getItem(CONNECTION_BRIDGE_SESSION_STORAGE_KEYS.SESSION_DATA_AVAILABLE));\n  }\n\n  protected async createAndSetSequentlyDependenciesInstances() {\n    this.setCurrentCentralAuthorityConnection(await this.createAndStartConnectionWithCentralAuthority());\n    this.setCurrentSwarmMessageEncryptedCacheFabric(await this.createSwarmMessageEncryptedCacheFabric());\n    this.setCurrentSwarmMessageConstructorFabric(await this.createSwarmMessageConstructorFabric());\n    this.setCurrentSwarmMessageEncryptedCache(await this.createSwarmMessageEncryptedCache());\n    this.setCurrentSwarmMessageConstructor(await this.createSwarmMessageConstructor());\n    this.setCurrentSwarmConnection(await this.createSwarmConnection());\n    this.setCurrentSwarmMessageStorage(await this.createAndStartSwarmMessageStorageConnection());\n  }\n}\n","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.types.ts",["2822","2823","2824","2825","2826","2827","2828","2829","2830","2831","2832","2833","2834"],"import {\n  ISwarmMessageStore,\n  ISwarmMessageStoreAccessControlOptions,\n  ISwarmMessageStoreOptions,\n  ISwarmMessageStoreOptionsWithConnectorFabric,\n  TSwarmMessagesStoreGrantAccessCallback,\n} from '../swarm-message-store/swarm-message-store.types';\nimport { ESwarmStoreConnector } from '../swarm-store-class/swarm-store-class.const';\nimport { ICentralAuthority, ICentralAuthorityOptions } from '../central-authority-class/central-authority-class.types';\nimport {\n  ISwarmMessageConstructor,\n  TSwarmMessageInstance,\n  TSwarmMessageSerialized,\n} from '../swarm-message/swarm-message-constructor.types';\nimport { ISensitiveDataSessionStorageOptions } from 'classes/sensitive-data-session-storage/sensitive-data-session-storage.types';\nimport {\n  ISwarmMessageConstructorWithEncryptedCacheFabric,\n  ISwarmMessageEncryptedCacheFabric,\n} from '../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport {\n  ISwarmStoreConnector,\n  ISwarmStoreConnectorBasic,\n  ISwarmStoreOptionsConnectorFabric,\n  ISwarmStoreProviderOptions,\n  TSwarmStoreConnectorBasicFabric,\n  TSwarmStoreConnectorConnectionOptions,\n  TSwarmStoreDatabaseOptions,\n  TSwarmStoreDatabaseType,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { IPFS } from 'types/ipfs.types';\nimport { TSwarmStoreConnectorConstructorOptions } from '../swarm-store-class/swarm-store-class.types';\n\nexport type TNativeConnectionType<P extends ESwarmStoreConnector> = P extends ESwarmStoreConnector.OrbitDB ? IPFS : never;\n\nexport type TNativeConnectionOptions<P extends ESwarmStoreConnector> = P extends ESwarmStoreConnector.OrbitDB ? {} : never;\n\nexport type TConnectionBridgeOptionsAuthCredentials = Omit<ICentralAuthorityOptions['user']['credentials'], 'session'>;\n\nexport type TConnectionBridgeCFODefault<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, PO>,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> | undefined\n> = CFO extends undefined ? ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> : CFO;\n\nexport interface IConnectionBridgeOptionsAuth<CD extends boolean = false> {\n  /**\n   * url of an  auth provider from the auth providers pool\n   * on which the user will be authorized or registered\n   * if still had not.\n   *\n   * @type {ICentralAuthorityOptions['user']['authProviderUrl']}\n   */\n  providerUrl: ICentralAuthorityOptions['user']['authProviderUrl'];\n  /**\n   * credentials used to authorize or register on a credentials\n   * provider. If credentials are not provided, then session\n   * must be started before\n   *\n   * @type {ICentralAuthorityOptions['user']['credentials']}\n   */\n  credentials: CD extends true ? TConnectionBridgeOptionsAuthCredentials : TConnectionBridgeOptionsAuthCredentials | undefined;\n  session?: ISensitiveDataSessionStorageOptions;\n  /**\n   * this is list of auth providers will be used to authorize\n   * the user and a keys of another users connected to the\n   * swarm\n   *\n   * @type {ICentralAuthorityOptions['authProvidersPool']}\n   */\n  authProvidersPool?: ICentralAuthorityOptions['authProvidersPool'];\n}\n\nexport interface IConnectionBridgeSwarmConnection<P extends ESwarmStoreConnector, NC extends TNativeConnectionType<P>> {\n  getNativeConnection(): NC;\n}\n\nexport interface IGetBasicConnectorFabric<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, PO>\n> {\n  (\n    swarmStoreConnectorConstructorOptions: TSwarmStoreConnectorConstructorOptions<P, T, DbType>\n  ): ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>;\n}\n\nexport interface IConnectionBridgeOptionsGetMainConnectorFabric<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, PO>\n> {\n  (\n    swarmStoreConnectorConstructorOptions: TSwarmStoreConnectorConstructorOptions<P, T, DbType>\n  ): ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>;\n}\n\nexport interface IConnectionBridgeStorageOptions<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, PO>,\n  MSI extends TSwarmMessageInstance | T,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, T, MSI, GAC> | undefined,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> | undefined,\n  CBFO extends TSwarmStoreConnectorBasicFabric<P, T, DbType, DBO, ConnectorBasic> | undefined\n> extends Omit<\n    ISwarmMessageStoreOptions<P, T, DbType, DBO, ConnectorBasic, PO, MSI, GAC, MCF, ACO>,\n    'userId' | 'credentials' | 'messageConstructors' | 'providerConnectionOptions' | 'databasesListStorage'\n  > {\n  connectorBasicFabric: CBFO;\n  connectorMainFabric?: CFO;\n  getMainConnectorFabric:\n    | IConnectionBridgeOptionsGetMainConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>\n    | undefined;\n}\n\nexport interface IConnectionBridgeOptionsUser {\n  /**\n   * profile of the user for the central auth provider\n   *\n   * @type {ICentralAuthorityOptions['user']['profile']}\n   */\n  profile?: ICentralAuthorityOptions['user']['profile'];\n}\n\nexport interface IConnectionBridgeOptions<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, PO>,\n  MSI extends TSwarmMessageInstance | T,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, T, MSI, GAC> | undefined,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> | undefined,\n  CBFO extends TSwarmStoreConnectorBasicFabric<P, T, DbType, DBO, ConnectorBasic> | undefined,\n  CD extends boolean\n> {\n  swarmStoreConnectorType: P;\n  user: IConnectionBridgeOptionsUser;\n  auth: IConnectionBridgeOptionsAuth<CD>;\n  /**\n   * this is options for a swarm databases user will be\n   * used to store a data.\n   *\n   * @type {ISwarmMessageStoreOptions<P>}\n   * @memberof IConnectionBridgeOptions\n   */\n  storage: IConnectionBridgeStorageOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    CFO,\n    CBFO\n  >;\n  /**\n   * specify options for the swarm connection native provider\n   *\n   * @memberof IConnectionBridgeOptions\n   */\n  nativeConnection: TNativeConnectionOptions<P>;\n}\n\nexport interface IConnectionBridge<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, PO>,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> | undefined,\n  CBFO extends TSwarmStoreConnectorBasicFabric<P, T, DbType, DBO, ConnectorBasic> | undefined,\n  MSI extends TSwarmMessageInstance | T,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, T, MSI, GAC> | undefined,\n  O extends ISwarmMessageStoreOptionsWithConnectorFabric<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n    MSI,\n    GAC,\n    MCF,\n    ACO\n  >,\n  CD extends boolean,\n  CBO extends IConnectionBridgeOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    CFO,\n    CBFO,\n    CD\n  >\n> {\n  /**\n   * used to authorize the user or get\n   * a common information about the users\n   * also connected to the swarm.\n   *\n   * @type {ICentralAuthority}\n   * @memberof IConnectionBridge\n   */\n  centralAuthorityConnection?: ICentralAuthority;\n  /**\n   * storage allows to add or read messages from\n   * the swarm\n   *\n   * @type {ISwarmMessageStore<P>}\n   * @memberof IConnectionBridge\n   */\n  swarmMessageStore?: ISwarmMessageStore<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    O\n  >;\n  /**\n   * allows to create messages, which can be stored in the swarm\n   *\n   * @type {ISwarmMessageConstructor}\n   * @memberof IConnectionBridge\n   */\n  messageConstructor?: ISwarmMessageConstructor;\n\n  /**\n   * Fabric which provides instances of SwarmMessageEncryptedCache,\n   * already connected to the storage and ready to use.\n   *\n   * @type {ISwarmMessageEncryptedCacheFabric}\n   * @memberof IConnectionBridge\n   */\n  swarmMessageEncryptedCacheFabric?: ISwarmMessageEncryptedCacheFabric;\n\n  /**\n   * allows to construct SwarmMessagesConstructor with support of\n   * encrypted cache storage and ready to use.\n   *\n   * @type {ISwarmMessageConstructorWithEncryptedCacheFabric}\n   * @memberof IConnectionBridge\n   */\n  swarmMessageConstructorFabric?: ISwarmMessageConstructorWithEncryptedCacheFabric;\n\n  /**\n   * Connect to central authority and swarm. If the connection\n   * will be succeed than the caConnection and storage\n   * properties will be available.\n   * If email or any other operations are necessary then\n   * the promise returned will be resolved with Error\n   * have a message with the problem description.\n   *\n   * @param {IConnectionBridgeOptions<P>} options\n   * @returns {(Promise<Error | void>)}\n   * @memberof IConnectionBridge\n   */\n  connect(options: CBO): Promise<Error | void>;\n\n  /**\n   * checks was a session started before and\n   * if it's data is available for now.\n   * If a session is availablr, the user\n   * can try to connect without credentials.\n   *\n   * @param {(ISensitiveDataSessionStorageOptions | IConnectionBridgeOptions<P>)} [options]\n   * @returns {Promise<boolean>}\n   * @memberof IConnectionBridge\n   */\n  checkSessionAvailable(options?: ISensitiveDataSessionStorageOptions | CBO): Promise<boolean>;\n  /**\n   * Close all connections and release the options.\n   * The connection can't be used anymore.\n   *\n   * @returns {(Promise<Error | void>)}\n   * @memberof IConnectionBridge\n   */\n  close(): Promise<Error | void>;\n}\n\nexport interface IConnectionBridgeOptionsDefault<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  CD extends boolean = true,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType> = TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T = TSwarmMessageInstance | T,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined = undefined,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI> = TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, T, MSI, GAC> | undefined = undefined,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO> = ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  CBFO extends TSwarmStoreConnectorBasicFabric<P, T, DbType, DBO, ConnectorBasic> | undefined = undefined,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic> = TSwarmStoreConnectorConnectionOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic\n  >,\n  CO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, PO> = ISwarmStoreProviderOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO\n  >,\n  ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, PO> = ISwarmStoreConnector<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO\n  >,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> | undefined = undefined\n> extends IConnectionBridgeOptions<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, MSI, GAC, MCF, ACO, CFO, CBFO, CD> {}\n\nexport type TConnectionBridgeOptionsDefault<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  CD extends boolean = true,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType> = TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T = TSwarmMessageInstance | T\n> = IConnectionBridgeOptionsDefault<P, T, DbType, CD, DBO, MSI>['storage'];\n\nexport interface IConnectionBridgeStorageOptionsDefault<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  CD extends boolean = true,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType> = TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T = TSwarmMessageInstance | T\n> extends TConnectionBridgeOptionsDefault<P, T, DbType, CD, DBO, MSI> {}\n\nexport interface IConnectionBridgeUnknown<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  CD extends boolean = true,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType> = TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T = TSwarmMessageInstance | T,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined = undefined,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI> = TSwarmMessagesStoreGrantAccessCallback<P, MSI>\n> extends IConnectionBridge<P, T, DbType, DBO, any, any, any, any, any, any, MSI, GAC, MCF, any, any, CD, any> {}\n","/home/paul/projects/protocol/src/classes/connection-bridge/index.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.const.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.ts",["2835","2836","2837","2838","2839","2840","2841","2842","2843","2844"],"import { FILE_STORAGE_SERVICE_STATUS, FILE_STORAGE_SERVICE_TYPE } from '../../filestorage-class.const';\nimport HttpRequest from 'classes/basic-classes/http-request-class-base/http-request-class-base';\nimport {\n  IFileStorageClassProviderHTTPFileGetOptions,\n  IFileStorageClassProviderHTTPFileAddOptions,\n} from './filestorage-class-provider-http.types';\nimport { FILE_STORAGE_PROVIDER_HTTP_TYPE, FILE_STORAGE_PROVIDER_HTTP_IDENTIFIER } from './filestorage-class-provider-http.const';\nimport { HTTP_REQUEST_MODE } from 'classes/basic-classes/http-request-class-base';\nimport { downloadFileByUrl } from 'utils/files-utils/files-utils-download';\n\nimport { IFileStorageService, TFileStorageFileAddress } from '../../filestorage-class.types';\nimport { TFileStorageFile } from '../../filestorage-class.types';\n\nexport class FileStorageClassProviderHTTP implements IFileStorageService<FILE_STORAGE_SERVICE_TYPE.HTTP> {\n  public type = FILE_STORAGE_PROVIDER_HTTP_TYPE;\n\n  public readonly isSingleton = true;\n\n  public readonly identifier = FILE_STORAGE_PROVIDER_HTTP_IDENTIFIER;\n\n  public get status() {\n    return FILE_STORAGE_SERVICE_STATUS.READY;\n  }\n\n  public isFileServed(addr: TFileStorageFileAddress): boolean {\n    return addr.startsWith('/http') || this.isBlobAddr(addr);\n  }\n\n  public async connect(options: {}) {\n    return FILE_STORAGE_PROVIDER_HTTP_IDENTIFIER;\n  }\n\n  public async close() {}\n\n  public add = async (filename: string, file: TFileStorageFile, options?: {}): Promise<TFileStorageFileAddress> => {\n    throw new Error('The HTTP provider does not supports files uploading');\n  };\n\n  public get = async (addr: TFileStorageFileAddress, options?: IFileStorageClassProviderHTTPFileGetOptions): Promise<File> => {\n    const urlNormalized = this.getFileURL(addr);\n    const req = new HttpRequest({\n      credentials: 'include',\n      mode: HTTP_REQUEST_MODE.CORS,\n      ...options,\n      url: urlNormalized,\n    });\n    const result = await req.send();\n\n    if (!(result instanceof File)) {\n      throw new Error('Failed to get the file from the network');\n    }\n    return result;\n  };\n\n  public download = async (addr: TFileStorageFileAddress, options?: IFileStorageClassProviderHTTPFileAddOptions) => {\n    const urlNormalized = this.getFileURL(addr);\n\n    downloadFileByUrl(urlNormalized);\n  };\n\n  protected isBlobAddr(addr: TFileStorageFileAddress): boolean {\n    return addr.startsWith('/data:');\n  }\n\n  protected getFileURL(addr: TFileStorageFileAddress): string {\n    if (this.isBlobAddr(addr)) {\n      return addr.slice(1);\n    }\n\n    const isHttps = addr.startsWith('/https');\n    const protocol = isHttps ? 'https://' : 'http://';\n    const addrWithoutPrefix = (isHttps ? addr.slice(6) : addr.slice(5)).replace(/^\\W+/, '');\n    const resultedUrl = `${protocol}${addrWithoutPrefix}`;\n\n    return String(new URL(resultedUrl));\n  }\n}\n","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.types.ts",["2845","2846","2847","2848"],"import { IHttpRequestOptions } from 'classes/basic-classes/http-request-class-base/http-request-class-base.types';\n\nexport interface IFileStorageClassProviderHTTPOptions {}\n\nexport interface IFileStorageClassProviderHTTPFileGetOptions extends IHttpRequestOptions {}\n\nexport interface IFileStorageClassProviderHTTPFileAddOptions {}\n\nexport interface IFileStorageClassProviderHTTPFileDownloadOptions {}\n","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/index.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.const.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.ts",["2849","2850","2851","2852","2853","2854","2855","2856","2857","2858","2859","2860"],"import { IFileStorageService, TFileStorageFileAddress } from '../../filestorage-class.types';\nimport {\n  IFileStorageClassProviderIPFSOptions,\n  IFileStorageClassProviderIPFSFileAddOptions,\n} from './filestorage-class-provider-ipfs.types';\nimport { FILE_STORAGE_PROVIDER_IPFS_IDENTIFIER, FILE_STORAGE_PROVIDER_IPFS_TYPE } from './filestorage-class-provider-ipfs.const';\nimport { FILE_STORAGE_SERVICE_STATUS, FILE_STORAGE_SERVICE_TYPE } from '../../filestorage-class.const';\nimport { TFileStorageFile } from '../../filestorage-class.types';\nimport { extend } from 'utils';\nimport { getFileSize } from 'utils/files-utils';\nimport assert from 'assert';\nimport path from 'path';\nimport { FILE_STORAGE_PROVIDER_IPFS_FILE_UPLOAD_TIMEOUT_MS } from './filestorage-class-provider-ipfs.const';\nimport { IPFS, FileObject, IPFSFile } from 'types/ipfs.types';\nimport BufferList from 'bl';\nimport { FILE_STORAGE_PROVIDER_ROOT_PATH_DEFAULT } from './filestorage-class-provider-ipfs.const';\nimport { timeout } from 'utils/common-utils/common-utils-timer';\nimport { UnixTime } from 'types/ipfs.types';\nimport { downloadFile } from '../../../../utils/files-utils/files-utils-download';\nimport {\n  IFileStorageClassProviderIPFSFileGetOptions,\n  IFileStorageClassProviderIPFSFileDownloadOptions,\n} from './filestorage-class-provider-ipfs.types';\n\nexport class FileStorageClassProviderIPFS implements IFileStorageService<FILE_STORAGE_SERVICE_TYPE.IPFS> {\n  public type = FILE_STORAGE_PROVIDER_IPFS_TYPE;\n\n  public readonly isSingleton = true;\n\n  public readonly identifier = FILE_STORAGE_PROVIDER_IPFS_IDENTIFIER;\n\n  public get status() {\n    const { _ipfs: ipfs } = this;\n\n    if (!ipfs || !ipfs.isOnline()) {\n      return FILE_STORAGE_SERVICE_STATUS.NOT_READY;\n    }\n    if (!ipfs.files || this._error) {\n      return FILE_STORAGE_SERVICE_STATUS.ERROR;\n    }\n    return FILE_STORAGE_SERVICE_STATUS.READY;\n  }\n\n  /**\n   * this is the prefix for path\n   * of each file uploaded\n   *\n   * @protected\n   * @type {string}\n   * @memberof FileStorageClassProviderIPFS\n   */\n  protected _rootPath: string = FILE_STORAGE_PROVIDER_ROOT_PATH_DEFAULT;\n\n  protected _ipfs?: IPFS;\n\n  protected _error?: Error;\n\n  public isFileServed(addr: TFileStorageFileAddress): boolean {\n    return addr.startsWith('/ipfs');\n  }\n\n  public async connect(options: IFileStorageClassProviderIPFSOptions) {\n    try {\n      this.setOptions(options);\n      await this._ipfs?.ready;\n    } catch (err) {\n      console.log(err);\n      throw err;\n    }\n    return FILE_STORAGE_PROVIDER_IPFS_IDENTIFIER;\n  }\n\n  public async close() {\n    this._ipfs = undefined;\n  }\n\n  public add = async (\n    filename: string,\n    file: TFileStorageFile,\n    options?: IFileStorageClassProviderIPFSFileAddOptions\n  ): Promise<TFileStorageFileAddress> => {\n    const ipfs = this._ipfs;\n    const fileSize = getFileSize(file);\n\n    assert(this.status === FILE_STORAGE_SERVICE_STATUS.READY, 'Service is not ready to use');\n    assert(fileSize, 'Failed to get a size of the file');\n    let files: IPFSFile[] | Error | undefined;\n    const progressCallback = options?.progress;\n    let resolve: undefined | Function;\n    const pending = new Promise((res, rej) => {\n      resolve = res;\n    });\n    const opts = extend(\n      options || {},\n      {\n        pin: false,\n        cidVersion: 1,\n        progress: (bytes: number) => {\n          const percent = (bytes / fileSize!) * 100;\n\n          if (progressCallback) {\n            progressCallback(percent);\n          }\n          if (resolve && percent >= 100) {\n            resolve();\n          }\n        },\n      },\n      true\n    );\n\n    try {\n      files = await Promise.race([\n        ipfs?.add(this.getFileObject(filename, file), opts),\n        timeout(FILE_STORAGE_PROVIDER_IPFS_FILE_UPLOAD_TIMEOUT_MS),\n      ]);\n      await pending;\n    } catch (err) {\n      console.error(err);\n      throw err;\n    }\n\n    if (!files) {\n      throw new Error('Failed to upload for an unknown reason');\n    }\n    if (files instanceof Error) {\n      throw files;\n    }\n    return this.getMultiaddr(files[0]);\n  };\n\n  public get = async (addr: TFileStorageFileAddress, options?: IFileStorageClassProviderIPFSFileGetOptions): Promise<File> => {\n    assert(this.status === FILE_STORAGE_SERVICE_STATUS.READY, 'Service is not ready to use');\n    assert(this.isFileServed(addr), 'The file is not supported by the service');\n\n    const ipfs = this._ipfs;\n    const fileDesc = this.getFileDescription(addr);\n    const filesOrChunks = await ipfs!.get(fileDesc.cid);\n    const content = new BufferList();\n    let lastModified = 0;\n    let fileBlob: ArrayBuffer | Blob[];\n\n    if (!filesOrChunks) {\n      throw new Error('Failed to read the file');\n    }\n    if (filesOrChunks instanceof Array) {\n      const chunksLen = filesOrChunks.length;\n      let idx = 0;\n\n      while (idx < chunksLen) {\n        const chunk = filesOrChunks[idx++];\n        content.append(chunk.content);\n        lastModified = this.getMSByUnix(chunk.mtime);\n      }\n      const buff = content.slice();\n      fileBlob = buff.buffer.slice(buff.byteOffset, buff.byteOffset + buff.byteLength);\n    } else {\n      if (!filesOrChunks.content) {\n        throw new Error(\"Failed to read the file's content\");\n      }\n      if (filesOrChunks.content instanceof Blob) {\n        fileBlob = [filesOrChunks.content];\n        if (filesOrChunks.mtime) {\n          lastModified = this.getMSByUnix(filesOrChunks.mtime);\n        }\n      } else if (typeof filesOrChunks.content === 'string') {\n        content.append(filesOrChunks.content);\n      }\n      throw new Error('Unknown content type');\n    }\n    return new File([fileBlob], fileDesc.path, {\n      lastModified: lastModified ? lastModified : undefined,\n    });\n  };\n\n  public download = async (addr: TFileStorageFileAddress, options?: IFileStorageClassProviderIPFSFileDownloadOptions) => {\n    const file = await this.get(addr, options);\n\n    downloadFile(file);\n  };\n\n  protected setOptions(options: IFileStorageClassProviderIPFSOptions) {\n    assert(options.ipfs, 'An instance of IPFS must be provided in the options');\n    this._ipfs = options.ipfs;\n    this._rootPath = options.rootPath || FILE_STORAGE_PROVIDER_ROOT_PATH_DEFAULT;\n  }\n\n  protected getFileObject(filename: string, file: TFileStorageFile): FileObject {\n    const filePath = path.join('/', this._rootPath, filename);\n\n    return {\n      path: filePath,\n      content: file,\n      mtime: file instanceof File ? new Date(file.lastModified) : undefined,\n    };\n  }\n\n  protected getMultiaddr(file: IPFSFile): TFileStorageFileAddress {\n    return path.join('/ipfs/', file.hash, file.path);\n  }\n\n  protected getFileDescription(addr: TFileStorageFileAddress) {\n    const [nothing, prefix, cid, path] = addr.split('/');\n\n    assert(cid, 'Failed to get CID by the address');\n    assert(path, 'Failed to get file path by the address');\n    return {\n      cid,\n      path,\n    };\n  }\n\n  protected getMSByUnix(unix?: UnixTime): number {\n    return unix && unix.secs ? unix.secs : Date.now();\n  }\n}\n","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.types.ts",["2861","2862"],"import { IPFS } from 'types/ipfs.types';\nimport { IFileStorageServiceFileAddCommonOptions } from '../../filestorage-class.types';\n/**\n * this is options used by the file storage class\n *\n * @export\n * @interface IFileStorageClassProviderIPFSOptions\n */\nexport interface IFileStorageClassProviderIPFSOptions {\n  /**\n   * instance of the IPFS, running and\n   * ready to use\n   *\n   * @type {IPFS}\n   * @memberof IFileStorageClassProviderIPFSOptions\n   */\n  ipfs: IPFS;\n  /**\n   * the prefix for each path of a file uploaded\n   *\n   * @type {string}\n   * @memberof IFileStorageClassProviderIPFSOptions\n   */\n  rootPath?: string;\n}\n\nexport interface IFileStorageClassProviderIPFSFileAddOptions extends IFileStorageServiceFileAddCommonOptions {\n  /**\n   * hunking algorithm used to build ipfs DAGs. Available formats:\n   * size-{size}\n   * rabin\n   * rabin-{avg}\n   * rabin-{min}-{avg}-{max}\n   */\n  chunker?: string;\n  /**\n   * (integer, default 0): the CID version to use when storing the data (storage keys are based on the CID, including its version).\n   */\n  cidVersion?: number;\n  /**\n   * (boolean, default false): if true will use the trickle DAG format for DAG generation. Trickle definition from go-ipfs documentation.\n   */\n  trickle?: boolean;\n  /**\n   * adds a wrapping node around the content.\n   */\n  wrapWithDirectory?: boolean;\n}\n\nexport interface IFileStorageClassProviderIPFSFileGetOptions {}\n\nexport interface IFileStorageClassProviderIPFSFileDownloadOptions extends IFileStorageClassProviderIPFSFileGetOptions {}\n","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/index.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class-providers/index.ts",[],"/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class.const.ts",["2863","2864"],"import { IFileStorageService } from './filestorage-class.types';\n/**\n * status of a service\n *\n * @export\n * @enum {number}\n */\nexport enum FILE_STORAGE_SERVICE_STATUS {\n  /**\n   * ready to use\n   */\n  READY = 'READY',\n  /**\n   * connecting to the service\n   */\n  CONNECTING = 'CONNECTING',\n  /**\n   * not ready - may be disconnected or still not connected to\n   */\n  NOT_READY = 'NOT_READY',\n  /**\n   * fault on connecting or file uploading\n   * and means that the service can't be used\n   * anymore\n   */\n  ERROR = 'ERROR',\n}\n\n/**\n * service type\n *\n * @export\n * @enum {number}\n */\nexport enum FILE_STORAGE_SERVICE_TYPE {\n  IPFS = 'IPFS',\n  HTTP = 'HTTP',\n  // will be added in the feature\n  // AMAZONS3 = 'AMAZONS3',\n  // AZUREBLOB = 'AZUREBLOB',\n}\n\n// implementations of the services.\n// will be loaded only if required\nexport const FILE_STORAGE_SERVICES_IMPLEMENTATIONS: Record<\n  FILE_STORAGE_SERVICE_TYPE,\n  () => Promise<any> // Promise<new () => IFileStorageService<any>>\n> = {\n  [FILE_STORAGE_SERVICE_TYPE.IPFS]: () => import('./filestorage-class-providers/filestorage-class-provider-ipfs'),\n  [FILE_STORAGE_SERVICE_TYPE.HTTP]: () => import('./filestorage-class-providers/filestorage-class-provider-http'),\n};\n\nexport const FILE_STORAGE_SERVICE_PREFIX = '/file';\n\nexport const FILE_STORAGE_SERVICE_PREFIX_LENGTH = FILE_STORAGE_SERVICE_PREFIX.length;\n","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class.ts",["2865","2866","2867","2868","2869","2870","2871","2872","2873","2874","2875","2876","2877","2878","2879","2880","2881","2882","2883","2884"],"import { FILE_STORAGE_SERVICE_TYPE, FILE_STORAGE_SERVICES_IMPLEMENTATIONS } from './filestorage-class.const';\nimport { IFileStorageServiceConnectOptions, IFileStorageService } from './filestorage-class.types';\nimport assert from 'assert';\nimport path from 'path';\nimport { FILE_STORAGE_SERVICE_PREFIX, FILE_STORAGE_SERVICE_PREFIX_LENGTH } from './filestorage-class.const';\nimport { TFileStorageFileAddress, TFileStorageServiceFileGetOptions } from './filestorage-class.types';\nimport { TFileStorageServiceIdentifier, TFileStorageFile, TFileStorageServiceFileAddOptions } from './filestorage-class.types';\nimport { IFileStorage, TFileStorageServiceFileDownloadOptions } from './filestorage-class.types';\n\nexport class FileStorage<T extends FILE_STORAGE_SERVICE_TYPE> implements IFileStorage<T> {\n  protected readonly services = new Map<TFileStorageServiceIdentifier, IFileStorageService<T>>();\n\n  protected readonly servicesByTypes = new Map<T, IFileStorageService<T>>();\n\n  public connect = async (configurations: IFileStorageServiceConnectOptions<T>[]) => {\n    return Promise.all(configurations.map(this.connectToService));\n  };\n\n  public close = async (s: TFileStorageServiceIdentifier) => {\n    const service = this.getServiceByTypeOrId(s);\n\n    if (!service) {\n      throw new Error(`Service with the given identifier = \"${s}\" was not found`);\n    }\n    return this.removeService(service);\n  };\n\n  public add = async (\n    s: TFileStorageServiceIdentifier | T,\n    filename: string,\n    file: TFileStorageFile,\n    options?: TFileStorageServiceFileAddOptions\n  ) => {\n    const service = this.getServiceByTypeOrId(s);\n\n    if (!service) {\n      throw new Error(`Service with the given identifier or type = \"${s}\" was not found`);\n    }\n    return this.addPrefixToFileAddress(await service.add(filename, file, options));\n  };\n\n  public get = async (addr: TFileStorageFileAddress, options?: TFileStorageServiceFileGetOptions) => {\n    const addrWOPrefix = this.getAddrWOPrefix(addr);\n    const service = this.getServiceByFileAddr(addrWOPrefix);\n\n    if (!service) {\n      throw new Error(`A file with the address \"${addr}\" is not supported`);\n    }\n    return service.get(addrWOPrefix, options);\n  };\n\n  public async download(addr: TFileStorageFileAddress, options?: TFileStorageServiceFileDownloadOptions) {\n    const addrWOPrefix = this.getAddrWOPrefix(addr);\n    const service = this.getServiceByFileAddr(addrWOPrefix);\n\n    if (!service) {\n      throw new Error(`A file with the address \"${addr}\" is not supported`);\n    }\n    return service.download(addrWOPrefix, options);\n  }\n\n  protected getAddrWOPrefix(addr: TFileStorageFileAddress): string {\n    if (!addr.startsWith(FILE_STORAGE_SERVICE_PREFIX)) {\n      throw new Error(`Uknown address ${addr}`);\n    }\n    return addr.slice(FILE_STORAGE_SERVICE_PREFIX_LENGTH);\n  }\n\n  protected addPrefixToFileAddress(addrWOPrefix: TFileStorageFileAddress): string {\n    if (typeof addrWOPrefix !== 'string') {\n      throw new Error('The result is not a valid file address');\n    }\n    return path.join(FILE_STORAGE_SERVICE_PREFIX, addrWOPrefix);\n  }\n\n  protected getServiceById(serviceId: TFileStorageServiceIdentifier) {\n    return this.services.get(serviceId);\n  }\n\n  protected getServiceByType(serviceType: T) {\n    return this.servicesByTypes.get(serviceType);\n  }\n\n  protected getServiceByTypeOrId(s: TFileStorageServiceIdentifier | T) {\n    return this.getServiceById(s as TFileStorageServiceIdentifier) || this.getServiceByType(s as T);\n  }\n\n  protected getServiceConstructorByType(type: FILE_STORAGE_SERVICE_TYPE) {\n    const constructorGetter = FILE_STORAGE_SERVICES_IMPLEMENTATIONS[type];\n    return constructorGetter();\n  }\n\n  protected getServiceByFileAddr(addr: TFileStorageFileAddress) {\n    for (const sevice of this.services.values()) {\n      if (sevice.isFileServed(addr)) {\n        return sevice;\n      }\n    }\n  }\n\n  protected addService<ST extends T>(type: ST, service: IFileStorageService<ST>) {\n    this.services.set(service.identifier, service);\n    this.servicesByTypes.set(type, service);\n  }\n\n  protected removeService(service: IFileStorageService<T>) {\n    this.services.delete(service.identifier);\n    this.servicesByTypes.delete(service.type as T);\n  }\n\n  protected connectToService = async (\n    configuration: IFileStorageServiceConnectOptions<T>\n  ): Promise<TFileStorageServiceIdentifier> => {\n    assert(configuration, 'Service configuration was not provided');\n\n    const { type, options } = configuration;\n\n    assert(type, 'Service type must be defined');\n    assert(options, `Options for the service \"${type}\" must be defined`);\n\n    const ServiceConstuctor = await this.getServiceConstructorByType(configuration.type);\n    const service = new (ServiceConstuctor.default ?? ServiceConstuctor)();\n\n    await service.connect(options);\n    this.addService(type as T, service);\n    return service.identifier as string;\n  };\n}\n","/home/paul/projects/protocol/src/classes/filestorage-class/filestorage-class.types.ts",["2885"],"import { IFileStorageClassProviderIPFSOptions } from './filestorage-class-providers/filestorage-class-provider-ipfs';\nimport {\n  IFileStorageClassProviderHTTPFileDownloadOptions,\n  IFileStorageClassProviderHTTPOptions,\n} from './filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.types';\nimport { IFileStorageClassProviderIPFSFileDownloadOptions } from './filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.types';\nimport { FILE_STORAGE_SERVICE_TYPE } from './filestorage-class.const';\nimport {\n  IFileStorageClassProviderIPFSFileAddOptions,\n  IFileStorageClassProviderIPFSFileGetOptions,\n} from './filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs.types';\nimport {\n  IFileStorageClassProviderHTTPFileGetOptions,\n  IFileStorageClassProviderHTTPFileAddOptions,\n} from './filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http.types';\nimport {\n  FILE_STORAGE_SERVICE_TYPE as FileStorageServiceType,\n  FILE_STORAGE_SERVICE_STATUS as FileStorageServiceStatus,\n} from './filestorage-class.const';\n\nexport type TFileStorageServiceOptions<T extends FILE_STORAGE_SERVICE_TYPE> = T extends FILE_STORAGE_SERVICE_TYPE.IPFS\n  ? IFileStorageClassProviderIPFSOptions\n  : T extends FILE_STORAGE_SERVICE_TYPE.HTTP\n  ? IFileStorageClassProviderHTTPOptions\n  : never;\n\nexport type TFileStorageServiceFileAddOptions =\n  | IFileStorageClassProviderIPFSFileAddOptions\n  | IFileStorageClassProviderHTTPFileAddOptions;\n\nexport type TFileStorageServiceFileGetOptions =\n  | IFileStorageClassProviderIPFSFileGetOptions\n  | IFileStorageClassProviderHTTPFileGetOptions;\n\nexport type TFileStorageServiceFileDownloadOptions =\n  | IFileStorageClassProviderHTTPFileDownloadOptions\n  | IFileStorageClassProviderIPFSFileDownloadOptions;\n\nexport interface IFileStorageServiceFileAddCommonOptions {\n  progress?: (progress: number) => any;\n}\n\nexport type TFileStorageFile = ArrayBuffer | Buffer | Blob | File;\n\n/**\n * multiaddr or address in the ipfs:\n * '/ipfs/QmXEmhrMpbVvTh61FNAxP9nU7ygVtyvZA8HZDUaqQCAb66',\n * '/ipfs/QmXEmhrMpbVvTh61FNAxP9nU7ygVtyvZA8HZDUaqQCAb66/a.txt'\n * or if http file:\n * '/http/server.com:3000/download/file.pdf',\n * '/https/upload.com/?d=f'\n */\nexport type TFileStorageFileAddress = string;\n\n/**\n * unique identifier of the service connected to,\n * may be an url or another string\n */\nexport type TFileStorageServiceIdentifier = string;\n\nexport interface IFileStorageService<T extends FILE_STORAGE_SERVICE_TYPE> {\n  /**\n   * the current status of the service\n   *\n   * @type {FileStorageServiceStatus}\n   * @memberof IFileStorageService\n   */\n  status: FileStorageServiceStatus;\n  /**\n   * type of the service\n   *\n   * @type {FileStorageServiceType}\n   * @memberof IFileStorageService\n   */\n  type: FileStorageServiceType;\n  /**\n   * unique name of the service, maybe url\n   *\n   * @type {TFileStorageServiceIdentifier}\n   * @memberof IFileStorageService\n   */\n  identifier: TFileStorageServiceIdentifier;\n  /**\n   * is only the one implementation is allowed\n   *\n   * @type {boolean}\n   * @memberof IFileStorageService\n   */\n  isSingleton: boolean;\n  /**\n   * initialize connection with the service\n   *\n   * @param {TFileStorageServiceOptions} options\n   * @returns {Promise<TFileStorageServiceIdentifier>}\n   * @memberof IFileStorageService\n   */\n  connect(options: TFileStorageServiceOptions<T>): Promise<TFileStorageServiceIdentifier>;\n  /**\n   * close connection to the service\n   *\n   * @returns {Promise<void>}\n   * @memberof IFileStorageService\n   */\n  close(): Promise<void>;\n  /**\n   * check whether a file with the address\n   * is served by the service.\n   *\n   * @param {TFileStorageFileAddress} addr\n   * @returns {boolean}\n   * @memberof IFileStorageService\n   */\n  isFileServed(addr: TFileStorageFileAddress): boolean;\n  /**\n   * add the file to the service\n   *\n   * @param {string} filename - filename, e.g. 'file.txt'\n   * @param {TFileStorageFile} file - file content\n   * @param {object} [undefined] options - options, not required, specific for the service\n   * @returns {Promise<TFileStorageFileAddress>} - returns an address of the file added,\n   * which can be used to access the file\n   * @throws\n   * @memberof IFileStorageService\n   */\n  add(\n    filename: string,\n    file: TFileStorageFile,\n    options?: IFileStorageServiceFileAddCommonOptions\n  ): Promise<TFileStorageFileAddress>;\n  /**\n   * get the file\n   * TODO - add download progress callback\n   * @param {TFileStorageFileAddress} addr - address of the file\n   * @param {object} [undefined] options - options, not required, specific for the service\n   * @returns {Promise<File>} - returns file itself\n   * @memberof IFileStorageService\n   * @throws\n   */\n  get(addr: TFileStorageFileAddress, options?: TFileStorageServiceFileGetOptions): Promise<File>;\n  /**\n   * download the file, do net necessary\n   * to read it's content\n   * @param {TFileStorageFileAddress} addr\n   * @param {TFileStorageServiceFileDownloadOptions} [options]\n   * @returns {Promise<void>}\n   * @memberof IFileStorageService\n   */\n  download(addr: TFileStorageFileAddress, options?: TFileStorageServiceFileDownloadOptions): Promise<void>;\n}\n\nexport interface IFileStorageServiceConnectOptions<T extends FILE_STORAGE_SERVICE_TYPE> {\n  /**\n   * type of the service provider\n   *\n   * @type {FileStorageServiceType}\n   * @memberof IFileStorageServiceConnectOptions\n   */\n  type: FileStorageServiceType;\n  /**\n   * options used be the service provider to\n   * connect to the service\n   *\n   * @type {TFileStorageServiceOptions}\n   * @memberof IFileStorageServiceConnectOptions\n   */\n  options: TFileStorageServiceOptions<T>;\n}\n\nexport interface IFileStorage<T extends FILE_STORAGE_SERVICE_TYPE> {\n  /**\n   * connect to the file upload service\n   *\n   * @param {IFileStorageServiceConnectOptions} options\n   * @returns {Promise<TFileStorageServiceIdentifier>}\n   * @memberof IFileStorage\n   */\n  connect(configurations: IFileStorageServiceConnectOptions<T>[]): Promise<TFileStorageServiceIdentifier[]>;\n  /**\n   * close the existing connection with the service\n   * have the identifier provided\n   *\n   * @param {TFileStorageServiceIdentifier} service - service identifier\n   * @returns {Promise<void>}\n   * @memberof IFileStorage\n   */\n  close(serviceId: TFileStorageServiceIdentifier): Promise<void>;\n  /**\n   * add the file to the service\n   *\n   * @param {TFileStorageServiceIdentifier} service - service identifier connected to,\n   * on which to upload the file\n   * @param {string} filename - filename, e.g. 'file.txt'\n   * @param {TFileStorageFile} file - file content\n   * @param {object} [undefined] options - options, not required, specific for the service\n   * @returns {Promise<TFileStorageFileAddress>} - returns an address of the file added,\n   * which can be used to access the file\n   * @throws\n   * @memberof IFileStorage\n   */\n  add(\n    service: TFileStorageServiceIdentifier | T,\n    filename: string,\n    file: TFileStorageFile,\n    options?: TFileStorageServiceFileAddOptions\n  ): Promise<TFileStorageFileAddress>;\n  /**\n   * get the file from the service\n   *\n   * @param {TFileStorageFileAddress} addr - address of the file\n   * @param {object} [TFileStorageServiceIdentifier] service - service identifier connected to,\n   * from which to download the file. If the identifier is not provided, then\n   * it will be identified by a services connected to by the address provided.\n   * @param {object} [undefined] options - options, not required, specific for the service\n   * @returns {Promise<File>} - returns file donwloaded from the service\n   * @memberof IFileStorage\n   * @throws\n   */\n  get(addr: TFileStorageFileAddress, options?: TFileStorageServiceFileGetOptions): Promise<File>;\n  /**\n   * download the file, do net necessary\n   * to read it's content\n   *\n   * @param {TFileStorageFileAddress} addr - file address supported by services\n   * connected to\n   * @param {TFileStorageServiceFileDownloadOptions} [options] - options which used\n   * by the service to download the file\n   * @returns {Promise<void>}\n   * @memberof IFileStorage\n   */\n  download(addr: TFileStorageFileAddress, options?: TFileStorageServiceFileDownloadOptions): Promise<void>;\n}\n","/home/paul/projects/protocol/src/classes/filestorage-class/index.ts",[],"/home/paul/projects/protocol/src/classes/index.ts",[],"/home/paul/projects/protocol/src/classes/open-storage/index.ts",[],"/home/paul/projects/protocol/src/classes/open-storage/open-storage.const.ts",[],"/home/paul/projects/protocol/src/classes/open-storage/open-storage.ts",["2886","2887","2888","2889","2890","2891","2892","2893","2894"],"import { OPEN_STORAGE_KEY_PREFIX } from './open-storage.const';\nimport { STORAGE_PROVIDERS_NAME } from './../storage-providers/storage-providers.const';\nimport { StorageProvider, IStorageProviderOptions } from 'classes/storage-providers/storage-providers.types';\nimport { getStorageProviderByName } from 'classes/storage-providers';\nimport { OpenStorageClass, IOpenStorageConfiguration } from './open-storage.types';\n\n/**\n * This class used to store values\n * into a persistant storage by with\n * no encryption of the data saved.\n * TODO - add caching of a mostly used\n * data in the memory.\n */\nexport class OpenStorage implements OpenStorageClass {\n  public get isActive(): boolean {\n    return !!this.storageProvider;\n  }\n\n  public get isBufferSupported() {\n    return (\n      this.isActive &&\n      !!this.storageProvider &&\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      !!(this.storageProvider as any).constructor.isBufferSupported\n    );\n  }\n\n  protected get isDbNameSupported() {\n    return (\n      this.isActive &&\n      !this.storageProvider &&\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      !!(this.storageProvider as any).constructor.isDbNameSupported\n    );\n  }\n\n  protected storageProvider?: StorageProvider;\n\n  protected dbName?: string;\n\n  protected connectingPromise: Promise<void> | undefined;\n\n  public connect = async (configuration?: IOpenStorageConfiguration): Promise<void | Error> => {\n    const { connectingPromise } = this;\n    if (connectingPromise) {\n      return connectingPromise;\n    }\n    try {\n      const connectToStorePromise = this.connectToStore(configuration);\n      this.setConnectingPromise(connectToStorePromise);\n      return await connectToStorePromise;\n    } catch (err) {\n      this.unsetConnectingPromise();\n      return err;\n    }\n  };\n\n  public disconnect = async (): Promise<Error | void> => {\n    await this.waitTillConnecting();\n    const { isActive, storageProvider } = this;\n\n    if (isActive && storageProvider) {\n      const disconnectResult = await storageProvider.disconnect();\n\n      if (disconnectResult instanceof Error) {\n        console.error(disconnectResult);\n        return new Error('Failed to disconnect from the storage provider');\n      }\n    }\n    this.unsetStorageProviderConnection();\n    this.unsetOptions();\n    this.unsetConnectingPromise();\n    console.error(new Error('disconnect'));\n    throw new Error('disconnect');\n  };\n\n  public set = async (key: string, value?: string): Promise<boolean | Error> => {\n    await this.waitTillConnecting();\n    const { isActive, storageProvider } = this;\n\n    if (!isActive || !storageProvider) {\n      return new Error('There is no connection to a StorageProvider');\n    }\n    return storageProvider.set(this.keyNameInStorage(key), value);\n  };\n\n  public setUInt8Array = async (key: string, value: Uint8Array): Promise<boolean | Error> => {\n    await this.waitTillConnecting();\n    const { isActive, storageProvider, isBufferSupported } = this;\n\n    if (!isActive || !storageProvider) {\n      return new Error('There is no connection to a StorageProvider');\n    }\n    if (!isBufferSupported || typeof storageProvider.setUInt8Array !== 'function') {\n      return new Error('The storage provider is not support this operation');\n    }\n    return storageProvider.setUInt8Array(this.keyNameInStorage(key), value);\n  };\n\n  public get = async (key: string): Promise<string | undefined | Error> => {\n    await this.waitTillConnecting();\n    const { isActive, storageProvider } = this;\n\n    if (!isActive || !storageProvider) {\n      return new Error('There is no connection to a StorageProvider');\n    }\n    return storageProvider.get(this.keyNameInStorage(key));\n  };\n\n  public getUInt8Array = async (key: string): Promise<Uint8Array | undefined | Error> => {\n    await this.waitTillConnecting();\n    const { isActive, storageProvider, isBufferSupported } = this;\n\n    if (!isActive || !storageProvider) {\n      return new Error('There is no connection to a StorageProvider');\n    }\n    if (!isBufferSupported || typeof storageProvider.getUInt8Array !== 'function') {\n      return new Error('The storage provider is not support this operation');\n    }\n    return storageProvider.getUInt8Array(this.keyNameInStorage(key));\n  };\n\n  public clearDb = async (): Promise<boolean | Error> => {\n    await this.waitTillConnecting();\n    const { isActive, storageProvider } = this;\n\n    if (!isActive || !storageProvider) {\n      return new Error('There is no connection to a StorageProvider');\n    }\n    const result = await this.storageProvider?.clearDb();\n\n    if (result instanceof Error) {\n      console.error(result);\n      return Error('Failed to clear the database with the storage provider');\n    }\n    return true;\n  };\n\n  /**\n   * added the prefix to the key\n   * to work around if the StorageProvider\n   * have no native support of a database name\n   *\n   * @protected\n   * @param {string} key\n   * @returns {string}\n   * @memberof OpenStorage\n   */\n  protected keyNameInStorage(key: string): string {\n    if (!this.isDbNameSupported && this.dbName) {\n      return `${this.dbName}_${key}`;\n    }\n    return `${OPEN_STORAGE_KEY_PREFIX}_${key}`;\n  }\n\n  protected setOptions(options?: IStorageProviderOptions) {\n    this.dbName = options ? options.dbName : undefined;\n  }\n\n  protected unsetOptions() {\n    this.dbName = undefined;\n  }\n\n  protected setStorageProviderConnection(storageProviderConnection: StorageProvider) {\n    this.storageProvider = storageProviderConnection;\n  }\n\n  protected unsetStorageProviderConnection() {\n    this.storageProvider = undefined;\n  }\n\n  protected async connectToStore(configuration?: IOpenStorageConfiguration): Promise<void> {\n    const { options, storageProviderName } = configuration || {};\n    const storageProvider = getStorageProviderByName(storageProviderName || STORAGE_PROVIDERS_NAME.LOCAL_FORAGE);\n\n    if (!storageProvider) {\n      throw new Error(`There is no storage provider with the name ${storageProviderName}`);\n    }\n\n    const connectToStorageProviderResult = await storageProvider.connect(options);\n\n    if (connectToStorageProviderResult instanceof Error) {\n      console.error(connectToStorageProviderResult);\n      throw new Error('Failed to connect to the storage provider');\n    }\n    this.setStorageProviderConnection(storageProvider);\n    this.setOptions(options);\n  }\n\n  protected setConnectingPromise(connectingPromise: Promise<void>): void {\n    this.connectingPromise = connectingPromise;\n  }\n\n  protected unsetConnectingPromise(): void {\n    this.connectingPromise = undefined;\n  }\n\n  protected async waitTillConnecting(): Promise<void> {\n    await this.connectingPromise;\n  }\n}\n","/home/paul/projects/protocol/src/classes/open-storage/open-storage.types.ts",[],"/home/paul/projects/protocol/src/classes/pseudo-ntp-class/index.ts",[],"/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.const.ts",[],"/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.ts",["2895","2896","2897","2898","2899","2900","2901","2902","2903","2904","2905","2906","2907","2908","2909","2910","2911","2912","2913","2914","2915","2916","2917","2918"],"import { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport {\n  IPseudoNTPClassEvents,\n  IPseudoNTPClassOptions,\n  TPseudoNTPClassServersPoolOption,\n  IPseudoNTPClassServerConnection,\n  IPseudoNTPClassCommonOptionsMilliseconds,\n  TPseudoNTPClassServerResponse,\n  TPseudoNTPClassResponseWithTimesamps,\n  IPseudoNTPClassServerConnectionField,\n  IPseudoNTPClassServerConnectionCb,\n} from './pseudo-ntp-class.types';\nimport {\n  PSEUDO_NTP_CLASS_DEFAULT_OPTIONS,\n  PSEUDO_NTP_CLASS_LOGS_PREFIX,\n  PSEUDO_NTP_CLASS_EVENTS,\n  PSEUDO_NTP_CLASS_REQUEST_OPTIONS,\n} from './pseudo-ntp-class.const';\nimport { getTimestampSeconds, addSecondsToDate, datesDifferenceSeconds } from './pseudo-ntp-class.utils';\nimport HttpRequest from 'classes/basic-classes/http-request-class-base/http-request-class-base';\nimport { IHttpRequestOptions } from 'classes/basic-classes/http-request-class-base/http-request-class-base.types';\n\n/**\n * This is class for time sync with the\n * server which provides API to get\n * the current date and time in UTC.\n * This allows to sync time for all users.\n *\n * @export\n * @class PseudoNTPClass\n * @extends {EventEmitter<IPseudoNTPClassEvents>}\n */\nexport class PseudoNTPClass extends EventEmitter<IPseudoNTPClassEvents> {\n  public static Event = PSEUDO_NTP_CLASS_EVENTS;\n\n  /**\n   * true if the sync is running on\n   *\n   * @type {boolean}\n   * @memberof PseudoNTPClass\n   */\n  public isRunning: boolean = false;\n\n  /**\n   * if sync process is running at now\n   * then this flag will be set on true\n   *\n   * @protected\n   * @type {boolean}\n   * @memberof PseudoNTPClass\n   */\n  protected isSyncInProgress: boolean = false;\n\n  protected serversPool?: TPseudoNTPClassServersPoolOption;\n\n  // index of the server connected to\n  protected currentServerIndex?: number;\n\n  // options of the server connected to\n  protected currentServerOptions?: IPseudoNTPClassServerConnection;\n\n  protected currentServerRequestOptions?: IHttpRequestOptions;\n\n  // a number of fails for the current server\n  protected currentServerFails: number = 0;\n\n  /**\n   * the options used for requesting\n   *\n   * @protected\n   * @type {IPseudoNTPClassCommonOptionsMilliseconds}\n   * @memberof PseudoNTPClass\n   */\n  protected commonOptions: IPseudoNTPClassCommonOptionsMilliseconds = PSEUDO_NTP_CLASS_DEFAULT_OPTIONS;\n\n  /**\n   * the active interval for requesting\n   * the server\n   *\n   * @protected\n   * @type {NodeJS.Timer}\n   * @memberof PseudoNTPClass\n   */\n  protected intervalRunning?: NodeJS.Timeout;\n\n  constructor(options: IPseudoNTPClassOptions) {\n    super();\n    this.setOptions(options);\n  }\n\n  /**\n   * start the requesting of the servers in the pool\n   *\n   * @memberof PseudoNTPClass\n   */\n  public start() {\n    this.setCurrentServerFromPool();\n    this.startInterval();\n  }\n\n  /**\n   * stop the requesting of the servers in the pool\n   *\n   * @memberof PseudoNTPClass\n   */\n  public stop() {\n    this.stopInterval();\n  }\n\n  /**\n   * write something in console.log\n   *\n   * @protected\n   * @param {(Error | string)} message\n   * @memberof PseudoNTPClass\n   */\n  protected log = (message: Error | string) => {\n    const { currentServerOptions } = this;\n    const consoleMethod = message instanceof Error ? 'error' : 'log';\n\n    console[consoleMethod](\n      PSEUDO_NTP_CLASS_LOGS_PREFIX,\n      `server is ${currentServerOptions ? currentServerOptions.server : 'not defined'}`,\n      message\n    );\n  };\n\n  /**\n   * check is a server's options are valid\n   *\n   * @protected\n   * @param {*} options\n   * @returns {options is IPseudoNTPClassServerConnection}\n   * @memberof PseudoNTPClass\n   */\n  protected checkServerOptions(options: any): options is IPseudoNTPClassServerConnection {\n    return !!options && typeof options === 'object' && typeof options.server === 'string' && !!options.server.length;\n  }\n\n  /**\n   * set options for the instance and\n   * convert seconds in milliseconds\n   * for all the options\n   *\n   * @protected\n   * @param {IPseudoNTPClassOptions} options\n   * @memberof PseudoNTPClass\n   * @throws\n   */\n  protected setOptions(options: IPseudoNTPClassOptions) {\n    const { serversPool, maxFailedResponses, maxOffsetErrorS, responseTimeoutS, retryRequestDelayS, syncIntervalS } = options;\n\n    if (!(serversPool instanceof Array) || !serversPool.length) {\n      throw new Error('The \"servers pool\" option must be defined');\n    }\n    this.serversPool = serversPool;\n\n    const optionsInMs = {\n      maxFailedResponses:\n        typeof maxFailedResponses === 'number' ? maxFailedResponses : PSEUDO_NTP_CLASS_DEFAULT_OPTIONS.maxFailedResponses,\n      maxOffsetErrorS: typeof maxOffsetErrorS === 'number' ? maxOffsetErrorS : PSEUDO_NTP_CLASS_DEFAULT_OPTIONS.maxOffsetErrorS,\n      responseTimeoutMs:\n        typeof responseTimeoutS === 'number' ? responseTimeoutS * 1000 : PSEUDO_NTP_CLASS_DEFAULT_OPTIONS.responseTimeoutMs,\n      retryRequestDelayMs:\n        typeof retryRequestDelayS === 'number' ? retryRequestDelayS * 1000 : PSEUDO_NTP_CLASS_DEFAULT_OPTIONS.retryRequestDelayMs,\n      syncIntervalMs: typeof syncIntervalS === 'number' ? syncIntervalS * 1000 : PSEUDO_NTP_CLASS_DEFAULT_OPTIONS.syncIntervalMs,\n    };\n\n    this.commonOptions = optionsInMs;\n  }\n\n  protected setCurrentServerFromPoolIndex(): void {\n    const { serversPool, currentServerIndex } = this;\n    const serversPoolLength = serversPool!.length;\n    let currentServerIndexResolved: number;\n\n    if (typeof currentServerIndex === 'number') {\n      if (currentServerIndex === serversPoolLength) {\n        currentServerIndexResolved = 0;\n      }\n      currentServerIndexResolved = currentServerIndex + 1;\n    } else {\n      currentServerIndexResolved = 0;\n    }\n    this.currentServerIndex = currentServerIndexResolved;\n  }\n\n  /**\n   * create an object to send the request\n   * to the server to request the current\n   * date and time\n   *\n   * @protected\n   * @returns {(void | Error)}\n   * @memberof PseudoNTPClass\n   */\n  protected setCurrentServerRequestOptions(): void | Error {\n    const { currentServerOptions } = this;\n    const { server: serverUrl } = currentServerOptions!;\n\n    if (!currentServerOptions) {\n      return new Error('The current server options is not defined');\n    }\n    this.currentServerRequestOptions = {\n      ...PSEUDO_NTP_CLASS_REQUEST_OPTIONS,\n      url: serverUrl,\n    };\n  }\n\n  protected setCurrentServerFromPoolOptions(): void {\n    const { serversPool, currentServerIndex } = this;\n    const currentServerOptions = serversPool![currentServerIndex || 0];\n\n    if (!this.checkServerOptions(currentServerOptions)) {\n      // if the options is not defined for the server or there is no url for it\n      // choose another server from the pool\n      this.log(`Options is not defined for the server under the index ${currentServerIndex} in the pool`);\n      this.setCurrentServerFromPoolIndex();\n      return this.setCurrentServerFromPoolOptions();\n    }\n    this.currentServerOptions = currentServerOptions;\n\n    const serCurrentServerRequestOptionsResult = this.setCurrentServerRequestOptions();\n\n    if (serCurrentServerRequestOptionsResult instanceof Error) {\n      return this.setCurrentServerFromPoolOptions();\n    }\n  }\n\n  protected resetCurrentServerDescription() {\n    this.currentServerFails = 0;\n    this.currentServerOptions = undefined;\n  }\n\n  /**\n   * choose the next server from the pool\n   * and set it's options to use as the\n   * current server\n   *\n   * @protected\n   * @memberof PseudoNTPClass\n   */\n  protected setCurrentServerFromPool() {\n    this.resetCurrentServerDescription();\n    this.setCurrentServerFromPoolIndex();\n    this.setCurrentServerFromPoolOptions();\n  }\n\n  /**\n   * send a request to the server\n   * and handle a response from it\n   *\n   * @protected\n   * @memberof PseudoNTPClass\n   */\n  protected sync = async (): Promise<void> => {\n    const { isSyncInProgress } = this;\n\n    if (isSyncInProgress) {\n      // if the sync process is\n      // already is running on\n      return;\n    }\n    this.isSyncInProgress = true;\n\n    const response = await this.sendRequestToCurrentServer();\n\n    if (response instanceof Error) {\n      return this.handleSyncFail(response);\n    }\n\n    const resultOfHandlig = await this.handleServerResponse(response);\n\n    if (resultOfHandlig instanceof Error) {\n      return this.handleSyncFail(resultOfHandlig);\n    }\n    this.isSyncInProgress = false;\n  };\n\n  /**\n   * starts the interval for requesting\n   * the current server from the servers\n   * pool for it's current time\n   *\n   * @protected\n   * @memberof PseudoNTPClass\n   */\n  protected startInterval(): void {\n    const { commonOptions } = this;\n    const { syncIntervalMs } = commonOptions;\n\n    if (this.isRunning) {\n      this.log('Want to start the instance already running');\n    } else {\n      this.intervalRunning = setInterval(this.sync, syncIntervalMs);\n      this.isRunning = true;\n      void this.sync();\n    }\n  }\n\n  protected stopInterval() {\n    if (this.intervalRunning) {\n      clearInterval(this.intervalRunning);\n      this.intervalRunning = undefined;\n    }\n    this.isRunning = false;\n  }\n\n  /**\n   * handle failed sync attempt\n   *\n   * @param err\n   */\n  protected handleSyncFail(err?: Error) {\n    if (err instanceof Error) {\n      this.log(`Request failed ${err.message}`);\n    }\n\n    const { currentServerFails, commonOptions } = this;\n    const { maxFailedResponses } = commonOptions;\n\n    if (currentServerFails > maxFailedResponses) {\n      this.log(`There is ${currentServerFails} fail`);\n      this.setCurrentServerFromPool();\n    }\n  }\n\n  /**\n   * returns the date from the server response\n   * or an error\n   *\n   * @private\n   * @memberof PseudoNTPClass\n   */\n  protected parseServerResponse = (response: TPseudoNTPClassServerResponse): Error | Date => {\n    const { currentServerOptions } = this;\n\n    if (typeof (currentServerOptions as IPseudoNTPClassServerConnectionField).fieldName === 'string') {\n      const { fieldName } = currentServerOptions as IPseudoNTPClassServerConnectionField;\n\n      if (typeof response !== 'object') {\n        return new Error(`Response must be an object to get the date from the field ${fieldName}`);\n      }\n\n      const fieldValue = (response as any)[fieldName];\n\n      if (typeof fieldValue !== 'string') {\n        return new Error(`Response field ${fieldName} must be a string`);\n      }\n      try {\n        const resultParse = new Date(fieldValue);\n\n        if (resultParse instanceof Date) {\n          return resultParse;\n        }\n        return new Error(`Failed to parse string from the server response from field ${fieldName}`);\n      } catch (err) {\n        return err;\n      }\n    }\n    if (typeof (currentServerOptions as IPseudoNTPClassServerConnectionCb).parseCallback === 'function') {\n      const { parseCallback } = currentServerOptions as IPseudoNTPClassServerConnectionCb;\n\n      if (!parseCallback.length) {\n        this.log('The callback seems to have no arguments accepted');\n      }\n      try {\n        const parseResponseResult = parseCallback(response);\n\n        if (parseResponseResult instanceof Error) {\n          return parseResponseResult;\n        }\n        if (parseResponseResult instanceof Date) {\n          return parseResponseResult;\n        }\n      } catch (err) {}\n      return new Error('The server response do not parse correctly');\n    }\n    if (typeof response === 'string') {\n      try {\n        const resultParse = new Date(response);\n\n        if (resultParse instanceof Date) {\n          return resultParse;\n        }\n      } catch (err) {}\n      return new Error('Failed to parse string from the server response');\n    }\n    return new Error('There is unknown response format');\n  };\n\n  protected emitClientServerTimeDifference(timeDifferenceSeconds: number) {\n    this.emit(PSEUDO_NTP_CLASS_EVENTS.TIME_SYNC, timeDifferenceSeconds);\n  }\n\n  /**\n   * handle Date received in a server response\n   * and make an adjustment based on the on the\n   * time the request was sent and\n   * the response was received.\n   * If the difference is more than the max error\n   * then emit the event.\n   *\n   * @protected\n   * @param {Date} serverDate\n   * @param {number} timestampReq - request sent in seconds\n   * @param {number} timestampRes - response received in seconds\n   * @param {Date} dateRes - Date when the responce received\n   * @memberof PseudoNTPClass\n   */\n  protected handleServerDate(serverDate: Date, timestampReq: number, timestampRes: number, dateRes: Date): void {\n    // we think that the request was received on the\n    // server at half of the request-response time\n    const adjustmentS = (timestampRes - timestampReq) / 2;\n    const clientDate = addSecondsToDate(dateRes, adjustmentS);\n    const offsetClientTimeFromServer = datesDifferenceSeconds(clientDate, serverDate);\n\n    if (offsetClientTimeFromServer) {\n      const { commonOptions } = this;\n      const { maxOffsetErrorS } = commonOptions;\n\n      if (Math.abs(offsetClientTimeFromServer) > maxOffsetErrorS) {\n        this.log(`The client-server time difference is equals to ${offsetClientTimeFromServer}`);\n        this.emitClientServerTimeDifference(offsetClientTimeFromServer);\n      }\n    }\n  }\n\n  protected convertServerResponseRaw(responseRaw: { [key: string]: string }): TPseudoNTPClassServerResponse | Error {\n    return responseRaw;\n  }\n\n  /**\n   * handle the responce from the server\n   *\n   * @private\n   * @memberof PseudoNTPClass\n   */\n  private handleServerResponse = async (responseWithTimestamps: TPseudoNTPClassResponseWithTimesamps): Promise<void | Error> => {\n    const { responseRaw, timestampReq, timestempRes, dateRes } = responseWithTimestamps;\n    const response = this.convertServerResponseRaw(responseRaw);\n\n    if (response instanceof Error) {\n      return response;\n    }\n\n    const responseResult = this.parseServerResponse(response);\n\n    if (responseResult instanceof Error) {\n      return responseResult;\n    }\n    if (responseResult instanceof Date) {\n      return this.handleServerDate(responseResult, timestampReq, timestempRes, dateRes);\n    }\n    return new Error('An unknown result of parsing the response');\n  };\n\n  /**\n   * send the HTTP request to the current\n   * server from the pool\n   *\n   * @private\n   * @memberof PseudoNTPClass\n   */\n  private async sendRequestToCurrentServer(): Promise<Error | TPseudoNTPClassResponseWithTimesamps> {\n    const { currentServerRequestOptions } = this;\n    // timestamp when the request sent\n    const timestampReq = getTimestampSeconds();\n    const request = new HttpRequest({\n      ...currentServerRequestOptions!,\n    });\n    let responseRaw;\n\n    try {\n      responseRaw = await request.send();\n\n      if (responseRaw instanceof Error) {\n        console.error(responseRaw);\n        return new Error('The request failed');\n      }\n    } catch (err) {\n      return err;\n    }\n    // timestamp when the response received\n    const timestempRes = getTimestampSeconds();\n    const dateRes = new Date();\n    return {\n      responseRaw,\n      timestampReq,\n      timestempRes,\n      dateRes,\n    };\n  }\n}\n\nexport default PseudoNTPClass;\n","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.types.ts",["2919","2920"],"import { PSEUDO_NTP_CLASS_EVENTS } from './pseudo-ntp-class.const';\n\nexport type TPseudoNTPClassResponseRaw = any;\n\n/**\n * @param {number} timestampReq - timestamp when the request was sent\n * @param {number} timestempRes - timestamp when the response was received\n * @param {Date} dateRes - date when the response was received\n * @param {TPseudoNTPClassResponseRaw} responseRaw - reqponse from the server\n */\nexport type TPseudoNTPClassResponseWithTimesamps = {\n  timestampReq: number;\n  timestempRes: number;\n  dateRes: Date;\n  responseRaw: TPseudoNTPClassResponseRaw;\n};\n\n/**\n *  events emitted by the pseudo ntp\n *\n * @export\n * @interface IPseudoNTPClassEvents\n */\nexport interface IPseudoNTPClassEvents {\n  /**\n   * after syncronization with the\n   * server emit the event and\n   * returns the time offset in\n   * seconds\n   */\n  [PSEUDO_NTP_CLASS_EVENTS.TIME_SYNC]: number;\n}\n\nexport type TPseudoNTPClassServerResponse = string | { [key: string]: any };\n\n/**\n *\n * @export\n * @interface IPseudoNTPClassServerConnection\n * @param {string} server - the url of the server connect to\n * @param {string} fieldName - name of the field where is\n * the server's current date as a string in ISO format\n * @param {function} parseCallback - callback which called\n * to parse the response from the server and must return\n * the Date on the server\n */\nexport interface IPseudoNTPClassServerConnectionField {\n  server: string;\n  fieldName: string;\n}\nexport interface IPseudoNTPClassServerConnectionCb {\n  server: string;\n  parseCallback: (response: TPseudoNTPClassServerResponse) => Date | Error;\n}\nexport type IPseudoNTPClassServerConnection = IPseudoNTPClassServerConnectionCb | IPseudoNTPClassServerConnectionField;\n\nexport type TPseudoNTPClassServersPoolOption = IPseudoNTPClassServerConnection[];\n\n/**\n * @param {number} [1] responseTimeoutS - timeout for reponse from the\n * server in seconds\n * @param {number} [60] syncIntervalS - interval in seconds to request the server\n * to get the time on it\n * @param {number} [10] maxOffsetErrorS - the maximum offset between the client\n * and the server time which will not be suggested as error\n * @param {number} [3] maxFailedResponses - the maximum fails of the responses\n * to switch on the another server\n * @param {number} [5] retryRequestDelayS - the delay to repeat the request\n * after fail\n */\nexport interface IPseudoNTPClassCommonOptions {\n  syncIntervalS?: number;\n  maxFailedResponses?: number;\n  retryRequestDelayS?: number;\n  responseTimeoutS?: number;\n  maxOffsetErrorS?: number;\n}\n\nexport interface IPseudoNTPClassCommonOptionsMilliseconds {\n  syncIntervalMs: number;\n  maxFailedResponses: number;\n  retryRequestDelayMs: number;\n  responseTimeoutMs: number;\n  maxOffsetErrorS: number;\n}\n\n/**\n * options for pseudo ntp class\n *\n * @export\n * @interface IPseudoNTPClassOptions\n * @param {IPseudoNTPClassServerConnection[]} serversPool - this is options for\n * the pool of the servers to receive the current date and time\n */\nexport interface IPseudoNTPClassOptions extends IPseudoNTPClassCommonOptions {\n  serversPool: TPseudoNTPClassServersPoolOption;\n}\n","/home/paul/projects/protocol/src/classes/pseudo-ntp-class/pseudo-ntp-class.utils.ts",["2921"],"export const getSecondsByMilliseconds = (ms: number): number => Math.round(ms / 1000);\n\nexport const getTimestampSeconds = () => getSecondsByMilliseconds(performance.now());\n\nexport const addSecondsToDate = (date: Date, seconds: number): Date => {\n  date.setSeconds(date.getSeconds() + seconds);\n  return date;\n};\n\nexport const datesDifferenceSeconds = (dateMinuend: Date, dateSubtrahend: Date): number => {\n  return getSecondsByMilliseconds(dateMinuend.getTime() - dateSubtrahend.getTime());\n};\n","/home/paul/projects/protocol/src/classes/safe-storage-class/index.ts",[],"/home/paul/projects/protocol/src/classes/safe-storage-class/safe-storage-class.const.ts",[],"/home/paul/projects/protocol/src/classes/safe-storage-class/safe-storage-class.ts",["2922","2923","2924","2925","2926","2927","2928","2929","2930","2931","2932","2933","2934","2935","2936"],"import {\n  ISafeStorageOptions,\n  TSafeStorageStoredDataType,\n  TSafeStorageStoredDataTypeKeyValue,\n  TSafeStorageStoredDataTypeAppendLog,\n  TSafeStorageDataTypesAvail,\n  TSafeStorageKeyType,\n  TSafeStorageDataType,\n  TSafeStorageStorageAppendLogDataType,\n} from './safe-storage-class.types';\nimport { DEFAULT_INTERVAL_MS } from 'classes/basic-classes/queue-manager-class-base/queue-manager-class-base.const';\nimport { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';\nimport {\n  SAFE_STORAGE_DUMP_PROVIDER_DEFAULT,\n  ESAFE_STORAGE_PROVIDER_STATUS,\n  SAFE_STORAGE_STORAGE_NAME_COMMON_PREFIX,\n  ESAFE_STORAGE_STORAGE_TYPE,\n  SAFE_STORAGE_MAX_ITEMS_APPEND_LOG,\n  SAFE_STORAGE_KEY_VALUE_INITIAL_VALUE,\n  SAFE_STORAGE_APPEND_LOG_INITIAL_VALUE,\n  SAFE_STORAGE_APPEND_LOG_APPEND_DATA_INITIAL_VALUE,\n  SAFE_STORAGE_KEY_VALUE_APPEND_DATA_INITIAL_VALUE,\n  SAFE_STORAGE_STORAGE_APPEND_LOG_COMMON_POSTFIX,\n  SAFE_STORAGE_ATTEMPTS_TO_SAVE_DATA_TO_STORAGE,\n  SAFE_STORAGE_DEFAULT_STORAGE_BUSY_TIMEOUT_MS,\n} from './safe-storage-class.const';\nimport { getStatusClass, STATUS_EVENT } from 'classes/basic-classes/status-class-base/status-class-base';\n\nexport class SafeStorage<TYPE extends ESAFE_STORAGE_STORAGE_TYPE> extends getStatusClass<typeof ESAFE_STORAGE_PROVIDER_STATUS>({\n  errorStatus: ESAFE_STORAGE_PROVIDER_STATUS.ERROR,\n  instanceName: 'SafeStorage',\n}) {\n  static storagesNames: string[] = []; // exists storages names, put it from constructor\n\n  static checkIfNameIsExists(storageName: string) {\n    const { storagesNames } = SafeStorage;\n\n    return storagesNames.includes(storageName);\n  }\n\n  static addStorageName(storageName: string) {\n    const { storagesNames } = SafeStorage;\n\n    storagesNames.push(storageName);\n  }\n\n  protected storageName: string = '';\n\n  protected storageNameAppendLog: string = '';\n\n  protected options?: ISafeStorageOptions;\n\n  protected dumpIntervalMs?: number;\n\n  protected dumpIntervalRunning?: NodeJS.Timeout | number;\n\n  protected secretStorageConnection?: InstanceType<typeof SecretStorage>;\n\n  protected tableData: TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE> = [] as TSafeStorageStoredDataType<\n    ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n  >;\n\n  /**\n   *\n   * this is data which will be merged with the data from storage\n   * and then will be write to the storage\n   * @protected\n   * @type {TSafeStorageStoredDataType<\n   *     ESAFE_STORAGE_STORAGE_TYPE\n   *   >}\n   * @memberof SafeStorage\n   */\n  protected appendData: TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE> = [] as TSafeStorageStoredDataType<\n    ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n  >;\n\n  /**\n   *\n   * here a data will be placed if any dumping of appendData is in progress,\n   * on a dumping will be ended up, data\n   * from this property will be merged with the appendData property\n   * @protected\n   * @type {TSafeStorageStoredDataType<\n   *     ESAFE_STORAGE_STORAGE_TYPE\n   *   >}\n   * @memberof SafeStorage\n   */\n  protected appendDataTemp: TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE> = [] as TSafeStorageStoredDataType<\n    ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n  >;\n\n  protected storageType?: ESAFE_STORAGE_STORAGE_TYPE;\n\n  constructor(options: ISafeStorageOptions) {\n    super();\n\n    const setOptionsResult = this.setOptions(options);\n\n    if (setOptionsResult instanceof Error) {\n      throw setOptionsResult;\n    }\n    this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.NEW);\n    if (options.storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG) {\n      this.appendData = [] as TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG>;\n      this.appendDataTemp = [] as TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG>;\n    } else {\n      this.appendData = {} as TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE>;\n      this.appendDataTemp = {} as TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE>;\n    }\n  }\n\n  get secretStorageOptions() {\n    const { options } = this;\n    const { storageDumpProvider } = options as ISafeStorageOptions;\n\n    return {\n      storageProviderName: storageDumpProvider || SAFE_STORAGE_DUMP_PROVIDER_DEFAULT,\n    };\n  }\n\n  get isStorageBusy(): boolean {\n    const { status } = this;\n\n    return status === ESAFE_STORAGE_PROVIDER_STATUS.WORKING_WITH_STORAGE;\n  }\n\n  /**\n   * connect to the secret storage\n   * and preload a data dumped\n   * from it\n   * @returns {boolean | Error} - true on success, false if connecting is\n   * already in progress, Error if an error has occurred\n   */\n  async connect(): Promise<boolean | Error> {\n    const { status, options } = this;\n\n    if (status !== ESAFE_STORAGE_PROVIDER_STATUS.CONNECTING_TO_STORAGE) {\n      const { credentials } = options as ISafeStorageOptions;\n      const connectionToTheSecretStorage = this.createSecretStorageInstance();\n\n      if (connectionToTheSecretStorage instanceof Error) {\n        return connectionToTheSecretStorage;\n      }\n      this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.CONNECTING_TO_STORAGE);\n\n      const connectionToSecretStorageResult = await connectionToTheSecretStorage.authorize(credentials);\n\n      if (connectionToSecretStorageResult instanceof Error) {\n        return this.setErrorStatus(connectionToSecretStorageResult);\n      }\n      this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.CONNECTED_TO_STORAGE);\n\n      const preloadDataResult = await this.reloadOverallTableData();\n\n      if (preloadDataResult instanceof Error) {\n        return preloadDataResult;\n      }\n\n      const startIntervalResult = this.startInterval();\n\n      if (startIntervalResult instanceof Error) {\n        return this.setErrorStatus(startIntervalResult);\n      }\n      this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.READY);\n      return true;\n    }\n    return false;\n  }\n\n  checkOptionsAreValid(options: ISafeStorageOptions): Error | true {\n    const { name, credentials } = options;\n\n    if (typeof credentials !== 'object' || !credentials || !credentials.password) {\n      return this.setErrorStatus('SafeStorage: a storage with the name is already exists');\n    }\n    if (SafeStorage.checkIfNameIsExists(name)) {\n      return this.setErrorStatus('SafeStorage: a storage with the name is already exists');\n    }\n    return true;\n  }\n\n  setOptions(options: ISafeStorageOptions): Error | true {\n    const { name, dumpIntervalMs, storageType } = options;\n    const checkOptionsResult = this.checkOptionsAreValid(options);\n    const dumpInterval = typeof dumpIntervalMs === 'number' ? dumpIntervalMs : DEFAULT_INTERVAL_MS;\n    const storageTypeResolved =\n      storageType && Object.values(ESAFE_STORAGE_STORAGE_TYPE).includes(storageType)\n        ? storageType\n        : ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG;\n\n    if (checkOptionsResult instanceof Error) {\n      return checkOptionsResult;\n    }\n    SafeStorage.addStorageName(name);\n    this.options = {\n      ...options,\n      dumpIntervalMs: dumpInterval,\n      storageType: storageTypeResolved,\n    };\n    this.storageType = storageTypeResolved;\n\n    const storageName = `${SAFE_STORAGE_STORAGE_NAME_COMMON_PREFIX}${name}`;\n\n    this.storageName = storageName;\n    this.storageNameAppendLog = `${storageName}${SAFE_STORAGE_STORAGE_APPEND_LOG_COMMON_POSTFIX}`;\n    this.dumpIntervalMs = dumpInterval;\n    return true;\n  }\n\n  /**\n   * load all the data from the secret storage\n   * and put all the data to the memory table\n   */\n  async reloadOverallTableData(): Promise<boolean | Error> {\n    // load data from the storage\n    // and it's append log\n    const tableData = await this.loadOverallTable();\n\n    if (tableData instanceof Error) {\n      return this.setErrorStatus(tableData);\n    }\n    // set all data to the memory table\n    this.setTableData(tableData);\n    return true;\n  }\n\n  /**\n   * disconnect from the secret storage\n   * and dump the data before it\n   */\n  async disconnect(): Promise<Error | true> {\n    const { dumpIntervalRunning } = this;\n\n    if (typeof dumpIntervalRunning === 'number') {\n      clearInterval(dumpIntervalRunning);\n    }\n\n    // dump the data before disconnection\n    const resultDumping = await this.dumpData();\n\n    if (resultDumping === true) {\n      this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.DISCONNECTED);\n      return true;\n    }\n    return this.setErrorStatus(\"Can't dump the table's data before disconnected\");\n  }\n\n  /**\n   * @returns {boolean} - returns true if the storage is freed\n   * false - on timeout\n   */\n  waitingStorageFreed(): Promise<boolean | undefined> | true {\n    if (!this.isStorageBusy) {\n      return true;\n    }\n\n    return new Promise((res) => {\n      const timeout = setTimeout(res, SAFE_STORAGE_DEFAULT_STORAGE_BUSY_TIMEOUT_MS);\n      const { statusEmitter } = this;\n\n      statusEmitter.once(STATUS_EVENT, () => {\n        if (!this.isStorageBusy) {\n          clearTimeout(timeout);\n          res(true);\n        }\n      });\n    });\n  }\n\n  castDataToAppendLogType(data?: null | TSafeStorageStoredDataType<TYPE>): TSafeStorageStoredDataTypeAppendLog | Error {\n    if (data == null) {\n      return [] as TSafeStorageStoredDataTypeAppendLog;\n    }\n    if (data instanceof Array) {\n      return data as TSafeStorageStoredDataTypeAppendLog;\n    }\n    return new Error(`There is a wrong data type ${typeof data} for the append log storage`);\n  }\n\n  castDataToKeyValueType(data?: null | TSafeStorageStoredDataType<TYPE>): TSafeStorageStoredDataTypeKeyValue | Error {\n    if (data == null) {\n      return {} as TSafeStorageStoredDataTypeKeyValue;\n    }\n    if (!(data instanceof Array) && typeof data === 'object') {\n      return data as TSafeStorageStoredDataTypeKeyValue;\n    }\n    return new Error(`There is a wrong data type ${typeof data} for a key value storage`);\n  }\n\n  /**\n   * check if the data given\n   * is conformed to the\n   * storage type and\n   * return an Error if it's\n   * not conformed or data in\n   * storage type\n   * @param data\n   */\n  castDataToStorageType(data?: Error | null | TSafeStorageStoredDataType<TYPE>): TSafeStorageStoredDataType<TYPE> | Error {\n    if (data instanceof Error) {\n      return data;\n    }\n\n    const { storageType } = this;\n\n    switch (storageType) {\n      case ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG:\n        return this.castDataToAppendLogType(data) as TSafeStorageStoredDataType<TYPE>;\n      default:\n        return this.castDataToKeyValueType(data) as TSafeStorageStoredDataType<TYPE>;\n    }\n  }\n\n  /**\n   * parse a data stringified\n   * before save it to the storage\n   * and read from the secret storage\n   * as a string.\n   * @param {string | Error | undefined} data\n   */\n  parseDataFromStorage<D>(data: string | undefined | Error): Error | D | undefined {\n    if (data instanceof Error) {\n      return this.setErrorStatus(data);\n    }\n    if (data == null) {\n      return undefined;\n    }\n    try {\n      return JSON.parse(data) as D | undefined;\n    } catch (err) {\n      return err as Error;\n    }\n  }\n\n  /**\n   * merge the data and cast it to the\n   * storage type\n   * returns the merged data\n   * casted to the storage type\n   * @memberof SafeStorage\n   * @param { object | array } result\n   * @param { string | object | array }\n   * @returns { object | array | Error }\n   */\n  mergeData = (\n    result: TSafeStorageStoredDataType<TYPE> | Error,\n    dataToAppend: string | TSafeStorageStoredDataType<TYPE>\n  ): TSafeStorageStoredDataType<TYPE> | Error => {\n    const { storageType } = this;\n    const isAppendLogStorage = storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG;\n\n    if (result instanceof Error) {\n      return result;\n    }\n\n    const dataObj = typeof dataToAppend === 'string' ? this.parseDataFromStorage(dataToAppend) : dataToAppend;\n    const dataCastedToStorageType = this.castDataToStorageType(dataObj as Error | TSafeStorageStoredDataType<TYPE>);\n    if (dataCastedToStorageType instanceof Error) {\n      return this.setErrorStatus(dataCastedToStorageType);\n    }\n    return (isAppendLogStorage\n      ? [...(result as TSafeStorageStoredDataTypeAppendLog), ...(dataCastedToStorageType as TSafeStorageStoredDataTypeAppendLog)]\n      : {\n          ...(result as TSafeStorageStoredDataTypeKeyValue),\n          ...(dataCastedToStorageType as TSafeStorageStoredDataTypeKeyValue),\n        }) as TSafeStorageStoredDataType<TYPE>;\n  };\n\n  /**\n   * load a data from the key\n   * named as storage name param\n   * of the secret storage connected\n   * to and return this data\n   * @param {string} storageName\n   */\n  async loadDataFromTable<D>(storageName: string): Promise<D | undefined | Error> {\n    const { secretStorageConnection } = this;\n\n    if (await this.waitingStorageFreed()) {\n      const setPreviousStatus = this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.WORKING_WITH_STORAGE);\n      const data = await (secretStorageConnection as SecretStorage).get(storageName);\n\n      setPreviousStatus();\n\n      const parsedDate = this.parseDataFromStorage(data || undefined);\n\n      if (parsedDate instanceof Error) {\n        return this.setErrorStatus(parsedDate);\n      }\n      return parsedDate as D | undefined;\n    }\n    return new Error(`The storage is too busy`);\n  }\n\n  /**\n   * load data from append log key\n   * of the secret storage connected to\n   */\n  loadDataFromStorageAppendLog(): Promise<TSafeStorageStorageAppendLogDataType | undefined | Error> {\n    const { storageNameAppendLog } = this;\n\n    return this.loadDataFromTable<TSafeStorageStorageAppendLogDataType>(storageNameAppendLog);\n  }\n\n  /**\n   * load data from the append log key\n   * of the secret storage connected to\n   * parse it as an array of data append\n   * and return in a type of the storage:\n   * 1) array for an APPEND LOG type storage\n   * 2) object for an KEY VALUE type storage\n   */\n  async loadAndParseDataFromAppendLogStorage(): Promise<TSafeStorageStoredDataType<TYPE> | undefined | Error> {\n    const tableAppendlogsArray = await this.loadDataFromStorageAppendLog();\n    if (tableAppendlogsArray instanceof Error) {\n      return tableAppendlogsArray;\n    }\n    if (tableAppendlogsArray == null) {\n      return undefined;\n    }\n    if (tableAppendlogsArray instanceof Array) {\n      return tableAppendlogsArray\n        .map((str) => (typeof str === 'string' ? decodeURIComponent(str) : str))\n        .reduce(this.mergeData, this.castDataToStorageType(undefined) as TSafeStorageStoredDataType<TYPE>);\n    }\n  }\n\n  loadDataFromMainStorage(): Promise<TSafeStorageStoredDataType<TYPE> | undefined | Error> {\n    const { storageName } = this;\n\n    return this.loadDataFromTable<TSafeStorageStoredDataType<TYPE>>(storageName);\n  }\n\n  /**\n   * loads a data from the main storage\n   * and the append log\n   * and merge it\n   */\n  async loadOverallData(): Promise<TSafeStorageStoredDataType<TYPE> | Error> {\n    const storageMainTableData = this.castDataToStorageType(await this.loadDataFromMainStorage());\n    if (storageMainTableData instanceof Error) {\n      return this.setErrorStatus(storageMainTableData);\n    }\n\n    const storageDataFromAppendLogTable = this.castDataToStorageType(await this.loadAndParseDataFromAppendLogStorage());\n    if (storageDataFromAppendLogTable instanceof Error) {\n      return this.setErrorStatus(storageDataFromAppendLogTable);\n    }\n    return this.mergeData(storageMainTableData, storageDataFromAppendLogTable);\n  }\n\n  /**\n   * save a data to the secret storage\n   * to the key with name\n   * storageName\n   * @param {string} storageName\n   * @param {string | null | undefined} dataStringified\n   */\n  async saveDataToStorage(storageName: string, dataStringified?: string | null): Promise<boolean | Error> {\n    const { secretStorageConnection, status } = this;\n\n    if (dataStringified !== null && typeof dataStringified !== 'string') {\n      const err = new Error(`The table overall data must be null or string, but ${typeof dataStringified} was given`);\n\n      console.error(err);\n      return err;\n    }\n\n    let attempt = 0;\n\n    if (await this.waitingStorageFreed()) {\n      const setPrevStatus = this.setStatus(ESAFE_STORAGE_PROVIDER_STATUS.WORKING_WITH_STORAGE);\n\n      while ((attempt += 1) < SAFE_STORAGE_ATTEMPTS_TO_SAVE_DATA_TO_STORAGE) {\n        if (\n          !(\n            (secretStorageConnection as InstanceType<typeof SecretStorage>).set(storageName, dataStringified || '') instanceof\n            Error\n          )\n        ) {\n          setPrevStatus();\n          return true;\n        }\n      }\n      setPrevStatus();\n      return new Error(`Can't save the data to the storage ${storageName}`);\n    }\n    return new Error(`The storage is too busy`);\n  }\n\n  /**\n   * stringify data for the\n   * storage\n   * @param dataAppendLog\n   * @returns {Error | string | false} - sating -stringified data, falser - no data, Error - an error has occurred\n   */\n  async stringifyDataForStorage(\n    dataAppendLog: TSafeStorageDataType[] | TSafeStorageStoredDataTypeKeyValue\n  ): Promise<string | null | Error> {\n    if (this.checkIfEmptyData(dataAppendLog)) {\n      return null;\n    }\n\n    try {\n      return JSON.stringify(dataAppendLog);\n    } catch (err) {\n      return this.setErrorStatus(err);\n    }\n  }\n\n  async writeOverallDataToMainTable(\n    data?: string | null | TSafeStorageDataType[] | TSafeStorageStoredDataTypeKeyValue\n  ): Promise<boolean | Error> {\n    const { storageName } = this;\n    let dataStringified;\n    if (data && typeof data === 'object') {\n      dataStringified = await this.stringifyDataForStorage(data);\n    } else if (data && typeof data === 'string') {\n      dataStringified = data;\n    } else if (data) {\n      return new Error('Only an object data can be write to the main table key of the secret storage');\n    }\n    if (dataStringified instanceof Error) {\n      return dataStringified;\n    }\n    return this.saveDataToStorage(storageName, dataStringified);\n  }\n\n  /**\n   * write the data to the secret storage's\n   * key used as append log data for the\n   * main storage key\n   * @param [string[]] [undefined] data\n   */\n  async writeDataToStorageAppengLog(data?: string | null | TSafeStorageStorageAppendLogDataType): Promise<Error | boolean> {\n    const { storageNameAppendLog } = this;\n    let dataStringified;\n    if (data && data instanceof Array) {\n      dataStringified = await this.stringifyDataForStorage(data);\n    } else if (data && typeof data === 'string') {\n      dataStringified = data;\n    } else if (data) {\n      return new Error('Only an array data can be write to the append log key of the secret storage');\n    }\n    if (dataStringified instanceof Error) {\n      return dataStringified;\n    }\n    return this.saveDataToStorage(storageNameAppendLog, dataStringified);\n  }\n\n  async clearAppendLogData(): Promise<boolean | Error> {\n    const { storageNameAppendLog } = this;\n\n    return this.saveDataToStorage(storageNameAppendLog, null);\n  }\n\n  async loadOverallTable(): Promise<TSafeStorageStoredDataType<TYPE> | Error> {\n    /**\n     * read data from the main storage table\n     * and storage append log table\n     * merge it\n     */\n    const overallData = await this.loadOverallData();\n    if (overallData instanceof Error) {\n      return this.setErrorStatus(overallData);\n    }\n\n    /*\n      save data from the main storage and \n      append log storage to the main storage\n      table\n    */\n    const resultSaveDataToMainStorage = await this.writeOverallDataToMainTable(overallData);\n    if (resultSaveDataToMainStorage instanceof Error) {\n      this.setErrorStatus(resultSaveDataToMainStorage);\n      // if an error is occurred while writing\n      // an overall data on the main storage\n      // set an error and return overall data\n      // without clearing the storage append\n      // log table\n      return overallData;\n    }\n\n    const resultClearStorageAppendLogData = await this.clearAppendLogData();\n    if (resultClearStorageAppendLogData instanceof Error) {\n      // if an error occurred while clearing the\n      // storage append log table\n      // return an error occurred as the\n      // result\n      return this.setErrorStatus(resultClearStorageAppendLogData);\n    }\n    return overallData;\n  }\n\n  setTableData(tableData?: TSafeStorageStoredDataType<TYPE>) {\n    const { storageType } = this;\n\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG) {\n      this.tableData = (tableData || SAFE_STORAGE_APPEND_LOG_INITIAL_VALUE) as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n      >;\n      this.appendData = SAFE_STORAGE_APPEND_LOG_APPEND_DATA_INITIAL_VALUE as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n      >;\n    } else {\n      this.tableData = (tableData || SAFE_STORAGE_KEY_VALUE_INITIAL_VALUE) as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n      >;\n      this.appendData = SAFE_STORAGE_KEY_VALUE_APPEND_DATA_INITIAL_VALUE as TSafeStorageStoredDataType<\n        ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE\n      >;\n    }\n  }\n\n  createSecretStorageInstance(): Error | SecretStorage {\n    const { secretStorageOptions } = this;\n    try {\n      const connectionToTheSecretStorage = new SecretStorage(secretStorageOptions);\n\n      this.secretStorageConnection = connectionToTheSecretStorage;\n      return connectionToTheSecretStorage;\n    } catch (err) {\n      return this.setErrorStatus(err);\n    }\n  }\n\n  startInterval(): boolean | Error {\n    const { dumpIntervalMs } = this;\n\n    try {\n      this.dumpIntervalRunning = setInterval(this.dumpData, dumpIntervalMs);\n      return true;\n    } catch (err) {\n      return this.setErrorStatus(err);\n    }\n  }\n\n  checkIfEmptyData(\n    data: TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG | ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE>\n  ): boolean {\n    if (data instanceof Array && !data.length) {\n      return true;\n    }\n    if (typeof data === 'object' && !Object.keys(data).length) {\n      return true;\n    }\n    return false;\n  }\n\n  async writeDump(data: TSafeStorageStoredDataTypeAppendLog | TSafeStorageStoredDataTypeKeyValue): Promise<Error | boolean> {\n    if (this.checkIfEmptyData(data)) {\n      return true;\n    }\n    let dataStringified: string;\n\n    try {\n      dataStringified = JSON.stringify(data);\n    } catch (err) {\n      return this.setErrorStatus(err);\n    }\n    return this.writeDataToStorageAppengLog(dataStringified);\n  }\n\n  async dumpAllStorageTypes(): Promise<Error | boolean> {\n    const tableOverallDataDump = await this.loadDataFromStorageAppendLog();\n    if (tableOverallDataDump instanceof Error) {\n      return this.setErrorStatus(tableOverallDataDump);\n    }\n\n    const { appendData } = this;\n    const appendDataString = await this.stringifyDataForStorage(appendData);\n    if (appendDataString instanceof Error) {\n      return this.setErrorStatus(appendDataString);\n    }\n    if (tableOverallDataDump != null && !(tableOverallDataDump instanceof Array)) {\n      return this.setErrorStatus('A wrong data type was read from storage');\n    }\n\n    const tableOverallData = [...(tableOverallDataDump || []), appendDataString] as TSafeStorageStoredDataTypeAppendLog;\n    return this.writeDump(tableOverallData);\n  }\n\n  async dumpDataAppendLog(): Promise<Error | true> {\n    const writeDumpResult = await this.dumpAllStorageTypes();\n\n    if (writeDumpResult instanceof Error) {\n      const { appendData } = this;\n\n      this.appendData = [\n        ...(appendData as TSafeStorageStoredDataTypeAppendLog),\n        ...(this.appendDataTemp as TSafeStorageStoredDataTypeAppendLog),\n      ];\n      this.appendDataTemp = [];\n      return writeDumpResult;\n    }\n    this.appendData = this.appendDataTemp;\n    this.appendDataTemp = [];\n    return true;\n  }\n\n  async dumpDataKeyValueStorage(): Promise<Error | boolean> {\n    const writeDumpResult = await this.dumpAllStorageTypes();\n\n    if (writeDumpResult instanceof Error) {\n      const { appendData } = this;\n\n      this.appendData = {\n        ...(appendData as TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE>),\n        ...(this.appendDataTemp as TSafeStorageStoredDataType<ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE>),\n      };\n      this.appendDataTemp = {};\n      return writeDumpResult;\n    }\n    this.appendData = this.appendDataTemp;\n    this.appendDataTemp = {};\n    return true;\n  }\n\n  /**\n   * write the data from the append log\n   * in-memory table to the secret storage\n   * append log table. On error merge data\n   * from in-memory append log and\n   * in-memory temporary append log data,\n   * then clear the in-memory append log data.\n   * On success clear the in-memory\n   * append log data table and copy data\n   * from the temporary append log\n   * to the in-memory append log. And\n   * clear in-memory temporary append log\n   */\n  dumpData = async (): Promise<Error | boolean> => {\n    const { storageType, appendData, status } = this;\n\n    if (this.isStorageBusy) {\n      // if already writing a dump\n      return true;\n    }\n    if (this.checkIfEmptyData(appendData)) {\n      return true;\n    }\n\n    let resultWritingDump;\n\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE) {\n      resultWritingDump = await this.dumpDataKeyValueStorage();\n    } else {\n      resultWritingDump = await this.dumpDataAppendLog();\n    }\n    if (resultWritingDump === true) {\n      // TODO - ??reload all the data from storage\n      // to guarantee the data persistance\n      return true;\n    }\n    return this.setErrorStatus('An unknown error has occurred while writing the dump of the data to the SecretStorage');\n  };\n\n  /**\n   * check if too much data in the in-memory\n   * append log storage\n   * If it is, write a data from it\n   * to the secret storage\n   */\n  async checkIfMemoryAppendLogOverflow() {\n    const { appendData } = this;\n\n    if (appendData instanceof Array && appendData.length > SAFE_STORAGE_MAX_ITEMS_APPEND_LOG) {\n      await this.dumpData();\n    }\n  }\n\n  getDataFromAppendLogStorage<D extends TSafeStorageDataTypesAvail>(key: TSafeStorageKeyType): Error | null | undefined | D {\n    const { tableData } = this;\n    const keyType = typeof key;\n\n    if (keyType !== 'number') {\n      const err = new Error(`For append log storage only a numeric keys are available but ${keyType} type key was given`);\n\n      console.error(err);\n      return err;\n    }\n    return (tableData as TSafeStorageStoredDataTypeAppendLog)[key as number] as Error | null | undefined | D;\n  }\n\n  getDataFromKeyValueStorage<D extends TSafeStorageDataTypesAvail>(key: TSafeStorageKeyType): Error | null | undefined | D {\n    const { tableData } = this;\n    const keyType = typeof key;\n\n    if (keyType !== 'string') {\n      const err = new Error(`For append log storage only a string keys are available but ${keyType} type key was given`);\n\n      console.error(err);\n      return err;\n    }\n    return (tableData as TSafeStorageStoredDataTypeKeyValue)[key as string] as Error | null | undefined | D;\n  }\n\n  /**\n   * get data for the key specified\n   * from the in-memory table\n   * @param key\n   */\n  get<D extends TSafeStorageDataTypesAvail>(key: TSafeStorageKeyType): Error | undefined | null | D {\n    const { storageType } = this;\n\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG) {\n      return this.getDataFromAppendLogStorage<D>(key);\n    }\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE) {\n      return this.getDataFromKeyValueStorage<D>(key);\n    }\n    const err = new Error('An unknown storage type');\n\n    console.error(err);\n    return err;\n  }\n\n  /**\n   * try to stringify the data\n   * and return true if all is\n   * ok or an Error otherwise\n   * @param data\n   */\n  checkDataIsSafetyForSave(data: any): boolean | Error {\n    try {\n      JSON.stringify(data);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * encode the data to the JSON\n   * format, e.g. Date type\n   * will be normalized to\n   * a stringified date in ISO\n   * @param data\n   */\n  normilizeData(data: TSafeStorageDataTypesAvail | undefined | null): string | null | undefined {\n    return data != null ? JSON.parse(JSON.stringify(data)) : undefined;\n  }\n\n  async setDataInAppendLogStorage(\n    data: TSafeStorageDataTypesAvail | undefined | null,\n    key?: TSafeStorageKeyType\n  ): Promise<Error | boolean> {\n    if (key && typeof key !== 'number') {\n      const err = new Error(`For append log storage only a numeric keys are available but ${typeof key} type key was given`);\n\n      console.error(err);\n      return err;\n    }\n\n    const { appendData, appendDataTemp, tableData } = this;\n    const tempStorage = this.isStorageBusy ? appendDataTemp : appendData;\n    const stringifiedData = this.normilizeData(data);\n\n    if (!key) {\n      (tempStorage as TSafeStorageStoredDataTypeAppendLog).push(stringifiedData || null);\n      (tableData as TSafeStorageStoredDataTypeAppendLog).push(stringifiedData || null);\n    } else {\n      (tempStorage as TSafeStorageStoredDataTypeAppendLog)[key as number] = stringifiedData || null;\n      (tableData as TSafeStorageStoredDataTypeAppendLog)[key as number] = stringifiedData || null;\n    }\n    return true;\n  }\n\n  /**\n   *\n   * @param data\n   * @param [numbder] key [undefined] - index where\n   * put the data given.\n   * If it's not specified\n   * then set the data given\n   * by the last index\n   */\n  async setDataInKeyValueStorage(\n    data: TSafeStorageDataTypesAvail | undefined | null,\n    key?: TSafeStorageKeyType\n  ): Promise<Error | boolean> {\n    if (typeof key !== 'string') {\n      const err = new Error(`For key value storage only a string keys are available but ${typeof key} type key was given`);\n\n      console.error(err);\n      return err;\n    }\n\n    const { appendData, appendDataTemp, tableData } = this;\n    const tempStorage = this.isStorageBusy ? appendDataTemp : appendData;\n    const stringifiedData = this.normilizeData(data);\n\n    (tableData as TSafeStorageStoredDataTypeKeyValue)[key] = stringifiedData || null;\n    (tempStorage as TSafeStorageStoredDataTypeKeyValue)[key] = stringifiedData || null;\n    return true;\n  }\n\n  /**\n   * set data in the in-memory\n   * table and in-memory append log\n   * table or in-memory temporary\n   * append-log table\n   * if any operations on append log\n   * in-memory table is active.\n   * Also the data set into\n   * the in-memory overall data\n   * table for the key specified\n   * @param data\n   * @param key\n   */\n  async set(data: TSafeStorageDataTypesAvail | undefined | null, key?: TSafeStorageKeyType): Promise<Error | boolean> {\n    const { storageType } = this;\n\n    const dataSafeResult = this.checkDataIsSafetyForSave(data);\n    if (dataSafeResult instanceof Error) {\n      return dataSafeResult;\n    }\n    await this.checkIfMemoryAppendLogOverflow();\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG) {\n      return this.setDataInAppendLogStorage(data, key);\n    }\n    if (storageType === ESAFE_STORAGE_STORAGE_TYPE.KEY_VALUE) {\n      return this.setDataInKeyValueStorage(data, key);\n    }\n\n    const err = new Error('An unknown storage type');\n\n    console.error(err);\n    return err;\n  }\n\n  /**\n   * remove a data by fot a key specified\n   */\n  async remove(key: TSafeStorageKeyType) {\n    if (!key) {\n      return new Error('A key must be specified to remove a data from it');\n    }\n    return this.set(null, key);\n  }\n\n  /**\n   * clear the data in the storage\n   */\n  async clear(): Promise<Error | boolean> {\n    this.appendData = this.castDataToStorageType() as TSafeStorageStoredDataType<TYPE>;\n    this.appendDataTemp = this.castDataToStorageType() as TSafeStorageStoredDataType<TYPE>;\n    this.tableData = this.castDataToStorageType() as TSafeStorageStoredDataType<TYPE>;\n    return this.writeDataToStorageAppengLog(null);\n  }\n}\n","/home/paul/projects/protocol/src/classes/safe-storage-class/safe-storage-class.types.ts",["2937","2938"],"import { ISecretStoreCredentials, TSecretStorageProviderName } from 'classes/secret-storage-class/secret-storage-class.types';\nimport { ESAFE_STORAGE_STORAGE_TYPE, ESAFE_STORAGE_PROVIDER_STATUS } from './safe-storage-class.const';\n\nexport type TSafeStorageProviderName = TSecretStorageProviderName;\n\nexport type TSafeStorageStorageAppendLogDataType = string[];\n\nexport type TSafeStorageKeyType = string | number;\n\nexport type TSafeStorageDataType = string | object | number | null;\n\nexport type TSafeStorageStoredDataTypeKeyValue = {\n  [keyName: string]: TSafeStorageDataType;\n};\n\nexport type TSafeStorageStoredDataTypeAppendLog = Array<TSafeStorageDataType>;\n\nexport type TSafeStorageStoredDataType<T extends ESAFE_STORAGE_STORAGE_TYPE> = T extends ESAFE_STORAGE_STORAGE_TYPE.APPEND_LOG\n  ? TSafeStorageStoredDataTypeAppendLog\n  : TSafeStorageStoredDataTypeKeyValue;\n\nexport interface ISafeStorageOptions {\n  name: string; // a unique name for the storage\n  credentials: ISecretStoreCredentials; // credentials for access to the secret storage\n  dumpIntervalMs?: number; // how often a dump of a data must be saved in secret storage\n  storageDumpProvider?: TSafeStorageProviderName; // name for the provider where the dumps will be stored\n  storageType?: ESAFE_STORAGE_STORAGE_TYPE; // storage data type\n}\n\nexport type TSafeStorageDataTypesAvail = string | number | object;\n\nexport type TSafeStorageEvents = {\n  status: ESAFE_STORAGE_PROVIDER_STATUS;\n};\n","/home/paul/projects/protocol/src/classes/secret-storage-class/index.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/index.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-login/index.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-login/secret-storage-class-utils-login.const.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-login/secret-storage-class-utils-login.ts",["2939"],"import { encryptDataToString } from './../../../../utils/password-utils/encrypt.password-utils';\nimport { decryptDataWithKey } from './../../../../utils/password-utils/decrypt.password-utils';\nimport { generatePasswordKeyByPasswordString } from 'utils/password-utils/derive-key.password-utils';\nimport { calculateHash } from 'utils/hash-calculation-utils';\nimport {\n  SECRET_STORAGE_CLASS_UTILS_LOGIN_HASH_ALG,\n  SECRET_STORAGE_CLASS_UTILS_LOGIN_SALT,\n} from './secret-storage-class-utils-login.const';\n\nexport const getLoginHash = (login: string) => {\n  return calculateHash(login, SECRET_STORAGE_CLASS_UTILS_LOGIN_HASH_ALG);\n};\n\nexport const getCryptoKeyByLogin = (login: string): Promise<CryptoKey | Error> => {\n  return generatePasswordKeyByPasswordString(login, SECRET_STORAGE_CLASS_UTILS_LOGIN_SALT);\n};\n\nexport const encryptValueByLogin = async (login: string, value: string): Promise<string | Error> => {\n  const loginCryptoKey = await getCryptoKeyByLogin(login);\n\n  if (loginCryptoKey instanceof Error) {\n    console.error(loginCryptoKey);\n    return new Error('Failed to generate a crypto key by the login');\n  }\n  return encryptDataToString(loginCryptoKey, value);\n};\n\nexport const decryptValueByLogin = async (login: string, value: string): Promise<Error | string> => {\n  const loginCryptoKey = await getCryptoKeyByLogin(login);\n\n  if (loginCryptoKey instanceof Error) {\n    return loginCryptoKey;\n  }\n  return decryptDataWithKey(loginCryptoKey, value);\n};\n","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-main/index.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-main/secret-storage-class-utils-main.ts",["2940","2941"],"import { ISecretStoreCredentialsCryptoKey } from './../../secret-storage-class.types';\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const checkIsStorageProviderInstance = (storageProviderInstance: any): Error | boolean => {\n  if (!storageProviderInstance || typeof storageProviderInstance !== 'object') {\n    return new Error('Storage provider must be an object');\n  }\n\n  const { connect, get, set, disconnect } = storageProviderInstance;\n\n  if (\n    typeof connect !== 'function' ||\n    typeof get !== 'function' ||\n    typeof set !== 'function' ||\n    typeof disconnect !== 'function'\n  ) {\n    return new Error('The instance has a wrong implemntation of a StorageProvider interface');\n  }\n  return true;\n};\n\nexport const validateCryptoKeyCredentials = (credentials?: ISecretStoreCredentialsCryptoKey): void | Error => {\n  if (!credentials) {\n    return new Error('validateCryptoKeyCredentials::Credentials must not be empty');\n  }\n  if (typeof credentials !== 'object') {\n    return new Error('validateCryptoKeyCredentials::Credentials must be an object');\n  }\n\n  const { key } = credentials;\n\n  if (!key) {\n    return new Error('validateCryptoKeyCredentials::A Key must be provided to authorize');\n  }\n  if (key instanceof CryptoKey) {\n    return;\n  }\n  return new Error('validateCryptoKeyCredentials::A Key must be ab instance of CryptoKey');\n};\n","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-password/index.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-password/secret-storage-class-utils-password.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class.const.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class.ts",["2942","2943","2944","2945","2946","2947","2948","2949","2950","2951","2952","2953","2954","2955","2956","2957","2958","2959","2960","2961"],"import {\n  ISecretStoreConfiguration,\n  ISecretStorageSessionInfo,\n  ISecretStorageSessionInfoStored,\n  ISecretStoreCredentialsSession,\n} from 'classes/secret-storage-class/secret-storage-class.types';\nimport { ownValueOf } from 'types/helper.types';\nimport {\n  importPasswordKey,\n  exportPasswordKeyAsString,\n  importPasswordKeyFromString,\n} from 'utils/password-utils/derive-key.password-utils';\nimport { TPASSWORD_ENCRYPTION_KEY_IMPORT_NATIVE_SUPPORTED_TYPES } from 'utils/password-utils/password-utils.types';\nimport { decryptDataWithKey, decryptDataWithKeyFromUint8Array } from 'utils/password-utils/decrypt.password-utils';\nimport { encryptDataToString, encryptDataToUInt8Array } from 'utils/password-utils/encrypt.password-utils';\nimport { getStatusClass } from 'classes/basic-classes/status-class-base/status-class-base';\nimport {\n  STORAGE_PROVIDERS,\n  STORAGE_PROVIDERS_NAME,\n  STORAGE_PROVIDERS_NAMES,\n} from 'classes/storage-providers/storage-providers.const';\nimport { SecretStorageProviderLocalStorage } from 'classes/storage-providers/storage-local-storage-provider/secret-storage-local-storage-provider';\nimport { calcCryptoKeyHash } from './../../utils/encryption-keys-utils/encryption-keys-utils';\nimport {\n  checkIsStorageProviderInstance,\n  validateCryptoKeyCredentials,\n} from './secret-storage-class-utils/secret-storage-class-utils-main/secret-storage-class-utils-main';\nimport {\n  decryptValueByLogin,\n  encryptValueByLogin,\n} from './secret-storage-class-utils/secret-storage-class-utils-login/secret-storage-class-utils-login';\nimport {\n  generatePasswordKeyByPasswordSalt,\n  generateSaltForPassword,\n} from './secret-storage-class-utils/secret-storage-class-utils-password/secret-storage-class-utils-password';\nimport {\n  TInstanceofStorageProvider,\n  IStorageProvider,\n  ISecretStoreCredentials,\n  ISecretStorage,\n  ISecretStoreCredentialsCryptoKey,\n} from './secret-storage-class.types';\nimport {\n  SECRET_STORAGE_STATUS,\n  SECRET_STORAGE_PASSWORD_MIN_LENGTH,\n  SECRET_STORAGE_SESSION_KEY,\n} from './secret-storage-class.const';\nimport { getLoginHash } from './secret-storage-class-utils/secret-storage-class-utils-login';\nimport { SECRET_STORAGE_LOGIN_MIN_LENGTH, SECRET_STORAGE_UNSET_MAX_ATTEMPTS } from './secret-storage-class.const';\nimport { IStorageProviderOptions } from 'classes/storage-providers/storage-providers.types';\nimport { ISensitiveDataSessionStorage } from 'classes/sensitive-data-session-storage/sensitive-data-session-storage.types';\nimport { isCryptoKeyDataEncryption } from '../../utils/encryption-keys-utils/encryption-keys-utils';\nimport { TSecretStorageAuthorizazionOptions } from './secret-storage-class.types';\n\n/**\n * this classed used to store value in a\n * persistent storage locally on client side\n * in encrypted format. Each key for a value is unique\n * for the user which is authorized withing database.\n * Therefore another user authorized can't to unset values\n * which were set before by another user.\n *\n * @export\n * @class SecretStorage\n * @extends {getStatusClass<typeof SECRET_STORAGE_STATUS>({\n *     errorStatus: SECRET_STORAGE_STATUS.ERROR,\n *     instanceName: 'SecretStorage',\n *   })}\n * @implements {ISecretStorage}\n */\nexport class SecretStorage\n  extends getStatusClass<typeof SECRET_STORAGE_STATUS>({\n    errorStatus: SECRET_STORAGE_STATUS.ERROR,\n    instanceName: 'SecretStorage',\n  })\n  implements ISecretStorage {\n  private static AuthStorageProvider: IStorageProvider = STORAGE_PROVIDERS[STORAGE_PROVIDERS_NAME.SESSION_STORAGE];\n\n  private static PREFIX_KEY_IN_SECRET_STORAGE = '__SecretStorage__';\n\n  private static PREFIX_FOR_SALT_VALUE = '__SecretStorage__s_uk';\n\n  public static validatePassword(password: any) {\n    if (typeof password !== 'string') {\n      return new Error('validateCredentials::A password string must be provided to authorize');\n    }\n    if (!password) {\n      return new Error('validateCredentials::A password non-empty string must be provided to authorize');\n    }\n    if (password.length < SECRET_STORAGE_PASSWORD_MIN_LENGTH) {\n      return new Error(\n        `validateCredentials::The password string must be a ${SECRET_STORAGE_PASSWORD_MIN_LENGTH} characters ar least`\n      );\n    }\n  }\n\n  public static validateLogin(login: any) {\n    if (typeof login !== 'string') {\n      return new Error('validateCredentials::A login string must be provided to authorize');\n    }\n    if (!login) {\n      return new Error('validateCredentials::A login non-empty string must be provided to authorize');\n    }\n    if (login.length < SECRET_STORAGE_LOGIN_MIN_LENGTH) {\n      return new Error(`validateCredentials::The login string must be a ${SECRET_STORAGE_LOGIN_MIN_LENGTH} characters ar least`);\n    }\n  }\n\n  public static validateCredentials(credentials?: ISecretStoreCredentials): void | Error {\n    if (!credentials) {\n      return new Error('validateCredentials::Credentials must not be empty');\n    }\n    if (typeof credentials !== 'object') {\n      return new Error('validateCredentials::Credentials must be an object');\n    }\n    return SecretStorage.validateLogin(credentials.login) ?? SecretStorage.validatePassword(credentials.password);\n  }\n\n  private static async saltKey(credentials: ISecretStoreCredentials) {\n    const loginHash = await getLoginHash(credentials.login);\n\n    if (loginHash instanceof Error) {\n      console.error(loginHash);\n      return new Error('Failed to calculate hash by a login string');\n    }\n    return `${SecretStorage.PREFIX_FOR_SALT_VALUE}__${loginHash}`;\n  }\n\n  private keyHash: string = '';\n\n  private k?: CryptoKey;\n\n  private storageProvider?: TInstanceofStorageProvider;\n\n  /**\n   * check whether the storage provider\n   * is support operations on\n   * UInt8Array values\n   *\n   * @private\n   * @type {boolean}\n   * @memberof SecretStorage\n   */\n  private isStorageProviderSupportUInt8Array: boolean = false;\n\n  private authStorageProvider?: TInstanceofStorageProvider;\n\n  private storageProviderName?: ownValueOf<typeof STORAGE_PROVIDERS_NAME>;\n\n  /**\n   * options for the instance\n   *\n   * @private\n   * @type {IStorageProviderOptions}\n   * @memberof SecretStorage\n   */\n  private options?: IStorageProviderOptions;\n\n  /**\n   * name of the database\n   *\n   * @private\n   * @type {string}\n   * @memberof SecretStorage\n   */\n  private dbName?: string;\n\n  /**\n   * Hash of the user login will be used as the prefix for the key\n   *\n   * @private\n   * @type {string}\n   * @memberof SecretStorage\n   */\n  private userHash?: string;\n\n  /**\n   * returns true if connected succesfully to\n   * a storage and have a vaild crypto key\n   */\n  protected get isRunning() {\n    const { status } = this;\n\n    return status === SECRET_STORAGE_STATUS.RUNNING;\n  }\n\n  public get isActive() {\n    return !!this.isRunning;\n  }\n\n  /**\n   * @param {object} configuration\n   * @param {strig} [SECRET_STORAGE_PROVIDERS_NAME.LOCAL_STORAGE] configuration.storageProviderName\n   * - provider name use to store a secret data\n   */\n  constructor(protected configuration: Partial<ISecretStoreConfiguration> = {}) {\n    super();\n  }\n\n  public connect = async (options?: IStorageProviderOptions): Promise<boolean | Error> => {\n    this.clearState();\n    this.setStatus(SECRET_STORAGE_STATUS.CONNECTING);\n    this.setOptions(options);\n\n    const resultRunAuthProvider = await this.runAuthStorageProvider();\n\n    if (resultRunAuthProvider instanceof Error) {\n      this.setErrorStatus(resultRunAuthProvider);\n      return resultRunAuthProvider;\n    }\n\n    const isStorageProviderStarted = await this.runStorageProvider();\n\n    if (isStorageProviderStarted instanceof Error) {\n      this.setErrorStatus(isStorageProviderStarted);\n      return isStorageProviderStarted;\n    }\n    this.setStatus(SECRET_STORAGE_STATUS.RUNNING);\n    return true;\n  };\n\n  public async disconnect(): Promise<boolean | Error> {\n    const resultDisconnectFromStorageProvider = await this.storageProviderDisconnect();\n\n    if (resultDisconnectFromStorageProvider instanceof Error) {\n      console.error(resultDisconnectFromStorageProvider);\n      return new Error('Failed to disconnect from the storage provider');\n    }\n    this.reset();\n    this.setStatus(SECRET_STORAGE_STATUS.STOPPED);\n    return true;\n  }\n\n  /**\n   * generate a new crypto key with salt provided\n   *\n   * @param {ISecretStoreCredentials} credentials\n   * @returns {(Promise<CryptoKey | Error>)}\n   * @memberof SecretStorage\n   */\n  public async generateCryptoKey(credentialsOrSession: TSecretStorageAuthorizazionOptions): Promise<CryptoKey | Error> {\n    if (isCryptoKeyDataEncryption(credentialsOrSession)) {\n      return credentialsOrSession;\n    }\n    const session = (credentialsOrSession as ISecretStoreCredentialsSession).session;\n    if (session) {\n      const sessionInfo = await this.readLoginAndKeyFromSession(session);\n\n      if (sessionInfo && !(sessionInfo instanceof Error) && sessionInfo.key) {\n        return sessionInfo.key;\n      }\n    }\n\n    const credentials = credentialsOrSession as ISecretStoreCredentials;\n    const credentialsValidationResult = SecretStorage.validateCredentials(credentials);\n\n    if (credentialsValidationResult instanceof Error) {\n      this.setErrorStatus(credentialsValidationResult);\n      return credentialsValidationResult;\n    }\n\n    const salt = await this.getSaltValue(credentials);\n\n    if (salt instanceof Error) {\n      this.setErrorStatus(salt);\n      return new Error('Failed to generate salt value');\n    }\n\n    const cryptoKey = await generatePasswordKeyByPasswordSalt(credentials.password, salt);\n\n    if (cryptoKey instanceof Error) {\n      this.setErrorStatus(cryptoKey);\n      return cryptoKey;\n    }\n    return cryptoKey;\n  }\n\n  public async authorize(\n    credentials: TSecretStorageAuthorizazionOptions,\n    options?: IStorageProviderOptions\n  ): Promise<boolean | Error> {\n    const credentialsWithKey = credentials as ISecretStoreCredentialsCryptoKey;\n\n    if (\n      credentialsWithKey.key &&\n      isCryptoKeyDataEncryption(credentialsWithKey.key) &&\n      isCryptoKeyDataEncryption(credentialsWithKey.key)\n    ) {\n      return this.authorizeByKey(credentialsWithKey, options);\n    }\n\n    const credentialsWithSession = credentials as ISecretStoreCredentialsSession;\n\n    if (credentialsWithSession && credentialsWithSession.session) {\n      const sessionInfo = await this.readLoginAndKeyFromSession(credentialsWithSession.session);\n\n      if (sessionInfo && !(sessionInfo instanceof Error)) {\n        return this.authorizeByKey(\n          {\n            key: sessionInfo.key,\n          },\n          options\n        );\n      }\n    }\n\n    const cred = credentials as ISecretStoreCredentials;\n    const cryptoKey = await this.generateCryptoKey(cred);\n\n    if (cryptoKey instanceof Error) {\n      console.error(cryptoKey);\n      return new Error('Failed to generate a crypto key to encrypt local data');\n    }\n\n    const resultRunAuthProvider = await this.runAuthStorageProvider();\n\n    if (resultRunAuthProvider instanceof Error) {\n      this.setErrorStatus(resultRunAuthProvider);\n      return resultRunAuthProvider;\n    }\n\n    const setKeyResult = await this.setEncryptionKey(cryptoKey);\n\n    if (setKeyResult instanceof Error) {\n      this.setErrorStatus(setKeyResult);\n      return setKeyResult;\n    }\n    if (credentialsWithSession.session) {\n      await this.saveLoginAndKeyToSession(credentialsWithSession.session, cred.login, cryptoKey);\n    }\n    return this.connect(options);\n  }\n\n  public async authorizeByKey(\n    credentials: ISecretStoreCredentialsCryptoKey,\n    options?: IStorageProviderOptions\n  ): Promise<boolean | Error> {\n    const credentialsValidationResult = validateCryptoKeyCredentials(credentials);\n\n    if (credentialsValidationResult instanceof Error) {\n      this.setErrorStatus(credentialsValidationResult);\n      return credentialsValidationResult;\n    }\n\n    const { key: cryptoKey } = credentials;\n    const resultRunAuthProvider = await this.runAuthStorageProvider();\n\n    if (resultRunAuthProvider instanceof Error) {\n      this.setErrorStatus(resultRunAuthProvider);\n      return resultRunAuthProvider;\n    }\n\n    const setKeyResult = await this.setEncryptionKey(cryptoKey);\n\n    if (setKeyResult instanceof Error) {\n      this.setErrorStatus(setKeyResult);\n      return setKeyResult;\n    }\n    return this.connect(options);\n  }\n\n  public has = async (key: string): Promise<boolean | Error> => {\n    const valueEncrypted = await this.readValueForKey(key);\n\n    if (valueEncrypted instanceof Error) {\n      return valueEncrypted;\n    }\n    return this.isValueDefined(valueEncrypted);\n  };\n\n  public get = async (key: string): Promise<string | Error | undefined | null> => {\n    const valueEncrypted = await this.readValueForKey(key);\n\n    if (!valueEncrypted) {\n      return valueEncrypted;\n    }\n    if (valueEncrypted instanceof Error) {\n      return SecretStorage.error(valueEncrypted);\n    }\n    if (this.isNullishValue(valueEncrypted)) {\n      return null;\n    }\n\n    const decryptResult = await (valueEncrypted instanceof Uint8Array\n      ? this.decryptValueFromUInt8Array(valueEncrypted)\n      : this.decryptValue(valueEncrypted));\n\n    if (decryptResult instanceof Error) {\n      return decryptResult;\n    }\n    return decryptResult || undefined;\n  };\n\n  public async set(keyForValue: string, value: string | null): Promise<boolean | Error> {\n    let encryptedValue: Uint8Array | Error | string;\n\n    if (!this.isRunning) {\n      return SecretStorage.error(\n        'The instance of SecretStorage is not connected to the storage provider or there is no an encryption key'\n      );\n    }\n    if (value === null) {\n      encryptedValue = this.isStorageProviderSupportUInt8Array ? new Uint8Array() : '';\n    } else {\n      //value - must be an escaped sctring\n      encryptedValue = this.isStorageProviderSupportUInt8Array\n        ? await this.encryptValueAsInt8Array(value)\n        : await this.encryptValue(value);\n    }\n    if (encryptedValue instanceof Error) {\n      return SecretStorage.error(encryptedValue);\n    }\n\n    const key = this.storageKey(keyForValue);\n    const storeValueResult = await (encryptedValue instanceof Uint8Array\n      ? this.setWithStorageProviderUInt8Array(key, encryptedValue)\n      : this.setWithStorageProvider(key, encryptedValue));\n\n    if (storeValueResult instanceof Error) {\n      return SecretStorage.error(storeValueResult);\n    }\n    return storeValueResult;\n  }\n\n  public async insert(keyForValue: string, value: string | null): Promise<boolean | Error> {\n    if (await this.has(keyForValue)) {\n      return false;\n    }\n    return this.set(keyForValue, value);\n  }\n\n  public async unset(key: string | string[], maxAttempts: number = SECRET_STORAGE_UNSET_MAX_ATTEMPTS): Promise<Error | void> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let promisePending: Promise<any>[] = [];\n    let attempt = 1;\n    const isKeyString = typeof key === 'string';\n\n    if (key instanceof Array) {\n      promisePending = key.map(this.unsetWithStorageProvider);\n    } else if (isKeyString) {\n      promisePending = [this.unsetWithStorageProvider(key)];\n    } else {\n      return new Error('Key must be a string or an array of strings');\n    }\n    while (promisePending.length && attempt++ < maxAttempts) {\n      const results = await Promise.all(promisePending);\n      const len = results.length;\n      let idx = 0;\n\n      promisePending = [];\n      for (; idx < len; idx++) {\n        if (results[idx] instanceof Error) {\n          promisePending.push(this.unsetWithStorageProvider(isKeyString ? (key as string) : key[idx]));\n        }\n      }\n    }\n  }\n\n  public async clearDb() {\n    if (!this.isRunning) {\n      return SecretStorage.error(\n        'The instance of SecretStorage is not connected to the storage provider or there is no an encryption key'\n      );\n    }\n    const result = await this.storageProvider?.clearDb();\n\n    if (result instanceof Error) {\n      console.error(result);\n      return SecretStorage.error('Failed to clear the database with the storage provider');\n    }\n    return true;\n  }\n\n  private setStorageProviderName(storageProviderName: string = STORAGE_PROVIDERS_NAME.LOCAL_STORAGE): boolean {\n    if (STORAGE_PROVIDERS_NAMES.includes(storageProviderName)) {\n      this.storageProviderName = storageProviderName;\n      return true;\n    }\n    return false;\n  }\n\n  private createInstanceOfStorageProvider(StorageProviderConstructor: IStorageProvider): TInstanceofStorageProvider | Error {\n    try {\n      const storageProvider = new StorageProviderConstructor();\n      const checkResult = checkIsStorageProviderInstance(storageProvider);\n\n      if (checkResult instanceof Error) {\n        return checkResult;\n      }\n      return storageProvider;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  private setSupportForUInt8Array(StorageProviderConstructor: IStorageProvider): void {\n    this.isStorageProviderSupportUInt8Array = !!StorageProviderConstructor.isBufferSupported;\n  }\n\n  private async runAuthStorageProvider(): Promise<boolean | Error> {\n    const { authStorageProvider: runningAuthStorageProvider } = this;\n    const checkIsRunning = checkIsStorageProviderInstance(runningAuthStorageProvider);\n\n    /**\n     * if running already\n     */\n    if (checkIsRunning === true) {\n      return true;\n    }\n\n    const { AuthStorageProvider } = SecretStorage;\n\n    if (!AuthStorageProvider) {\n      return new Error('There is no provider for the auth storage is defined');\n    }\n\n    const authStorageProvider = this.createInstanceOfStorageProvider(AuthStorageProvider);\n\n    if (authStorageProvider instanceof Error) {\n      return authStorageProvider;\n    }\n\n    const { dbName } = this;\n    const connectResult = await authStorageProvider.connect({\n      dbName,\n    });\n\n    if (connectResult instanceof Error) {\n      return connectResult;\n    }\n    if (connectResult !== true) {\n      return new Error('There is a wrong result was returned by auth storage provider');\n    }\n    this.authStorageProvider = authStorageProvider;\n    return true;\n  }\n\n  protected async runStorageProvider(): Promise<Error | boolean> {\n    const { configuration } = this;\n\n    if (configuration) {\n      const { storageProviderName } = configuration;\n\n      if (this.setStorageProviderName(storageProviderName)) {\n        const { storageProviderName: storageProviderChosenName } = this;\n\n        if (!storageProviderChosenName) {\n          return new Error('There is no storage provider was choosed');\n        }\n\n        const storageProviderConstructor = STORAGE_PROVIDERS[storageProviderChosenName];\n\n        this.setSupportForUInt8Array(storageProviderConstructor);\n        if (storageProviderConstructor) {\n          const storageProvider = this.createInstanceOfStorageProvider(storageProviderConstructor);\n\n          if (storageProvider instanceof Error) {\n            return storageProvider;\n          }\n\n          const { dbName } = this;\n          const storageProviderIsRunning = await storageProvider.connect({\n            dbName,\n          });\n\n          if (storageProviderIsRunning instanceof Error) {\n            return storageProviderIsRunning;\n          }\n          this.storageProvider = storageProvider;\n          return true;\n        }\n      }\n      throw new Error('Failed to set the name of the storage provider');\n    }\n    throw new Error('There is no storage provider configuration was defined');\n  }\n\n  protected storageKey(key: string) {\n    return `${SecretStorage.PREFIX_KEY_IN_SECRET_STORAGE}_${this.keyHash}_${key}`;\n  }\n\n  protected async setEncryptionKey(\n    key: TPASSWORD_ENCRYPTION_KEY_IMPORT_NATIVE_SUPPORTED_TYPES | CryptoKey\n  ): Promise<boolean | Error> {\n    let k;\n\n    if (key instanceof CryptoKey) {\n      k = key;\n    } else {\n      const importedKey = await importPasswordKey(key);\n\n      if (importedKey instanceof Error) {\n        return importedKey;\n      }\n    }\n    if (!(k instanceof CryptoKey)) {\n      return new Error('Unknown type of the key');\n    }\n\n    const keyString = await exportPasswordKeyAsString(k);\n\n    if (keyString instanceof Error) {\n      return new Error(\"Can't convert the key to exported format\");\n    }\n\n    const keyHash = await calcCryptoKeyHash(k);\n\n    if (keyHash instanceof Error) {\n      console.error(keyHash);\n      return new Error('Failed to calculate hash value for the CryptoKey');\n    }\n    this.k = k;\n    this.keyHash = keyHash;\n    return true;\n  }\n\n  protected setOptions(options?: IStorageProviderOptions): void {\n    if (options && typeof options === 'object') {\n      this.options = options;\n\n      const { dbName } = options;\n\n      if (dbName && typeof dbName === 'string') {\n        this.dbName = dbName;\n      }\n    }\n  }\n\n  protected isNullishValue(value: any): boolean {\n    return (typeof value === 'string' && value === '') || (value instanceof Uint8Array && value.byteLength === 0);\n  }\n\n  protected reset() {\n    this.clearError();\n    this.clearStatus();\n    this.clearState();\n    this.k = undefined;\n    this.authStorageProvider = undefined;\n  }\n\n  protected storageProviderDisconnect = async (): Promise<boolean | Error> => {\n    const { authStorageProvider } = this;\n\n    if (authStorageProvider) {\n      return authStorageProvider.disconnect();\n    }\n    return new Error('There is no Auth storage provider defined');\n  };\n\n  protected async getSaltValue(credentials: ISecretStoreCredentials): Promise<Error | string> {\n    const key = await SecretStorage.saltKey(credentials);\n\n    if (key instanceof Error) {\n      console.error(key);\n      return new Error('Failed to get key for a salt value');\n    }\n\n    const saltStorageProvider = new SecretStorageProviderLocalStorage();\n    const saltStorageProviderConnectResult = await saltStorageProvider.connect();\n\n    if (saltStorageProviderConnectResult instanceof Error) {\n      console.error(saltStorageProviderConnectResult);\n      return new Error('Failed to connect to the salt storage provider');\n    }\n\n    const saltEncrypted = await saltStorageProvider.get(key);\n\n    if (saltEncrypted instanceof Error) {\n      console.error(saltEncrypted);\n      return new Error('Failed to read salt value');\n    }\n    if (!saltEncrypted) {\n      console.log('A salt value was not found a new one will be generated');\n\n      const newSalt = generateSaltForPassword();\n\n      if (newSalt instanceof Error) {\n        console.error(newSalt);\n        return new Error('Failed to generate a new salt value');\n      }\n\n      const newSaltEncrypted = await encryptValueByLogin(credentials.login, newSalt);\n\n      if (newSaltEncrypted instanceof Error) {\n        console.error(newSaltEncrypted);\n        return new Error('Failed to encrypt the salt value');\n      }\n\n      const saltValueSetInStorageResult = await saltStorageProvider.set(key, newSaltEncrypted);\n\n      if (saltValueSetInStorageResult instanceof Error) {\n        console.error(saltValueSetInStorageResult);\n        return new Error('Failed to store the salt value in the persistant storage');\n      }\n      return newSalt;\n    }\n    return decryptValueByLogin(credentials.login, saltEncrypted);\n  }\n\n  protected async getWithStorageProvider(key: string): Promise<string | Error | undefined> {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error('There is no connection with a storage provider');\n    }\n\n    const value = await storageProvider.get(key);\n\n    if (value instanceof Error) {\n      return SecretStorage.error(value);\n    }\n    if (!value) {\n      return value;\n    }\n    if (typeof value !== 'string' || !value.length) {\n      return SecretStorage.error('There is a wrong value type returned by the storage provider. A string must be returned');\n    }\n    return value;\n  }\n\n  protected async getWithStorageProviderUint8Array(key: string): Promise<Uint8Array | Error | undefined> {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error('There is no connection with a storage provider');\n    }\n\n    if (typeof storageProvider.getUInt8Array !== 'function') {\n      return new Error('The storage provider which support Uint8Array must provide the method called getUInt8Array');\n    }\n\n    const value = await storageProvider.getUInt8Array(key);\n\n    if (!value) {\n      return undefined;\n    }\n    if (value instanceof Error) {\n      return SecretStorage.error(value);\n    }\n    if (!(value instanceof Uint8Array) || !value.length) {\n      return SecretStorage.error(\n        'There is a wrong value type returned by the storage provider. An instance of Uint8Array must be returned'\n      );\n    }\n    return value;\n  }\n\n  protected async decryptValue(value: string): Promise<string | Error> {\n    const { k } = this;\n\n    if (!(k instanceof CryptoKey)) {\n      return SecretStorage.error('There is no a valid key to decrypt the value');\n    }\n\n    const decryptedValue = await decryptDataWithKey(k, value);\n\n    if (decryptedValue instanceof Error) {\n      return SecretStorage.error(decryptedValue);\n    }\n    if (typeof decryptedValue !== 'string') {\n      return SecretStorage.error('A wrong value decrypted');\n    }\n    return decryptedValue;\n  }\n\n  protected async decryptValueFromUInt8Array(value: Uint8Array): Promise<string | Error> {\n    const { k } = this;\n\n    if (!(k instanceof CryptoKey)) {\n      return SecretStorage.error('There is no a valid key to decrypt the value');\n    }\n    if (!value.length) {\n      return SecretStorage.error('The value must not be empty');\n    }\n\n    const decryptedValue = await decryptDataWithKeyFromUint8Array(k, value);\n\n    if (decryptedValue instanceof Error) {\n      return SecretStorage.error(decryptedValue);\n    }\n    if (typeof decryptedValue !== 'string') {\n      return SecretStorage.error('A wrong value decrypted');\n    }\n    return decryptedValue;\n  }\n\n  protected async setWithStorageProvider(key: string, value: string): Promise<boolean | Error> {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error('There is no an active connection with storage provider');\n    }\n\n    const result = await storageProvider.set(key, value);\n\n    if (result instanceof Error) {\n      return result;\n    }\n    if (result !== true) {\n      return new Error('A wrong result on set the value into the storage provider');\n    }\n    return true;\n  }\n\n  protected unsetWithStorageProvider = async (key: string): Promise<boolean | Error> => {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error('There is no an active connection with storage provider');\n    }\n\n    const result = await storageProvider.set(this.storageKey(key), undefined);\n\n    if (result instanceof Error) {\n      return result;\n    }\n    return true;\n  };\n\n  protected async setWithStorageProviderUInt8Array(key: string, value: Uint8Array): Promise<boolean | Error> {\n    const { storageProvider } = this;\n\n    if (!storageProvider) {\n      return new Error('There is no an active connection with storage provider');\n    }\n    if (typeof storageProvider.setUInt8Array !== 'function') {\n      return new Error(\"The storage provider doesn't have the method setUInt8Array\");\n    }\n\n    const result = await storageProvider.setUInt8Array(key, value);\n\n    if (result instanceof Error) {\n      return result;\n    }\n    if (result !== true) {\n      return new Error('A wrong result on set the value into the storage provider');\n    }\n    return true;\n  }\n\n  protected async encryptValue(value: string): Promise<string | Error> {\n    const { k } = this;\n\n    if (!(k instanceof CryptoKey)) {\n      return new Error('There is no key to encrypt the value');\n    }\n\n    const encryptedValue = await encryptDataToString(k, value);\n\n    if (encryptedValue instanceof Error) {\n      return encryptedValue;\n    }\n    if (typeof encryptedValue !== 'string' || !encryptedValue.length) {\n      return new Error('A wrong encryption result for the value');\n    }\n    return encryptedValue;\n  }\n\n  /**\n   * encrypts string to the UInt8Array\n   *\n   * @protected\n   * @param {string} value\n   * @returns {(Promise<Uint8Array | Error>)}\n   * @memberof SecretStorage\n   */\n  protected async encryptValueAsInt8Array(value: string | Uint8Array): Promise<Uint8Array | Error> {\n    const { k } = this;\n\n    if (!(k instanceof CryptoKey)) {\n      return new Error('There is no key to encrypt the value');\n    }\n\n    const encryptedValue = await encryptDataToUInt8Array(k, value);\n\n    if (encryptedValue instanceof Error) {\n      return encryptedValue;\n    }\n    if (!(encryptedValue instanceof Uint8Array) || !encryptedValue.length) {\n      return new Error('A wrong encryption result for the value');\n    }\n    return encryptedValue;\n  }\n\n  protected async readLoginAndKeyFromSession(\n    session: ISensitiveDataSessionStorage\n  ): Promise<ISecretStorageSessionInfo | Error | undefined> {\n    try {\n      const sessionInfo: ISecretStorageSessionInfoStored | undefined = await session.getItem(SECRET_STORAGE_SESSION_KEY);\n\n      if (sessionInfo) {\n        const cryptoKey = await importPasswordKeyFromString(sessionInfo.key);\n\n        if (cryptoKey instanceof Error) {\n          return cryptoKey;\n        }\n        return {\n          key: cryptoKey,\n          login: sessionInfo.login,\n        };\n      }\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  protected async saveLoginAndKeyToSession(\n    session: ISensitiveDataSessionStorage,\n    login: string,\n    key: CryptoKey\n  ): Promise<Error | undefined> {\n    const keyExported = await exportPasswordKeyAsString(key);\n\n    if (keyExported instanceof Error) {\n      return keyExported;\n    }\n\n    const sessionInfo: ISecretStorageSessionInfoStored = {\n      login,\n      key: keyExported,\n    };\n\n    try {\n      await session.setItem(SECRET_STORAGE_SESSION_KEY, sessionInfo);\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  protected readValueForKey = async (key: string) => {\n    if (!this.isRunning) {\n      return new Error('There is no connection with storage or not authorized');\n    }\n\n    const k = this.storageKey(key);\n    const { isStorageProviderSupportUInt8Array } = this;\n\n    return isStorageProviderSupportUInt8Array ? this.getWithStorageProviderUint8Array(k) : this.getWithStorageProvider(k);\n  };\n\n  protected isValueDefined(valueEncrypted: any): boolean {\n    if (this.isNullishValue(valueEncrypted)) {\n      return true;\n    }\n    if (!valueEncrypted) {\n      return false;\n    }\n    return true;\n  }\n}\n","/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class.types.ts",["2962","2963"],"import { IStorageProviderOptions, TStorageProviderName } from './../storage-providers/storage-providers.types';\nimport { ISensitiveDataSessionStorage } from 'classes/sensitive-data-session-storage/sensitive-data-session-storage.types';\nimport { IStorageCommon } from '../../types/storage.types';\nexport * from 'classes/storage-providers/storage-providers.types';\n\nexport interface ISecretStoreConfiguration {\n  storageProviderName: TStorageProviderName;\n}\n\nexport interface IISecretStorageOptions extends IStorageProviderOptions {}\n\nexport interface ISecretStorageSessionInfoStored {\n  login: string;\n  key: string;\n}\n\nexport interface ISecretStorageSessionInfo {\n  login: string;\n  key: CryptoKey;\n}\n\nexport type TSecretStorageProviderName = string;\n\nexport interface ISecretStoreCredentialsSession {\n  session: ISensitiveDataSessionStorage;\n}\n\nexport interface ISecretStoreCredentialsPassword {\n  login: string;\n  password: string;\n}\n\nexport interface ISecretStoreCredentials extends ISecretStoreCredentialsPassword {}\n\nexport interface ISecretStoreCredentialsCryptoKey {\n  key: CryptoKey;\n}\n\nexport type TSecretStorageAuthOptionsCredentials = ISecretStoreCredentials | ISecretStoreCredentialsSession;\n\nexport type TSecretStorageAuthOptions = TSecretStorageAuthOptionsCredentials | ISecretStoreCredentialsCryptoKey;\n\nexport type TSecretStorageAuthorizazionOptions =\n  | ISecretStoreCredentials\n  | ISecretStoreCredentialsSession\n  | ISecretStoreCredentialsCryptoKey;\n\nexport interface ISecretStorage extends IStorageCommon {\n  // returns true if connected succesfully to\n  // a storage and have a vaild crypto key\n  isActive: boolean;\n  connect(options?: IISecretStorageOptions): Promise<boolean | Error>;\n  // authorize and connect to the storage\n  authorize(credentials: ISecretStoreCredentials, options?: IISecretStorageOptions): Promise<boolean | Error>;\n  authorize(sessionOptions: ISecretStoreCredentialsSession, options?: IISecretStorageOptions): Promise<boolean | Error>;\n  authorize(cryptoKey: ISecretStoreCredentialsCryptoKey, options?: IISecretStorageOptions): Promise<boolean | Error>;\n  authorize(credentials: TSecretStorageAuthorizazionOptions, options?: IISecretStorageOptions): Promise<boolean | Error>;\n  // authorize by the crypto key provided\n  authorizeByKey(credentials: ISecretStoreCredentialsCryptoKey, options?: IStorageProviderOptions): Promise<boolean | Error>;\n  // disconnect from the storage\n  disconnect(): Promise<boolean | Error>;\n  /**\n   * for the null value the null value will be set in the storage\n   *\n   * @param {string} key\n   * @param {(string | null)} value\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof ISecretStorage\n   */\n  set(key: string, value: string | null): Promise<boolean | Error>;\n  /**\n   * insert value only if there is no value or value.\n   * Nullish value is considered to be existing.\n   *\n   * @param {string} key\n   * @param {(string | null)} value\n   * @returns {(Promise<boolean | Error>)} - return false if the value was not inserted, true otherwise\n   * @memberof ISecretStorage\n   */\n  insert(key: string, value: string | null): Promise<boolean | Error>;\n  /**\n   * if the null value was set before, null will be returned\n   */\n  get(key: string): Promise<string | undefined | null | Error>;\n\n  /**\n   * check if a value exists in the storage for\n   * the key given\n   *\n   * @param {string} key\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof ISecretStorage\n   */\n  has(key: string): Promise<boolean | Error>;\n\n  /**\n   * unset a record with the key\n   * provided or a list of records\n   * with have the keys provided\n   *\n   * @param {(string | string[])} key\n   * @returns {(Promise<Error | void>)}\n   * @memberof ISecretStorage\n   */\n  unset(key: string | string[]): Promise<Error | void>;\n  /**\n   * generates crypto key by the credentials provided.\n   * it may be used to authorize to the storage\n   *\n   * @param {(ISecretStoreCredentials\n   *       | ISecretStoreCredentialsSession)} credentialsOrSession\n   * @returns {(Promise<CryptoKey | Error>)}\n   * @memberof ISecretStorage\n   */\n  generateCryptoKey(credentialsOrSession: TSecretStorageAuthorizazionOptions): Promise<CryptoKey | Error>;\n  /**\n   * remove all content withting the database\n   * connected to.\n   *\n   * @returns {(Promise<boolean | Error>)}\n   * @memberof ISecretStorage\n   */\n  clearDb(): Promise<Error | boolean>;\n}\n","/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/index.ts",[],"/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/sensitive-data-session-storage.const.ts",[],"/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/sensitive-data-session-storage.ts",["2964","2965","2966","2967","2968","2969","2970","2971","2972","2973","2974","2975","2976","2977","2978","2979"],"import { ISensitiveDataSessionStorage, ISensitiveDataSessionStorageOptions } from './sensitive-data-session-storage.types';\nimport {\n  SENSITIVE_DATA_SESSION_STORAGE_STORAGE_KEY,\n  SENSITIVE_DATA_SESSION_STORAGE_STORAGE_KEY_SALT,\n} from './sensitive-data-session-storage.const';\nimport assert from 'assert';\nimport { generatePasswordKeyByPasswordSalt, generateSaltForPassword } from 'classes/secret-storage-class';\nimport { encryptDataToString, decryptDataByPassword } from 'utils';\n\nexport class SensitiveDataSessionStorage implements ISensitiveDataSessionStorage {\n  protected isConnected: boolean = false;\n\n  protected connectingPromise: undefined | Promise<void> = undefined;\n\n  protected _temp: Record<string, any> = {};\n\n  private _tempStringified: string | undefined = undefined;\n\n  private k?: CryptoKey;\n\n  private storagePrefix: string = '';\n\n  private get storageKeyValue() {\n    return `${this.storagePrefix}//${SENSITIVE_DATA_SESSION_STORAGE_STORAGE_KEY}`;\n  }\n\n  private get storageKeySalt() {\n    return `${this.storagePrefix}//${SENSITIVE_DATA_SESSION_STORAGE_STORAGE_KEY_SALT}`;\n  }\n\n  public async connect(options?: ISensitiveDataSessionStorageOptions) {\n    if (this.isConnected) {\n      return;\n    }\n    if (options) {\n      const { storagePrefix } = options;\n\n      if (storagePrefix) {\n        this.storagePrefix = storagePrefix;\n      }\n    }\n    if (!this.connectingPromise) {\n      this.connectingPromise = this.connectToStorage(options);\n    }\n    await this.connectingPromise;\n  }\n\n  public getItem = async (key: string) => {\n    assert(typeof key === 'string', 'Key must be a string');\n    return this._temp[key];\n  };\n\n  public setItem = async (key: string, v: any) => {\n    assert(typeof key === 'string', 'Key must be a string');\n    if (v == null) {\n      delete this._temp[key];\n    } else {\n      this._temp[key] = v;\n    }\n    await this.stringifyTemp();\n  };\n\n  private async connectToStorage(options?: ISensitiveDataSessionStorageOptions) {\n    let error: Error | undefined;\n    try {\n      let k: CryptoKey | undefined;\n      const pinCode = options?.pinCode;\n\n      try {\n        this._temp = (await this.readFromStorage(pinCode)) ?? {};\n      } catch (err) {\n        error = err;\n      }\n      this.subscribeOnWindowUnload();\n      if (pinCode) {\n        assert(typeof pinCode === 'string', 'Pin code must be a string');\n        const pinCodeNewCryptoKey = await generatePasswordKeyByPasswordSalt(pinCode, this.generateSalt());\n\n        if (pinCodeNewCryptoKey instanceof Error) {\n          throw pinCodeNewCryptoKey;\n        }\n        k = pinCodeNewCryptoKey;\n      }\n      this.k = k;\n      await this.stringifyTemp();\n    } catch (err) {\n      this.reset();\n      console.error(err);\n      throw err;\n    } finally {\n      if (options?.clearStorageAfterConnect !== false) {\n        this.clearValueStorage();\n      }\n      this.isConnected = true;\n    }\n    if (error) {\n      throw error;\n    }\n  }\n\n  private readSalt() {\n    const salt = sessionStorage.getItem(this.storageKeySalt);\n\n    return salt;\n  }\n\n  private generateSalt() {\n    const newSalt = generateSaltForPassword();\n\n    if (typeof newSalt !== 'string') {\n      throw new Error('Failed to generate a salt value');\n    }\n    sessionStorage.setItem(this.storageKeySalt, newSalt);\n    return newSalt;\n  }\n\n  public toString() {\n    return this._tempStringified ?? '';\n  }\n\n  private subscribeOnWindowUnload() {\n    window.addEventListener('beforeunload', () => {\n      const v = this._tempStringified;\n      if (v && typeof v === 'string') {\n        sessionStorage.setItem(this.storageKeyValue, v);\n      }\n    });\n  }\n\n  private async readFromStorage(pinCode?: string) {\n    const v = sessionStorage.getItem(this.storageKeyValue);\n\n    if (!v) {\n      return;\n    }\n    const salt = !!pinCode && this.readSalt();\n    const decrypted = salt && pinCode ? await decryptDataByPassword(pinCode, salt, v) : v;\n\n    if (decrypted instanceof Error) {\n      throw decrypted;\n    }\n    return JSON.parse(decrypted);\n  }\n\n  protected clearSaltStorage() {\n    sessionStorage.removeItem(this.storageKeySalt);\n  }\n\n  protected clearValueStorage() {\n    sessionStorage.removeItem(this.storageKeyValue);\n  }\n\n  protected reset() {\n    this.clearSaltStorage();\n    this.clearValueStorage();\n    this.k = undefined;\n    this._temp = {};\n    this._tempStringified = undefined;\n  }\n\n  private stringifyTemp = async () => {\n    const k = this.k;\n    const v = this._temp;\n    let stringified = undefined as string | undefined;\n\n    if (!Object.keys(v).length) {\n      stringified = undefined;\n    } else if (k) {\n      const encrypted = await encryptDataToString(k, v);\n\n      if (encrypted instanceof Error) {\n        return;\n      }\n      stringified = encrypted;\n    } else {\n      stringified = JSON.stringify(v);\n    }\n    this._tempStringified = stringified;\n  };\n}\n","/home/paul/projects/protocol/src/classes/sensitive-data-session-storage/sensitive-data-session-storage.types.ts",["2980","2981"],"export interface ISensitiveDataSessionStorageOptions {\n  /**\n   * pincode value used to encrypt and decrypt a sensitive information\n   *\n   * @type {string}\n   * @memberof ISensitiveDataSessionStorageOptions\n   */\n  pinCode?: string;\n  storagePrefix?: string;\n  /**\n   * clear values in the session storage\n   * after connection to it.\n   *\n   * @type {boolean}\n   * @memberof ISensitiveDataSessionStorageOptions\n   */\n  clearStorageAfterConnect?: boolean;\n}\n/**\n * used to store data in the session storage.\n * A data may be secured with a pin code value.\n *\n * @export\n * @interface ISensitiveDataSessionStorage\n */\nexport interface ISensitiveDataSessionStorage {\n  /**\n   * connect to the storage\n   *\n   * @param {ISensitiveDataSessionStorageOptions} options\n   * @returns {Promise<void>}\n   * @memberof ISensitiveDataSessionStorage\n   * @throws\n   */\n  connect(options: ISensitiveDataSessionStorageOptions): Promise<void>;\n  /**\n   * add item to the storage\n   *\n   * @param {string} key\n   * @param {*} value\n   * @returns {Promise<void>}\n   * @memberof ISensitiveDataSessionStorage\n   */\n  setItem(key: string, value: any): Promise<void>;\n  getItem(key: string): Promise<any>;\n}\n","/home/paul/projects/protocol/src/classes/storage-providers/index.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-level-js-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-level-js-provider/secret-storage-level-js-provider.const.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-level-js-provider/secret-storage-level-js-provider.ts",["2982","2983","2984","2985","2986","2987","2988","2989","2990","2991","2992","2993","2994","2995","2996","2997","2998","2999","3000"],"import levelup, { LevelUp } from 'levelup';\nimport leveljs from 'level-js';\nimport { StorageProvider, IStorageProviderOptions } from '../storage-providers.types';\nimport { SECRET_STORAGE_LEVELJS_PROVIDER_DEFAULTS_DB_NAME } from './secret-storage-level-js-provider.const';\n\nexport class SecretStorageProviderLevelJS implements StorageProvider {\n  public static isBufferSupported = true;\n\n  private levelStorage?: LevelUp;\n\n  private dbName: string = SECRET_STORAGE_LEVELJS_PROVIDER_DEFAULTS_DB_NAME;\n\n  private options?: IStorageProviderOptions;\n\n  private isDisconnected: boolean = false;\n\n  public async connect(options?: IStorageProviderOptions): Promise<true | Error> {\n    try {\n      const { isDisconnected } = this;\n\n      if (isDisconnected) {\n        return new Error('The instance of the SecretStorageProvider was closed before');\n      }\n\n      this.setOptions(options);\n\n      const res = await this.createInstanceOfLevelDB();\n\n      if (res instanceof Error) {\n        console.error('SecretStorageProviderLevelJS', res);\n        return res;\n      }\n      return true;\n    } catch (err) {\n      console.error('SecretStorageProviderLevelJS', err);\n      return err;\n    }\n  }\n\n  public async disconnect(): Promise<true | Error> {\n    try {\n      const { levelStorage, isDisconnected } = this;\n\n      if (isDisconnected) {\n        return true;\n      }\n      this.setIsDisconnected();\n      if (levelStorage) {\n        await levelStorage.close();\n      }\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n    return true;\n  }\n\n  /**\n   * WARNING! If the value is empty\n   * it will be removed with the leveljs.del\n   *\n   * @param {string} key\n   * @param {string} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public async set(key: string, value?: string): Promise<Error | true> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n\n      if (!levelStorage) {\n        return new Error('There is no storage connected');\n      }\n      if (!value) {\n        return await this.unset(key);\n      } else {\n        await levelStorage.put(key, value);\n      }\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async unset(key: string): Promise<Error | true> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n\n      if (!levelStorage) {\n        return new Error('There is no storage connected');\n      }\n      await levelStorage.del(key);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async clearDb(): Promise<Error | boolean> {\n    try {\n      const isDisconnected = this.checkIsReady();\n      const { levelStorage } = this;\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n      if (!levelStorage) {\n        return new Error('There is no connection to the local forage');\n      }\n      if (this.dbName === SECRET_STORAGE_LEVELJS_PROVIDER_DEFAULTS_DB_NAME) {\n        return new Error(\"The DEFAULT database can't be removed\");\n      }\n      if (!(levelStorage as any).clear) {\n        return new Error('The version of the library does not supports for a db clearing');\n      }\n      await (levelStorage as any).clear();\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * WARNING! If the value is empty\n   * it will be removed with the leveljs.del\n   *\n   * @param {string} key\n   * @param {string} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public async setUInt8Array(key: string, value?: Uint8Array): Promise<Error | true> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n\n      if (!levelStorage) {\n        return new Error('There is no storage connected');\n      }\n      if (!value) {\n        return await this.unset(key);\n      }\n      await levelStorage.put(key, value);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async get(key: string): Promise<Error | string | undefined> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n      const item = await levelStorage!.get(key, { asBuffer: false });\n\n      if (typeof item !== 'string') {\n        return undefined;\n      }\n      return item;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async getUInt8Array(key: string): Promise<Error | Uint8Array | undefined> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { levelStorage } = this;\n      // TODO - the custom patch used to return\n      // Uint8Array instead of Buffer\n      const item = await levelStorage!.get(key, { asBuffer: true });\n\n      return new Uint8Array(item);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected setOptions(options?: IStorageProviderOptions): void {\n    if (options && typeof options === 'object') {\n      this.options = options;\n\n      const { dbName } = options;\n\n      if (dbName && typeof dbName === 'string') {\n        this.dbName = dbName;\n      }\n    }\n  }\n\n  protected setIsDisconnected() {\n    this.isDisconnected = true;\n  }\n\n  protected checkIsReady(): void | Error {\n    const { isDisconnected, levelStorage } = this;\n\n    if (isDisconnected) {\n      return new Error('The StorageProvider instance is disconnected');\n    }\n    if (!levelStorage) {\n      return new Error('There is no storage connected');\n    }\n  }\n\n  protected async createInstanceOfLevelDB(): Promise<void | Error> {\n    const { dbName } = this;\n    const levelStorage = levelup(leveljs(dbName));\n\n    try {\n      await levelStorage.open();\n    } catch (err) {\n      return err;\n    }\n    this.levelStorage = levelStorage;\n  }\n}\n","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-forage-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-local-forage-provider/secret-storage-local-forage-provider.const.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-local-forage-provider/secret-storage-local-forage-provider.ts",["3001","3002","3003","3004","3005","3006","3007","3008","3009","3010"],"import localforage from 'localforage';\nimport assert from 'assert';\nimport { StorageProvider, IStorageProviderOptions } from '../storage-providers.types';\nimport {\n  SECRET_STORAGE_LOCAL_FORAGE_PROVIDER_DEFAULTS_DB_NAME,\n  SECRET_STORAGE_LOCAL_FORAGE_PROVIDER_DRIVER,\n} from './secret-storage-local-forage-provider.const';\n\n/**\n * The main advantage of using the LocalForage provider because\n * it can store a large binary data(such as UInt8Array) as is\n * without an issues caused unsupported encoding\n *\n * @export\n * @class SecretStorageProviderLocalForage\n * @implements {StorageProvider}\n */\nexport class SecretStorageProviderLocalForage implements StorageProvider {\n  public static isBufferSupported = true;\n\n  public static isDbNameSupported = true;\n\n  private localForage?: LocalForage;\n\n  private dbName: string = SECRET_STORAGE_LOCAL_FORAGE_PROVIDER_DEFAULTS_DB_NAME;\n\n  private options?: IStorageProviderOptions;\n\n  private isDisconnected: boolean = false;\n\n  public async connect(options?: IStorageProviderOptions): Promise<true | Error> {\n    try {\n      const { isDisconnected } = this;\n\n      if (isDisconnected) {\n        return new Error('The instance of the SecretStorageProvider was closed before');\n      }\n      this.setOptions(options);\n\n      const res = await this.createInstanceOfLocalforage();\n\n      if (res instanceof Error) {\n        console.error('SecretStorageProviderLevelJS', res);\n        return res;\n      }\n      return true;\n    } catch (err) {\n      console.error('SecretStorageProviderLevelJS', err);\n      return err;\n    }\n  }\n\n  public async disconnect(): Promise<true | Error> {\n    try {\n      const { localForage, isDisconnected } = this;\n\n      if (isDisconnected) {\n        return true;\n      }\n      this.setIsDisconnected();\n      this.localForage = undefined;\n      if (localForage) {\n        await localForage.dropInstance();\n      }\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n    return true;\n  }\n\n  /**\n   * WARNING! If the value is empty\n   * it will be removed with the leveljs.del\n   *\n   * @param {string} key\n   * @param {string} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public async set(key: string, value?: string): Promise<Error | boolean> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { localForage: levelStorage } = this;\n\n      if (!levelStorage) {\n        return new Error('There is no storage connected');\n      }\n      if (!value) {\n        return await this.unset(key);\n      } else {\n        await levelStorage.setItem(key, value);\n      }\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * WARNING! If the value is empty\n   * it will be removed with the leveljs.del\n   *\n   * @param {string} key\n   * @param {string} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public async setUInt8Array(key: string, value?: Uint8Array): Promise<Error | boolean> {\n    try {\n      const isDisconnected = this.checkIsReady();\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n\n      const { localForage: levelStorage } = this;\n\n      if (!levelStorage) {\n        return new Error('There is no storage connected');\n      }\n      if (!value) {\n        return await this.unset(key);\n      }\n      await levelStorage.setItem(key, value);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async get(key: string): Promise<Error | string | undefined> {\n    try {\n      const isDisconnected = this.checkIsReady();\n      const { localForage } = this;\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n      if (!localForage) {\n        return new Error('There is no connection to the local forage');\n      }\n\n      const item = await localForage.getItem(key);\n\n      if (typeof item !== 'string') {\n        return undefined;\n      }\n      return item;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async unset(key: string): Promise<Error | boolean> {\n    try {\n      const isDisconnected = this.checkIsReady();\n      const { localForage } = this;\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n      if (!localForage) {\n        return new Error('There is no connection to the local forage');\n      }\n      await localForage.removeItem(key);\n      return true;\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  public async clearDb(): Promise<Error | boolean> {\n    try {\n      const isDisconnected = this.checkIsReady();\n      const { localForage } = this;\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n      if (!localForage) {\n        return new Error('There is no connection to the local forage');\n      }\n      if (this.dbName === SECRET_STORAGE_LOCAL_FORAGE_PROVIDER_DEFAULTS_DB_NAME) {\n        return new Error(\"The DEFAULT database can't be removed\");\n      }\n      await localForage.clear();\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async getUInt8Array(key: string): Promise<Error | Uint8Array | undefined> {\n    try {\n      const isDisconnected = this.checkIsReady();\n      const { localForage } = this;\n\n      if (isDisconnected instanceof Error) {\n        return isDisconnected;\n      }\n      if (!localForage) {\n        return new Error('There is no connection to the local forage');\n      }\n\n      // TODO - the custom patch used to return\n      // Uint8Array instead of Buffer\n      const item = await localForage.getItem(key);\n\n      if (!item) {\n        return undefined;\n      }\n      return new Uint8Array(item as Buffer);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected setOptions(options?: IStorageProviderOptions): void {\n    if (options && typeof options === 'object') {\n      this.options = options;\n\n      const { dbName } = options;\n\n      if (dbName) {\n        assert(typeof dbName === 'string', 'A name of the database must be a string');\n        this.dbName = dbName;\n      }\n    }\n  }\n\n  protected setIsDisconnected() {\n    this.isDisconnected = true;\n  }\n\n  protected checkIsReady(): void | Error {\n    const { isDisconnected, localForage: levelStorage } = this;\n\n    if (isDisconnected) {\n      return new Error('The StorageProvider instance is disconnected');\n    }\n    if (!levelStorage) {\n      return new Error('There is no storage connected');\n    }\n  }\n\n  protected async createInstanceOfLocalforage(): Promise<void | Error> {\n    const { dbName } = this;\n\n    const localForage = localforage.createInstance({\n      name: dbName,\n      storeName: dbName,\n      driver: SECRET_STORAGE_LOCAL_FORAGE_PROVIDER_DRIVER,\n    });\n\n    try {\n      await localForage.ready();\n    } catch (err) {\n      return err;\n    }\n    this.localForage = localForage;\n  }\n}\n","/home/paul/projects/protocol/src/classes/storage-providers/storage-local-storage-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-local-storage-provider/secret-storage-local-storage-provider.ts",["3011","3012","3013","3014","3015","3016","3017","3018","3019","3020","3021","3022","3023"],"import { IStorageProviderOptions } from './../storage-providers.types';\nimport { StorageProvider } from '../storage-providers.types';\nimport assert from 'assert';\n\nexport class SecretStorageProviderLocalStorage implements StorageProvider {\n  public static isDbNameSupported = true;\n  private localStorage?: Storage;\n\n  protected dbName?: string;\n\n  public async connect(options?: IStorageProviderOptions): Promise<true | Error> {\n    try {\n      if (!window || !window.localStorage) {\n        return new Error('There is no localStorage available for this context');\n      }\n      this.setOptions(options);\n      this.localStorage = window.localStorage; // set the instance to use\n      return true;\n    } catch (err) {\n      console.error('SecretStorageProviderLocalStorage', err);\n      return err;\n    }\n  }\n\n  public async disconnect(): Promise<true | Error> {\n    this.localStorage = undefined;\n    return true;\n  }\n\n  public async clearDb() {\n    try {\n      const { dbName, localStorage } = this;\n\n      if (!dbName) {\n        return new Error('There is no database connected to');\n      }\n      if (!localStorage) {\n        return new Error('Does not connected to a session storage to remove the database');\n      }\n      Object.keys(localStorage).forEach((key) => {\n        if (key.startsWith(dbName)) {\n          localStorage.removeItem(key);\n        }\n      });\n      return true;\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  public async set(key: string, value?: string): Promise<Error | true> {\n    try {\n      const { localStorage } = this;\n\n      if (!localStorage) {\n        return new Error('There is no storage connected');\n      }\n      if (!value) {\n        return await this.unset(key);\n      }\n      localStorage.setItem(this.resolveKey(key), value);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async unset(key: string): Promise<Error | true> {\n    try {\n      const { localStorage } = this;\n\n      if (!localStorage) {\n        return new Error('There is no storage connected');\n      }\n      localStorage.removeItem(this.resolveKey(key));\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async get(key: string): Promise<Error | string | undefined> {\n    try {\n      const { localStorage } = this;\n\n      if (!localStorage) {\n        return new Error('There is no storage connected');\n      }\n\n      const item = localStorage.getItem(this.resolveKey(key));\n\n      if (typeof item !== 'string') {\n        return undefined;\n      }\n      return item;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected setOptions(options?: IStorageProviderOptions) {\n    if (options) {\n      assert(typeof options === 'object', 'Options provided must be an object');\n\n      const { dbName } = options;\n\n      if (dbName) {\n        assert(typeof dbName === 'string', 'dbName must be a string');\n        this.dbName = `${dbName}//`;\n      }\n    }\n  }\n\n  protected resolveKey(key: string) {\n    if (this.dbName) {\n      return `${this.dbName}${key}`;\n    }\n    return key;\n  }\n}\n","/home/paul/projects/protocol/src/classes/storage-providers/storage-providers.const.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-providers.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-providers.types.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-session-storage-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-session-storage-provider/secret-storage-session-storage-provider.ts",["3024","3025","3026","3027","3028","3029","3030","3031","3032","3033","3034","3035","3036"],"import assert from 'assert';\nimport { StorageProvider, IStorageProviderOptions } from '../storage-providers.types';\n\nexport class SecretStorageProvideSessionStorage implements StorageProvider {\n  public static isDbNameSupported = true;\n  private sessionStorage?: Storage;\n\n  protected dbName?: string;\n\n  public async connect(options?: IStorageProviderOptions): Promise<true | Error> {\n    try {\n      if (!window || !window.sessionStorage) {\n        return new Error('There is no sessionStorage available for this context');\n      }\n      this.setOptions(options);\n      this.sessionStorage = window.sessionStorage; // set the instance to use\n      return true;\n    } catch (err) {\n      console.error('SecretStorageProvidersessionStorage', err);\n      return err;\n    }\n  }\n\n  public async disconnect(): Promise<true | Error> {\n    this.sessionStorage = undefined;\n    return true;\n  }\n\n  public async clearDb() {\n    try {\n      const { dbName, sessionStorage } = this;\n\n      if (!dbName) {\n        return new Error('There is no database connected to');\n      }\n      if (!sessionStorage) {\n        return new Error('Does not connected to a session storage to remove the database');\n      }\n      Object.keys(sessionStorage).forEach((key) => {\n        if (key.startsWith(dbName)) {\n          sessionStorage.removeItem(key);\n        }\n      });\n      return true;\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  public async set(key: string, value?: string): Promise<Error | true> {\n    try {\n      const { sessionStorage } = this;\n\n      if (!sessionStorage) {\n        return new Error('There is no storage connected');\n      }\n      if (!value) {\n        return await this.unset(key);\n      }\n      sessionStorage.setItem(this.resolveKey(key), value);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async unset(key: string): Promise<Error | true> {\n    try {\n      const { sessionStorage } = this;\n\n      if (!sessionStorage) {\n        return new Error('There is no storage connected');\n      }\n      sessionStorage.removeItem(this.resolveKey(key));\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async get(key: string): Promise<Error | string | undefined> {\n    try {\n      const { sessionStorage } = this;\n\n      if (!sessionStorage) {\n        return new Error('There is no storage connected');\n      }\n\n      const item = sessionStorage.getItem(this.resolveKey(key));\n\n      if (typeof item !== 'string') {\n        return undefined;\n      }\n      return item;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected setOptions(options?: IStorageProviderOptions) {\n    if (options) {\n      assert(typeof options === 'object', 'Options provided must be an object');\n\n      const { dbName } = options;\n\n      if (dbName) {\n        assert(typeof dbName === 'string', 'dbName must be a string');\n        this.dbName = `${dbName}//`;\n      }\n    }\n  }\n\n  protected resolveKey(key: string) {\n    if (this.dbName) {\n      return `${this.dbName}${key}`;\n    }\n    return key;\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-message/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-constructor.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-constructor.ts",["3037","3038","3039","3040","3041","3042","3043"],"import assert from 'assert';\nimport { getDateNowInSeconds } from '../../utils/common-utils/common-utils-date-time-synced';\nimport { extend } from '../../utils/common-utils/common-utils-objects';\nimport {\n  SWARM_MESSAGE_CONSTRUCTOR_OPTIONS_DEFAULTS_SERIALIZER,\n  SWARM_MESSAGE_CONSTRUCTOR_OPTIONS_DEFAULTS_UTILS,\n} from './swarm-message-constructor.const';\nimport {\n  ISwarmMessageConstructor,\n  ISwarmMessageConstructorOptionsRequired,\n  TSwarmMessageInstance,\n  TSwarmMessageConstructorArgumentBody,\n  TSwarmMessageConstructorOptions,\n  TSwarmMessageSerialized,\n} from './swarm-message-constructor.types';\nimport { SwarmMessageSubclassParser } from './swarm-message-subclasses/swarm-message-subclass-parser/swarm-message-subclass-parser';\nimport {\n  ISwarmMessageSubclassParser,\n  ISwarmMessageSubclassParserOptions,\n} from './swarm-message-subclasses/swarm-message-subclass-parser/swarm-message-subclass-parser.types';\nimport { SwarmMessageSerializer } from './swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer';\nimport {\n  ISwarmMessageSerializer,\n  ISwarmMessageSerializerConstructorOptions,\n} from './swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.types';\nimport { SwarmMessageSubclassValidator } from './swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator';\nimport { SWARM_MESSAGE_CONSTRUCTOR_OPTIONS_DEFAULTS_VALIDATION } from './swarm-message-constructor.const';\nimport { ICentralAuthority } from '../central-authority-class/central-authority-class.types';\nimport { TSwarmMessageConstructorArgumentBodyPrivate } from './swarm-message-constructor.types';\nimport { ISwarmMessgaeEncryptedCache } from '../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport {\n  IMessageValidatorOptions,\n  ISwarmMessageSubclassValidator,\n} from './swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.types';\n\nexport class SwarmMessageConstructor implements ISwarmMessageConstructor {\n  public caConnection?: ICentralAuthority;\n\n  public encryptedCache?: ISwarmMessgaeEncryptedCache;\n\n  protected constructorOptions?: ISwarmMessageConstructorOptionsRequired;\n\n  protected validator?: ISwarmMessageSubclassValidator;\n\n  protected serializer?: ISwarmMessageSerializer;\n\n  protected parser?: ISwarmMessageSubclassParser;\n\n  /**\n   * return full object with options\n   *\n   * @readonly\n   * @protected\n   * @type {ISwarmMessageConstructorOptions}\n   * @memberof SwarmMessageConstructor\n   * @throws\n   */\n  protected get options(): ISwarmMessageConstructorOptionsRequired {\n    if (!this.constructorOptions) {\n      throw new Error('Options are not defined');\n    }\n    return this.constructorOptions;\n  }\n\n  /**\n   * options for swarm message parser constructor\n   *\n   * @readonly\n   * @protected\n   * @type {ISwarmMessageSubclassParserOptions}\n   * @memberof SwarmMessageConstructor\n   * @throws\n   */\n  protected get optionsForSwarmMessageParser(): ISwarmMessageSubclassParserOptions {\n    const { options, validator } = this;\n\n    if (!validator) {\n      throw new Error('A swarm message validator instance is not running');\n    }\n    return {\n      validator,\n      utils: options.utils,\n      encryptedCache: this.encryptedCache,\n    };\n  }\n\n  /**\n   * options for swarm message serializer constructor\n   *\n   * @readonly\n   * @protected\n   * @type {ISwarmMessageSerializerConstructorOptions}\n   * @memberof SwarmMessageConstructor\n   * @throws\n   */\n  protected get optionsForSwarmMessageSerizlizer(): ISwarmMessageSerializerConstructorOptions {\n    const { options, validator } = this;\n\n    if (!validator) {\n      throw new Error('A swarm message validator instance is not running');\n    }\n    return {\n      ...SWARM_MESSAGE_CONSTRUCTOR_OPTIONS_DEFAULTS_SERIALIZER,\n      caConnection: options.caConnection,\n      utils: options.utils,\n      messageValidator: validator,\n    };\n  }\n\n  /**\n   * options for swarm message validator constructor\n   *\n   * @readonly\n   * @protected\n   * @type {IMessageValidatorOptions}\n   * @memberof SwarmMessageConstructor\n   * @throws\n   */\n  protected get optionsForSwarmMessageValidator(): IMessageValidatorOptions {\n    const { options } = this;\n\n    return options.validation;\n  }\n\n  constructor(options: TSwarmMessageConstructorOptions) {\n    this.setOptions(options);\n  }\n\n  /** */\n  public construct = async <T extends TSwarmMessageConstructorArgumentBody | TSwarmMessageSerialized>(\n    message: T\n  ): Promise<TSwarmMessageInstance> => {\n    assert(message, 'Message must not be empty');\n    if (typeof message === 'string') {\n      return this.parse(message);\n    } else if (typeof message === 'object') {\n      return this.serialize(message as TSwarmMessageConstructorArgumentBody | TSwarmMessageConstructorArgumentBodyPrivate);\n    }\n    throw new Error('A message must be an object or a string');\n  };\n\n  /**\n   * Validates shallow the options used by\n   * all the inner subclasses.\n   *\n   * @protected\n   * @param {ISwarmMessageConstructorOptions} options\n   * @memberof SwarmMessageConstructor\n   * @throws\n   */\n  protected validateOptions(options: TSwarmMessageConstructorOptions) {\n    assert(options, 'An options must be defined');\n    assert(typeof options === 'object', 'The options must be an object');\n\n    const { utils, caConnection, instances, validation } = options;\n\n    assert(caConnection, 'There is no connection to the central authority provided');\n    assert(typeof caConnection === 'object', 'Connection to the central authority must be an object');\n    assert(caConnection.isRunning === true, 'Connection to the central authority must be already running');\n    assert(\n      typeof caConnection.getUserIdentity === 'function',\n      'Connection to the central authority incorrectly implements the interface, cause there is no method to get the current user identity'\n    );\n    if (utils) {\n      assert(typeof utils === 'object', 'The utils must be an object');\n    }\n    if (validation) {\n      assert(typeof validation === 'object', 'The validation options must be an object');\n      if (validation.formatValidatorOpts) {\n        assert(typeof validation.formatValidatorOpts === 'object', 'The formatValidatorOpts options must be an object');\n      }\n      if (validation.signatureValidationOpts) {\n        assert(typeof validation.signatureValidationOpts === 'object', 'The signatureValidationOpts options must be an object');\n      }\n    }\n\n    let warnAboutNoCryptoCache = true;\n\n    if (instances) {\n      assert(typeof instances === 'object', 'The instances must be an object');\n      if (instances.parser) {\n        assert(typeof instances.parser === 'object', 'A parser instance must be an object');\n      }\n      if (instances.serizlizer) {\n        assert(typeof instances.serizlizer === 'object', 'A serizlizer instance must be an object');\n      }\n      if (instances.validator) {\n        assert(typeof instances.validator === 'object', 'A validator instance must be an object');\n      }\n      if (instances.encryptedCache) {\n        assert(typeof instances.encryptedCache === 'object', 'Encrypted cache storage must be an object');\n        assert(\n          typeof instances.encryptedCache.connect === 'function' &&\n            typeof instances.encryptedCache.add === 'function' &&\n            typeof instances.encryptedCache.get === 'function',\n          'Encrypted cache storage have a wrong implementation'\n        );\n        this.encryptedCache = instances.encryptedCache;\n        warnAboutNoCryptoCache = false;\n      }\n    }\n    if (warnAboutNoCryptoCache) {\n      console.warn('The encrypted cache must be provided to support private messages as decrypted');\n    }\n  }\n\n  /**\n   * extends the options provided by the defaults\n   *\n   * @protected\n   * @param {TSwarmMessageConstructorOptions} options\n   * @returns {ISwarmMessageConstructorOptionsRequired}\n   * @memberof SwarmMessageConstructor\n   */\n  protected extendOptionsByDefaults(options: TSwarmMessageConstructorOptions): ISwarmMessageConstructorOptionsRequired {\n    return {\n      ...options,\n      validation: extend(options.validation || {}, {\n        ...SWARM_MESSAGE_CONSTRUCTOR_OPTIONS_DEFAULTS_VALIDATION,\n        signatureValidationOpts: {\n          ...SWARM_MESSAGE_CONSTRUCTOR_OPTIONS_DEFAULTS_VALIDATION.signatureValidationOpts,\n          caConnection: options.caConnection,\n        },\n      }),\n      utils: extend(options.utils || {}, SWARM_MESSAGE_CONSTRUCTOR_OPTIONS_DEFAULTS_UTILS),\n    };\n  }\n\n  /**\n   * runs a validator of swarm messges\n   *\n   * @protected\n   * @memberof SwarmMessageConstructor\n   * @throws\n   */\n  protected runSwarmMessageValidator() {\n    const { options } = this;\n    const { instances } = options;\n\n    this.validator =\n      instances && instances.validator\n        ? instances.validator\n        : new SwarmMessageSubclassValidator(this.optionsForSwarmMessageValidator);\n  }\n\n  /**\n   * runs a parser of swarm messges\n   *\n   * @protected\n   * @memberof SwarmMessageConstructor\n   * @throws\n   */\n  protected async runSwarmMessageParser() {\n    const { options } = this;\n    const { instances } = options;\n    const userRncryptionKeyPair = this.caConnection?.getUserEncryptionKeyPair();\n\n    if (!userRncryptionKeyPair) {\n      throw new Error(\"Failed to get user's crypto key pair\");\n    }\n    if (userRncryptionKeyPair instanceof Error) {\n      throw userRncryptionKeyPair;\n    }\n\n    this.parser =\n      instances && instances.parser\n        ? instances.parser\n        : new SwarmMessageSubclassParser({\n            ...this.optionsForSwarmMessageParser,\n            decryptionKey: userRncryptionKeyPair.privateKey,\n          });\n  }\n\n  /**\n   * runs a parser of swarm messges\n   *\n   * @protected\n   * @memberof SwarmMessageConstructor\n   * @throws\n   */\n  protected runSwarmMessageSerizlizer() {\n    const { options } = this;\n    const { instances } = options;\n\n    this.serializer =\n      instances && instances.serizlizer\n        ? instances.serizlizer\n        : new SwarmMessageSerializer(this.optionsForSwarmMessageSerizlizer);\n  }\n\n  /**\n   * set options for the instance\n   *\n   * @protected\n   * @param {TSwarmMessageConstructorOptions} options\n   * @memberof SwarmMessageConstructor\n   */\n  protected setOptions(options: TSwarmMessageConstructorOptions) {\n    this.validateOptions(options);\n    this.caConnection = options.caConnection;\n    this.constructorOptions = this.extendOptionsByDefaults(options);\n    // validator must runs at first cause\n    // it used by another instances\n    this.runSwarmMessageValidator();\n    this.runSwarmMessageSerizlizer();\n    void this.runSwarmMessageParser();\n  }\n\n  /**\n   * add message to the cache if it's a private\n   * message\n   *\n   * @protected\n   * @param {TSwarmMessageInstance} msg\n   * @memberof SwarmMessageConstructor\n   */\n  protected async addPrivateMessageToCache(msg: TSwarmMessageInstance) {\n    if (msg.isPrivate) {\n      await this.addPrivateMessageBodyToCache(msg.sig, msg.bdy as TSwarmMessageConstructorArgumentBodyPrivate);\n    }\n  }\n\n  /**\n   * parse a message serialized\n   *\n   * @protected\n   * @param {string} msg\n   * @memberof SwarmMessageConstructor\n   * @throws\n   */\n  protected async parse(msg: TSwarmMessageSerialized): Promise<TSwarmMessageInstance> {\n    if (!this.parser) {\n      throw new Error('A swarm message parser instance is not defined');\n    }\n\n    const messageParsed = await this.parser.parse(msg);\n\n    if (messageParsed instanceof Error) {\n      return messageParsed;\n    }\n    await this.addPrivateMessageToCache(messageParsed);\n    return messageParsed;\n  }\n\n  /**\n   * parse a message serialized\n   *\n   * @protected\n   * @param {string} msg\n   * @memberof SwarmMessageConstructor\n   * @throws\n   */\n  protected async serialize(\n    msg: TSwarmMessageConstructorArgumentBody | TSwarmMessageConstructorArgumentBodyPrivate\n  ): Promise<TSwarmMessageInstance> {\n    if (!this.serializer) {\n      throw new Error('A swarm message serializer instance is not defined');\n    }\n\n    const receiverId = (msg as TSwarmMessageConstructorArgumentBodyPrivate).receiverId;\n    let cryptoKey: CryptoKey | undefined;\n\n    if (receiverId) {\n      if (!this.caConnection) {\n        throw new Error('There is no connection with the CentralAuthority');\n      }\n\n      const receiverPubKey = await this.caConnection.getSwarmUserEncryptionPubKey(receiverId);\n\n      if (receiverPubKey instanceof Error) {\n        console.error(\"Failed to get the user's public key\");\n        throw receiverPubKey;\n      }\n      if (!receiverPubKey) {\n        throw new Error('There is no public crypto key of the receiver');\n      }\n      cryptoKey = receiverPubKey;\n    }\n\n    const bodyWithTs = {\n      ...msg,\n      ts: getDateNowInSeconds(),\n    };\n    const swarmMessageSerialized = await this.serializer.serialize(bodyWithTs, cryptoKey);\n    const { sig, isPrivate } = swarmMessageSerialized;\n\n    if (isPrivate) {\n      await this.addPrivateMessageBodyToCache(sig, bodyWithTs as TSwarmMessageConstructorArgumentBodyPrivate);\n    }\n    return swarmMessageSerialized;\n  }\n\n  /**\n   * add private message body decrypted to the encrypted\n   * cache to restore the body in the feature.\n   *\n   * @private\n   * @memberof SwarmMessageConstructor\n   */\n  private async addPrivateMessageBodyToCache(sig: string, msgBody: TSwarmMessageConstructorArgumentBodyPrivate) {\n    if (this.encryptedCache && this.encryptedCache.isRunning) {\n      await this.encryptedCache.add(sig, JSON.stringify(msgBody));\n    }\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-constructor.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-parser/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-parser/swarm-message-subclass-parser.ts",["3044","3045"],"import assert from 'assert';\nimport {\n  TSwarmMessageInstance,\n  TSwarmMessageBodyRaw,\n  TSwarmMessageBodyRawEncrypted,\n} from '../../swarm-message-constructor.types';\nimport { isCryptoKeyDataDecryption } from '../../../../utils/encryption-keys-utils/encryption-keys-utils';\nimport { QueuedEncryptionClassBase } from '../../../basic-classes/queued-encryption-class-base/queued-encryption-class-base';\nimport { ISwarmMessgaeEncryptedCache } from '../../../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport {\n  IQueuedEncrypyionClassBaseOptions,\n  IQueuedEncrypyionClassBase,\n} from '../../../basic-classes/queued-encryption-class-base/queued-encryption-class-base.types';\nimport { ISwarmMessageRaw, TSwarmMessage, TSwarmMessageSerialized } from '../../swarm-message-constructor.types';\nimport { ISwarmMessageSubclassParserOptions, ISwarmMessageSubclassParser } from './swarm-message-subclass-parser.types';\n\nexport class SwarmMessageSubclassParser implements ISwarmMessageSubclassParser {\n  protected constructorOptions?: ISwarmMessageSubclassParserOptions;\n\n  protected msgDecryptQueue?: IQueuedEncrypyionClassBase;\n\n  protected encryptedCache?: ISwarmMessgaeEncryptedCache;\n\n  protected get options(): ISwarmMessageSubclassParserOptions {\n    if (!this.constructorOptions) {\n      throw new Error('The options is not defined for the instance');\n    }\n    return this.constructorOptions;\n  }\n\n  /**\n   * returns an options for messages signing\n   * queue\n   *\n   * @readonly\n   * @protected\n   * @type {IQueuedEncrypyionClassBaseOptions}\n   * @memberof SwarmMessageSerializer\n   */\n  protected get messageDecryptQueueOptions(): IQueuedEncrypyionClassBaseOptions {\n    return {\n      ...this.options.queueOptions,\n      keys: {\n        decryptKey: this.options.decryptionKey,\n      },\n    };\n  }\n\n  constructor(options: ISwarmMessageSubclassParserOptions) {\n    this.setOptions(options);\n    this.startMessageDecryptQueue();\n  }\n\n  /**\n   * parses the message serialized to a\n   * deserizlized message object\n   *\n   * @memberof SwarmMessageSubclassParser\n   */\n  public parse = async (message: TSwarmMessageSerialized): Promise<TSwarmMessageInstance> => {\n    const messageRaw = await this.parseMessageToRaw(message);\n    const messageParsed = await this.parseMessageRaw(messageRaw);\n\n    return this.getSwarmMessageInstance(messageParsed, message);\n  };\n\n  protected validateOptions(options: ISwarmMessageSubclassParserOptions): void {\n    assert(options, 'Options must be provided');\n    assert(typeof options === 'object', 'The options provided must be an object');\n\n    const { utils, validator, decryptionKey } = options;\n\n    assert(utils, 'Utils must be provided');\n    assert(typeof utils === 'object', 'Utils must be an object');\n    assert(typeof utils.messageBodyRawParser === 'function', 'messageBodyRawParser utility must be a function');\n    assert(typeof utils.messageParser === 'function', 'messageParser utility must be a function');\n    assert(validator, 'Validator is not provided');\n    assert(\n      typeof validator.valiadateSwarmMessageRaw === 'function',\n      'Validator incorrectly implements the interface, cause the valiadateSwarmMessageRaw method is absent'\n    );\n    assert(\n      typeof validator.valiadateSwarmMessage === 'function',\n      'Validator incorrectly implements the interface, cause the valiadateSwarmMessage method is absent'\n    );\n    if (!decryptionKey) {\n      console.warn('There is no key for private messages decryption provided in options');\n    } else {\n      assert(isCryptoKeyDataDecryption(decryptionKey), \"The key provided can't be used for data decryption\");\n    }\n  }\n\n  protected setOptions(options: ISwarmMessageSubclassParserOptions): void {\n    this.validateOptions(options);\n    this.constructorOptions = options;\n    this.encryptedCache = options.encryptedCache;\n  }\n\n  protected startMessageDecryptQueue() {\n    this.msgDecryptQueue = new QueuedEncryptionClassBase(this.messageDecryptQueueOptions);\n  }\n\n  /**\n   * parses the messgae to the raw message format\n   * and validates it.\n   *\n   * @protected\n   * @param {TSwarmMessageSerialized} mesage\n   * @returns {ISwarmMessageRaw}\n   * @memberof SwarmMessageSubclassParser\n   * @throws\n   */\n  protected async parseMessageToRaw(mesage: TSwarmMessageSerialized): Promise<ISwarmMessageRaw> {\n    const { utils, validator } = this.options;\n    const { messageParser } = utils;\n    const messageRaw = messageParser(mesage);\n\n    await validator.valiadateSwarmMessageRaw(messageRaw);\n    return messageRaw;\n  }\n\n  /**\n   * parses a swarm message form the raw format\n   * and validates it.\n   *\n   * @protected\n   * @param {ISwarmMessageRaw} messageRaw\n   * @returns {TSwarmMessage}\n   * @memberof SwarmMessageSubclassParser\n   * @throws\n   */\n  protected async parseMessageRaw(messageRaw: ISwarmMessageRaw): Promise<TSwarmMessage> {\n    const { utils, validator } = this.options;\n    const { messageBodyRawParser } = utils;\n    const { bdy: bodyRaw, isPrivate } = messageRaw;\n    let bodyRawDecrypted;\n\n    if (isPrivate) {\n      validator.validateMessageBodyEncrypted(messageRaw.bdy);\n\n      const msgBody = await this.readMessgeBodyFromCache(messageRaw.sig);\n\n      if (typeof msgBody === 'string') {\n        // if the message's body decrypted found\n        bodyRawDecrypted = msgBody;\n      }\n    }\n    if (!bodyRawDecrypted) {\n      bodyRawDecrypted = isPrivate ? await this.decryptMessageBodyRaw(bodyRaw) : bodyRaw;\n    }\n\n    const bodyRawParsed = messageBodyRawParser(bodyRawDecrypted);\n\n    const swarmMessage: TSwarmMessage = {\n      ...messageRaw,\n      bdy: bodyRawParsed,\n    };\n\n    validator.valiadateSwarmMessage(swarmMessage);\n\n    return swarmMessage;\n  }\n\n  protected async decryptMessageBodyRaw(bodyRaw: TSwarmMessageBodyRawEncrypted): Promise<TSwarmMessageBodyRaw> {\n    if (!this.msgDecryptQueue) {\n      throw new Error('Message decrypt queue must be started to read private messgaes');\n    }\n    const decryptedBody = await this.msgDecryptQueue.decryptData(bodyRaw);\n\n    if (decryptedBody instanceof Error) {\n      console.error('Failed to decrypt the private message');\n      throw decryptedBody;\n    }\n    if (!decryptedBody) {\n      throw new Error('No data got after message was decrypted');\n    }\n    return decryptedBody;\n  }\n\n  protected getSwarmMessageInstance(msg: TSwarmMessage, msgSerizlized: TSwarmMessageSerialized): TSwarmMessageInstance {\n    return {\n      ...msg,\n      toString: function (a: TSwarmMessageSerialized) {\n        return a;\n      }.bind(undefined, msgSerizlized),\n    };\n  }\n\n  /**\n   * read a message's body decrypted.\n   *\n   * @protected\n   * @param {string} sig\n   * @returns\n   * @memberof SwarmMessageSubclassParser\n   */\n  protected async readMessgeBodyFromCache(sig: string) {\n    if (this.encryptedCache) {\n      return this.encryptedCache.get(sig);\n    }\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-parser/swarm-message-subclass-parser.types.ts",["3046"],"import { ISwarmMessageSubclassValidator } from '../swarm-message-subclass-validators/swarm-message-subclass-validator.types';\nimport { ISwarmMessageUtilsMessageParser } from '../../swarm-message-utils/swarm-message-utils-message-parser/swarm-message-utils-message-parser.types';\nimport { ISwarmMessageUtilsBodyParser } from '../../swarm-message-utils/swarm-message-utils-body-parser';\nimport { IQueuedEncrypyionClassBaseOptions } from '../../../basic-classes/queued-encryption-class-base/queued-encryption-class-base.types';\nimport { ISwarmMessgaeEncryptedCache } from '../../../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { TSwarmMessageSerialized, TSwarmMessageInstance } from '../../swarm-message-constructor.types';\n\nexport interface ISwarmMessageSubclassParserUtils {\n  messageParser: ISwarmMessageUtilsMessageParser;\n  messageBodyRawParser: ISwarmMessageUtilsBodyParser;\n}\n\nexport interface ISwarmMessageSubclassParserOptions {\n  validator: ISwarmMessageSubclassValidator;\n  utils: ISwarmMessageSubclassParserUtils;\n  queueOptions?: IQueuedEncrypyionClassBaseOptions['queueOptions'];\n  /**\n   * this is a key used to decrypt private messages\n   */\n  decryptionKey?: CryptoKey;\n  /**\n   * if provided, then:\n   * 1) For private messages, before decrypt it's body, parser will try to\n   * read it's body from the cache provided before;\n   * 2) For all messages, parser will try to read sign mark before\n   * validation of a message signature. If there is no mark stored,\n   * then it will be validated.\n   *\n   * @type {ISwarmMessgaeEncryptedCache}\n   * @memberof ISwarmMessageSubclassParserOptions\n   */\n  encryptedCache?: ISwarmMessgaeEncryptedCache;\n}\n\n/**\n * parses and validates swarm message serizlized\n *\n * @export\n * @interface ISwarmMessageSubclassParser\n */\nexport interface ISwarmMessageSubclassParser {\n  /**\n   * deserialize and validate the swarm message\n   *\n   * @param {TSwarmMessageSerialized} message - swarm message serialized\n   * @returns {Promise<ISwarmMessage>}\n   * @memberof ISwarmMessageSubclassParser\n   * @throws\n   */\n  parse(message: TSwarmMessageSerialized): Promise<TSwarmMessageInstance>;\n}\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.ts",["3047","3048","3049","3050"],"import assert from 'assert';\nimport { isCryptoKeyDataSign } from '../../../../utils/encryption-keys-utils/encryption-keys-utils';\nimport { QueuedEncryptionClassBase } from '../../../basic-classes/queued-encryption-class-base/queued-encryption-class-base';\nimport { ISwarmMessageSerializerUser } from './swarm-message-subclass-serializer.types';\nimport CentralAuthorityIdentity from '../../../central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity';\nimport { typedArrayToString } from '../../../../utils/typed-array-utils';\nimport { ISwarmMessageBody, TSwarmMessageBodyRawEncrypted } from '../../swarm-message-constructor.types';\nimport { TSwarmMessageInstance, TSwarmMessagePayloadDeserialized } from '../../swarm-message-constructor.types';\nimport { TSwarmMessageBodyRaw, ISwarmMessageRaw } from '../../swarm-message-constructor.types';\nimport { ISwarmMessageBodyDeserialized } from '../../swarm-message-constructor.types';\nimport {\n  IQueuedEncrypyionClassBase,\n  IQueuedEncrypyionClassBaseOptions,\n} from '../../../basic-classes/queued-encryption-class-base/queued-encryption-class-base.types';\nimport { ISwarmMessageSerializerConstructorOptions, ISwarmMessageSerializer } from './swarm-message-subclass-serializer.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\n\nexport class SwarmMessageSerializer implements ISwarmMessageSerializer {\n  protected msgSignEncryptQueue?: IQueuedEncrypyionClassBase;\n\n  protected constructorOptions?: ISwarmMessageSerializerConstructorOptions;\n\n  protected user?: ISwarmMessageSerializerUser;\n\n  protected get options(): ISwarmMessageSerializerConstructorOptions {\n    if (!this.constructorOptions) {\n      throw new Error('Options are not defined');\n    }\n    return this.constructorOptions;\n  }\n\n  /**\n   * returns an options for messages signing\n   * queue\n   *\n   * @readonly\n   * @protected\n   * @type {IQueuedEncrypyionClassBaseOptions}\n   * @memberof SwarmMessageSerializer\n   */\n  protected get messageEncryptAndSignQueueOptions(): IQueuedEncrypyionClassBaseOptions {\n    const { user } = this;\n\n    if (!user) {\n      throw new Error(\"The current user's infromation is not defined\");\n    }\n    return {\n      ...this.options.queueOptions,\n      keys: {\n        signKey: user.dataSignKey,\n      },\n    };\n  }\n\n  constructor(options: ISwarmMessageSerializerConstructorOptions) {\n    this.setConstructorOptions(options);\n  }\n\n  /**\n   * sign and serizlize the message\n   *\n   * @memberof SwarmMessageSerializer\n   */\n  public serialize = async (\n    msgBody: ISwarmMessageBodyDeserialized,\n    encryptWithKey?: CryptoKey\n  ): Promise<TSwarmMessageInstance> => {\n    this.validateMessageBody(msgBody);\n\n    const swarmMessageBody = this.serializeMessageBody(msgBody);\n    const bodySeriazlized = await this.getMessageBodySerialized(swarmMessageBody, encryptWithKey);\n    const swarmMessageNotSigned = this.getMessageRawWithoutSignature(bodySeriazlized);\n\n    const signature = await this.signSwarmMessageRaw(swarmMessageNotSigned);\n\n    if (signature instanceof Error) {\n      throw new Error('Failed to sign the message');\n    }\n    return this.getMessageSignedSerialized(swarmMessageNotSigned, swarmMessageBody, signature, !!encryptWithKey);\n  };\n\n  /**\n   * validates options used for messages creation\n   *\n   * @protected\n   * @param {ISwarmMessageSerializerConstructorOptions} options\n   * @memberof SwarmMessageSerializer\n   * @throws\n   */\n  protected validateConstructorOptions(options: ISwarmMessageSerializerConstructorOptions): void {\n    assert(!!options, 'The options must be defined');\n    assert(typeof options === 'object', 'The options must be an object');\n    assert(options.messageValidator, 'Message field validator must be defined');\n    assert(\n      typeof options.messageValidator.validateMessageBody === 'function',\n      'Message field validator incorrectly implements interface, cause there is no \"validateMessageBody method\"'\n    );\n    assert(options.caConnection, 'Connection to the CentralAuthority is not provided');\n    assert(typeof options.alg === 'string', 'The algorithm value must be a string');\n\n    const { utils } = options;\n\n    assert(utils, 'Utils must be provided in options');\n    assert(\n      typeof utils.getDataToSignBySwarmMsg === 'function',\n      'getDataToSignBySwarmMsg function must be provided in utils option'\n    );\n    assert(\n      typeof utils.swarmMessageBodySerializer === 'function',\n      'swarmMessageBodySerializer function must be provided in utils option'\n    );\n    assert(\n      typeof utils.swarmMessageSerializer === 'function',\n      'swarmMessageSerializer function must be provided in utils option'\n    );\n  }\n\n  /**\n   * get user identity and crypto keys\n   * of the current user\n   *\n   * @protected\n   * @memberof SwarmMessageSerializer\n   */\n  protected setUserInfo() {\n    const { caConnection } = this.options;\n    const currentUserId = caConnection.getUserIdentity();\n\n    assert(\n      !(currentUserId instanceof Error),\n      'Failed to read an identity of the crurrent user from connection to the central authority'\n    );\n\n    const userIdSerialized = new CentralAuthorityIdentity(currentUserId as string).identityDescritptionSerialized;\n\n    assert(!(userIdSerialized instanceof Error), 'The user identity serialized is not valid');\n\n    const dataSignCryptoKeyPair = caConnection.getUserDataSignKeyPair();\n\n    if (dataSignCryptoKeyPair instanceof Error) {\n      throw new Error('Failed to read data sign key pairs of the current user from a connection to the central authority');\n    }\n\n    const dataSignKey = isCryptoKeyDataSign(dataSignCryptoKeyPair.privateKey)\n      ? dataSignCryptoKeyPair.privateKey\n      : dataSignCryptoKeyPair.publicKey;\n\n    assert(\n      isCryptoKeyDataSign(dataSignKey),\n      'There is not key may used for data signing returned by the conntion to the central authority'\n    );\n    this.user = {\n      dataSignKey: dataSignCryptoKeyPair.privateKey,\n      userId: userIdSerialized as TSwarmMessageUserIdentifierSerialized,\n    };\n  }\n\n  /**\n   * creates queue for a message signing\n   *\n   * @protected\n   * @memberof SwarmMessageSerializer\n   */\n  protected startMessagesSigningQueue() {\n    this.msgSignEncryptQueue = new QueuedEncryptionClassBase(this.messageEncryptAndSignQueueOptions);\n  }\n\n  /**\n   * set options used for messages construction\n   *\n   * @protected\n   * @param {ISwarmMessageSerializerConstructorOptions} options\n   * @memberof SwarmMessageSerializer\n   */\n  protected setConstructorOptions(options: ISwarmMessageSerializerConstructorOptions) {\n    this.validateConstructorOptions(options);\n    this.constructorOptions = options;\n    this.setUserInfo();\n    this.startMessagesSigningQueue();\n  }\n\n  /**\n   * validates message's body, throws if it's\n   * not valid.\n   *\n   * @protected\n   * @param {ISwarmMessageBodyDeserialized} msgBody\n   * @memberof SwarmMessageSerializer\n   */\n  protected validateMessageBody(msgBody: ISwarmMessageBodyDeserialized) {\n    const { messageValidator } = this.options;\n\n    messageValidator.validateMessageBody(msgBody);\n  }\n\n  /**\n   * serizlize message body to\n   * the SwarmMessage's instance format\n   *\n   * @protected\n   * @param {ISwarmMessageBodyDeserialized} msgBody\n   * @returns {ISwarmMessageBody}\n   * @memberof SwarmMessageSerializer\n   * @throws - throw an error is failed to serialize\n   * body\n   */\n  protected serializeMessageBody(msgBody: ISwarmMessageBodyDeserialized): ISwarmMessageBody {\n    let msgPayload: TSwarmMessagePayloadDeserialized;\n    const { pld } = msgBody;\n\n    if (pld instanceof ArrayBuffer) {\n      msgPayload = typedArrayToString(pld) as string;\n      assert(typeof msgPayload === 'string', 'Failed to convert message payload from Buffer to string');\n    } else {\n      msgPayload = pld;\n    }\n    return {\n      ...msgBody,\n      pld: msgPayload,\n    };\n  }\n\n  /**\n   * seriazlize message body\n   *\n   * @protected\n   * @param {ISwarmMessageBodyDeserialized} msgBody\n   * @returns {TSwarmMessageBodyRaw}\n   * @memberof SwarmMessageSerializer\n   */\n  protected async getMessageBodySerialized(\n    msgBody: ISwarmMessageBody,\n    encryptWithKey?: CryptoKey\n  ): Promise<TSwarmMessageBodyRaw> {\n    const { utils } = this.options;\n    const bodyRaw = utils.swarmMessageBodySerializer(msgBody);\n\n    return encryptWithKey ? this.encryptMessageBodyRaw(bodyRaw, encryptWithKey) : bodyRaw;\n  }\n\n  /**\n   * encrypt the message's body with the key provided\n   *\n   * @protected\n   * @param {TSwarmMessageBodyRaw} msgBody\n   * @param {CryptoKey} [encryptWithKey]\n   * @returns {Promise<>}\n   * @memberof SwarmMessageSerializer\n   */\n  protected async encryptMessageBodyRaw(\n    msgBody: TSwarmMessageBodyRaw,\n    encryptWithKey: CryptoKey\n  ): Promise<TSwarmMessageBodyRawEncrypted> {\n    const encrypted = await this.msgSignEncryptQueue?.encryptData(msgBody, encryptWithKey);\n\n    if (encrypted instanceof Error) {\n      console.error('Failed to encrypt the message body');\n      throw encrypted;\n    }\n    if (!encrypted) {\n      throw new Error('Failed to encrype the message body cause an unknown error');\n    }\n    return encrypted;\n  }\n\n  /**\n   * returns swarm message not signed\n   *\n   * @protected\n   * @param {TSwarmMessageBodyRaw} msgBodySerialized\n   * @memberof SwarmMessageSerializer\n   */\n  protected getMessageRawWithoutSignature(msgBodySerialized: TSwarmMessageBodyRaw): Omit<ISwarmMessageRaw, 'sig'> {\n    if (!this.user) {\n      throw new Error('The current user data is not defined');\n    }\n    return {\n      bdy: msgBodySerialized,\n      alg: this.options.alg,\n      uid: this.user.userId,\n    };\n  }\n\n  /**\n   * returns signature for the message\n   *\n   * @protected\n   * @param {Omit<ISwarmMessageRaw, 'sig'>} msgRawUnsigned\n   * @returns {ISwarmMessageRaw['sig']}\n   * @memberof SwarmMessageSerializer\n   */\n  protected async signSwarmMessageRaw(msgRawUnsigned: Omit<ISwarmMessageRaw, 'sig'>): Promise<ISwarmMessageRaw['sig'] | Error> {\n    if (!this.user) {\n      throw new Error('The user info is not defined');\n    }\n    if (!this.msgSignEncryptQueue) {\n      throw new Error('The messages sign queue was not started');\n    }\n\n    const { utils } = this.options;\n    const dataToSign = utils.getDataToSignBySwarmMsg(msgRawUnsigned);\n\n    return this.msgSignEncryptQueue.signData(dataToSign, this.user.dataSignKey);\n  }\n\n  /**\n   * returns message serialized\n   *\n   * @protected\n   * @param {Omit<ISwarmMessageRaw, 'sig'>} msgRawUnsigned\n   * @param {ISwarmMessageRaw['sig']} signature\n   * @returns\n   * @memberof SwarmMessageSerializer\n   */\n  protected getMessageSignedSerialized(\n    msgRawUnsigned: Omit<ISwarmMessageRaw, 'sig'>,\n    msgBody: ISwarmMessageBody,\n    signature: ISwarmMessageRaw['sig'],\n    isPrivate: boolean\n  ): TSwarmMessageInstance {\n    const { utils } = this.options;\n    const swarmMessage = {\n      ...msgRawUnsigned,\n      sig: signature,\n    };\n\n    if (isPrivate) {\n      swarmMessage.isPrivate = isPrivate;\n    }\n    return {\n      ...swarmMessage,\n      bdy: msgBody,\n      toString: utils.swarmMessageSerializer.bind(undefined, swarmMessage),\n    };\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-serializer/swarm-message-subclass-serializer.types.ts",["3051"],"import { ISwarmMessageSubclassFieldsValidator } from '../swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { ISwarmMessageUtilSignatureGetStringForSignByMessageRaw } from '../../swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.types';\nimport { ICentralAuthority } from '../../../central-authority-class/central-authority-class.types';\nimport { IQueuedEncrypyionClassBaseOptions } from '../../../basic-classes/queued-encryption-class-base/queued-encryption-class-base.types';\nimport { ISwarmMessageUtilsBodySerializer } from '../../swarm-message-utils/swarm-message-utils-body-serializer/swarm-message-utils-body-serializer.types';\nimport { ISwarmMessageUtilsMessageSerializer } from '../../swarm-message-utils/swarm-message-utils-message-serializer/swarm-message-utils-message-serializer.types';\nimport { ISwarmMessageSubclassValidator } from '../swarm-message-subclass-validators/swarm-message-subclass-validator.types';\nimport { TSwarmMessageInstance } from '../../swarm-message-constructor.types';\nimport { TSwarmMessageSignatureAlgorithm } from '../../swarm-message-constructor.types';\nimport { ISwarmMessageBodyDeserialized } from '../../swarm-message-constructor.types';\n\nexport interface ISwarmMessageSerializerUtils {\n  getDataToSignBySwarmMsg: ISwarmMessageUtilSignatureGetStringForSignByMessageRaw;\n  swarmMessageBodySerializer: ISwarmMessageUtilsBodySerializer;\n  swarmMessageSerializer: ISwarmMessageUtilsMessageSerializer;\n}\n\n/**\n * data about the user who will create\n * messages.\n *\n * @export\n * @interface ISwarmMessageSerializerUser\n */\nexport interface ISwarmMessageSerializerUser {\n  /**\n   * identity of the user who will be a creator of\n   * swarm messages.\n   *\n   * @type {TSwarmMessageUserIdentifierSerialized}\n   * @memberof ISwarmMessageSerializerUser\n   */\n  userId: TSwarmMessageUserIdentifierSerialized;\n  /**\n   * A crypto key which will be used for\n   * messages signing.\n   *\n   * @type {CryptoKey}\n   * @memberof ISwarmMessageSerializerUser\n   */\n  dataSignKey: CryptoKey;\n}\n\n/**\n * User for messages creation\n *\n * @export\n * @interface ISwarmMessageSerializerConstructorOptions\n */\nexport interface ISwarmMessageSerializerConstructorOptions {\n  /**\n   * options used for the message signing queue\n   *\n   * @type {Required<IQueuedEncrypyionClassBaseOptions['queueOptions']>}\n   * @memberof ISwarmMessageSerializerConstructorOptions\n   */\n  queueOptions?: Required<IQueuedEncrypyionClassBaseOptions['queueOptions']>;\n  /**\n   * instance implemented connection to the CentralAuthority\n   * to get information described in ISwarmMessageSerializerUser\n   *\n   * @type {ICentralAuthority}\n   * @memberof ISwarmMessageSerializerConstructorOptions\n   */\n  caConnection: ICentralAuthority;\n  /**\n   * utils used for a message signing\n   *\n   * @type {ISwarmMessageSerializerUtils}\n   * @memberof ISwarmMessageSerializerConstructorOptions\n   */\n  utils: ISwarmMessageSerializerUtils;\n  /**\n   * instance of the SwarmMessageFieldsValidator subclass\n   *\n   * @type {ISwarmMessageSubclassFieldsValidator}\n   * @memberof ISwarmMessageSerializerConstructorOptions\n   */\n  messageValidator: ISwarmMessageSubclassValidator;\n  /**\n   * the algorithm used for messages signing\n   *\n   * @type {ESwarmMessageSignatureAlgorithmsDescription}\n   * @memberof ISwarmMessageSerializerConstructorOptions\n   */\n  alg: TSwarmMessageSignatureAlgorithm;\n}\n\n/**\n * this class used for messages serizlization\n * before sending it to the swarm users.\n *\n * @export\n * @interface ISwarmMessageSerializer\n */\nexport interface ISwarmMessageSerializer {\n  /**\n   * serialize the message into a type\n   * which can be used for sending of\n   * a message into the swarm.\n   * If a message's data is not valid\n   * the method throws.\n   *\n   * @param {ISwarmMessageBodyDeserialized} msgBody\n   * @returns {TSwarmMessageSerialized}\n   * @memberof ISwarmMessageSerializer\n   * @throws\n   */\n  serialize(msgBody: ISwarmMessageBodyDeserialized): Promise<TSwarmMessageInstance>;\n  /**\n   * serialize the message as a private and\n   * encrypt it's body with the key provided.\n   *\n   * @param {ISwarmMessageBodyDeserialized} msgBody\n   * @param {CryptoKey} encryptWithKey - user's public key to encrypt\n   * the message as a private\n   * @returns {Promise<TSwarmMessageInstance>}\n   * @memberof ISwarmMessageSerializer\n   */\n  serialize(msgBody: ISwarmMessageBodyDeserialized, encryptWithKey?: CryptoKey): Promise<TSwarmMessageInstance>;\n}\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/swarm-message-subclass-validator-fields-validator-body-raw.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/swarm-message-subclass-validator-fields-validator-body-raw.ts",["3052"],"import assert from 'assert';\nimport {\n  VALIDATE_MESSAGE_BODY_RAW_FORAMT_MIN_LENGTH,\n  VALIDATE_MESSAGE_BODY_RAW_FORAMT_MAX_LENGTH,\n} from './swarm-message-subclass-validator-fields-validator-body-raw.const';\n\nexport function validateMessageBodyRawFormat(bodyRaw: string) {\n  assert(bodyRaw, 'A body of the message must not be empty');\n  assert(typeof bodyRaw === 'string', 'A body of the message must be a string');\n  assert(\n    bodyRaw.length > VALIDATE_MESSAGE_BODY_RAW_FORAMT_MIN_LENGTH,\n    `The minimum length of a message bodyRaw is ${VALIDATE_MESSAGE_BODY_RAW_FORAMT_MIN_LENGTH}`\n  );\n  assert(\n    bodyRaw.length < VALIDATE_MESSAGE_BODY_RAW_FORAMT_MAX_LENGTH,\n    `The maximum length of a message bodyRaw is ${VALIDATE_MESSAGE_BODY_RAW_FORAMT_MIN_LENGTH}`\n  );\n}\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/swarm-message-subclass-validator-fields-validator-signature.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/swarm-message-subclass-validator-fields-validator-signature.ts",["3053"],"import assert from 'assert';\nimport {\n  VALIDATE_MESSAGE_SIGNATURE_FORAMT_MIN_LENGTH,\n  VALIDATE_MESSAGE_SIGNATURE_FORAMT_MAX_LENGTH,\n} from './swarm-message-subclass-validator-fields-validator-signature.const';\n\nexport function validateMessageSignatureFormat(signature: string) {\n  assert(signature, 'A signature of the message must not be empty');\n  assert(typeof signature === 'string', 'A signature of the message must be a string');\n  assert(\n    signature.length > VALIDATE_MESSAGE_SIGNATURE_FORAMT_MIN_LENGTH,\n    `The minimum length of the message signature must be ${VALIDATE_MESSAGE_SIGNATURE_FORAMT_MIN_LENGTH}`\n  );\n  assert(\n    signature.length < VALIDATE_MESSAGE_SIGNATURE_FORAMT_MAX_LENGTH,\n    `The maximum length of the message signature must be ${VALIDATE_MESSAGE_SIGNATURE_FORAMT_MIN_LENGTH}`\n  );\n}\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.ts",["3054"],"import assert from 'assert';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport {\n  TSwarmMessagePayloadSerialized,\n  ISwarmMessagePayloadValidationOptions,\n} from './swarm-message-subclass-validator-fields-validator-validator-payload.types';\nimport { commonUtilsArrayCalculateLengthOfIntegerArray } from 'utils/common-utils/common-utils';\nimport { SwarmMessagePayloadValidationOptionsDefault } from './swarm-message-subclass-validator-fields-validator-validator-payload.const';\n\n/**\n * validates if the payload is an instance\n * of the Buffer-compatible types or a string.\n * And checks the length of the payload value\n * to be less than the max and greater than the\n * min\n *\n * @param {} pld\n * @throws\n */\nfunction validatePayloadFunc(\n  pld: TSwarmMessagePayloadSerialized,\n  options: Required<ISwarmMessagePayloadValidationOptions>\n): void {\n  assert(pld != null, 'A payload must be specified');\n\n  const { payloadMaxLengthBytes, payloadMinLengthBytes } = options;\n  let len;\n\n  if (pld instanceof Array) {\n    len = commonUtilsArrayCalculateLengthOfIntegerArray(pld);\n    if (len instanceof Error) {\n      console.error(len);\n      assert.fail('The value of the payload is not a valid array with byte-length integers');\n    }\n  } else if (typeof pld === 'string') {\n    len = pld.length;\n  } else if (pld instanceof Uint8Array) {\n    len = pld.buffer.byteLength;\n  } else if (pld instanceof ArrayBuffer) {\n    len = pld.byteLength;\n  } else if (pld instanceof SharedArrayBuffer) {\n    len = pld.byteLength;\n  } else {\n    assert.fail(\n      'The payload value must be a string, an instance of a byte-integers Array, Uint8Array, ArrayBuffer or SharedArrayBuffer'\n    );\n  }\n  if (typeof len !== 'number') {\n    assert.fail('Unknown error has occurred while calculating the lenght of the payload');\n    return;\n  }\n  assert(Number.isFinite(len), 'The length of the payload is too big');\n  assert(len <= payloadMaxLengthBytes, 'The payload value is too big');\n  assert(len >= payloadMinLengthBytes, 'The payload value is too small');\n}\n\nexport const createValidatePayload = (opts?: ISwarmMessagePayloadValidationOptions) => (pld: TSwarmMessagePayloadSerialized) =>\n  validatePayloadFunc(pld, defaultsDeep(opts, SwarmMessagePayloadValidationOptionsDefault));\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.const.ts",["3055"],"import { CONST_VALIDATION_VALUES_TIMESTAMP_UNIX_MIN_S } from 'const/const-validation-values/const-validation-values-messaging-date';\nimport { getDateNowInSeconds } from 'utils/common-utils/common-utils-date-time-synced';\nimport { CONST_VALUES_RESTRICTIONS_COMMON_CURRENT_DATE_MAX_ERROR_SECONDS } from 'const/const-values-restrictions-common';\n\nexport const SWARM_MESSAGE_SUBCLASS_VALIDATOR_TIMESTAMP_MAX_TIME_TO_LIVE_SECONDS = 24 * 60 * 60;\n\nexport const SWARM_MESSAGE_SUBCLASS_VALIDATOR_TIMESTAMP_OPTIONS_DEFAULT = {\n  ttl: SWARM_MESSAGE_SUBCLASS_VALIDATOR_TIMESTAMP_MAX_TIME_TO_LIVE_SECONDS,\n  minValue: CONST_VALIDATION_VALUES_TIMESTAMP_UNIX_MIN_S,\n  get maxValue() {\n    return getDateNowInSeconds();\n  },\n  maxDiffErrorSeconds: CONST_VALUES_RESTRICTIONS_COMMON_CURRENT_DATE_MAX_ERROR_SECONDS,\n};\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.ts",["3056"],"import defaultsDeep from 'lodash.defaultsdeep';\nimport {\n  TSwarmMessageTimestampSerialized,\n  ISwarmMessageTimestampValidationOptions,\n} from './swarm-message-subclass-validator-fields-validator-validator-timestamp.types';\nimport assert from 'assert';\nimport { getDateNowInSeconds } from 'utils/common-utils/common-utils-date-time-synced';\nimport { SWARM_MESSAGE_SUBCLASS_VALIDATOR_TIMESTAMP_OPTIONS_DEFAULT } from './swarm-message-subclass-validator-fields-validator-validator-timestamp.const';\n\n/**\n * validate the timestamp format and\n * check whether it within the ttl defined\n * if ttlSeconds <= 0 than time to live\n * will not be validated\n *\n * @param {number} timestamp\n * @throws\n */\nfunction validateTimestamp(\n  timestamp: TSwarmMessageTimestampSerialized,\n  options: Required<ISwarmMessageTimestampValidationOptions>\n): void {\n  assert(timestamp != null, 'Timestamp must be defined');\n  if (typeof timestamp !== 'number') {\n    assert.fail('Timestamp must be a number');\n    return;\n  }\n  assert(Number.isInteger(timestamp), `Timestamp must be an integer`);\n\n  const { maxDiffErrorSeconds, ttlSeconds, minValue, maxValue } = options;\n  const currentTimestampSeconds = getDateNowInSeconds();\n\n  if (ttlSeconds > 0 && timestamp < currentTimestampSeconds) {\n    assert(currentTimestampSeconds - timestamp - maxDiffErrorSeconds < ttlSeconds, 'The message was expired');\n  }\n  assert(timestamp + maxDiffErrorSeconds > minValue, `Timestamp must be greater than ${minValue}`);\n  assert(timestamp - maxDiffErrorSeconds < maxValue, `Timestamp must be less than ${maxValue}`);\n}\n\nexport const createValidateTimestamp = (options?: ISwarmMessageTimestampValidationOptions) => (\n  timestamp: TSwarmMessageTimestampSerialized\n) => validateTimestamp(timestamp, defaultsDeep(options, SWARM_MESSAGE_SUBCLASS_VALIDATOR_TIMESTAMP_OPTIONS_DEFAULT));\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/swarm-message-subclass-validator-fields-validator-validator-type.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/swarm-message-subclass-validator-fields-validator-validator-type.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator.ts",["3057","3058","3059","3060","3061"],"import assert from 'assert';\nimport { commonUtilsArrayDeleteFromArray, commonUtilsArrayDoCallbackTillNoError } from 'utils/common-utils/common-utils';\nimport { TSwarmMessageUserIdentifierVersion } from '../swarm-message-subclass-validator.types';\nimport { validateIssuerDesirizlizedFormat } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied';\nimport validateIssuerSerializedFormat from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized/swarm-message-subclass-validator-fields-validator-validator-issuer-serialized';\nimport { TSwarmMessageIssuerDeserialized } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied/swarm-message-subclass-validator-fields-validator-validator-issuer-deserizlied.types';\nimport validateTypeFormat from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/swarm-message-subclass-validator-fields-validator-validator-type';\nimport { validateUserIdentifier } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier';\nimport { createValidatePayload } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload';\nimport { createValidateTimestamp } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp';\nimport { TSwarmMessageType } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-type/swarm-message-subclass-validator-fields-validator-validator-type.types';\nimport { ISwarmMessagePayloadValidationOptions } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-payload/swarm-message-subclass-validator-fields-validator-validator-payload.types';\nimport { ISwarmMessageTimestampValidationOptions } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-timestamp/swarm-message-subclass-validator-fields-validator-validator-timestamp.types';\nimport { TSwarmMessageUserIdentifierSerialized } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { CA_USER_IDENTITY_VERSIONS_LIST } from '../../../../central-authority-class/central-authority-class-user-identity/central-authority-class-user-identity.const';\nimport { TSwarmMessage, TSwarmMessageBodyEncrypted } from '../../../swarm-message-constructor.types';\nimport { validateMessageBodyRawFormat } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-body-raw/swarm-message-subclass-validator-fields-validator-body-raw';\nimport { validateMessageSignatureFormat } from './swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-signature/swarm-message-subclass-validator-fields-validator-signature';\nimport {\n  IMessageFieldsValidatorOptions,\n  ISwarmMessageSubclassFieldsValidator,\n} from './swarm-message-subclass-validator-fields-validator.types';\nimport { ISwarmMessageBodyDeserialized, ISwarmMessageRaw } from '../../../swarm-message-constructor.types';\nimport {\n  SWARM_MESSAGE_SUBCLASS_VALIDATOR_BODY_ENCRYPTED_MAX_LENGTH_BYTES,\n  SWARM_MESSAGE_SUBCLASS_VALIDATOR_BODY_ENCRYPTED_MIN_LENGTH_BYTES,\n} from '../swarm-message-subclass-validator.const';\n\nexport class SwarmMessageSubclassFieldsValidator implements ISwarmMessageSubclassFieldsValidator {\n  /**\n   * list of a valid issuers.\n   * If it is empty then any issuer will\n   * be considered correct.\n   *\n   * @protected\n   * @static\n   * @type {string[]}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected issuersList: TSwarmMessageIssuerDeserialized[] = [];\n\n  /**\n   * list of a valid user identifier versions.\n   *\n   * @protected\n   * @static\n   * @type {string[]}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected supportedUserIdentifierVer: TSwarmMessageUserIdentifierVersion[] = CA_USER_IDENTITY_VERSIONS_LIST;\n\n  /**\n   * list of a valid message types.\n   * If it is empty then any type will\n   * be considered correct.\n   *\n   * @protected\n   * @static\n   * @type {Array<string | number>}\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected typesList: TSwarmMessageType[] = [];\n\n  protected payloadValidationOptions?: ISwarmMessagePayloadValidationOptions;\n\n  protected timestampValidationOptions?: ISwarmMessageTimestampValidationOptions;\n\n  protected validatePayload = createValidatePayload(this.payloadValidationOptions);\n\n  protected validateTimestamp = createValidateTimestamp(this.timestampValidationOptions);\n\n  /**\n   * Creates an instance of SwarmMessageSubclassValidator.\n   * @param {IMessageFieldsValidatorOptions} options\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  constructor(options?: IMessageFieldsValidatorOptions) {\n    this.setOptions(options);\n  }\n\n  /**\n   * validate message's deserialized body object\n   *\n   * @param {ISwarmMessageBodyDeserialized} messageBody\n   * @memberof SwarmMessageSubclassFieldsValidator\n   * @throws\n   */\n  public validateMessageBody(messageBody: ISwarmMessageBodyDeserialized): void {\n    assert(!!messageBody, 'Message body must be defined');\n    assert(typeof messageBody === 'object', 'Message body must be an object');\n    const { iss, pld, ts, typ } = messageBody;\n\n    this.validateType(typ);\n    this.validateIssuer(iss);\n    this.validatePayload(pld);\n    this.validateTimestamp(ts);\n  }\n\n  public validateMessageBodyEncrypted(messsageBodyEncrypted: TSwarmMessageBodyEncrypted): void {\n    assert(!!messsageBodyEncrypted, 'Message body must be specefied');\n    assert(typeof messsageBodyEncrypted === 'string', 'Message body must be a string for a private messages');\n    assert(\n      messsageBodyEncrypted.length < SWARM_MESSAGE_SUBCLASS_VALIDATOR_BODY_ENCRYPTED_MAX_LENGTH_BYTES,\n      'Private message body is increased the maximum length'\n    );\n    assert(\n      messsageBodyEncrypted.length > SWARM_MESSAGE_SUBCLASS_VALIDATOR_BODY_ENCRYPTED_MIN_LENGTH_BYTES,\n      'Private message body is less then the minimal length'\n    );\n  }\n\n  /**\n   * validate swarm message object\n   * throw an error if the message\n   * is not valid\n   *\n   * @param {TSwarmMessage} message\n   * @memberof SwarmMessageSubclassFieldsValidator\n   * @throws\n   */\n  public validateMessage(message: TSwarmMessage): void {\n    assert(!!message, 'Message must be defined');\n    assert(typeof message === 'object', 'Message must be an object');\n\n    const { bdy, uid, sig, isPrivate } = message;\n\n    validateMessageSignatureFormat(sig);\n    this.validateUserIdentifier(uid);\n    this.validateIsPrivateField(isPrivate);\n    this.validateMessageBody(bdy as ISwarmMessageBodyDeserialized);\n  }\n\n  /**\n   * validate the message's in format\n   * when the body is serizlized\n   *\n   * @param {ISwarmMessageRaw} messageRaw\n   * @memberof SwarmMessageSubclassFieldsValidator\n   */\n  public validateMessageRaw(messageRaw: ISwarmMessageRaw): void {\n    assert(!!messageRaw, 'Message must be defined');\n    assert(typeof messageRaw === 'object', 'Message must be an object');\n\n    const { bdy, uid, sig } = messageRaw;\n\n    validateMessageBodyRawFormat(bdy);\n    validateMessageSignatureFormat(sig);\n    this.validateUserIdentifier(uid);\n  }\n\n  /**\n   * add an issuer string in the list\n   * as a valid issuer.\n   *\n   * @param {string} issuer\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  public addIssuerToValidList = (issuer: string): void => {\n    const { issuersList } = this;\n\n    validateIssuerDesirizlizedFormat(issuer);\n    if (!issuersList.includes(issuer)) {\n      issuersList.push(issuer);\n    }\n  };\n\n  /**\n   * remove an issuer from the list of the\n   * valid issuers. If there is no\n   * issuer in the list returns true.\n   *\n   * @param {string} issuer\n   * @memberof SwarmMessageSubclassValidator\n   */\n  public removeIssuerFromValidList(issuer: string): boolean | Error {\n    const { issuersList } = this;\n\n    if (typeof issuer !== 'string') {\n      return new Error('The issuer must be a string');\n    }\n    commonUtilsArrayDeleteFromArray(issuersList, issuer);\n    return true;\n  }\n\n  /**\n   * checks whether the issuer is in the\n   * list of the valid issuers. If the\n   * list of the valid issuers is empty\n   * then returns true\n   *\n   * @param {string} issuer\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected checkIssuerIsInList(issuer: string): void {\n    const { issuersList } = this;\n\n    assert(!issuersList.length || issuersList.includes(issuer), 'The issuer is not into the list of the valid issuers');\n  }\n\n  protected validateIsPrivateField(isPrivateField?: any) {\n    if (isPrivateField != null) {\n      assert(isPrivateField === true, 'Is private value must be a \"true\"');\n    }\n  }\n\n  /**\n   * validate the Issuer format and\n   * if it is in the list of the valid\n   * issuers\n   *\n   * @param {string} issuer\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected validateIssuer(issuer: string): void {\n    validateIssuerSerializedFormat(issuer);\n    this.checkIssuerIsInList(issuer);\n  }\n\n  /**\n   * add an type string in the list\n   * as a valid types.\n   *\n   * @param {string | number} type\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected addType = (type: TSwarmMessageType): void => {\n    const { typesList } = this;\n\n    validateTypeFormat(type, typesList);\n  };\n\n  /**\n   * remove an issuer from the list of the\n   * valid issuers. If there is no\n   * issuer in the list returns true.\n   *\n   * @param {string | number} type\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected removeType(type: TSwarmMessageType): void {\n    const { typesList } = this;\n\n    commonUtilsArrayDeleteFromArray(typesList, type);\n  }\n\n  /**\n   * Checks whether the list of valid types is defined and not empty.\n   * If it is then checks if the type is into the list.\n   *\n   * @param {string| number} type\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected checkTypeInList(type: TSwarmMessageType): void {\n    const { typesList } = this;\n\n    assert(!typesList.length || typesList.includes(type), 'The type is not into the list of the valid types');\n  }\n\n  /**\n   * check the Type value format and\n   * if the type is in the list of the\n   * valid types\n   *\n   * @param {string | number} type\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected validateType(type: TSwarmMessageType): void {\n    validateTypeFormat(type);\n    this.checkTypeInList(type);\n  }\n\n  protected validateUserIdentifier = (userId: TSwarmMessageUserIdentifierSerialized): void => {\n    validateUserIdentifier(userId, this.supportedUserIdentifierVer);\n  };\n\n  /**\n   * set the options\n   *\n   * @protected\n   * @param {IMessageFieldsValidatorOptions} options\n   * @memberof SwarmMessageSubclassValidator\n   * @throws\n   */\n  protected setOptions(options?: IMessageFieldsValidatorOptions) {\n    if (options != null) {\n      assert(typeof options === 'object', 'The options must be an object');\n\n      const {\n        supportedUserIdentifierVer,\n        payloadValidationOptions,\n        issuersList,\n        typesList,\n        timestampValidationOptions,\n      } = options;\n\n      if (timestampValidationOptions) {\n        this.timestampValidationOptions = timestampValidationOptions; // set time to live in milliseconds\n        this.validateTimestamp = createValidateTimestamp(timestampValidationOptions);\n      }\n      if (payloadValidationOptions) {\n        this.payloadValidationOptions = payloadValidationOptions;\n        this.validatePayload = createValidatePayload(payloadValidationOptions);\n      }\n      if (supportedUserIdentifierVer instanceof Array) {\n        this.supportedUserIdentifierVer = supportedUserIdentifierVer.map((userIdentifierVersion) => {\n          if (typeof userIdentifierVersion === 'string') {\n            return userIdentifierVersion;\n          }\n          assert.fail(`The version ${userIdentifierVersion} must be a string`);\n        });\n      }\n      if (issuersList) {\n        if (issuersList instanceof Array) {\n          const setIssuersListResult = commonUtilsArrayDoCallbackTillNoError<string>(issuersList, this.addIssuerToValidList);\n\n          if (setIssuersListResult instanceof Error) {\n            assert.fail(setIssuersListResult);\n          }\n        } else {\n          assert.fail('The value of the \"issuersList\" option must be an Array');\n        }\n      }\n      if (typesList) {\n        if (typesList instanceof Array) {\n          const setTypesListResult = commonUtilsArrayDoCallbackTillNoError<TSwarmMessageType>(typesList, this.addType);\n\n          if (setTypesListResult instanceof Error) {\n            throw setTypesListResult;\n          }\n        } else {\n          assert.fail('The value of the \"typesList\" option must be an Array');\n        }\n      }\n    }\n  }\n}\n\nexport default SwarmMessageSubclassFieldsValidator;\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/swarm-message-subclass-validator-signature-validator.ts",["3062","3063","3064","3065","3066"],"import { IMessageSignatureValidatorOptions } from './swarm-message-subclass-validator-signature-validator.types';\nimport assert from 'assert';\nimport { ISwarmMessageRaw } from '../../../swarm-message-constructor.types';\nimport { ICentralAuthority } from '../../../../central-authority-class/central-authority-class.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { isCryptoKeyDataVerify } from '../../../../../utils/encryption-keys-utils/encryption-keys-utils';\nimport { QueuedEncryptionClassBase } from '../../../../basic-classes/queued-encryption-class-base/queued-encryption-class-base';\nimport { IQueuedEncrypyionClassBase } from '../../../../basic-classes/queued-encryption-class-base/queued-encryption-class-base.types';\nimport { swarmMessageUtilSignatureGetStringForSignByMessageRaw } from '../../../swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature';\nimport { ISwarmMessageUtilSignatureGetStringForSignByMessageRaw } from '../../../swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.types';\n\nexport class SwarmMessgeSubclassSignatureValidator {\n  protected algSupported?: Array<IMessageSignatureValidatorOptions['algSupported']>;\n\n  protected queueOptions: IMessageSignatureValidatorOptions['queueOptions'];\n\n  protected caConnection?: ICentralAuthority;\n\n  protected signVerificationQueue?: IQueuedEncrypyionClassBase;\n\n  protected getDataToSignBySwarmMsg?: ISwarmMessageUtilSignatureGetStringForSignByMessageRaw;\n\n  /**\n   * this is a cache of signatures already validated\n   *\n   * @protected\n   * @type {Record<string, string>}\n   * @memberof SwarmMessgeSubclassSignatureValidator\n   */\n  protected signaturesValidatedCache: Record<string, string> = {};\n\n  constructor(options: IMessageSignatureValidatorOptions) {\n    this.setOptions(options);\n    this.startSignatureVerificationQueue();\n  }\n\n  public validateSignature = async (messageRaw: ISwarmMessageRaw): Promise<void> => {\n    this.validateRawMessageFormat(messageRaw);\n\n    const { uid } = messageRaw;\n    const userSignPubKey = await this.getSenderSignPubKey(uid);\n\n    assert(isCryptoKeyDataVerify(userSignPubKey), 'Failed to get a valid key for the signature verification');\n    assert(\n      !((await this.validateSig(messageRaw, userSignPubKey as CryptoKey)) instanceof Error),\n      'The signature of the message is not valid'\n    );\n  };\n\n  protected validateOptions(options: IMessageSignatureValidatorOptions) {\n    assert(options, 'An options must be defined');\n    assert(typeof options === 'object', 'The options must be an object');\n\n    const { queueOptions, caConnection } = options;\n\n    assert(!!caConnection, 'Central authority connection must be provided in options');\n    assert(\n      typeof caConnection.getSwarmUserSignPubKey === 'function',\n      'Central authority connection must have the method getSwarmUserSignPubKey'\n    );\n    assert(options.utils, 'Utils must be provided in options');\n    assert(typeof options.utils === 'object', 'Utils must be an object');\n\n    if (queueOptions) {\n      assert(typeof queueOptions === 'object', 'The queue options must be an object');\n    }\n\n    const { getDataToSignBySwarmMsg } = options.utils;\n\n    assert(typeof getDataToSignBySwarmMsg === 'function', 'getDataToSignBySwarmMsg must be provided');\n  }\n\n  protected setOptions(options: IMessageSignatureValidatorOptions) {\n    this.validateOptions(options);\n\n    const { utils, queueOptions, algSupported, caConnection } = options;\n    const { getDataToSignBySwarmMsg } = utils;\n\n    this.caConnection = caConnection;\n    this.queueOptions = queueOptions;\n    this.getDataToSignBySwarmMsg = getDataToSignBySwarmMsg;\n    this.algSupported = typeof algSupported === 'string' ? [algSupported] : algSupported;\n  }\n\n  protected startSignatureVerificationQueue() {\n    this.signVerificationQueue = new QueuedEncryptionClassBase({\n      queueOptions: this.queueOptions,\n    });\n  }\n\n  protected validateRawMessageFormat(messageRaw: ISwarmMessageRaw): void {\n    assert(!!messageRaw, 'Message is not defined');\n    assert(typeof messageRaw === 'object', 'Message must be an object');\n\n    const { bdy, uid, sig, alg } = messageRaw;\n\n    assert(!!bdy, 'A body of the message must be defined');\n    assert(typeof bdy === 'string', 'Body of the message deserialized must be a string');\n    assert(!!uid, 'A user identifier of the message must not be empty');\n    assert(typeof uid === 'string', 'A user identifier of the message must be a string');\n    assert(sig, 'A signature of the message must not be empty');\n    assert(typeof sig === 'string', 'A signature of the message must be a string');\n    assert(typeof alg === 'string', \"Algorithm of the message's singature must be a string\");\n    assert(this.algSupported && this.algSupported.includes(alg), \"The algorithm of the message's signature is not supported\");\n  }\n\n  protected getSenderSignPubKey(uid: TSwarmMessageUserIdentifierSerialized) {\n    assert(!!this.caConnection, 'there is no connection to the central authority to get the user public key for data sign');\n    return !!this.caConnection && this.caConnection.getSwarmUserSignPubKey(uid);\n  }\n\n  protected getHashForSignature(sig: string): string {\n    return this.signaturesValidatedCache[sig];\n  }\n\n  protected addHashForSignature(sig: string, hash: string): void {\n    this.signaturesValidatedCache[sig] = hash;\n  }\n\n  protected async validateSig(msgRaw: ISwarmMessageRaw, key: CryptoKey) {\n    const data = swarmMessageUtilSignatureGetStringForSignByMessageRaw(msgRaw);\n    const sig = msgRaw.sig;\n    const hashFromCache = !!sig && this.getHashForSignature(sig);\n\n    if (hashFromCache) {\n      if (hashFromCache === data) {\n        return true;\n      }\n      return new Error('Signature from the cache is not the same as provided');\n    }\n    assert(this.signVerificationQueue, 'signVerificationQueue is not started');\n    const result = !!this.signVerificationQueue && (await this.signVerificationQueue.verifyData(data, sig, key));\n\n    if (result instanceof Error) {\n      return result;\n    }\n    this.addHashForSignature(sig, data);\n    return result;\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/swarm-message-subclass-validator-signature-validator.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.ts",["3067"],"import { IMessageValidatorOptions, ISwarmMessageSubclassValidator } from './swarm-message-subclass-validator.types';\nimport { ISwarmMessgeSubclassSignatureValidator } from './swarm-message-subclass-validator-signature-validator/swarm-message-subclass-validator-signature-validator.types';\nimport { ISwarmMessageSubclassFieldsValidator } from './swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator.types';\nimport SwarmMessageSubclassFieldsValidator from './swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator';\nimport { SwarmMessgeSubclassSignatureValidator } from './swarm-message-subclass-validator-signature-validator/swarm-message-subclass-validator-signature-validator';\nimport { ISwarmMessageRaw, TSwarmMessage, ISwarmMessageBodyDeserialized } from '../../swarm-message-constructor.types';\nimport assert from 'assert';\nimport { TSwarmMessageBodyEncrypted } from '../../swarm-message-constructor.types';\n\nexport class SwarmMessageSubclassValidator implements ISwarmMessageSubclassValidator {\n  protected messageFormatValidator?: ISwarmMessageSubclassFieldsValidator;\n\n  protected signatureValidator?: ISwarmMessgeSubclassSignatureValidator;\n\n  constructor(protected options: IMessageValidatorOptions) {\n    this.startValidators();\n  }\n\n  public valiadateSwarmMessageRaw = async (msgRaw: ISwarmMessageRaw): Promise<void> => {\n    const { messageFormatValidator, signatureValidator } = this;\n\n    if (!messageFormatValidator || !signatureValidator) {\n      assert(!!messageFormatValidator, 'Validator of a message fields format is not defined');\n      assert(!!signatureValidator, 'Validator of a message signature is not defined');\n      return;\n    }\n    messageFormatValidator.validateMessageRaw(msgRaw);\n    return signatureValidator.validateSignature(msgRaw);\n  };\n\n  public valiadateSwarmMessage = (msg: TSwarmMessage): void => {\n    const { messageFormatValidator } = this;\n\n    if (!messageFormatValidator) {\n      assert(!!messageFormatValidator, 'Validator of a message fields format is not defined');\n      return;\n    }\n    return messageFormatValidator.validateMessage(msg);\n  };\n\n  public validateMessageBodyEncrypted = (bdy: TSwarmMessageBodyEncrypted): void => {\n    const { messageFormatValidator } = this;\n\n    if (!messageFormatValidator) {\n      assert(!!messageFormatValidator, 'Validator of a message fields format is not defined');\n      return;\n    }\n    return messageFormatValidator.validateMessageBodyEncrypted(bdy);\n  };\n\n  public validateMessageBody = (msgBody: ISwarmMessageBodyDeserialized): void => {\n    const { messageFormatValidator } = this;\n\n    if (!messageFormatValidator) {\n      assert(!!messageFormatValidator, 'Validator of a message fields format is not defined');\n      return;\n    }\n    return messageFormatValidator.validateMessageBody(msgBody);\n  };\n\n  /**\n   * starts message's format validator\n   * and validator of a signature for\n   * raw messages.\n   *\n   * @protected\n   * @memberof SwarmMessageSubclassValidator\n   */\n  protected startValidators() {\n    const { formatValidatorOpts, signatureValidationOpts } = this.options;\n\n    this.messageFormatValidator = new SwarmMessageSubclassFieldsValidator(formatValidatorOpts);\n    this.signatureValidator = new SwarmMessgeSubclassSignatureValidator(signatureValidationOpts);\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-parser/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-parser/swarm-message-utils-body-parser.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-parser/swarm-message-utils-body-parser.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-serializer/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-serializer/swarm-message-utils-body-serializer.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-body-serializer/swarm-message-utils-body-serializer.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-parser/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-parser/swarm-message-utils-message-parser.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-parser/swarm-message-utils-message-parser.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-serializer/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-serializer/swarm-message-utils-message-serializer.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-message-serializer/swarm-message-utils-message-serializer.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.ts",["3068"],"import { ISwarmMessageRaw, TSwarmMessageSignatureAlgorithm } from '../../swarm-message-constructor.types';\nimport { ISwarmMessageUtilSignatureGetStringForSignByMessageRaw } from './swarm-message-utils-signature.types';\nimport { SWARM_MESSAGE_UTIL_SIGNATURE_GET_STRING_FOR_SIGN_BY_MESSAGE_RAW_DELIMETER } from './swarm-message-utils-signature.const';\n\nexport const swarmMessageUtilSignatureGetStringForSignByMessageRaw: ISwarmMessageUtilSignatureGetStringForSignByMessageRaw = (\n  msg: Omit<ISwarmMessageRaw, 'sig'>\n) =>\n  `${msg.alg}${SWARM_MESSAGE_UTIL_SIGNATURE_GET_STRING_FOR_SIGN_BY_MESSAGE_RAW_DELIMETER}${msg.uid}${SWARM_MESSAGE_UTIL_SIGNATURE_GET_STRING_FOR_SIGN_BY_MESSAGE_RAW_DELIMETER}${msg.bdy}`;\n","/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-signature/swarm-message-utils-signature.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-common/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-common/swarm-message-store-utils-common.ts",["3069"],"import {\n  ISwarmMessageDatabaseConstructors,\n  TSwarmMessageStoreAccessControlGrantAccessCallback,\n} from '../../swarm-message-store.types';\nimport { TSwarmStoreDatabaseEntryOperation } from '../../../swarm-store-class/swarm-store-class.types';\nimport { TCentralAuthorityUserIdentity } from '../../../central-authority-class/central-authority-class-types/central-authority-class-types-common';\nimport { ESwarmStoreConnector } from '../../../swarm-store-class/swarm-store-class.const';\nimport { EOrbitDbFeedStoreOperation } from '../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback } from '../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.types';\nimport { TSwarmMessageInstance } from '../../../swarm-message/swarm-message-constructor.types';\nimport {\n  TSwarmStoreDatabaseEntityKey,\n  TSwarmStoreDatabaseOptions,\n  TSwarmStoreDatabaseType,\n} from '../../../swarm-store-class/swarm-store-class.types';\nimport { TSwarmMessagesStoreGrantAccessCallback } from '../../swarm-message-store.types';\nimport { TSwarmMessageSerialized, ISwarmMessageConstructor } from '../../../swarm-message/swarm-message-constructor.types';\n\nexport const getMessageConstructorForDatabase = <SMC extends ISwarmMessageConstructor>(\n  dbName: string,\n  messageConstructors: ISwarmMessageDatabaseConstructors<SMC>\n) => {\n  if (!messageConstructors) {\n    return;\n  }\n\n  const dbMessageConstructor = messageConstructors[dbName];\n\n  if (dbMessageConstructor) {\n    return dbMessageConstructor;\n  }\n  return messageConstructors.default;\n};\n\nasync function swarmMessageGrantValidator<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  I extends TSwarmMessageInstance,\n  CB extends\n    | TSwarmMessageStoreAccessControlGrantAccessCallback<P, T>\n    | TSwarmMessageStoreAccessControlGrantAccessCallback<P, I>\n    | undefined\n>(\n  this: {\n    dbName: string;\n    messageConstructor: ISwarmMessageConstructor;\n    grantAccessCb: CB;\n    isPublic: boolean | undefined;\n    isUserCanWrite: boolean;\n    currentUserId: TCentralAuthorityUserIdentity;\n  },\n  value: T,\n  userId: TCentralAuthorityUserIdentity,\n  key?: TSwarmStoreDatabaseEntityKey<P>,\n  op?: TSwarmStoreDatabaseEntryOperation<P>\n) {\n  const { dbName, messageConstructor, grantAccessCb, isPublic, isUserCanWrite, currentUserId } = this;\n\n  if ((isPublic || isUserCanWrite) && userId === currentUserId) {\n    // TODO - may be it's necessary to parse a message and compare\n    // the uid of the message to the currentUserId instead of the\n    // userId === currentUserId\n    return true;\n  }\n  if (op === EOrbitDbFeedStoreOperation.DELETE && !value) {\n    return true;\n  } else if (!value) {\n    return false;\n  }\n\n  try {\n    const swarmMessage = await messageConstructor.construct(value);\n\n    if (swarmMessage.uid !== userId) {\n      return false;\n    }\n    if (grantAccessCb) {\n      return await (grantAccessCb as TSwarmMessageStoreAccessControlGrantAccessCallback<P, I>)(\n        (swarmMessage as unknown) as I,\n        userId,\n        dbName,\n        key,\n        op\n      );\n    }\n    return true;\n  } catch (err) {\n    console.error(err);\n    return false;\n  }\n}\n\nexport const getMessageValidator = <\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  SMC extends ISwarmMessageConstructor\n>(\n  dboptions: DBO,\n  messageConstructors: ISwarmMessageDatabaseConstructors<SMC>,\n  grantAccessCb: GAC,\n  currentUserId: TCentralAuthorityUserIdentity\n): TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback<P, T, MSI> => {\n  const { dbName, isPublic, write } = dboptions;\n  const messageConstructor = getMessageConstructorForDatabase(dbName, messageConstructors);\n\n  if (!messageConstructor) {\n    throw new Error(`There is no message contructor found for the ${dbName}`);\n  }\n  return (swarmMessageGrantValidator as TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback<P, T, MSI>).bind({\n    messageConstructor,\n    dbName,\n    grantAccessCb,\n    isPublic,\n    isUserCanWrite: !!isPublic || (!!write && write.includes(currentUserId)),\n    currentUserId,\n  });\n};\n","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-connector-options-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-connector-options-provider/swarm-message-store-utils-connector-options-provider.ts",["3070","3071","3072","3073","3074","3075"],"import assert from 'assert';\nimport { ESwarmStoreConnector } from '../../../swarm-store-class/swarm-store-class.const';\nimport { ISwarmMessageStoreOptions } from '../../swarm-message-store.types';\nimport { TSwarmMessageSerialized, TSwarmMessageInstance } from '../../../swarm-message/swarm-message-constructor.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../../../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { ISwarmStoreConnectorOrbitDBConnectionOptions } from '../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types';\nimport { ipfsUtilsConnectBasic } from '../../../../utils/ipfs-utils/ipfs-utils';\nimport { getMessageValidator } from '../swarm-message-store-utils-common/swarm-message-store-utils-common';\nimport { ISwarmStoreConnectorOrbitDBOptions } from '../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types';\nimport { ISwarmStoreConnectorOrbitDbDatabaseOptions } from '../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport {\n  TSwarmStoreDatabaseType,\n  TSwarmStoreConnectorConnectionOptions,\n  ISwarmStoreProviderOptions,\n  ISwarmStoreOptionsConnectorFabric,\n  ISwarmStoreConnector,\n  ISwarmStoreDatabasesOptions,\n  ISwarmStoreDatabasesCommonStatusList,\n} from '../../../swarm-store-class/swarm-store-class.types';\nimport { ISwarmStoreConnectorBasic } from '../../../swarm-store-class/swarm-store-class.types';\nimport {\n  ISwarmMessageStoreOptionsWithConnectorFabric,\n  ISwarmMessageStoreAccessControlOptions,\n  TSwarmMessagesStoreGrantAccessCallback,\n} from '../../swarm-message-store.types';\nimport { ISwarmMessageConstructorWithEncryptedCacheFabric } from '../../../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport { PromiseResolveType } from '../../../../types/helper.types';\nimport { ISwarmStoreDatabaseBaseOptions, TSwarmStoreDatabaseOptions } from '../../../swarm-store-class/swarm-store-class.types';\n\n/**\n * Add access control options for OrbitDB provided\n * databases.\n *\n * @template ItemType\n * @param {ISwarmMessageStoreOptions<ESwarmStoreConnector.OrbitDB>} options\n * @param {(ISwarmStoreConnectorOrbitDbDatabaseOptions<ItemType> &\n *     ISwarmStoreDatabaseBaseOptions)} dbOptions\n * @param {string[]} [allowAccessForUsers]\n * @param {TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback<ESwarmStoreConnector, ItemType>} [grantAccessCallback]\n * @returns {(TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, ItemType> &\n *   ISwarmStoreDatabaseBaseOptions & { provider: ESwarmStoreConnector.OrbitDB })}\n */\nfunction swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControlOrbitDB<\n  P extends ESwarmStoreConnector.OrbitDB,\n  ItemType extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>,\n  MSI extends TSwarmMessageInstance | ItemType,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, ItemType, MSI, GAC> | undefined,\n  O extends ISwarmMessageStoreOptionsWithConnectorFabric<\n    P,\n    ItemType,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO\n  >\n>(\n  options: O,\n  dbOptions: DBO,\n  allowAccessForUsers: string[] | undefined,\n  grantAccessCallback: GAC\n): TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, ItemType, DbType> &\n  ISwarmStoreDatabaseBaseOptions & { provider: ESwarmStoreConnector.OrbitDB } {\n  const grantAccess = getMessageValidator<P, ItemType, DbType, DBO, MSI, GAC, PromiseResolveType<ReturnType<NonNullable<MCF>>>>(\n    dbOptions,\n    options.messageConstructors,\n    // TODO - TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback<string, P>\n    (grantAccessCallback || dbOptions.grantAccess) as GAC,\n    options.userId\n  );\n\n  return {\n    write: allowAccessForUsers,\n    ...dbOptions,\n    grantAccess,\n    provider: ESwarmStoreConnector.OrbitDB,\n  };\n}\n\n/**\n * Return a function which extends a database options with\n * access control\n *\n * @param {ISwarmMessageStoreOptions<ESwarmStoreConnector.OrbitDB>} options\n * @throw\n * @exports\n */\nexport const swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControl = <\n  P extends ESwarmStoreConnector.OrbitDB,\n  ItemType extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>,\n  MSI extends TSwarmMessageInstance | ItemType,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, ItemType, MSI, GAC> | undefined,\n  O extends ISwarmMessageStoreOptionsWithConnectorFabric<\n    P,\n    ItemType,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO\n  >\n>(\n  options: O\n) => (dbOptions: DBO): DBO & ISwarmStoreDatabaseBaseOptions & { provider: P } => {\n  const { accessControl } = options;\n  let grantAccessCallback: GAC = undefined as GAC;\n  let allowAccessForUsers: TSwarmMessageUserIdentifierSerialized[] | undefined;\n\n  // validate options first\n  if (accessControl) {\n    const { grantAccess, allowAccessFor } = accessControl as ISwarmMessageStoreAccessControlOptions<P, ItemType, MSI, GAC>;\n\n    if (!grantAccess) {\n      throw new Error('\"Grant access\" callback function must be provided');\n    }\n    assert(\n      typeof grantAccess === 'function' && grantAccess.length === 3,\n      '\"Grant access\" callback must be a function which accepts a 3 arguments'\n    );\n    if (allowAccessFor) {\n      assert(allowAccessFor instanceof Array, 'Users list for which access is uncinditionally granted for must be a function');\n      allowAccessFor.forEach((userId) => assert(typeof userId === 'string', 'The user identity must be a string'));\n      allowAccessForUsers = allowAccessFor;\n    }\n    grantAccessCallback = grantAccess;\n  }\n  return swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControlOrbitDB<\n    P,\n    ItemType,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    O\n  >(options, dbOptions, allowAccessForUsers, grantAccessCallback) as DBO & ISwarmStoreDatabaseBaseOptions & { provider: P };\n};\n\n/**\n * Extends options for connector to a databases of the OrbitDB type\n *\n * @param {ISwarmMessageStoreOptions<ESwarmStoreConnector.OrbitDB>} options - options for the connector\n * @param {ReturnType<typeof swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControl>} extendWithAccessControlOptions - get access options for a database\n * @returns {(Promise<\n *   ISwarmStoreConnectorOrbitDBOptions<TSwarmMessageSerialized> & {\n *     providerConnectionOptions: ISwarmStoreConnectorOrbitDBConnectionOptions;\n *     provider: typeof ESwarmStoreConnector.OrbitDB;\n *   }\n * >)}\n */\nasync function swarmMessageStoreUtilsConnectorOptionsProviderForOrbitDB<\n  P extends ESwarmStoreConnector.OrbitDB,\n  ItemType extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>,\n  MSI extends TSwarmMessageInstance | ItemType,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, ItemType, MSI, GAC> | undefined,\n  O extends ISwarmMessageStoreOptionsWithConnectorFabric<\n    P,\n    ItemType,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO\n  >\n>(\n  options: O,\n  extendWithAccessControlOptions: (dbOptions: DBO) => DBO\n): Promise<\n  ISwarmStoreConnectorOrbitDBOptions<ItemType, DbType> & {\n    providerConnectionOptions: ISwarmStoreConnectorOrbitDBConnectionOptions<ItemType, DbType, DBO, ConnectorBasic>;\n    provider: typeof ESwarmStoreConnector.OrbitDB;\n  }\n> {\n  const ipfsConnection =\n    options.providerConnectionOptions && options.providerConnectionOptions.ipfs\n      ? options.providerConnectionOptions.ipfs\n      : await ipfsUtilsConnectBasic();\n  const databases = (options.databases as DBO[]).map(extendWithAccessControlOptions);\n\n  return {\n    ...options,\n    providerConnectionOptions: {\n      ...options.providerConnectionOptions,\n      ipfs: ipfsConnection,\n    },\n    databases,\n  };\n}\n\n/**\n * transform options from options simplified\n * interface for the SwarmMessageStore to the\n * full options for the SwarmStore.\n *\n * @export\n * @template P\n * @param {ISwarmMessageStoreOptions<P>} options\n * @returns {ISwarmStoreOptions<P>}\n * @throws if the options can not be transformed then throws\n */\nexport async function swarmMessageStoreUtilsConnectorOptionsProvider<\n  P extends ESwarmStoreConnector.OrbitDB,\n  ItemType extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>,\n  MSI extends TSwarmMessageInstance | ItemType,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, ItemType, MSI, GAC> | undefined,\n  O extends ISwarmMessageStoreOptionsWithConnectorFabric<\n    P,\n    ItemType,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO\n  >\n>(options: O, extendWithAccessControlOptions: (dbOptions: DBO) => DBO): Promise<O> {\n  const { provider } = options;\n\n  switch (provider) {\n    case ESwarmStoreConnector.OrbitDB:\n      return swarmMessageStoreUtilsConnectorOptionsProviderForOrbitDB<\n        P,\n        ItemType,\n        DbType,\n        DBO,\n        ConnectorBasic,\n        PO,\n        CO,\n        ConnectorMain,\n        CFO,\n        MSI,\n        GAC,\n        MCF,\n        ACO,\n        O\n      >(options, extendWithAccessControlOptions) as Promise<O>;\n    default:\n      throw new Error(`Failed to transform options cause the provider \"${provider}\" is unknown`);\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store.ts",["3076","3077","3078","3079","3080","3081","3082","3083","3084","3085","3086","3087","3088","3089"],"import assert from 'assert';\nimport { SwarmStore } from '../swarm-store-class/swarm-store-class';\nimport { ESwarmStoreConnector, ESwarmStoreEventNames } from '../swarm-store-class/swarm-store-class.const';\nimport { ISwarmMessageStoreAccessControlOptions, ISwarmMessageDatabaseConstructors } from './swarm-message-store.types';\nimport {\n  ISwarmMessageConstructor,\n  TSwarmMessageInstance,\n  ISwarmMessageInstanceEncrypted,\n  ISwarmMessageInstanceDecrypted,\n  ISwarmMessageEncrypted,\n} from '../swarm-message/swarm-message-constructor.types';\nimport {\n  ESwarmMessageStoreEventNames,\n  SWARM_MESSAGE_STORE_CONNECTOR_ORBIT_DB_ITERATOR_OPTIONS_DEFAULT,\n} from './swarm-message-store.const';\nimport { extend } from '../../utils/common-utils/common-utils-objects';\nimport {\n  TSwarmStoreDatabaseIteratorMethodAnswer,\n  TSwarmStoreDatabaseMethodAnswer,\n  TSwarmStoreDatabaseEntityAddress,\n} from '../swarm-store-class/swarm-store-class.types';\nimport {\n  TSwarmStoreDatabaseMethodArgument,\n  TSwarmStoreDatabaseIteratorMethodArgument,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { TSwarmStoreConnectorOrbitDbDatabaseMethodNames } from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { TSwarmStoreValueTypes, TSwarmStoreDatabaseMethod } from '../swarm-store-class/swarm-store-class.types';\nimport { TSwarmMessageStoreConnectReturnType } from './swarm-message-store.types';\nimport { ISwarmMessageStoreEvents, ISwarmMessageStore } from './swarm-message-store.types';\nimport { swarmMessageStoreUtilsConnectorOptionsProvider } from './swarm-message-store-utils/swarm-message-store-utils-connector-options-provider';\nimport { getMessageConstructorForDatabase } from './swarm-message-store-utils/swarm-message-store-utils-common/swarm-message-store-utils-common';\nimport { ISwarmMessageStoreDeleteMessageArg } from './swarm-message-store.types';\nimport { TSwarmMessageSerialized, TSwarmMessageConstructorBodyMessage } from '../swarm-message/swarm-message-constructor.types';\nimport { ISwarmMessageConstructorWithEncryptedCacheFabric } from '../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport { TSwarmStoreDatabaseOptions, TSwarmStoreDatabaseType } from '../swarm-store-class/swarm-store-class.types';\nimport { swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControl } from './swarm-message-store-utils/swarm-message-store-utils-connector-options-provider/swarm-message-store-utils-connector-options-provider';\n\nimport {\n  ISwarmMessageStoreMessagingRequestWithMetaResult,\n  ISwarmMessageStoreSwarmMessageMetadata,\n  TSwarmMessageStoreEntryRaw,\n} from './swarm-message-store.types';\nimport {\n  TSwarmStoreDatabaseRequestMethodReturnType,\n  TSwarmStoreDatabaseEntityKey,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { StorageProviderInMemory } from '../storage-providers/storage-in-memory-provider/storage-in-memory-provider';\nimport { StorageProvider } from '../storage-providers/storage-providers.types';\nimport {\n  ISwarmMessageStoreUtilsMessagesCache,\n  ISwarmMessageStoreUtilsMessagesCacheOptions,\n} from './swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.types';\nimport { SwarmMessageStoreUtilsMessagesCache } from './swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache';\nimport {\n  EOrbitDbFeedStoreOperation,\n  ESwarmStoreConnectorOrbitDbDatabaseType,\n} from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { ESwarmStoreConnectorOrbitDbDatabaseMethodNames } from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db';\nimport { PromiseResolveType } from '../../types/helper.types';\nimport {\n  TSwarmStoreDatabaseRequestMethodEntitiesReturnType,\n  TSwarmStoreDatabaseLoadMethodAnswer,\n  TSwarmStoreDatabaseCloseMethodAnswer,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { ISwarmStoreConnectorBasic, ISwarmStoreConnector } from '../swarm-store-class/swarm-store-class.types';\nimport {\n  ISwarmMessageStoreOptionsWithConnectorFabric,\n  TSwarmMessagesStoreGrantAccessCallback,\n} from './swarm-message-store.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport {\n  TSwarmStoreConnectorConnectionOptions,\n  ISwarmStoreProviderOptions,\n  ISwarmStoreOptionsConnectorFabric,\n  TSwarmStoreOptionsOfDatabasesKnownList,\n} from '../swarm-store-class/swarm-store-class.types';\n\nexport class SwarmMessageStore<\n    P extends ESwarmStoreConnector,\n    ItemType extends TSwarmMessageSerialized,\n    DbType extends TSwarmStoreDatabaseType<P>,\n    DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n    ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n    PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n    CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n    ConnectorMain extends ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n    CFO extends ISwarmStoreOptionsConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>,\n    MSI extends TSwarmMessageInstance | ItemType,\n    GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n    MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined,\n    ACO extends ISwarmMessageStoreAccessControlOptions<P, ItemType, MSI, GAC> | undefined,\n    O extends ISwarmMessageStoreOptionsWithConnectorFabric<\n      P,\n      ItemType,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      CFO,\n      MSI,\n      GAC,\n      MCF,\n      ACO\n    >,\n    E extends ISwarmMessageStoreEvents<P, ItemType, DbType, DBO>,\n    DBL extends TSwarmStoreOptionsOfDatabasesKnownList<P, ItemType, DbType, DBO>\n  >\n  extends SwarmStore<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO, O, E, DBL>\n  implements ISwarmMessageStore<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO, MSI, GAC, MCF, ACO, O> {\n  protected connectorType: P | undefined;\n\n  protected accessControl?: ACO;\n\n  protected messageConstructors?: ISwarmMessageDatabaseConstructors<PromiseResolveType<ReturnType<NonNullable<MCF>>>>;\n\n  protected swarmMessageConstructorFabric?: MCF;\n\n  protected extendsWithAccessControl?: (dbOptions: DBO) => DBO;\n\n  protected _dbTypes: Record<string, DbType> = {};\n\n  protected _cache?: StorageProvider<Exclude<MSI, ItemType | ISwarmMessageEncrypted>> = new StorageProviderInMemory<\n    Exclude<MSI, ItemType | ISwarmMessageEncrypted>\n  >();\n\n  protected _databasesMessagesCaches: Record<\n    string,\n    ISwarmMessageStoreUtilsMessagesCache<P, Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>>\n  > = {};\n\n  protected get dbMethodAddMessage(): TSwarmStoreDatabaseMethod<P> {\n    const { connectorType } = this;\n\n    switch (connectorType as P) {\n      case ESwarmStoreConnector.OrbitDB:\n        return (ESwarmStoreConnectorOrbitDbDatabaseMethodNames.add as TSwarmStoreConnectorOrbitDbDatabaseMethodNames) as TSwarmStoreDatabaseMethod<\n          P\n        >;\n      default:\n        throw new Error('Failed to define the method for adding message');\n    }\n  }\n\n  protected get dbMethodRemoveMessage(): TSwarmStoreDatabaseMethod<P> {\n    const { connectorType } = this;\n\n    switch (connectorType as P) {\n      case ESwarmStoreConnector.OrbitDB:\n        return (ESwarmStoreConnectorOrbitDbDatabaseMethodNames.remove as TSwarmStoreConnectorOrbitDbDatabaseMethodNames) as TSwarmStoreDatabaseMethod<\n          P\n        >;\n      default:\n        throw new Error('Failed to define the method for adding message');\n    }\n  }\n\n  protected get dbMethodIterator(): TSwarmStoreDatabaseMethod<P> {\n    const { connectorType } = this;\n\n    switch (connectorType as P) {\n      case ESwarmStoreConnector.OrbitDB:\n        return (ESwarmStoreConnectorOrbitDbDatabaseMethodNames.iterator as TSwarmStoreConnectorOrbitDbDatabaseMethodNames) as TSwarmStoreDatabaseMethod<\n          P\n        >;\n      default:\n        throw new Error('Failed to define the method for adding message');\n    }\n  }\n\n  public async connect(\n    options: O\n  ): TSwarmMessageStoreConnectReturnType<\n    P,\n    ItemType,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    O\n  > {\n    const extendsWithAccessControl = swarmMessageStoreUtilsExtendDatabaseOptionsWithAccessControl<\n      P,\n      ItemType,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      CFO,\n      MSI,\n      GAC,\n      MCF,\n      ACO,\n      O\n    >(options);\n    const optionsSwarmStore = await swarmMessageStoreUtilsConnectorOptionsProvider<\n      P,\n      ItemType,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      CFO,\n      MSI,\n      GAC,\n      MCF,\n      ACO,\n      O\n    >(options, extendsWithAccessControl);\n\n    this.extendsWithAccessControl = extendsWithAccessControl;\n    this.setOptions(optionsSwarmStore);\n\n    const connectionResult = await super.connect(optionsSwarmStore, optionsSwarmStore.databasesListStorage);\n\n    if (connectionResult instanceof Error) {\n      throw connectionResult;\n    }\n    await this._startCacheStore();\n    this.setListeners();\n  }\n\n  /**\n   * open a new connection to the database specified\n   *\n   * @param {TSwarmStoreDatabaseOptions} dbOptions\n   * @returns {(Promise<void | Error>)}\n   * @memberof SwarmStore\n   */\n  public async openDatabase(dbOptions: DBO): Promise<void | Error> {\n    try {\n      const optionsWithAcessControl = this.extendsWithAccessControl?.(dbOptions) || dbOptions;\n      const dbOpenResult = await super.openDatabase(optionsWithAcessControl);\n\n      if (!(dbOpenResult instanceof Error)) {\n        await this.openDatabaseMessagesCache(dbOptions.dbName);\n      }\n\n      const dbType = this.getDatabaseTypeByOptions(dbOptions);\n\n      if (!dbType) {\n        throw new Error('Database type should ne defined');\n      }\n\n      this._setDatabaseType(dbOptions.dbName, dbType);\n    } catch (err) {\n      console.error(err);\n      return new Error(`Swarm message store:failed to open the database ${dbOptions.dbName}: ${err.message}`);\n    }\n  }\n\n  /**\n   * Remove the database, clean it's messages cache if exists,\n   * unset settings.\n   *\n   * @param {string} dbName\n   * @returns {(Promise<void | Error>)}\n   * @memberof SwarmMessageStore\n   */\n  public async dropDatabase(dbName: DBO['dbName']): Promise<void | Error> {\n    const dropDbResult = await super.dropDatabase(dbName);\n\n    if (dropDbResult instanceof Error) {\n      return dropDbResult;\n    }\n    const messageConstructor = await this.getMessageConstructor(dbName);\n\n    try {\n      if (messageConstructor?.encryptedCache) {\n        await messageConstructor.encryptedCache.clearDb();\n      }\n      await this.unsetDatabaseMessagesCache(dbName);\n      this._unsetDatabaseType(dbName);\n    } catch (err) {\n      console.error(`Failed to clear messages encrypted cache for the database ${dbName}`);\n      return err;\n    }\n  }\n\n  public async addMessage<ValueType extends MSI | TSwarmMessageConstructorBodyMessage, DT extends DbType>(\n    dbName: DBO['dbName'],\n    msg: ValueType,\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ): Promise<TSwarmStoreDatabaseEntityAddress<P>> {\n    assert(dbName, 'Database name must be provided');\n\n    const message = typeof msg === 'string' ? (msg as ItemType) : ((await this.constructMessage(dbName, msg)) as MSI);\n\n    this.validateMessageFormat(message as MSI | TSwarmMessageConstructorBodyMessage);\n\n    const requestAddArgument = {\n      value: this.serializeMessage(message as MSI),\n      key,\n    } as TSwarmStoreDatabaseMethodArgument<P, ItemType, DT>;\n    const response = (await this.request<ItemType, DT>(dbName, this.dbMethodAddMessage, requestAddArgument)) as\n      | TSwarmStoreDatabaseMethodAnswer<P, ItemType>\n      | Error;\n\n    if (response instanceof Error) {\n      throw response;\n    }\n    const deserializedResponse = this.deserializeAddMessageResponse(response);\n\n    if (!deserializedResponse) {\n      throw new Error('Failed to deserialize the response');\n    }\n    return deserializedResponse;\n  }\n\n  public async deleteMessage(dbName: DBO['dbName'], messageAddressOrDbKey: ISwarmMessageStoreDeleteMessageArg<P>): Promise<void> {\n    assert(dbName, 'Database name must be provided');\n    if (!messageAddressOrDbKey || typeof messageAddressOrDbKey !== 'string') {\n      throw new Error('Message address must be a non empty string');\n    }\n\n    const result = await this.request<ItemType, DbType>(\n      dbName,\n      this.dbMethodRemoveMessage,\n      this.getArgRemoveMessage(messageAddressOrDbKey)\n    );\n\n    if (result instanceof Error) {\n      throw result;\n    }\n    try {\n      await this.removeSwarmMessageFromCacheByAddressOrKey(dbName, messageAddressOrDbKey);\n    } catch (err) {\n      console.error(\n        new Error(`Failed to remove a message by address or key \"${messageAddressOrDbKey}\" from cache for database \"${dbName}\"`),\n        err\n      );\n    }\n  }\n\n  public async collect<\n    ValueType extends ItemType,\n    DT extends DbType,\n    MD extends Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>\n  >(dbName: DBO['dbName'], options: TSwarmStoreDatabaseIteratorMethodArgument<P, DT>): Promise<Array<MD | Error>> {\n    assert(dbName, 'Database name should be provided');\n\n    const dbType = this._getDatabaseType(dbName);\n\n    if (!dbType) {\n      throw new Error(\"The database's type can't be defined\");\n    }\n\n    const iterator = await this.request<ValueType, DT>(\n      dbName,\n      this.dbMethodIterator,\n      this.getArgIterateDb<ValueType, DT>(dbName, options)\n    );\n\n    if (iterator instanceof Error) {\n      throw iterator;\n    }\n    return this.collectMessages(dbName, iterator as TSwarmStoreDatabaseIteratorMethodAnswer<P, ValueType>, dbType);\n  }\n\n  public async collectWithMeta<MD extends Exclude<Exclude<MSI, ItemType>, ISwarmMessageInstanceEncrypted>>(\n    dbName: DBO['dbName'],\n    options: TSwarmStoreDatabaseIteratorMethodArgument<P, DbType>\n  ): Promise<Array<ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined>> {\n    assert(dbName, 'Database name should be defined');\n\n    const dbType = this._getDatabaseType(dbName);\n\n    if (!dbType) {\n      throw new Error(\"The database's type can't be defined\");\n    }\n\n    const rawEntries = await this.request<ItemType, DbType>(\n      dbName,\n      this.dbMethodIterator,\n      this.getArgIterateDb<ItemType, DbType>(dbName, options)\n    );\n\n    if (!this.checkIsRequestMethodReturnEntries(rawEntries)) {\n      throw new Error('The request returns unexpected result');\n    }\n\n    const collectMessagesResult = await this.collectMessages(dbName, rawEntries, dbType);\n    return this.getMessagesWithMeta<MD>(collectMessagesResult as Array<Error | MD>, rawEntries, dbName, dbType);\n  }\n\n  protected validateOpts(options: O): void {\n    super.validateOptions(options);\n\n    const { messageConstructors } = options;\n\n    assert(messageConstructors, 'messages constructors must be specified');\n    assert(typeof messageConstructors === 'object', 'messages constructors must an object');\n\n    const validateMessageConstructor = (mc: any) => {\n      assert(typeof mc === 'object', 'the message constructor must be specified');\n      assert(typeof mc.construct === 'function', 'the message constructor must have the \"construct\" method');\n    };\n\n    assert(typeof messageConstructors.default === 'object', 'the default message constructor must be cpecified');\n    validateMessageConstructor(messageConstructors.default);\n    Object.values(messageConstructors).forEach(validateMessageConstructor);\n    if (options.cache) {\n      assert(typeof options.cache === 'object', 'Cache option must be an object');\n      assert(typeof options.cache.get === 'function', 'Cache option must implements StorageProvider and have a \"get\" method');\n      assert(typeof options.cache.set === 'function', 'Cache option must implements StorageProvider and have a \"set\" method');\n      assert(\n        typeof options.cache.clearDb === 'function',\n        'Cache option must implements StorageProvider and have a \"clearDb\" method'\n      );\n    }\n  }\n\n  protected setOptions(options: O): void {\n    this.validateOpts(options);\n    this.connectorType = options.provider;\n    this.accessControl = options.accessControl;\n    this.messageConstructors = options.messageConstructors;\n\n    if (options.cache) {\n      this._cache = options.cache as StorageProvider<Exclude<MSI, ItemType | ISwarmMessageEncrypted>>;\n    }\n    this.swarmMessageConstructorFabric = options.swarmMessageConstructorFabric;\n  }\n\n  /**\n   * Return database type specifically for OrbitDB databases\n   *\n   * @protected\n   * @param {TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB>} dbOptions\n   * @returns {ESwarmStoreConnectorOrbitDbDatabaseType}\n   * @memberof SwarmMessageStore\n   */\n  protected getOrbitDBDatabaseTypeByOptions(dbOptions: DBO): ESwarmStoreConnectorOrbitDbDatabaseType {\n    return dbOptions.dbType || ESwarmStoreConnectorOrbitDbDatabaseType.FEED;\n  }\n\n  /**\n   * Return type of the database by it's options.\n   *\n   * @protected\n   * @param {TSwarmStoreDatabaseOptions<P>} dbOptions\n   * @returns {ESwarmStoreConnectorOrbitDbDatabaseType}\n   * @memberof SwarmMessageStore\n   */\n  protected getDatabaseTypeByOptions(dbOptions: DBO): DbType | undefined {\n    const { connectorType } = this;\n\n    switch (connectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        return this.getOrbitDBDatabaseTypeByOptions(dbOptions) as DbType;\n      default:\n        return undefined;\n    }\n  }\n\n  /**\n   * return the message constructor specified\n   * for the database\n   *\n   * @protected\n   * @param {string} dbName\n   * @returns {(ISwarmMessageConstructor | undefined)}\n   * @memberof SwarmMessageStore\n   */\n  protected async getMessageConstructor(dbName: DBO['dbName']): Promise<ISwarmMessageConstructor | undefined> {\n    if (!dbName) {\n      return;\n    }\n    const messageConstructor = this.messageConstructors && getMessageConstructorForDatabase(dbName, this.messageConstructors);\n\n    if (!messageConstructor) {\n      return this.createMessageConstructorForDb(dbName);\n    }\n    return messageConstructor;\n  }\n\n  protected getMessagesWithMeta<MD extends Exclude<Exclude<MSI, ItemType>, ISwarmMessageInstanceEncrypted>>(\n    messages: Array<Error | MD>,\n    rawEntriesIterator: TSwarmStoreDatabaseRequestMethodEntitiesReturnType<P, ItemType>,\n    dbName: DBO['dbName'],\n    dbType: DbType\n  ): Array<ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined> {\n    if (this.connectorType === ESwarmStoreConnector.OrbitDB) {\n      return this.joinMessagesWithRawOrbitDBEntries<MD>(messages, rawEntriesIterator, dbName, dbType);\n    }\n    return [];\n  }\n\n  protected joinMessagesWithRawOrbitDBEntries<M extends Exclude<Exclude<MSI, ItemType>, ISwarmMessageInstanceEncrypted>>(\n    messages: Array<Error | M>,\n    rawEntriesIterator: TSwarmStoreDatabaseRequestMethodEntitiesReturnType<P, ItemType>,\n    dbName: DBO['dbName'],\n    dbType: DbType\n  ): Array<ISwarmMessageStoreMessagingRequestWithMetaResult<P, M> | undefined> {\n    const messagesWithMeta = messages.map((messageInstance, idx) => {\n      const entriesIterator = rawEntriesIterator instanceof Array ? rawEntriesIterator : [rawEntriesIterator];\n      const logEntry = entriesIterator[idx];\n      const messageMetadata = this.getSwarmMessageMetadata<ItemType>(logEntry as TSwarmMessageStoreEntryRaw<P, ItemType>, dbType);\n\n      if (!messageMetadata) {\n        return undefined;\n      }\n      return {\n        dbName,\n        message: messageInstance,\n        messageAddress: messageMetadata.messageAddress,\n        key: messageMetadata.key,\n      } as ISwarmMessageStoreMessagingRequestWithMetaResult<P, M>;\n    });\n    return messagesWithMeta;\n  }\n\n  /**\n   * emits error occurred on a message creation\n   *\n   * @protected\n   * @memberof SwarmMessageStore\n   */\n  protected emitMessageConstructionFails = (\n    dbName: DBO['dbName'],\n    message: ItemType,\n    messageAddr: TSwarmStoreDatabaseEntityAddress<P>,\n    key: TSwarmStoreDatabaseEntityKey<P> | undefined, // message key\n    error: Error\n  ) => {\n    this.emit(ESwarmMessageStoreEventNames.NEW_MESSAGE_ERROR, dbName, message, error, messageAddr, key);\n  };\n\n  /**\n   * new message incoming\n   *\n   * @protected\n   * @memberof SwarmMessageStore\n   */\n  protected emitMessageNew = (\n    dbName: DBO['dbName'],\n    message: Exclude<MSI, ItemType>,\n    messageAddr: TSwarmStoreDatabaseEntityAddress<P>,\n    messageKey: TSwarmStoreDatabaseEntityKey<P> | undefined\n  ) => {\n    console.log('SwarmMessageStore::emitMessageNew', {\n      dbName,\n      message,\n      messageAddr,\n      messageKey,\n    });\n    this.emit(ESwarmMessageStoreEventNames.NEW_MESSAGE, dbName, message, messageAddr, messageKey);\n  };\n\n  /**\n   * Message or key was deleted\n   *\n   * @protected\n   * @memberof SwarmMessageStore\n   */\n  protected emitMessageDelete = (\n    dbName: DBO['dbName'],\n    userId: TSwarmMessageUserIdentifierSerialized,\n    messageHash: TSwarmStoreDatabaseEntityAddress<P>,\n    messageDeletedHash: TSwarmStoreDatabaseEntityAddress<P> | undefined,\n    messageKey: TSwarmStoreDatabaseEntityKey<P> | undefined\n  ) => {\n    console.log('SwarmMessageStore::emitMessageDelete', {\n      dbName,\n      userId,\n      messageHash,\n      messageKey,\n    });\n    this.emit(ESwarmMessageStoreEventNames.DELETE_MESSAGE, dbName, userId, messageHash, messageDeletedHash, messageKey);\n  };\n\n  /**\n   * Check whether the message has a valid format\n   *\n   * @protected\n   * @param {*} message\n   * @param {ESwarmStoreConnectorOrbitDbDatabaseType} dbType\n   * @returns {message is (\n   *     P extends ESwarmStoreConnector.OrbitDB\n   *     ? LogEntry<TSwarmMessageSerialized>\n   *     : any\n   *   )}\n   * @memberof SwarmMessageStore\n   */\n  protected isValidDataMessageFormat<T extends ItemType>(\n    message: TSwarmMessageStoreEntryRaw<P, T>,\n    dbType: DbType\n  ): message is TSwarmMessageStoreEntryRaw<P, T> {\n    return (\n      typeof message === 'object' &&\n      typeof message.payload === 'object' &&\n      typeof message.hash === 'string' &&\n      typeof message.payload.value === 'string' &&\n      (dbType !== ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE || typeof message.payload.key === 'string')\n    );\n  }\n\n  protected getSwarmMessageMetadataOrbitDb<T extends ItemType>(\n    message: TSwarmMessageStoreEntryRaw<ESwarmStoreConnector.OrbitDB, T> | undefined,\n    dbType: DbType\n  ): ISwarmMessageStoreSwarmMessageMetadata<P> | undefined {\n    if (!message) {\n      return;\n    }\n    return {\n      messageAddress: message.hash,\n      key: dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE ? message.payload.key : undefined,\n    } as ISwarmMessageStoreSwarmMessageMetadata<P>;\n  }\n\n  protected getSwarmMessageMetadata<T extends ItemType>(\n    message: TSwarmMessageStoreEntryRaw<P, T> | undefined,\n    dbType: DbType\n  ): ISwarmMessageStoreSwarmMessageMetadata<P> | undefined {\n    const { connectorType } = this;\n\n    switch (connectorType as P) {\n      case ESwarmStoreConnector.OrbitDB:\n        return this.getSwarmMessageMetadataOrbitDb(message, dbType);\n      default:\n        throw new Error('Unsupported database connector');\n    }\n  }\n\n  /**\n   * Constructs new swarm message from the raw database entry.\n   *\n   * @template T\n   * @param {string} dbName\n   * @param {TSwarmMessageStoreEntryRaw<P, T>} message\n   * @param {ISwarmMessageStoreDatabaseType<P>} dbType\n   * @returns {(Promise<TSwarmMessageInstance>)}\n   * @throw\n   */\n  protected constructNewSwarmMessageFromRawEntry = async <T extends ItemType>(\n    dbName: DBO['dbName'],\n    dbType: DbType,\n    message: TSwarmMessageStoreEntryRaw<P, T>\n  ): Promise<Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>> => {\n    if (!dbName) {\n      throw new Error('Databsae name should be defined');\n    }\n    if (!this.isValidDataMessageFormat(message, dbType)) {\n      throw new Error('There is unknown message format');\n    }\n\n    const messageMetadata = this.getSwarmMessageMetadata<T>(message, dbType);\n    const swarmMessageInstance = await this.constructMessage(dbName, (message.payload.value as unknown) as MSI, messageMetadata);\n\n    if (swarmMessageInstance instanceof Error) {\n      throw swarmMessageInstance;\n    }\n    return swarmMessageInstance;\n  };\n\n  /**\n   * Handle message with some information\n   *\n   * @protected\n   * @memberof SwarmMessageStore\n   */\n  protected handleNewDataMessage = async <T extends ItemType>(\n    dbName: DBO['dbName'],\n    dbType: DbType,\n    message: TSwarmMessageStoreEntryRaw<P, T>\n  ): Promise<void> => {\n    let messageRawType: T | undefined;\n    let key: string | undefined;\n    let swarmMessageInstance: TSwarmMessageInstance | undefined;\n\n    try {\n      swarmMessageInstance = await this.getSwarmMessageFromCacheByRawEntry<T>(dbName, dbType, message);\n    } catch (err) {\n      console.error(new Error(`Failed to read a swarm message because the error: ${err.message}`));\n    }\n\n    if (!swarmMessageInstance) {\n      try {\n        swarmMessageInstance = await this.constructNewSwarmMessageFromRawEntry(dbName, dbType, message);\n      } catch (err) {\n        return this.emitMessageConstructionFails(\n          dbName,\n          (messageRawType ? String(messageRawType) : '') as T,\n          (message?.hash || '') as TSwarmStoreDatabaseEntityAddress<P>,\n          key as TSwarmStoreDatabaseEntityKey<P> | undefined,\n          err\n        );\n      }\n    }\n    if (swarmMessageInstance) {\n      const messageWithMeta = this.getSwarmMessageMetadata<T>(message, dbType);\n\n      if (!messageWithMeta) {\n        return;\n      }\n      const { messageAddress, key } = messageWithMeta;\n      return this.emitMessageNew(dbName, swarmMessageInstance as Exclude<MSI, ItemType>, messageAddress, key);\n    }\n  };\n\n  /**\n   * handle a new message stored in the local database\n   *\n   * @memberof SwarmMessageStore\n   */\n  protected handleNewMessage = async <T extends ItemType>([dbName, message, messageAddress, heads, dbType]: [\n    DBO['dbName'],\n    TSwarmMessageStoreEntryRaw<P, T>,\n    TSwarmStoreDatabaseEntityAddress<P>,\n    unknown,\n    DbType\n  ]): Promise<void> => {\n    console.log('SwarmMessageStore::handleNewMessage', {\n      dbName,\n      message,\n      messageAddress,\n    });\n    if (message?.payload?.op === EOrbitDbFeedStoreOperation.DELETE) {\n      // TODO - remove the message from the cache\n      return this.emitMessageDelete(\n        dbName,\n        message.identity.id,\n        message.hash as TSwarmStoreDatabaseEntityAddress<P>,\n        (message.payload.value as unknown) as DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n          ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n          : TSwarmStoreDatabaseEntityAddress<P>,\n        (dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n          ? message.payload.key\n          : undefined) as DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n          ? TSwarmStoreDatabaseEntityKey<P>\n          : undefined\n      );\n    }\n    return this.handleNewDataMessage<T>(dbName, dbType, message);\n  };\n\n  protected setListeners() {\n    this.addListener(ESwarmStoreEventNames.NEW_ENTRY, this.handleNewMessage);\n  }\n\n  /**\n   * validate format of a message to send\n   *\n   * @protected\n   * @param {(TSwarmMessageInstance | string)} message\n   * @memberof SwarmMessageStore\n   */\n  protected validateMessageFormat(\n    message: MSI | TSwarmMessageConstructorBodyMessage\n  ): message is MSI | TSwarmMessageConstructorBodyMessage {\n    assert(message, 'Message must be provided');\n    if (typeof message === 'object') {\n      assert(\n        typeof (message as TSwarmMessageInstance).bdy === 'object',\n        'Message must be an object which has bdy property with an object value'\n      );\n      assert(\n        typeof (message as TSwarmMessageInstance).uid === 'string',\n        'Message must be an object which has uid property with a string value'\n      );\n      assert(\n        typeof (message as TSwarmMessageInstance).sig === 'string',\n        'Message must be an object which has sig property with a string value'\n      );\n    } else {\n      assert(typeof message === 'string', 'Message must be a string or an object');\n    }\n    return true;\n  }\n\n  /**\n   * serizlize the message to a fromat\n   * to store it in the store with\n   * a type specified in the options\n   *\n   * @protected\n   * @returns {TSwarmStoreValueTypes<P>}\n   * @memberof SwarmMessageStore\n   */\n  protected serializeMessage(message: MSI): ItemType {\n    const { connectorType } = this;\n\n    switch (connectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        return (String(message) as TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>) as ItemType;\n      default:\n        throw new Error('Failed to serizlize the message to the store connector compatible format');\n    }\n  }\n\n  /**\n   * returns the argument for a message removing request\n   * accepted by the connector type provided\n   *\n   * @protected\n   * @param {string} messageAddress\n   * @returns {TSwarmStoreDatabaseMethodArgument<P, TSwarmStoreValueTypes<P>>}\n   * @memberof SwarmMessageStore\n   */\n  protected getArgRemoveMessage<DBT extends DbType>(\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>\n  ): TSwarmStoreDatabaseMethodArgument<P, ItemType, DBT> {\n    const { connectorType } = this;\n\n    switch (connectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        return messageAddress as TSwarmStoreDatabaseMethodArgument<P, ItemType, DBT>;\n      default:\n        throw new Error('Failed to define argument value for a swarm message removing');\n    }\n  }\n\n  /**\n   * returns argment for a database values iterator\n   *\n   * @protected\n   * @param {string} dbName\n   * @returns {TSwarmStoreDatabaseMethodArgument<P, TSwarmStoreValueTypes<P>>}\n   * @memberof SwarmMessageStore\n   */\n  protected getArgIterateDb<V extends ItemType, DBT extends DbType>(\n    dbName: DBO['dbName'],\n    options: TSwarmStoreDatabaseIteratorMethodArgument<P, DBT>\n  ): TSwarmStoreDatabaseMethodArgument<P, V, DBT> {\n    const { connectorType } = this;\n\n    switch (connectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        assert(options, 'The iteratro opti');\n        return (options\n          ? (extend(\n              options,\n              SWARM_MESSAGE_STORE_CONNECTOR_ORBIT_DB_ITERATOR_OPTIONS_DEFAULT\n            ) as TSwarmStoreDatabaseIteratorMethodArgument<P, DBT>)\n          : (SWARM_MESSAGE_STORE_CONNECTOR_ORBIT_DB_ITERATOR_OPTIONS_DEFAULT as TSwarmStoreDatabaseIteratorMethodArgument<\n              P,\n              DBT\n            >)) as TSwarmStoreDatabaseMethodArgument<P, V, DBT>;\n      default:\n        throw new Error('Failed to define argument value for a swarm message collecting');\n    }\n  }\n\n  protected async collectMessagesFromOrbitDBIterator<\n    T extends ItemType,\n    MD extends Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>\n  >(\n    dbName: DBO['dbName'],\n    rawEnties: TSwarmStoreDatabaseRequestMethodEntitiesReturnType<ESwarmStoreConnector.OrbitDB, T>, // TODO - may not be a string,\n    dbType: DbType\n  ): Promise<Array<MD | Error>> {\n    if (rawEnties instanceof Error) {\n      throw rawEnties;\n    }\n    if (!rawEnties) {\n      return [];\n    }\n\n    const arrayEntities = rawEnties instanceof Array ? rawEnties : [rawEnties];\n    const promises = arrayEntities.map(async (logEntry) => {\n      if (logEntry instanceof Error) {\n        return logEntry;\n      }\n      if (!logEntry) {\n        return logEntry;\n      }\n      try {\n        const messageMetadata = this.getSwarmMessageMetadata<T>(logEntry as TSwarmMessageStoreEntryRaw<P, T>, dbType);\n        const message = await this.constructMessage<MD>(dbName, (logEntry.payload.value as ItemType) as MSI, messageMetadata);\n\n        return message;\n      } catch (err) {\n        return err;\n      }\n    });\n    return Promise.all(promises);\n  }\n\n  protected isSwarmStoreDatabaseLoadMethodAnswer<T extends ItemType>(\n    rawEntries: TSwarmStoreDatabaseRequestMethodReturnType<P, T>\n  ): rawEntries is TSwarmStoreDatabaseLoadMethodAnswer<P> {\n    if (typeof rawEntries === 'object') {\n      if (\n        typeof (rawEntries as TSwarmStoreDatabaseLoadMethodAnswer<P>).count === 'number' &&\n        typeof (rawEntries as TSwarmStoreDatabaseLoadMethodAnswer<P>).loadedCount === 'number' &&\n        typeof (rawEntries as TSwarmStoreDatabaseLoadMethodAnswer<P>).overallCount === 'number'\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  protected isSwarmStoreDatabaseCloseMethodAnswer<T extends ItemType>(\n    rawEntries: TSwarmStoreDatabaseRequestMethodReturnType<P, T>\n  ): rawEntries is TSwarmStoreDatabaseCloseMethodAnswer<P> {\n    if (rawEntries === undefined) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Checks whether a database response consists of\n   * some entities or just one.\n   *\n   * @protected\n   * @template T\n   * @param {TSwarmStoreDatabaseRequestMethodReturnType<P, T>} rawEntries\n   * @returns {rawEntries is TSwarmStoreDatabaseRequestMethodEntitiesReturnType<P, T>}\n   * @memberof SwarmMessageStore\n   * @throws\n   */\n  protected checkIsRequestMethodReturnEntries<T extends ItemType>(\n    rawEntries: TSwarmStoreDatabaseRequestMethodReturnType<P, T>\n  ): rawEntries is TSwarmStoreDatabaseRequestMethodEntitiesReturnType<P, T> {\n    if (rawEntries instanceof Error) {\n      throw rawEntries;\n    }\n    if (this.isSwarmStoreDatabaseLoadMethodAnswer(rawEntries)) {\n      throw new Error('The argument is TSwarmStoreDatabaseLoadMethodAnswer type');\n    }\n    if (this.isSwarmStoreDatabaseCloseMethodAnswer(rawEntries)) {\n      throw new Error('The argument is TSwarmStoreDatabaseCloseMethodAnswer type');\n    }\n    return true;\n  }\n\n  /**\n   * collect messages from iterator\n   *\n   * @protected\n   * @param {string} dbName\n   * @param {TSwarmStoreDatabaseIteratorMethodAnswer<P, any>} rawEntries\n   * @param {any} d\n   * @returns {TSwarmMessageInstance[]}\n   * @memberof SwarmMessageStore\n   */\n  protected collectMessages<T extends ItemType, MD extends Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>>(\n    dbName: DBO['dbName'],\n    rawEntries: TSwarmStoreDatabaseRequestMethodEntitiesReturnType<P, T>,\n    dbType: DbType\n  ): Promise<Array<MD | Error>> {\n    const { connectorType } = this;\n\n    switch (connectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        return this.collectMessagesFromOrbitDBIterator<T, MD>(dbName, rawEntries, dbType);\n      default:\n        throw new Error('Failed to define argument value for a swarm message collecting');\n    }\n  }\n\n  /**\n   * transforms the result of a query for adding a message\n   * to the unique message's identifier in the database\n   *\n   * @protected\n   * @param {TSwarmStoreDatabaseMethodAnswer<\n   *       P,\n   TSwarmMessageSerialized\n   *     >} addMessageResponse\n   * @returns {TSwarmMessageStoreMessageId}\n   * @memberof SwarmMessageStore\n   */\n  protected deserializeAddMessageResponse<T extends ItemType>(\n    addMessageResponse: TSwarmStoreDatabaseMethodAnswer<P, T>\n  ): TSwarmStoreDatabaseEntityAddress<P> | undefined {\n    const { connectorType } = this;\n\n    switch (connectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        if (typeof addMessageResponse !== 'string') {\n          throw new Error('There is a wrong responce on add message request');\n        }\n        return addMessageResponse;\n      default:\n        return undefined;\n    }\n  }\n\n  protected async createMessageConstructorForDb(dbName: DBO['dbName']): Promise<ISwarmMessageConstructor | undefined> {\n    if (!this.swarmMessageConstructorFabric) {\n      return;\n    }\n    return this.swarmMessageConstructorFabric({}, { dbName });\n  }\n\n  /**\n   * construct message for the database by a constructor,\n   * specified for the database,\n   * or return itself if a SwarmMessageInstance\n   * given.\n   *\n   * @protected\n   * @param {string} dbName\n   * @param {(TSwarmMessageInstance | TSwarmMessageConstructorBodyMessage)} message\n   * @returns {Promise<TSwarmMessageInstance>}\n   * @memberof SwarmMessageStore\n   */\n  protected async constructMessage<MD extends Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>>(\n    dbName: DBO['dbName'],\n    message: MSI | TSwarmMessageConstructorBodyMessage,\n    metadata?: ISwarmMessageStoreSwarmMessageMetadata<P>\n  ): Promise<MD> {\n    if (metadata) {\n      // try to read message from the cache at first\n      // by it's unique address\n      const { messageAddress } = metadata;\n      const messageCached = await this.getSwarmMessageInstanceFromCacheByAddress(dbName, messageAddress);\n\n      if (messageCached) {\n        return messageCached as MD;\n      }\n    }\n\n    let swarmMessageInstance: Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>;\n\n    if ((message as TSwarmMessageInstance).bdy && (message as TSwarmMessageInstance).sig) {\n      // if the message argument is already instance of a swarm message\n      if (typeof (message as ISwarmMessageInstanceEncrypted).bdy === 'string') {\n        throw new Error('Swarm message should be decrypted');\n      }\n      swarmMessageInstance = message as Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>;\n    } else {\n      // construct swarm message instance if it's not in the cache and\n      // the message argument is not an instance by itself\n      const messageConsturctor = await this.getMessageConstructor(dbName);\n\n      if (!messageConsturctor) {\n        throw new Error(`A message consturctor is not specified for the database ${dbName}`);\n      }\n      swarmMessageInstance = (await messageConsturctor.construct(message as TSwarmMessageConstructorBodyMessage)) as Exclude<\n        MSI,\n        ItemType | ISwarmMessageInstanceEncrypted\n      >;\n    }\n    if (swarmMessageInstance && metadata) {\n      await this.addMessageToCacheByMetadata(dbName, metadata, swarmMessageInstance);\n    }\n    return swarmMessageInstance as MD;\n  }\n\n  protected getOptionsForDatabaseMessagesCache(\n    dbName: DBO['dbName']\n  ): ISwarmMessageStoreUtilsMessagesCacheOptions<P, Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>> {\n    if (!this._cache) {\n      throw new Error('Instance of storage used as messages cache is not defined');\n    }\n    return {\n      dbName,\n      cache: this._cache as StorageProvider<\n        | TSwarmStoreDatabaseEntityKey<P>\n        | TSwarmStoreDatabaseEntityAddress<P>\n        | Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>\n      >,\n    };\n  }\n\n  /**\n   * set messages cache for the database\n   *\n   * @protected\n   * @memberof SwarmMessageStore\n   * @throws\n   */\n  protected openDatabaseMessagesCache = async (dbName: DBO['dbName']): Promise<void> => {\n    const messagesCache = new SwarmMessageStoreUtilsMessagesCache<P, Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>>();\n    const options = this.getOptionsForDatabaseMessagesCache(dbName);\n\n    await messagesCache.connect(options);\n    this._databasesMessagesCaches[dbName] = messagesCache;\n  };\n\n  /**\n   * Unset messages cache for the database\n   *\n   * @param {string} dbName\n   * @returns {Promise<void>}\n   * @throws\n   */\n  protected unsetDatabaseMessagesCache = async (dbName: DBO['dbName']): Promise<void> => {\n    const messagesCache = this._databasesMessagesCaches[dbName];\n\n    if (messagesCache) {\n      await messagesCache.clear();\n    }\n  };\n\n  /**\n   * Returns messages cache or undefined.\n   *\n   * @protected\n   * @param {string} dbName\n   * @returns {(ISwarmMessageStoreUtilsMessagesCache | undefined)}\n   * @memberof SwarmMessageStore\n   */\n  protected getMessagesCacheForDb(\n    dbName: DBO['dbName']\n  ): ISwarmMessageStoreUtilsMessagesCache<P, Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>> {\n    return this._databasesMessagesCaches[dbName];\n  }\n\n  /**\n   * Add message to a cache storage defined for the database.\n   * If cache is not exists for the database do notrhing\n   *\n   * @protected\n   * @param {string} dbName\n   * @param {ISwarmMessageStoreSwarmMessageMetadata} messageMetadata\n   * @param {TSwarmMessageInstance} messageInstance\n   * @returns {Promise<void>}\n   * @memberof SwarmMessageStore\n   */\n  protected async addMessageToCacheByMetadata(\n    dbName: DBO['dbName'],\n    messageMetadata: ISwarmMessageStoreSwarmMessageMetadata<P>,\n    messageInstance: Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted>\n  ): Promise<void> {\n    const cache = this.getMessagesCacheForDb(dbName);\n\n    if (cache) {\n      const { messageAddress, key } = messageMetadata;\n      const pending = [cache.setMessageByAddress(messageAddress, messageInstance)];\n\n      if (key) {\n        pending.push(cache.setMessageAddressForKey(key, messageAddress));\n      }\n      await Promise.all(pending);\n    }\n  }\n\n  protected async removeSwarmMessageFromCacheByKey(dbName: DBO['dbName'], key: TSwarmStoreDatabaseEntityKey<P>): Promise<void> {\n    const cache = this.getMessagesCacheForDb(dbName);\n\n    if (cache) {\n      await cache.unsetMessageAddressForKey(key);\n    }\n  }\n\n  protected async removeSwarmMessageFromCacheByAddress(\n    dbName: DBO['dbName'],\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>\n  ): Promise<void> {\n    const cache = this.getMessagesCacheForDb(dbName);\n\n    if (cache) {\n      await cache.unsetMessageByAddress(messageAddress);\n    }\n  }\n\n  /**\n   * Remove the message from the swarm messages cache for\n   * the database by it's metadata.\n   *\n   * @protected\n   * @param {string} dbName\n   * @param {ISwarmMessageStoreDeleteMessageArg} deleteMessageArg\n   * @memberof SwarmMessageStore\n   */\n  protected async removeSwarmMessageFromCacheByAddressOrKey(\n    dbName: DBO['dbName'],\n    deleteMessageArg: ISwarmMessageStoreDeleteMessageArg<P>\n  ) {\n    const databaseType = this._getDatabaseType(dbName);\n\n    if (deleteMessageArg && databaseType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE) {\n      return this.removeSwarmMessageFromCacheByKey(dbName, deleteMessageArg);\n    }\n    if (deleteMessageArg) {\n      return this.removeSwarmMessageFromCacheByAddress(dbName, deleteMessageArg);\n    }\n    console.warn('The message address or key is not provided', dbName, deleteMessageArg);\n  }\n\n  protected async getSwarmMessageInstanceFromCacheByAddress(\n    dbName: DBO['dbName'],\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>\n  ): Promise<Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted> | undefined> {\n    const cache = this.getMessagesCacheForDb(dbName);\n\n    if (cache) {\n      return cache.getMessageByAddress(messageAddress);\n    }\n  }\n\n  protected async getSwarmMessageFromCacheByRawEntry<T extends ItemType>(\n    dbName: DBO['dbName'],\n    dbType: DbType,\n    message: TSwarmMessageStoreEntryRaw<P, T> | undefined\n  ): Promise<Exclude<MSI, ItemType | ISwarmMessageInstanceEncrypted> | undefined> {\n    const messageMetadata = this.getSwarmMessageMetadata<T>(message, dbType);\n    if (!messageMetadata) {\n      return;\n    }\n    return this.getSwarmMessageInstanceFromCacheByAddress(dbName, messageMetadata.messageAddress);\n  }\n\n  /**\n   * Set type for database with the name\n   *\n   * @protected\n   * @param {string} dbName\n   * @param {ESwarmStoreConnectorOrbitDbDatabaseType} dbType\n   * @memberof SwarmMessageStore\n   */\n  protected _setDatabaseType(dbName: DBO['dbName'], dbType: DbType): void {\n    this._dbTypes[dbName] = dbType;\n  }\n\n  protected _unsetDatabaseType(dbName: DBO['dbName']): void {\n    delete this._dbTypes[dbName];\n  }\n\n  /**\n   * Returns a database's type by it's name\n   *\n   * @param {string} dbName\n   * @returns {(ESwarmStoreConnectorOrbitDbDatabaseType | undefined)}\n   */\n  protected _getDatabaseType = (dbName: DBO['dbName']): DbType | undefined => this._dbTypes[dbName];\n\n  /**\n   * Connect to the cache store\n   *\n   * @returns {Promise<void>}\n   * @throws - throws if failed to connect\n   */\n  protected _startCacheStore = async (): Promise<void> => {\n    const { _cache: cacheStore } = this;\n\n    if (!cacheStore) {\n      throw new Error('There is no cache store');\n    }\n\n    const connectToCacheResult = await cacheStore.connect();\n    if (connectToCacheResult instanceof Error) {\n      throw new Error(`Failed to connect to cache store: ${connectToCacheResult.message}`);\n    }\n  };\n}\n","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-message-encrypted-cache.utils.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.ts",["3090","3091","3092","3093","3094","3095","3096","3097","3098","3099","3100","3101","3102","3103","3104","3105","3106"],"import { TSwarmMessgaeEncryptedCacheOptions, ISwarmMessgaeEncryptedCache } from './swarm-messgae-encrypted-cache.types';\nimport assert from 'assert';\nimport { ISecretStorage } from '../secret-storage-class/secret-storage-class.types';\nimport { SecretStorage } from '../secret-storage-class/secret-storage-class';\nimport { TSwarmMessageBodyRaw } from '../swarm-message/swarm-message-constructor.types';\nimport {\n  ISwarmMessgaeEncryptedCacheOptionsStorageProvider,\n  ISwarmMessgaeEncryptedCacheOptionsForStorageProvider,\n} from './swarm-messgae-encrypted-cache.types';\nimport {\n  SWARM_MESSGAE_ENCRYPTED_CACHE_DEFAULT_STORAGE_DATABASE_NAME,\n  SWARM_MESSGAE_ENCRYPTED_CACHE_DEFAULT_STORAGE_DATABASE_NAME_HASH,\n} from './swarm-messgae-encrypted-cache.const';\nimport { calculateHash } from '../../utils/hash-calculation-utils/hash-calculation-utils';\n\nexport class SwarmMessageEncryptedCache implements ISwarmMessgaeEncryptedCache {\n  public isRunning: boolean = false;\n\n  protected options?: TSwarmMessgaeEncryptedCacheOptions = undefined;\n\n  protected storageProvider?: ISecretStorage = undefined;\n\n  protected get dbNamePrefix() {\n    return (this.options as ISwarmMessgaeEncryptedCacheOptionsForStorageProvider)?.dbNamePrefix || '';\n  }\n\n  protected get dbName() {\n    return `${\n      (this.options as ISwarmMessgaeEncryptedCacheOptionsForStorageProvider)?.storageProviderOptions?.dbName ||\n      SWARM_MESSGAE_ENCRYPTED_CACHE_DEFAULT_STORAGE_DATABASE_NAME\n    }`;\n  }\n\n  public async connect(options: TSwarmMessgaeEncryptedCacheOptions) {\n    this.setOptions(options);\n    await this.runStorageConnection();\n    this.setIsRunning();\n  }\n\n  /**\n   * Add value only if not exists in the storage\n   *\n   * @memberof SwarmMessageEncryptedCache\n   */\n  public add = async (sig: string, message: TSwarmMessageBodyRaw) => {\n    this.checkIsActive();\n\n    const value = message || null;\n    const result = await this.storageProvider!.insert(sig, value);\n\n    if (result instanceof Error) {\n      throw result;\n    }\n    return result;\n  };\n  public get = async (sig: string) => {\n    const result = await this.readValue(sig);\n\n    if (!result) {\n      return undefined;\n    }\n    return result;\n  };\n\n  public unset = async (sig: string) => {\n    this.checkIsActive();\n\n    const resutl = await this.storageProvider!.unset(sig);\n\n    if (resutl instanceof Error) {\n      throw resutl;\n    }\n  };\n\n  public async clearDb() {\n    const clearDbResult = await this.storageProvider?.clearDb();\n\n    if (clearDbResult instanceof Error) {\n      throw clearDbResult;\n    }\n  }\n\n  /**\n   * Set value INDEPENDENTLY whether it's exists or not.\n   * WARNING!. The 'add' method should be used for storing messages.\n   * This method may be used if the instance is used not for the messages.\n   * TODO - It's added only to the instance be capatible with IStorageCommon interface\n   *\n   * @memberof SwarmMessageEncryptedCache\n   */\n  public set = async (sig: string, message: TSwarmMessageBodyRaw) => {\n    this.checkIsActive();\n\n    const value = message || null;\n    const result = await this.storageProvider!.set(sig, value);\n\n    if (result instanceof Error) {\n      throw result;\n    }\n  };\n\n  protected setOptions(options: TSwarmMessgaeEncryptedCacheOptions) {\n    assert(options, 'Options must be provided');\n    assert(typeof options === 'object', 'Options must be an object');\n\n    const optsWithStorageProvider = options as ISwarmMessgaeEncryptedCacheOptionsStorageProvider;\n\n    if (optsWithStorageProvider.storageProvider) {\n      assert(typeof optsWithStorageProvider.storageProvider === 'object', 'Storage provider must be an object');\n      assert(\n        typeof optsWithStorageProvider.storageProvider.connect === 'function' &&\n          typeof optsWithStorageProvider.storageProvider.get === 'function' &&\n          typeof optsWithStorageProvider.storageProvider.get === 'function',\n        'Storage provider provided is not valid'\n      );\n    } else {\n      const optsWithConfForStorageProviderConnection = options as ISwarmMessgaeEncryptedCacheOptionsForStorageProvider;\n\n      assert(\n        optsWithConfForStorageProviderConnection.storageProviderAuthOptions,\n        'Options for authorization to the storage provider must be provided'\n      );\n    }\n\n    this.options = options;\n  }\n\n  protected setStorageProvider(provider: ISecretStorage) {\n    this.storageProvider = provider;\n  }\n\n  protected async runStorageConnection() {\n    const { options } = this;\n    const optsWithStorageProvider = options as ISwarmMessgaeEncryptedCacheOptionsStorageProvider;\n\n    if (optsWithStorageProvider.storageProvider) {\n      this.setStorageProvider(optsWithStorageProvider.storageProvider);\n      return;\n    }\n\n    const optsWithConfForStorageProviderConnection = options as ISwarmMessgaeEncryptedCacheOptionsForStorageProvider;\n\n    if (!optsWithConfForStorageProviderConnection.storageProviderAuthOptions) {\n      throw new Error('Auth options was not provided to connect with the secret storage provider');\n    }\n\n    const { storageProviderOptions, storageProviderAuthOptions } = optsWithConfForStorageProviderConnection;\n\n    const storageProvider = new SecretStorage();\n    const dbName = await calculateHash(this.dbName, SWARM_MESSGAE_ENCRYPTED_CACHE_DEFAULT_STORAGE_DATABASE_NAME_HASH);\n\n    if (dbName instanceof Error) {\n      console.error(`Failed to calculate hash for the database name ${this.dbName}`);\n      throw dbName;\n    }\n    await storageProvider.authorize(storageProviderAuthOptions, {\n      ...storageProviderOptions,\n      dbName,\n    });\n    this.setStorageProvider(storageProvider);\n  }\n\n  protected setIsRunning() {\n    this.isRunning = true;\n  }\n\n  protected checkIsActive() {\n    if (!this.isRunning) {\n      throw new Error('The instance is not running');\n    }\n    if (!this.storageProvider || !this.storageProvider.isActive) {\n      throw new Error('There is no running storage provider');\n    }\n    return true;\n  }\n\n  protected async readValue(sig: string): Promise<TSwarmMessageBodyRaw | undefined | null> {\n    this.checkIsActive();\n\n    const result = await this.storageProvider!.get(sig);\n\n    if (result instanceof Error) {\n      throw result;\n    }\n    if (result === null) {\n      return undefined;\n    }\n    if (!result) {\n      return undefined;\n    }\n    if (typeof result !== 'string') {\n      throw new Error('There is a wrong result');\n    }\n    return result;\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class.ts",["3107","3108","3109","3110","3111","3112","3113","3114","3115","3116","3117","3118","3119","3120","3121","3122","3123","3124","3125","3126","3127"],"import { EventEmitter } from '../basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport assert from 'assert';\nimport {\n  TSwarmStoreDatabaseRequestMethodReturnType,\n  TSwarmStoreOptionsOfDatabasesKnownList,\n  ISwarmStoreDatabasesCommonStatusList,\n} from './swarm-store-class.types';\nimport {\n  ESwarmStoreConnector,\n  ESwarmStoreEventNames,\n  ESwarmStoreDbStatus,\n  SWARM_STORE_CONNECTORS,\n  SWARM_STORE_DATABASES_STATUSES_EMPTY,\n  SWARM_STORE_DATABASES_PERSISTENT_LIST_DIRECTORY_DEFAULT,\n} from './swarm-store-class.const';\nimport { IStorageCommon } from 'types/storage.types';\nimport { calculateHash } from 'utils/hash-calculation-utils';\nimport { checkIsError } from '../../utils/common-utils/common-utils-check-value';\nimport {\n  ISwarmStoreOptionsWithConnectorFabric,\n  TSwarmStoreConnectorConnectionOptions,\n  ISwarmStoreProviderOptions,\n  ISwarmStoreOptionsConnectorFabric,\n} from './swarm-store-class.types';\nimport { TSwarmStoreDatabaseType, ISwarmStoreConnectorBasic, ISwarmStoreWithConnector } from './swarm-store-class.types';\nimport {\n  ISwarmStoreConnector,\n  ISwarmStoreDatabasesStatuses,\n  TSwarmStoreValueTypes,\n  TSwarmStoreDatabaseMethod,\n  TSwarmStoreDatabaseMethodArgument,\n  TSwarmStoreConnectorEventRetransmitter,\n  TSwarmStoreDatabaseOptions,\n  ISwarmStoreEvents,\n  ISwarmStore,\n} from './swarm-store-class.types';\n\n/**\n * This is decentralized storage.\n * Allows to create a new database,\n * store a value, grant access,\n * validate, store a data on it.\n *\n * @export\n * @class SwarmStore\n * @extends {EventEmitter<ISwarmStoreEvents>}\n * @implements {ISwarmStore<P>}\n * @template P\n */\nexport class SwarmStore<\n    P extends ESwarmStoreConnector,\n    ItemType extends TSwarmStoreValueTypes<P>,\n    DbType extends TSwarmStoreDatabaseType<P>,\n    DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n    ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n    PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n    CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n    ConnectorMain extends ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n    CFO extends ISwarmStoreOptionsConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>,\n    O extends ISwarmStoreOptionsWithConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n    E extends ISwarmStoreEvents<P, ItemType, DbType, DBO>,\n    DBL extends TSwarmStoreOptionsOfDatabasesKnownList<P, ItemType, DbType, DBO>\n  >\n  extends EventEmitter<E>\n  implements\n    ISwarmStore<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO, O>,\n    ISwarmStoreWithConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO, ConnectorMain> {\n  public get isReady(): boolean {\n    return !!this.connector && this.connector.isReady;\n  }\n\n  public get isClosed(): boolean {\n    return !!this.connector && this.connector.isClosed;\n  }\n\n  public get dbStatuses(): ISwarmStoreDatabasesStatuses {\n    if (this.isReady && !this.isClosed) {\n      return this.dbStatusesExisting;\n    }\n    return SWARM_STORE_DATABASES_STATUSES_EMPTY;\n  }\n\n  public get databases(): ISwarmStoreDatabasesCommonStatusList<P, ItemType, DbType, DBO> {\n    const { databasesKnownOptionsList, databasesOpenedList } = this;\n\n    return {\n      get options() {\n        return databasesKnownOptionsList;\n      },\n      get opened() {\n        return databasesOpenedList;\n      },\n    };\n  }\n\n  protected connector: ConnectorMain | undefined;\n\n  protected dbStatusesExisting: ISwarmStoreDatabasesStatuses = SWARM_STORE_DATABASES_STATUSES_EMPTY;\n\n  protected storeConnectorEventsHandlers: Record<ESwarmStoreEventNames, TSwarmStoreConnectorEventRetransmitter> | undefined;\n\n  /**\n   * List of databases options opened during this session\n   * or during previous sessions\n   * (if an instanceof databasePersistantListStorage provided)\n   * and which were not dropped.\n   * If a database not opened because it's failed,\n   * then it's options won't be added to the list.\n   *\n   * @protected\n   * @type {TSwarmStoreOptionsOfDatabasesKnownList}\n   * @memberof SwarmStore\n   */\n  protected databasesKnownOptionsList: DBL = {} as DBL;\n\n  /**\n   * Databases opened during this session.\n   *\n   * @protected\n   * @type {Record<string, boolean>}\n   * @memberof SwarmStore\n   */\n  protected databasesOpenedList: Record<string, boolean> = {};\n\n  /**\n   * storage with list of all databases opened and not dropped.\n   *\n   * @protected\n   * @type {IStorageCommon}\n   * @memberof SwarmStore\n   */\n  protected databasePersistantListStorage?: IStorageCommon;\n\n  /**\n   * A directory name under which all the databases\n   * will be listed.\n   *\n   * @protected\n   * @type {string} []\n   * @memberof SwarmStore\n   */\n  protected databasesLisPersistantKey?: string;\n\n  /**\n   * Open connection with all databases listed in the options.\n   * If a databasePersistantListStorage provided, then a list with\n   * all databases opened and not dropped will be saved.\n   *\n   * @param {ISwarmStoreOptions<P, ItemType>} options\n   * @param {IStorageCommon} [databasePersistantListStorage]\n   * @returns {(Promise<Error | void>)}\n   * @memberof SwarmStore\n   */\n  public async connect(options: O, databasePersistantListStorage?: IStorageCommon): Promise<Error | void> {\n    let connectionWithConnector: ConnectorMain | undefined;\n    try {\n      this.validateOptions(options);\n      if (databasePersistantListStorage) {\n        await this.handleDatabasePersistentList(databasePersistantListStorage, this.getDatabasePersistentListDirectory(options));\n      }\n      connectionWithConnector = this.createConnectionWithStorageConnector(options);\n      this.createStatusTable(options);\n      this.subscribeOnConnector(connectionWithConnector);\n      await this.startConnectionWithConnector(connectionWithConnector, options);\n    } catch (err) {\n      if (connectionWithConnector) {\n        this.unSubscribeFromConnector(connectionWithConnector);\n      }\n      return err;\n    }\n  }\n\n  /**\n   * cloase all connections\n   *\n   * @returns {(Promise<Error | undefined>)}\n   * @memberof SwarmStore\n   */\n  public async close(): Promise<Error | undefined> {\n    let error: Error | undefined;\n    const { connector } = this;\n\n    try {\n      await this.closeConnector();\n    } catch (err) {\n      error = err;\n    }\n    this.reset();\n    if (connector) {\n      this.unSubscribeFromConnector(connector);\n    }\n    // this.removeAllListeners();\n    return error;\n  }\n\n  /**\n   * open a new connection to the database specified\n   *\n   * @param {TSwarmStoreDatabaseOptions} dbOptions\n   * @returns {(Promise<void | Error>)}\n   * @memberof SwarmStore\n   */\n  public async openDatabase(dbOptions: DBO): Promise<void | Error> {\n    const connector = this.getConnectorOrError();\n\n    if (checkIsError(connector)) {\n      return new Error('Connector is not exists');\n    }\n    this.setEmptyStatusForDb(dbOptions.dbName);\n\n    const result = await connector.openDatabase(dbOptions);\n\n    if (!(result instanceof Error)) {\n      await this.handleDatabaseOpened(dbOptions);\n    } else {\n      await this.handleDatabaseClosed(dbOptions);\n    }\n    return result;\n  }\n\n  /**\n   * close an existing connection to the database\n   * with the name specified\n   * if exists\n   *\n   * @param {TSwarmStoreDatabaseOptions} dbOptions\n   * @returns {(Promise<void | Error>)}\n   * @memberof SwarmStore\n   */\n  public async closeDatabase(dbName: string): Promise<void | Error> {\n    const connector = this.getConnectorOrError();\n\n    if (checkIsError(connector)) {\n      return new Error('Connector is not exists');\n    }\n    this.setClosedStatusForDb(dbName);\n\n    const result = connector.closeDatabase(dbName);\n\n    if (!(result instanceof Error)) {\n      const dbOptions = this.getDatabaseOptions(dbName);\n\n      if (dbOptions) {\n        await this.handleDatabaseClosed(dbOptions);\n      }\n    }\n    return result;\n  }\n\n  public async dropDatabase(dbName: string): Promise<void | Error> {\n    const connector = this.getConnectorOrError();\n\n    if (checkIsError(connector)) {\n      return new Error('Connector is not exists');\n    }\n    this.setClosedStatusForDb(dbName);\n\n    const dropDatabaseResult = await connector.dropDatabase(dbName);\n\n    if (dropDatabaseResult instanceof Error) {\n      return dropDatabaseResult;\n    }\n\n    const dbOptions = this.getDatabaseOptions(dbName);\n\n    if (dbOptions) {\n      await this.handleDatabaseDropped(dbOptions);\n    }\n  }\n\n  /**\n   * send request (get, set and so on) to a swarm database\n   *\n   * @template V\n   * @template A\n   * @param {TSwarmStoreDatabaseOptions['dbName']} dbName\n   * @param {TSwarmStoreDatabaseMethod<P>} dbMethod\n   * @param {TSwarmStoreDatabaseMethodArgument<P, V>} arg\n   * @returns {(Promise<TSwarmStoreDatabaseMethodAnswer<P, A> | Error>)}\n   * @memberof SwarmStore\n   */\n  public async request<A extends ItemType, DT extends DbType>(\n    dbName: DBO['dbName'],\n    dbMethod: TSwarmStoreDatabaseMethod<P>,\n    arg: TSwarmStoreDatabaseMethodArgument<P, A, DbType>\n  ): Promise<TSwarmStoreDatabaseRequestMethodReturnType<P, A>> {\n    const connector = this.getConnectorOrError();\n\n    if (checkIsError(connector)) {\n      return new Error('Connector is not exists');\n    }\n    this.setClosedStatusForDb(dbName);\n    return connector.request<A, DT>(dbName, dbMethod, arg);\n  }\n\n  /**\n   * throws an error if options provided\n   * are not valid\n   *\n   * @protected\n   * @param {ISwarmStoreOptions<P>} options\n   * @memberof SwarmStore\n   * @throws\n   */\n  protected validateOptions(options: O): void {\n    assert(options, 'An options must be specified');\n    assert(typeof options === 'object', 'The options specified is not an object');\n    assert(options.databases instanceof Array, 'The options for databases must be an array');\n    options.databases.forEach((optionsDb) => {\n      assert(optionsDb, 'Database options must be specified');\n      assert(typeof optionsDb === 'object', 'Database options must be an object');\n      assert(typeof optionsDb.dbName === 'string', 'Database name must be a string');\n    });\n    assert(typeof options.directory === 'string', 'Directory must be a string if specified');\n    assert(options.provider, 'Provider must be specified');\n    assert(options.connectorFabric, 'Connector fabric must be specified');\n    assert(\n      Object.values(ESwarmStoreConnector).includes(options.provider),\n      `There is unknown provider specified \"${options.provider}\"`\n    );\n    assert(\n      options.providerConnectionOptions && typeof options.providerConnectionOptions === 'object',\n      'Options specifically for the provider must be set and be an object'\n    );\n    assert(options.userId, 'The user identity must be provided');\n    assert(typeof options.userId === 'string', 'The user identity must be a string');\n    assert(options.credentials, 'A credentials must be provided');\n    assert(typeof options.credentials === 'object', 'Credentials must be an object');\n  }\n\n  /**\n   * returns a key of opened databases list\n   * options\n   *\n   * @protected\n   * @param {string} [directory]\n   * @returns {Promise<string>}\n   * @memberof SwarmStore\n   * @throws\n   */\n  protected async getDatabasesListKey(directory?: string): Promise<string> {\n    const hash = await calculateHash(`${directory || ''}/databases_opened_list`);\n\n    if (hash instanceof Error) {\n      throw hash;\n    }\n    return `${hash}/`;\n  }\n\n  /**\n   * returns a connector constructor specified\n   * or undefined if there is no constructor\n   * for for a connector with a name provided\n   *\n   * @protected\n   * @param {ESwarmStoreConnector} connectorName\n   * @returns\n   * @memberof SwarmStore\n   */\n  protected getStorageConnector(connectorName: ESwarmStoreConnector) {\n    return SWARM_STORE_CONNECTORS[connectorName];\n  }\n\n  /**\n   * returns options of a database if opened before\n   *\n   * @protected\n   * @param {string} dbName - name of a database\n   * @returns {ISwarmStoreDatabaseBaseOptions | undefined}\n   * @memberof SwarmStore\n   */\n  protected getDatabaseOptions(dbName: DBO['dbName']): undefined | DBO {\n    return this.databases?.options[dbName];\n  }\n\n  getConnectorOrError(): ConnectorMain | Error {\n    const { connector } = this;\n\n    if (!connector) {\n      return new Error('Connector is not exists');\n    }\n    return connector;\n  }\n\n  /**\n   * Directry for the database persistent list.\n   * Better if it will be uniq per users\n   *\n   * @protected\n   * @param {ISwarmStoreOptions<P, ItemType>} options\n   * @returns {string}\n   * @memberof SwarmStore\n   */\n  protected getDatabasePersistentListDirectory(options: O): string {\n    return `${options.userId}/${options.directory || SWARM_STORE_DATABASES_PERSISTENT_LIST_DIRECTORY_DEFAULT}`;\n  }\n\n  /**\n   * Preload the databases list.\n   *\n   * @protected\n   * @param {IStorageCommon} databasePersistantListStorage\n   * @param {string} ['' = directory] - will be used as a key for the databasePersistantListStorage storage\n   * @memberof SwarmStore\n   * @returns Promise<void>\n   * @throws\n   */\n  protected async handleDatabasePersistentList(databasePersistantListStorage: IStorageCommon, directory?: string): Promise<void> {\n    this.databasePersistantListStorage = databasePersistantListStorage;\n\n    const key = await this.getDatabasesListKey(directory);\n    this.databasesLisPersistantKey = key;\n    await this.preloadOpenedDatabasesList();\n  }\n\n  /**\n   * Stringify list of databases options\n   * known\n   *\n   * @protected\n   * @param {TSwarmStoreOptionsOfDatabasesKnownList} databasesKnownOptionsList\n   * @returns {string}\n   * @memberof SwarmStore\n   * @throws\n   */\n  protected stringifyDatabaseOptionsList(databasesKnownOptionsList: DBL): string {\n    return JSON.stringify(databasesKnownOptionsList);\n  }\n\n  /**\n   * Parse databases list loaded from storage\n   *\n   * @protected\n   * @param {string} databasesKnownOptionsList\n   * @returns {TSwarmStoreOptionsOfDatabasesKnownList}\n   * @memberof SwarmStore\n   * @throws\n   */\n  protected parseDatabaseOptionsList(databasesKnownOptionsList: string): DBL {\n    return JSON.parse(databasesKnownOptionsList);\n  }\n\n  /**\n   * preload a list of databases opened\n   * during previous sessions.\n   *\n   * @protected\n   * @memberof SwarmStore\n   * @returns Promise<void>\n   * @throws\n   */\n  protected async preloadOpenedDatabasesList(): Promise<void> {\n    const databasesOptionsList =\n      this.databasesLisPersistantKey && (await this.databasePersistantListStorage?.get(this.databasesLisPersistantKey));\n    if (databasesOptionsList) {\n      if (databasesOptionsList instanceof Error) {\n        throw databasesOptionsList;\n      }\n      this.databasesKnownOptionsList = this.parseDatabaseOptionsList(databasesOptionsList);\n    }\n  }\n\n  /**\n   * emit event with a databases list\n   *\n   * @protected\n   * @memberof SwarmStore\n   */\n  protected emitDatabasesListUpdated() {\n    this.emit(ESwarmStoreEventNames.DATABASES_LIST_UPDATED, this.databases);\n  }\n\n  /**\n   * Add a database opened to lists.\n   *\n   * @protected\n   * @param {ISwarmStoreDatabaseBaseOptions} dbOpenedOptions\n   * @memberof SwarmStore\n   * @returns {(Promise<void>)}\n   * @throws\n   */\n  protected async handleDatabaseOpened(dbOpenedOptions: DBO): Promise<void> {\n    this.databasesOpenedList[dbOpenedOptions.dbName] = true;\n    await this.addDatabaseOpenedOptions(dbOpenedOptions);\n    this.emitDatabasesListUpdated();\n  }\n\n  /**\n   * Delete a database dropped from lists\n   * of opened during the session databases.\n   *\n   * @protected\n   * @param {ISwarmStoreDatabaseBaseOptions} dbOpenedOptions\n   * @memberof SwarmStore\n   * @returns {(Promise<void>)}\n   * @throws\n   */\n  protected async handleDatabaseClosed(dbOpenedOptions: DBO): Promise<void> {\n    delete this.databasesOpenedList[dbOpenedOptions.dbName];\n    this.emitDatabasesListUpdated();\n  }\n\n  protected emitDatbaseDropped(dbName: string): void {\n    this.emit(ESwarmStoreEventNames.DROP_DATABASE, dbName);\n  }\n\n  /**\n   * Delete a database dropped from lists.\n   *\n   * @protected\n   * @param {ISwarmStoreDatabaseBaseOptions} dbOpenedOptions\n   * @memberof SwarmStore\n   * @returns {(Promise<void>)}\n   * @throws\n   */\n  protected async handleDatabaseDropped(dbOpenedOptions: DBO): Promise<void> {\n    const { dbName } = dbOpenedOptions;\n\n    delete this.databasesOpenedList[dbName];\n    await this.removeDatabaseOpenedOptions(dbOpenedOptions);\n    this.emitDatbaseDropped(dbName);\n    this.emitDatabasesListUpdated();\n  }\n\n  /**\n   * add a database opened options to the list\n   * of known databases options and store it\n   * if a storage instance was provided.\n   *\n   * @protected\n   * @param {ISwarmStoreDatabaseBaseOptions} dbOpenedOptions\n   * @memberof SwarmStore\n   */\n  protected async addDatabaseOpenedOptions(dbOpenedOptions: DBO) {\n    this.databasesKnownOptionsList[dbOpenedOptions.dbName as DBO['dbName']] = dbOpenedOptions as DBL[DBO['dbName']];\n    await this.storeDatabasesKnownOptionsList();\n  }\n\n  /**\n   * Remove a database options from the list\n   * of known databases options and store it\n   * if a persistant storage instance was provided.\n   *\n   * @protected\n   * @param {ISwarmStoreDatabaseBaseOptions} dbOpenedOptions\n   * @memberof SwarmStore\n   */\n  protected async removeDatabaseOpenedOptions(dbOpenedOptions: DBO) {\n    delete this.databasesKnownOptionsList[dbOpenedOptions.dbName as DBO['dbName']];\n    await this.storeDatabasesKnownOptionsList();\n  }\n\n  /**\n   * Store options of databases known to the storage\n   * if it was provided for the connect.\n   *\n   * @protected\n   * @memberof SwarmStore\n   */\n  protected async storeDatabasesKnownOptionsList() {\n    const { databasesKnownOptionsList, databasesLisPersistantKey, databasePersistantListStorage } = this;\n\n    if (databasePersistantListStorage && databasesLisPersistantKey) {\n      const list = this.stringifyDatabaseOptionsList(databasesKnownOptionsList);\n      await databasePersistantListStorage.set(databasesLisPersistantKey, list);\n    }\n  }\n\n  protected getOptionsForConnectorFabric(options: O): CO {\n    return {\n      provider: options.provider,\n      providerConnectionOptions: options.providerConnectionOptions,\n    } as CO;\n  }\n\n  /**\n   * create a connection with a connector\n   * specified in options\n   *\n   * @protected\n   * @param {ISwarmStoreOptions<P>} options\n   * @returns {(ISwarmStoreConnector<P> | Error)}\n   * @memberof SwarmStore\n   */\n  protected createConnectionWithStorageConnector(options: O): ConnectorMain {\n    const { connectorFabric } = options;\n    const connectorFabricOptions = this.getOptionsForConnectorFabric(options);\n    const connection = connectorFabric(connectorFabricOptions);\n\n    assert(connection, `Failed to create connection with the provider`);\n    return connection;\n  }\n\n  /**\n   * connect with the connector specified\n   *\n   * @protected\n   * @param {ISwarmStoreConnector<P>} connector\n   * @param {ISwarmStoreOptions<P>} options\n   * @memberof SwarmStore\n   */\n  protected async startConnectionWithConnector(connector: ConnectorMain, options: O): Promise<void> {\n    const connectionResult = await connector.connect(options.providerConnectionOptions);\n\n    assert(!(connectionResult instanceof Error), `Failed to connect through the provider ${options.provider}`);\n    this.connector = connector;\n  }\n\n  /**\n   * set empty status for a database\n   * if a status was not set before\n   *\n   * @protected\n   * @param {string} dbName\n   * @memberof SwarmStore\n   */\n  protected setEmptyStatusForDb = (dbName: string) => {\n    const { dbStatusesExisting } = this;\n\n    if (!dbStatusesExisting[dbName]) {\n      dbStatusesExisting[dbName] = ESwarmStoreDbStatus.EMPTY;\n    }\n  };\n\n  protected setClosedStatusForDb = (dbName: string) => {\n    this.dbStatusesExisting[dbName] = ESwarmStoreDbStatus.CLOSE;\n  };\n\n  /**\n   * create the table with a current status for\n   * a databases, which will be started\n   *\n   * @protected\n   * @param {ISwarmStoreOptions<P>} options\n   * @memberof SwarmStore\n   */\n  protected createStatusTable(options: O) {\n    const { databases } = options;\n\n    databases.forEach((dbOptions) => {\n      this.setEmptyStatusForDb(dbOptions.dbName);\n    });\n  }\n\n  protected dbReadyListener = (dbName: string) => {\n    this.dbStatusesExisting[dbName] = ESwarmStoreDbStatus.READY;\n  };\n\n  protected dbUpdateListener = (dbName: string) => (this.dbStatusesExisting[dbName] = ESwarmStoreDbStatus.UPDATE);\n\n  protected dbCloseListener = (dbName: string) => (this.dbStatusesExisting[dbName] = ESwarmStoreDbStatus.CLOSE);\n\n  protected dbLoadingListener = ([dbName, percent]: [string, number]) => {\n    if (percent < 100) {\n      this.dbStatusesExisting[dbName] = ESwarmStoreDbStatus.LOADING;\n    } else {\n      this.dbStatusesExisting[dbName] = ESwarmStoreDbStatus.LOADED;\n    }\n  };\n\n  /**\n   * subscribe on events emitted for databases\n   *\n   * @protected\n   * @param {boolean} [isSubscribe=true]\n   * @memberof SwarmStore\n   */\n  protected subscribeOnDbEvents(connector: ConnectorMain, isSubscribe: boolean = true): void {\n    if (!connector) {\n      if (isSubscribe) {\n        throw new Error('There is no connection to a connector');\n      }\n      return;\n    }\n\n    const methodName = isSubscribe ? 'addListener' : 'removeListener';\n\n    connector[methodName](ESwarmStoreEventNames.READY, this.dbReadyListener);\n    connector[methodName](ESwarmStoreEventNames.UPDATE, this.dbUpdateListener);\n    connector[methodName](ESwarmStoreEventNames.CLOSE_DATABASE, this.dbCloseListener);\n    connector[methodName](ESwarmStoreEventNames.DB_LOADING, this.dbLoadingListener);\n  }\n\n  protected unsubscribeFromDbEvents(connector: ConnectorMain) {\n    this.subscribeOnDbEvents(connector, false);\n  }\n\n  /**\n   * subscribe on store connector all events\n   * to retransmit it\n   *\n   * @protected\n   * @memberof SwarmStore\n   */\n  protected subscribeConnectorAllEvents(connector: ConnectorMain) {\n    if (!connector) {\n      throw new Error('There is no swarm connector');\n    }\n\n    const storeConnectorEventsHandlers = {} as Record<ESwarmStoreEventNames, TSwarmStoreConnectorEventRetransmitter>;\n\n    Object.values(ESwarmStoreEventNames).forEach((eventName) => {\n      storeConnectorEventsHandlers[eventName] = this.emit.bind(this, eventName);\n      connector.addListener(eventName, storeConnectorEventsHandlers[eventName]);\n    });\n    this.storeConnectorEventsHandlers = storeConnectorEventsHandlers;\n  }\n\n  protected unSubscribeConnectorAllEvents(connector: ConnectorMain) {\n    const { storeConnectorEventsHandlers } = this;\n\n    if (storeConnectorEventsHandlers && connector) {\n      Object.values(ESwarmStoreEventNames).forEach((eventName) => {\n        connector.removeListener(eventName, storeConnectorEventsHandlers[eventName]);\n      });\n    }\n  }\n\n  /**\n   * subsribes on events from the connector\n   *\n   * @protected\n   * @memberof SwarmStore\n   */\n  protected subscribeOnConnector(connector: ConnectorMain) {\n    this.subscribeOnDbEvents(connector);\n    this.subscribeConnectorAllEvents(connector);\n  }\n\n  /**\n   * subsribes on events from the connector\n   *\n   * @protected\n   * @memberof SwarmStore\n   */\n  protected unSubscribeFromConnector(connector: ConnectorMain) {\n    this.unsubscribeFromDbEvents(connector);\n    this.unSubscribeConnectorAllEvents(connector);\n  }\n\n  /**\n   * close the existing connection\n   * with a swarm store\n   *\n   * @protected\n   * @memberof SwarmStore\n   */\n  protected async closeConnector(): Promise<void> {\n    const { connector } = this;\n\n    if (connector) {\n      const result = await connector.close();\n\n      if (result instanceof Error) {\n        throw new Error('Failed to close the connection with the connector');\n      }\n    }\n  }\n\n  /**\n   * reset some options to defaults\n   *\n   * @protected\n   * @memberof SwarmStore\n   */\n  protected reset(): void {\n    Object.keys(this.dbStatusesExisting).forEach(this.setClosedStatusForDb);\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class.types.ts",["3128","3129","3130"],"import { TSecretStorageAuthorizazionOptions } from '../secret-storage-class/secret-storage-class.types';\nimport {\n  ESwarmStoreConnectorOrbitDbDatabaseMethodNames,\n  ISwarmStoreConnectorOrbitDbConnecectionBasicFabric,\n  ISwarmStoreConnectorOrbitDBConnectionOptions,\n  ISwarmStoreConnectorOrbitDBEvents,\n  ISwarmStoreConnectorOrbitDBOptions,\n} from './swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types';\nimport { EventEmitter } from '../basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport {\n  ESwarmStoreConnector,\n  ESwarmStoreDbStatus as ESwarmStoreDatabaseStatus,\n  ESwarmStoreEventNames,\n  SWARM_STORE_DATABASE_STATUS_ABSENT,\n} from './swarm-store-class.const';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions,\n  ISwarmStoreConnectorOrbitDbDatabaseOptions,\n  ISwarmStoreConnectorOrbitDbDatabaseValue,\n  TSwarmStoreConnectorOrbitDbDatabaseAddMethodArgument,\n  TSwarmStoreConnectorOrbitDbDatabaseEntityIndex,\n  TSwarmStoreConnectorOrbitDbDatabaseMethodArgument,\n  TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbLoad,\n  TSwarmStoreConnectorOrbitDbDatabaseMethodNames,\n  TSwarmStoreConnectorOrbitDbDatabaseStoreHash,\n  TSwarmStoreConnectorOrbitDbDatabaseStoreKey,\n} from './swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { IStorageCommon } from 'types/storage.types';\nimport {\n  EOrbitDbFeedStoreOperation,\n  ESwarmStoreConnectorOrbitDbDatabaseType,\n} from './swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { TSwarmMessageSerialized } from '../swarm-message/swarm-message-constructor.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\n\nexport type TSwarmStoreDatabaseType<P extends ESwarmStoreConnector> = ESwarmStoreConnectorOrbitDbDatabaseType;\n\nexport type TSwarmStoreDatabaseEntityUniqueIndex<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>\n> = P extends ESwarmStoreConnector.OrbitDB\n  ? DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n    ? TSwarmStoreDatabaseEntityAddress<P>\n    : TSwarmStoreDatabaseEntityKey<P>\n  : never;\n\nexport type TSwarmStoreConnectorBasicFabric<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO>\n> = P extends ESwarmStoreConnector.OrbitDB\n  ? ISwarmStoreConnectorOrbitDbConnecectionBasicFabric<T, DbType, DBO, ConnectorBasic>\n  : never;\n\nexport type TSwarmStoreConnectorEventRetransmitter = (...args: any[]) => void;\n\n/**\n * store a status of each database\n *\n * key - database name\n * value - the last event from the database received from the provider\n * @export\n * @interface ISwarmStoreDatabasesStatus\n */\nexport interface ISwarmStoreDatabasesStatuses\n  extends Record<string, ESwarmStoreDatabaseStatus | typeof SWARM_STORE_DATABASE_STATUS_ABSENT> {}\n\n// methods available for a database providers\nexport type TSwarmStoreDatabaseMethod<P extends ESwarmStoreConnector> = P extends ESwarmStoreConnector.OrbitDB\n  ? TSwarmStoreConnectorOrbitDbDatabaseMethodNames\n  : never;\n\nexport type TSwarmStoreDatabaseRequestMethodEntitiesReturnType<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>\n> = Error | TSwarmStoreDatabaseMethodAnswer<P, ItemType> | TSwarmStoreDatabaseIteratorMethodAnswer<P, ItemType>;\n\nexport type TSwarmStoreDatabaseRequestMethodReturnType<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>\n> =\n  | Error\n  | TSwarmStoreDatabaseLoadMethodAnswer<P>\n  | TSwarmStoreDatabaseCloseMethodAnswer<P>\n  | TSwarmStoreDatabaseRequestMethodEntitiesReturnType<P, ItemType>;\n\nexport type TSwarmStoreConnectorConstructorOptions<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>\n> = P extends ESwarmStoreConnector.OrbitDB ? ISwarmStoreConnectorOrbitDBOptions<ItemType, DbType> : never;\n\nexport interface ISwarmStoreConnectorRequestLoadAnswer {\n  /**\n   * how many new items loaded during the request\n   *\n   * @type {number}\n   * @memberof ISwarmStoreConnectorLoadAnswer\n   */\n  count: number;\n  /**\n   * overall items loaded\n   *\n   * @type {number}\n   * @memberof ISwarmStoreConnectorRequestLoadAnswer\n   */\n  loadedCount: number;\n  /**\n   * how many overall items exists in the database\n   *\n   * @type {number}\n   * @memberof ISwarmStoreConnectorLoadAnswer\n   */\n  overallCount: number;\n}\n\nexport interface ISwarmStoreEvents<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>\n> {\n  [ESwarmStoreEventNames.STATE_CHANGE]: boolean;\n  [ESwarmStoreEventNames.ERROR]: Error;\n  [ESwarmStoreEventNames.CLOSE]: void;\n  [ESwarmStoreEventNames.UPDATE]: string;\n  [ESwarmStoreEventNames.LOADING]: number;\n  [ESwarmStoreEventNames.DB_LOADING]: [string, number];\n  [ESwarmStoreEventNames.READY]: string;\n  [ESwarmStoreEventNames.DATABASES_LIST_UPDATED]: ISwarmStoreDatabasesCommonStatusList<P, ItemType, DbType, DBO>;\n}\n\n// arguments avalilable for a database method\nexport type TSwarmStoreDatabaseMethodArgument<\n  P extends ESwarmStoreConnector,\n  M,\n  DbType extends TSwarmStoreDatabaseType<P>\n> = P extends ESwarmStoreConnector.OrbitDB ? TSwarmStoreConnectorOrbitDbDatabaseMethodArgument<M, DbType> : never;\n\nexport type TSwarmStoreDatabaseEntryOperation<P extends ESwarmStoreConnector> = P extends ESwarmStoreConnector.OrbitDB\n  ? EOrbitDbFeedStoreOperation\n  : never;\n\n// arguments avalilable for a database method\nexport type TSwarmStoreDatabaseIteratorMethodArgument<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>\n> = P extends ESwarmStoreConnector.OrbitDB ? ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<DbType> : never;\n\nexport type TSwarmStoreDatabaseLoadMethodAnswer<P extends ESwarmStoreConnector.OrbitDB> = P extends ESwarmStoreConnector.OrbitDB\n  ? ISwarmStoreConnectorRequestLoadAnswer\n  : never;\n\nexport type TSwarmStoreDatabaseCloseMethodAnswer<P extends ESwarmStoreConnector.OrbitDB> = P extends ESwarmStoreConnector.OrbitDB\n  ? void\n  : never;\n\n// arguments avalilable for a database\nexport type TSwarmStoreDatabaseIteratorMethodAnswer<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmStoreValueTypes<P>\n> = P extends ESwarmStoreConnector.OrbitDB\n  ? Error | Array<ISwarmStoreConnectorOrbitDbDatabaseValue<T> | Error | undefined>\n  : never;\n\n// TODO - typescript issue\n// string cannot be assigned to P extends ESwarmStoreConnector.OrbitDB ? TSwarmMessageSerialized : any;\n/**\n * Type of a raw value can be stored in the database\n */\nexport type TSwarmStoreValueTypes<P extends ESwarmStoreConnector> = TSwarmMessageSerialized;\n\n// arguments avalilable for a database\nexport type TSwarmStoreDatabaseMethodAnswer<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmStoreValueTypes<P>\n> = P extends ESwarmStoreConnector.OrbitDB ? ISwarmStoreConnectorOrbitDbDatabaseValue<T> : never;\n\nexport interface ISwarmStoreDatabaseBaseOptions {\n  // Database name\n  dbName: string;\n  // is a puclic database. Private by\n  isPublic?: boolean;\n  // how many records to preload\n  preloadCount?: number;\n  /**\n   * use encrypted storage for the database\n   *\n   * @type {boolean} [false]\n   * @memberof ISwarmStoreDatabaseBaseOptions\n   */\n  useEncryptedStorage?: boolean;\n}\n\nexport type TSwarmStoreDatabaseEntityKey<P extends ESwarmStoreConnector = never> = P extends ESwarmStoreConnector.OrbitDB\n  ? TSwarmStoreConnectorOrbitDbDatabaseStoreKey\n  : never;\n\nexport type TSwarmStoreDatabaseEntityAddress<P extends ESwarmStoreConnector> = P extends ESwarmStoreConnector.OrbitDB\n  ? TSwarmStoreConnectorOrbitDbDatabaseStoreHash\n  : never;\n\n/**\n * options of a swarm database\n *\n * @export\n * @interface ISwarmStoreDatabaseOptions\n */\nexport type TSwarmStoreDatabaseOptions<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>\n> = P extends ESwarmStoreConnector.OrbitDB\n  ? ISwarmStoreConnectorOrbitDbDatabaseOptions<T, DbType>\n  : ISwarmStoreDatabaseBaseOptions;\n\n/**\n * options of swarm databases want to connect\n *\n * @export\n * @interface ISwarmStoreDatabasesOptions\n */\nexport interface ISwarmStoreDatabasesOptions<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>\n> {\n  // databases which must be started when the orbit db\n  // instance will be ready to use\n  databases: TSwarmStoreDatabaseOptions<P, T, DbType>[];\n  // a virtual directory name where to store all the data received\n  directory: string;\n}\n\n/**\n * options about the current user which\n * will be connected to swarm databases\n *\n * @export\n * @interface ISwarmStoreUserOptions\n */\nexport interface ISwarmStoreUserOptions {\n  // the current user identity\n  userId?: TSwarmMessageUserIdentifierSerialized;\n  // credentials used for data encryption\n  credentials?: TSecretStorageAuthorizazionOptions;\n}\n\nexport type TSwarmStoreConnectorConnectionOptions<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO>\n> = P extends ESwarmStoreConnector.OrbitDB ? ISwarmStoreConnectorOrbitDBConnectionOptions<T, DbType, DBO, ConnectorBasic> : never;\n\n/**\n * options defines which provider to use\n *\n * @export\n * @interface ISwarmStoreProviderOptions\n */\nexport interface ISwarmStoreProviderOptions<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>\n> {\n  provider: P;\n  providerConnectionOptions: PO;\n}\n\n/**\n * this options excluded options specific\n * for a provider connection\n *\n * @export\n * @interface ISwarmStoreMainOptions\n * @extends {ISwarmStoreUserOptions}\n * @extends {ISwarmStoreDatabasesOptions}\n */\nexport interface ISwarmStoreMainOptions<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>\n> extends ISwarmStoreUserOptions,\n    ISwarmStoreDatabasesOptions<P, T, DbType> {}\n\nexport interface ISwarmStoreOptionsConnectorFabric<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO>\n> {\n  (options: CO): ConnectorMain;\n}\n\n/**\n * options used for connection to a swarm databases\n *\n * @export\n * @interface ISwarmStoreOptions\n * @extends {ISwarmStoreUserOptions}\n * @extends {ISwarmStoreDatabasesOptions}\n */\nexport interface ISwarmStoreOptions<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>\n> extends Required<ISwarmStoreMainOptions<P, ItemType, DbType>>,\n    Required<ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>> {}\n\n/**\n * options used for connection to a swarm databases\n *\n * @export\n * @interface ISwarmStoreOptions\n * @extends {ISwarmStoreUserOptions}\n * @extends {ISwarmStoreDatabasesOptions}\n */\nexport interface ISwarmStoreOptionsWithConnectorFabric<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>\n> extends ISwarmStoreOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO> {\n  connectorFabric: CFO;\n}\n\n/**\n * this interface must be implemented by a swarm storage connectors\n *\n * @export\n * @interface ISwarmStoreConnector\n * @extends {EventEmitter<ISwarmStoreEvents>}\n * @template P\n */\nexport interface ISwarmStoreConnectorBase<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>\n> {\n  // ready to use\n  isReady: boolean;\n  // disconnected from the swarm\n  isClosed: boolean;\n  // open connection with all databases\n  connect(options: PO, dataBasePersistantStorage?: IStorageCommon): Promise<Error | void>;\n  // close all the existing connections\n  close(): Promise<Error | void>;\n  // open a new connection to the database specified\n  openDatabase(dbOptions: DBO): Promise<void | Error>;\n  // close connection to a database specified\n  closeDatabase(dbName: DBO['dbName']): Promise<void | Error>;\n  /**\n   * drop the local copy of the database connected to\n   * and close connection with the database.\n   *\n   * @param {string} dbName\n   * @returns {(Promise<Error | boolean>)}\n   * @memberof ISwarmStoreConnectorBase\n   */\n  dropDatabase(dbName: string): Promise<void | Error>;\n  // send request to a swarm database to perform\n  // an operation such as read or seta value\n  // on a database\n  request<A extends ItemType, DT extends DbType>(\n    dbName: DBO['dbName'],\n    dbMethod: TSwarmStoreDatabaseMethod<P>,\n    arg: TSwarmStoreDatabaseMethodArgument<P, A, DT>\n  ): Promise<TSwarmStoreDatabaseRequestMethodReturnType<P, A>>;\n}\n\nexport interface ISwarmStoreConnectorBasic<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>\n> extends EventEmitter<ISwarmStoreConnectorOrbitDBEvents<P, ItemType, DbType, DBO>> {\n  dbName: string;\n  isClosed: boolean;\n  isReady: boolean;\n\n  /**\n   * Close the insatnce\n   *\n   * @param {*} [opt]\n   * @returns {(Promise<Error | void>)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  [ESwarmStoreConnectorOrbitDbDatabaseMethodNames.close](opt?: any): Promise<Error | void>;\n\n  /**\n   * Load items count from a persistent storage to the memory\n   *\n   * @param {TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbLoad} count\n   * @returns {(Promise<ISwarmStoreConnectorRequestLoadAnswer | Error>)}\n   * @memberof ISwarmStoreConnectorBasic\n   */\n  [ESwarmStoreConnectorOrbitDbDatabaseMethodNames.load](\n    count: TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbLoad\n  ): Promise<ISwarmStoreConnectorRequestLoadAnswer | Error>;\n\n  /**\n   * Add the new entry to the database\n   *\n   * @param {TSwarmStoreConnectorOrbitDbDatabaseAddMethodArgument<ItemType>} addArg\n   * @returns {(Promise<string | Error>)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  [ESwarmStoreConnectorOrbitDbDatabaseMethodNames.add](\n    addArg: TSwarmStoreConnectorOrbitDbDatabaseAddMethodArgument<ItemType>\n  ): Promise<string | Error>;\n\n  /**\n   * Read entry from the database by the given argument.\n   * for the key value store a key must be used.\n   * for the feed store a hash of the value\n   * must be used.\n   *\n   * @param {TSwarmStoreConnectorOrbitDbDatabaseEntityIndex} keyOrHash\n   * @returns {(Promise<\n   *     Error | ISwarmStoreConnectorOrbitDbDatabaseValue<ItemType> | undefined\n   *   >)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  [ESwarmStoreConnectorOrbitDbDatabaseMethodNames.get](\n    keyOrHash: TSwarmStoreConnectorOrbitDbDatabaseEntityIndex\n  ): Promise<Error | ISwarmStoreConnectorOrbitDbDatabaseValue<ItemType> | undefined>;\n\n  /**\n   * Remove a value located in the key provided if it is a key value\n   * database.\n   * Remove an entry by it's address for a non key-value database.\n   *\n   * @param {TSwarmStoreConnectorOrbitDbDatabaseEntityIndex} keyOrEntryAddress\n   * @returns {(Promise<E): TSwarmMessageStoreConnectReturnType<P, T, DbType, ConnectorBasic, ConnectorMain, O> {rror | void>)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  [ESwarmStoreConnectorOrbitDbDatabaseMethodNames.remove](\n    keyOrEntryAddress: TSwarmStoreConnectorOrbitDbDatabaseEntityIndex\n  ): Promise<Error | void>;\n\n  /**\n   * Iterate over the database values which are follows conditions\n   * from the options.\n   *\n   * @param {ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<DbType>} [options]\n   * @returns {(Promise<\n   *     | Error\n   *     | Array<\n   *         | ISwarmStoreConnectorOrbitDbDatabaseValue<ItemType>\n   *         | Error\n   *         | undefined\n   *       >\n   *   >)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  [ESwarmStoreConnectorOrbitDbDatabaseMethodNames.iterator](\n    options?: ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<DbType>\n  ): Promise<Error | Array<ISwarmStoreConnectorOrbitDbDatabaseValue<ItemType> | Error | undefined>>;\n\n  /**\n   * Connect to the database\n   *\n   * @returns {(Promise<Error | void>)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  connect(): Promise<Error | void>;\n  /**\n   * Drop the database and clear all local stored entries.\n   *\n   * @returns {(Promise<Error | void>)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  drop(): Promise<Error | void>;\n}\n\nexport interface ISwarmStoreConnector<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>\n> extends EventEmitter<ISwarmStoreEvents<P, ItemType, DbType, DBO>>,\n    ISwarmStoreConnectorBase<P, ItemType, DbType, DBO, ConnectorBasic, PO> {}\n\nexport type TSwarmStoreOptionsOfDatabasesKnownList<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>\n> = Record<DBO['dbName'], DBO>;\n\nexport interface ISwarmStoreDatabasesCommonStatusList<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>\n> {\n  readonly options: TSwarmStoreOptionsOfDatabasesKnownList<P, ItemType, DbType, DBO>;\n  readonly opened: Record<string, boolean>;\n}\n\nexport interface ISwarmStoreWithConnector<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  ConnectorMain extends ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO>\n> {\n  getConnectorOrError(): ConnectorMain | Error;\n}\n\n/**\n * Implements connection to a swarm\n * databases.\n * After the instance will be connected\n * to databases it allows to send request\n * to databases connected to.\n * Status of connection to a specific\n * databases is available on subscription\n * to the instance's methods.\n *\n * @export\n * @interface ISwarmStore\n */\nexport interface ISwarmStore<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>,\n  O extends ISwarmStoreOptionsWithConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>\n> extends Omit<ISwarmStoreConnectorBase<P, ItemType, DbType, DBO, ConnectorBasic, PO>, 'connect'> {\n  // status of a database connected to\n  dbStatuses: ISwarmStoreDatabasesStatuses;\n  /**\n   * List with all databases opened any time.\n   * It is persistant only if\n   * a databasePersistantListStorage instance\n   * provided while connecting.\n   *\n   * @type {ISwarmStoreDatabasesCommonStatusList}\n   * @memberof ISwarmStore\n   */\n  databases: ISwarmStoreDatabasesCommonStatusList<P, ItemType, DbType, DBO> | undefined;\n  // open connection with all databases\n  connect(options: O): Promise<Error | void>;\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.ts",["3131","3132","3133","3134","3135","3136","3137"],"import OrbitDB from 'orbit-db';\nimport AccessController from 'orbit-db-access-controllers/src/access-controller-interface';\nimport {\n  SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_TYPE,\n  SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_LOG_PREFIX,\n} from './swarm-store-connector-orbit-db-subclass-access-controller.const';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions,\n  TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback,\n  ISwarmStoreConnectorOrbitDbDatabaseAccessControllerManifest,\n} from './swarm-store-connector-orbit-db-subclass-access-controller.types';\nimport { IdentityProvider } from 'orbit-db-identity-provider';\nimport { ESwarmStoreConnector } from '../../../../swarm-store-class.const';\nimport { EOrbitDbFeedStoreOperation } from '../swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { TSwarmStoreValueTypes } from '../../../../swarm-store-class.types';\n\nexport class SwarmStoreConnectorOrbitDBSubclassAccessController<\n  T extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>\n> extends AccessController {\n  // Returns the type of the access controller\n  public static get type(): string {\n    return SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_TYPE;\n  }\n  /**\n   * create and preload an instance\n   * of the SwarmStoreConnectorOrbitDBSubclassAccessController\n   *\n   * @static\n   * @template T\n   * @param {OrbitDB} orbitdb\n   * @param {ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T>} [options={}]\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  public static async create<T extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>>(\n    orbitdb: OrbitDB,\n    options: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T> = {}\n  ): Promise<SwarmStoreConnectorOrbitDBSubclassAccessController<T>> {\n    return new SwarmStoreConnectorOrbitDBSubclassAccessController<T>(orbitdb, options);\n  }\n\n  // if true then anyone have access\n  // to the database\n  protected _isPublic: boolean = false;\n\n  protected _grantAccessCallback?: TSwarmStoreConnectorOrbitDbAccessConrotllerGrantAccessCallback<\n    ESwarmStoreConnector.OrbitDB,\n    T\n  >;\n\n  protected _orbitdb?: OrbitDB;\n\n  protected _options?: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T>;\n\n  constructor(orbitdb: OrbitDB, options: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T> = {}) {\n    super();\n    this._orbitdb = orbitdb;\n    this.setOptions(options);\n  }\n\n  /**\n   * Called by the databases (the log) to see if entry should\n   * be allowed in the database. Return true if the entry is allowed,\n   * false is not allowed.\n   *\n   * @param {LogEntry<T>} entry\n   * @param {IdentityProvider} identityProvider\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  public async canAppend(entry: LogEntry<T>, identityProvider: IdentityProvider): Promise<boolean> {\n    if (!this.verifyEntryFormat(entry)) {\n      console.warn(`${SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_LOG_PREFIX}::entry have an unknown format`);\n      return false;\n    }\n\n    // Write keys and admins keys are allowed\n    const { _options, _isPublic } = this;\n\n    if (_isPublic) {\n      return this.checkAccess(entry, identityProvider);\n    }\n\n    if (!_options) {\n      return false;\n    }\n\n    const { identity } = entry;\n    const { id: userPerformedActionOnEntryId } = identity;\n    const { write: accessListForUsers } = _options;\n\n    // If the ACL contains the writer's public key or it contains '*'\n    if (accessListForUsers && accessListForUsers.includes(userPerformedActionOnEntryId)) {\n      return this.checkAccess(entry, identityProvider);\n    }\n    return false;\n  }\n\n  /**\n   *  return manifest params\n   *\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  public async save(): Promise<ISwarmStoreConnectorOrbitDbDatabaseAccessControllerManifest> {\n    return {};\n  }\n\n  /**\n   * check if the entry have the common fields\n   * used to verfy the access on it\n   *\n   * @protected\n   * @param {LogEntry<T>} entry\n   * @returns {entry is LogEntry<T>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  protected verifyEntryFormat(entry: LogEntry<T>): entry is LogEntry<T> {\n    if (!entry || typeof entry !== 'object') {\n      return false;\n    }\n\n    const { identity, payload } = entry;\n    const { id } = identity;\n\n    if (!id) {\n      return false;\n    }\n    if (payload === undefined) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * validate the identiry provided by the entity\n   *\n   * @protected\n   * @param {IdentityJson} identity\n   * @returns {Promise<boolean>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  protected verifyIdentity(identity: IdentityJson, identityProvider: IdentityProvider): Promise<boolean> {\n    return (identityProvider as any).verifyIdentity(identity);\n  }\n\n  /**\n   * validate the entity format and\n   * check the access on it for the\n   * identity provided\n   *\n   * @protected\n   * @param {LogEntry<T>} entry\n   * @returns {Promise<boolean>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  protected async verifyEntity(entry: LogEntry<T>): Promise<boolean> {\n    if (!this.verifyEntryFormat(entry)) {\n      return false;\n    }\n\n    const { identity, payload } = entry;\n    const { value, key, op } = payload;\n    const { id } = identity;\n    const { _grantAccessCallback } = this;\n\n    if (typeof _grantAccessCallback === 'function') {\n      return _grantAccessCallback(value, id, key, op as EOrbitDbFeedStoreOperation | undefined);\n    }\n    return true;\n  }\n\n  /**\n   * validates the enetry and verify the user have\n   * the access on it\n   *\n   * @protected\n   * @param {LogEntry<T>} entry\n   * @param {IdentityProvider} identityProvider\n   * @returns {Promise<boolean>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassAccessController\n   */\n  protected async checkAccess(entry: LogEntry<T>, identityProvider: IdentityProvider): Promise<boolean> {\n    try {\n      if (!this.verifyEntryFormat(entry)) {\n        return false;\n      }\n\n      const { identity } = entry;\n      const validateIdentityResult = await this.verifyIdentity(identity, identityProvider);\n\n      if (validateIdentityResult !== true) {\n        return false;\n      }\n      return await this.verifyEntity(entry);\n    } catch (err) {\n      console.error(err);\n      return false;\n    }\n  }\n\n  protected setOptions(options: ISwarmStoreConnectorOrbitDbDatabaseAccessControllerOptions<T>) {\n    if (options) {\n      const { write, grantAccess } = options;\n\n      if (write instanceof Array) {\n        if (write.includes('*')) {\n          this._isPublic = true;\n        }\n      } else {\n        console.warn(`${SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_LOG_PREFIX}::Noone have access on the database`);\n      }\n      if (typeof grantAccess === 'function') {\n        if (grantAccess.length !== 2) {\n          console.warn(\n            `${SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_ACCESS_CONTROLLER_LOG_PREFIX}::A grant access callback must receives 2 arguments generally, but receives ${grantAccess.length}`\n          );\n        }\n        this._grantAccessCallback = grantAccess;\n      }\n      this._options = options;\n    }\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.ts",["3138","3139","3140","3141","3142","3143","3144","3145","3146","3147","3148","3149","3150","3151","3152","3153","3154","3155","3156","3157","3158","3159","3160","3161","3162","3163","3164","3165","3166","3167","3168","3169","3170","3171","3172","3173","3174","3175","3176","3177","3178","3179"],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types.ts",["3180","3181","3182","3183"],"import {\n  ISwarmStoreDatabaseBaseOptions,\n  TSwarmStoreDatabaseEntityUniqueIndex,\n  TSwarmStoreDatabaseType,\n  TSwarmStoreValueTypes,\n} from '../../../../swarm-store-class.types';\nimport { ESwarmStoreConnector, ESwarmStoreEventNames } from '../../../../swarm-store-class.const';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from './swarm-store-connector-orbit-db-subclass-database.const';\nimport {\n  ISwarmStoreConnectorOrbitDbAccessConrotllerOrbitDBStandardOptionsWriteAccess,\n  ISwarmStoreConnectorOrbitDbDatabaseAccessControlleGrantCallback,\n} from '../swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller.types';\nimport OrbitDbFeedStore from 'orbit-db-feedstore';\nimport OrbitDbKeyValueStore from 'orbit-db-kvstore';\nimport { ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore } from '../swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclasses-cache.types';\nimport { ESwarmStoreConnectorOrbitDbDatabaseMethodNames } from '../../swarm-store-connector-orbit-db.types';\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseStoreHash = string;\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseStoreKey = string;\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseEntityIndex =\n  | TSwarmStoreConnectorOrbitDbDatabaseStoreHash\n  | TSwarmStoreConnectorOrbitDbDatabaseStoreKey;\n\nexport type TSwarmStoreConnectorOrbitDbDatabase<V> = OrbitDbFeedStore<V> | OrbitDbKeyValueStore<V>;\n\nexport interface ISwarmStoreConnectorOrbitDbDatabaseOptions<\n  TStoreValueType extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>,\n  DbType extends ESwarmStoreConnectorOrbitDbDatabaseType\n> extends ISwarmStoreConnectorOrbitDbDatabaseAccessControlleGrantCallback<TStoreValueType>,\n    ISwarmStoreConnectorOrbitDbAccessConrotllerOrbitDBStandardOptionsWriteAccess,\n    ISwarmStoreDatabaseBaseOptions {\n  /**\n   * Datatbase type, may be feed store or key-value store.\n   * By default the feed store type is used.\n   *\n   * @type {ESwarmStoreConnectorOrbitDbDatabaseType}\n   * @memberof ISwarmStoreConnectorOrbitDbDatabaseOptions\n   */\n  dbType?: DbType;\n  cache?: ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore;\n}\n\nexport interface ISwarmStoreConnectorOrbitDbDatabaseEvents<TSwarmStoreConnectorOrbitDBDatabase, TFeedStoreType> {\n  [ESwarmStoreEventNames.FATAL]: [string, Error, TSwarmStoreConnectorOrbitDBDatabase];\n\n  [ESwarmStoreEventNames.ERROR]: [string, Error, TSwarmStoreConnectorOrbitDBDatabase];\n  // Database name and percents loaded\n  [ESwarmStoreEventNames.LOADING]: [string, number, TSwarmStoreConnectorOrbitDBDatabase];\n  [ESwarmStoreEventNames.UPDATE]: [string, TSwarmStoreConnectorOrbitDBDatabase];\n  [ESwarmStoreEventNames.CLOSE]: [string, TSwarmStoreConnectorOrbitDBDatabase];\n  [ESwarmStoreEventNames.READY]: [string, TSwarmStoreConnectorOrbitDBDatabase];\n  [ESwarmStoreEventNames.NEW_ENTRY]: [\n    string, // database name\n    any, // entry added\n    string, // address of the entry,\n    any, // heads\n    ESwarmStoreConnectorOrbitDbDatabaseType,\n    TSwarmStoreConnectorOrbitDBDatabase\n  ];\n}\n\nexport type ISwarmStoreConnectorOrbitDbDatabaseKey = string;\n\nexport interface ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValueType> extends LogEntry<TStoreValueType> {}\n\nexport enum ESwarmStoreConnectorOrbitDbDatabaseIteratorOption {\n  /**\n   * not equals to address or key\n   */\n  neq = 'neq',\n  /**\n   * equals to address or key\n   */\n  eq = 'eq',\n  /**\n   * greater than\n   */\n  gt = 'gt',\n  /**\n   * greater than or equals\n   */\n  gte = 'gte',\n  /**\n   * less than\n   */\n  lt = 'lt',\n  /**\n   * less than or equal\n   */\n  lte = 'lte',\n  /**\n   * limit messages count to read\n   */\n  limit = 'limit',\n  /**\n   * in reverse order\n   */\n  reverse = 'reverse',\n}\n\nexport interface ISwarmStoreConnectorOrbitDbDatabaseIteratorOptionsRequired<\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>\n> {\n  // if the equal operator applyied all other will not be applied\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.eq]:\n    | TSwarmStoreDatabaseEntityUniqueIndex<ESwarmStoreConnector.OrbitDB, DbType>\n    | TSwarmStoreDatabaseEntityUniqueIndex<ESwarmStoreConnector.OrbitDB, DbType>[];\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.neq]:\n    | TSwarmStoreDatabaseEntityUniqueIndex<ESwarmStoreConnector.OrbitDB, DbType>\n    | TSwarmStoreDatabaseEntityUniqueIndex<ESwarmStoreConnector.OrbitDB, DbType>[];\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.gt]: TSwarmStoreDatabaseEntityUniqueIndex<\n    ESwarmStoreConnector.OrbitDB,\n    DbType\n  >;\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.gte]: TSwarmStoreDatabaseEntityUniqueIndex<\n    ESwarmStoreConnector.OrbitDB,\n    DbType\n  >;\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.lt]: TSwarmStoreDatabaseEntityUniqueIndex<\n    ESwarmStoreConnector.OrbitDB,\n    DbType\n  >;\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.lte]: TSwarmStoreDatabaseEntityUniqueIndex<\n    ESwarmStoreConnector.OrbitDB,\n    DbType\n  >;\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.limit]: number;\n  [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.reverse]: boolean;\n}\n\nexport interface ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>\n> extends Partial<ISwarmStoreConnectorOrbitDbDatabaseIteratorOptionsRequired<DbType>> {}\n\nexport interface ISwarmStoreConnectorOrbitDbDatabaseIteratorAnswer<T> {\n  collect(): T[];\n}\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseMethodNames = ESwarmStoreConnectorOrbitDbDatabaseMethodNames;\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseAddMethodArgument<TStoreValue> = {\n  value: TStoreValue;\n  /**\n   * Key of the value for Key-Value database store type.\n   *\n   * @type {TSwarmStoreConnectorOrbitDbDatabaseStoreKey}\n   */\n  key?: TSwarmStoreConnectorOrbitDbDatabaseStoreKey;\n};\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbClose = void;\n\n// how many items to load\nexport type TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbLoad = number;\n\nexport type TSwarmStoreConnectorOrbitDbDatabaseMethodArgument<\n  TStoreValue,\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>\n> =\n  | TSwarmStoreConnectorOrbitDbDatabaseStoreHash\n  | TStoreValue\n  | TSwarmStoreConnectorOrbitDbDatabaseAddMethodArgument<TStoreValue>\n  | ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<DbType>\n  | TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbClose\n  | TSwarmStoreConnectorOrbitDbDatabaseMethodArgumentDbLoad;\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider.ts",["3184","3185","3186","3187","3188","3189","3190","3191","3192","3193","3194","3195"],"import KeystoreClass, { Keystore } from 'orbit-db-keystore';\nimport { IdentityProvider, IdentityProviderOptions, IdentityAsJson } from 'orbit-db-identity-provider';\nimport { IOrbitDBKeystoreStoreCustom } from 'types';\nimport { SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_IDENTITY_PROVIDER_TYPE } from './swarm-store-connector-orbit-db-subclass-identity-provider.const';\n\nexport class SwarmStoreConnectorOrbitDBSubclassIdentityProvider extends IdentityProvider {\n  /**\n   * return name of the identity provider\n   *\n   * @readonly\n   * @static\n   * @type {string}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n   */\n  public static get type(): string {\n    return SWARM_STORE_CONNECTOR_ORBITDB_SUBCLASS_IDENTITY_PROVIDER_TYPE;\n  }\n\n  /**\n   * Verify that identity was signed by the ID\n   *\n   * @static\n   * @param {IdentityAsJson} identity\n   * @returns {Promise<boolean>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n   */\n  public static async verifyIdentity(identity: IdentityAsJson): Promise<boolean> {\n    // TODO - may be verify the identity with central authority\n    const verifyResult = await ((KeystoreClass as unknown) as IOrbitDBKeystoreStoreCustom).verify(\n      identity.signatures.publicKey,\n      identity.publicKey,\n      identity.publicKey + identity.signatures.id\n    );\n\n    return verifyResult;\n  }\n\n  protected _keystore?: Keystore;\n\n  constructor(options: IdentityProviderOptions = {}) {\n    super(options);\n    if (!options.keystore) {\n      throw new Error('IdentityProvider.createIdentity requires options.keystore');\n    }\n    if (!options.signingKeystore) {\n      options.signingKeystore = options.keystore;\n    }\n    this._keystore = options.signingKeystore;\n  }\n\n  /**\n   * return identifier of external id (eg. a public key)\n   *\n   * @param {IdentityProviderOptions} [options={}]\n   * @returns {Promise<string>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n   * @throws Error\n   */\n  async getId(options: IdentityProviderOptions = {}): Promise<string> {\n    const id = options.id;\n\n    if (!id) {\n      throw new Error('id is required');\n    }\n    return id;\n  }\n\n  /**\n   * return a signature of data (signature of the OrbtiDB public key)\n   *\n   * @param {*} data\n   * @param {IdentityProviderOptions} [options={}]\n   * @returns {Promise<any>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassIdentityProvider\n   * @throws Error\n   */\n  async signIdentity(data: any, options: IdentityProviderOptions = {}): Promise<string> {\n    const id = options.id;\n\n    if (!id) {\n      throw new Error('id is required');\n    }\n\n    const { _keystore: keystore } = this;\n    const key = await keystore!.getKey(id);\n\n    if (!key) {\n      throw new Error(`Signing key for '${id}' not found`);\n    }\n\n    const result = await (keystore! as any).sign(key, data);\n\n    return result;\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore.utils.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-cache/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-cache/swarm-store-connector-orbit-db-subclass-storage-cache.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.ts",["3196","3197","3198","3199","3200"],"import Storage from 'orbit-db-storage-adapter';\nimport { IStore } from 'orbit-db-cache';\n\nimport { ISecretStoreCredentials } from 'classes/secret-storage-class/secret-storage-class.types';\nimport { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';\n\nimport {\n  ISwarmStoreConnectorOrbitDBSubclassStorageFabric,\n  ISwarmStoreConnectorOrbitDbSubclassStorageFabricConstructorOptions,\n} from './swarm-store-connector-orbit-db-subclass-storage-fabric.types';\nimport { SwarmStoreConnectorOrbitDBSubclassStorageCache } from '../swarm-store-connector-orbit-db-subclass-storage-cache/swarm-store-connector-orbit-db-subclass-storage-cache';\nimport { SwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapter } from '../swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter';\nimport { ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore } from '../swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclasses-cache.types';\nimport assert from 'assert';\nimport { swarmStoreConnectorOrbitDbUtilsAddressCreateOrbitDbAddressByDatabaseName } from '../../swarm-store-connector-orbit-db-utils/swarm-store-connector-orbit-db-utils-address/swarm-store-connector-orbit-db-utils-address';\nimport { ISwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapterConstructorOptions } from '../swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter.types';\nimport { swarmStoreConnectorOrbitDbUtilsAddresGetHashPathFull } from '../../swarm-store-connector-orbit-db-utils';\nimport { TSecretStorageAuthorizazionOptions } from '../../../../../secret-storage-class/secret-storage-class.types';\n\nexport class SwarmStoreConnectorOrbitDBSubclassStorageFabric implements ISwarmStoreConnectorOrbitDBSubclassStorageFabric {\n  private key?: CryptoKey;\n\n  private ready?: Promise<void>;\n\n  /**\n   * names of databases which must be encrypted\n   *\n   * @protected\n   * @type {Set<string>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStorageFabric\n   */\n  protected secretDatabasesNames: Set<string> = new Set();\n\n  /**\n   * paths of databases which must be encrypted\n   *\n   * @protected\n   * @type {Set<string>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStorageFabric\n   */\n  protected secretDatabasesPaths: Set<string> = new Set();\n\n  protected storage: any;\n\n  protected rootPath?: string;\n\n  constructor({ credentials, rootPath }: ISwarmStoreConnectorOrbitDbSubclassStorageFabricConstructorOptions) {\n    if (credentials) {\n      this.applyCredentials(credentials);\n    }\n    this.setRootPath(rootPath);\n    this.createStorage();\n  }\n\n  public addSecretDatabaseName = async (dbName: string): Promise<void> => {\n    const databasePath = await this.createPathForDb(dbName);\n\n    this.secretDatabasesNames.add(dbName);\n    this.secretDatabasesPaths.add(databasePath);\n  };\n\n  /**\n   * create an instance of OrbitDB Cache\n   * for a path provided\n   *\n   * @param {string} path\n   * @returns {Cache}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStorageFabric\n   * @throws\n   */\n  public async createStore(path: string): Promise<ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore> {\n    await this.ready;\n    if (this.whetherUseSecretStorageForPath(path)) {\n      return this.createSecretStorageForPath(path);\n    }\n    // TODO - the default cache storage created by OrbitDB\n    // with the LevelUP library works incorrectly with a lot\n    // of I/O operations.\n    return this.createOpenStorageForPath(path);\n  }\n\n  /**\n   * create an instance of OrbitDB Cache\n   * for a path provided\n   *\n   * @param {string} dbName\n   * @returns {Cache}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStorageFabric\n   * @throws\n   */\n  public async createStoreForDb(dbName: string): Promise<ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore> {\n    await this.ready;\n    const dbPath = await this.createPathForDb(dbName);\n    if (this.whetherUseSecretStorageForDB(dbName)) {\n      return this.createSecretStorageForPath(dbPath);\n    }\n    // TODO - the default cache storage created by OrbitDB\n    // with the LevelUP library works incorrectly with a lot\n    // of I/O operations.\n    return this.createOpenStorageForPath(dbPath);\n  }\n\n  protected setRootPath(rootPath: string): void {\n    assert(typeof rootPath === 'string', 'Root path should be a string');\n    this.rootPath = rootPath;\n  }\n\n  protected createStorage(): void {\n    this.storage = Storage();\n  }\n\n  protected whetherUseSecretStorageForDB(dbName: string): boolean {\n    return this.secretDatabasesNames.has(dbName);\n  }\n\n  protected whetherUseSecretStorageForPath(path: string): boolean {\n    return this.secretDatabasesPaths.has(path);\n  }\n\n  protected applyCredentials(credentials: TSecretStorageAuthorizazionOptions): void {\n    this.ready = this.createKey(credentials);\n  }\n\n  /**\n   *\n   *\n   * @protected\n   * @param {ISecretStoreCredentials} credentials\n   * @returns {Promise<void>}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStorageFabric\n   * @throws\n   */\n  protected async createKey(credentials: TSecretStorageAuthorizazionOptions): Promise<void> {\n    const secretStorage = new SecretStorage();\n    const cryptoKey = await secretStorage.generateCryptoKey(credentials);\n\n    if (cryptoKey instanceof Error) {\n      console.error(`createKey::${cryptoKey}`);\n      throw new Error('Failed to generate a key');\n    }\n    if (!(cryptoKey instanceof CryptoKey)) {\n      throw new Error('createKey::the key generated by a password string must be a CryptoKey');\n    }\n    this.key = cryptoKey;\n  }\n\n  protected createSecretStorageCacheInstance(path: string): ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore {\n    const { key } = this;\n\n    if (!key) {\n      throw new Error('A CryptoKey is not exists');\n    }\n    if (!(key instanceof CryptoKey)) {\n      throw new Error('The key must be an instance of CryptoKey');\n    }\n\n    const cache = new SwarmStoreConnectorOrbitDBSubclassStorageCache({ dbName: path }, { key });\n\n    return cache;\n  }\n\n  protected async createSecretStorageForPath(path: string): Promise<ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore> {\n    const cache = this.createSecretStorageCacheInstance(path);\n\n    await cache.open();\n    return cache;\n  }\n\n  protected async createOptionsForOpenStorageCacheInstanceConstructor(\n    path: string\n  ): Promise<ISwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapterConstructorOptions> {\n    const dbName = await swarmStoreConnectorOrbitDbUtilsAddresGetHashPathFull(path);\n    return { dbName };\n  }\n\n  protected async createOpenStorageCacheInstance(\n    path: string\n  ): Promise<ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore> {\n    const cacheStoreConstructorOptions = await this.createOptionsForOpenStorageCacheInstanceConstructor(path);\n    const cacheStoreInstance = new SwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapter(cacheStoreConstructorOptions);\n\n    return cacheStoreInstance;\n  }\n\n  protected async createOpenStorageForPath(path: string): Promise<ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore> {\n    const cache = await this.createOpenStorageCacheInstance(path);\n\n    await cache.open();\n    return cache;\n  }\n\n  protected async createPathForDb(dbName: string): Promise<string> {\n    if (!this.rootPath) {\n      throw new Error('A root path is not defined');\n    }\n    return swarmStoreConnectorOrbitDbUtilsAddressCreateOrbitDbAddressByDatabaseName(this.rootPath, dbName);\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.ts",["3201","3202","3203","3204","3205","3206","3207","3208","3209","3210","3211","3212","3213","3214","3215","3216","3217","3218","3219","3220","3221","3222","3223","3224"],"import OrbitDB from 'orbit-db';\nimport Identities from 'orbit-db-identity-provider';\nimport AccessControllers from 'orbit-db-access-controllers';\nimport { Keystore } from 'orbit-db-keystore';\nimport { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport {\n  SWARM_STORE_CONNECTOR_ORBITDB_CONNECTION_TIMEOUT_MS,\n  SWARM_STORE_CONNECTOR_ORBITDB_LOG_PREFIX,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONNECTION_TIMEOUT_MS,\n  SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_RECONNECTION_ATTEMPTS_MAX,\n  SWARM_STORE_CONNECTOR_ORBITDB_IDENTITY_TYPE,\n  SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DBNAME,\n  SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DIRECTORY,\n} from './swarm-store-connector-orbit-db.const';\nimport { IPFS } from 'types/ipfs.types';\nimport { SwarmStoreConnectorOrbitDBSubclassIdentityProvider } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-identity-provider/swarm-store-connector-orbit-db-subclass-identity-provider';\nimport { SwarmStoreConnectorOrbitDBSubclassAccessController } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-access-controller/swarm-store-connector-orbit-db-subclass-access-controller';\nimport {\n  ISwarmStoreConnectorOrbitDBOptions,\n  ISwarmStoreConnectorOrbitDBConnectionOptions,\n  ISwarmStoreConnectorOrbitDBEvents,\n} from './swarm-store-connector-orbit-db.types';\nimport { timeout, delay } from 'utils/common-utils/common-utils-timer';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseOptions,\n  TSwarmStoreConnectorOrbitDbDatabaseMethodNames,\n  TSwarmStoreConnectorOrbitDbDatabaseMethodArgument,\n} from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { commonUtilsArrayDeleteFromArray } from 'utils/common-utils/common-utils';\nimport {\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON,\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_OFF,\n  COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_UNSET_ALL_LISTENERS,\n} from 'const/common-values/common-values';\nimport { SwarmStorageConnectorOrbitDBSublassKeyStore } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-keystore/swarm-store-connector-orbit-db-subclass-keystore';\nimport {\n  ISwarmStoreConnectorOrbitDBSubclassStorageFabric,\n  ISwarmStoreConnectorOrbitDbSubclassStorageFabricConstructorOptions,\n} from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric.types';\nimport { SwarmStoreConnectorOrbitDBSubclassStorageFabric } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-storage-fabric/swarm-store-connector-orbit-db-subclass-storage-fabric';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { TSwarmStoreDatabaseType, ISwarmStoreConnectorBasic } from '../../swarm-store-class.types';\nimport { ISwarmStoreConnectorOrbitDbUtilsAddressCreateRootPathOptions } from './swarm-store-connector-orbit-db-utils/swarm-store-connector-orbit-db-utils-address/swarm-store-connector-orbit-db-utils-address.types';\nimport { swarmStoreConnectorOrbitDbUtilsAddressCreateRootPath } from './swarm-store-connector-orbit-db-utils/swarm-store-connector-orbit-db-utils-address/swarm-store-connector-orbit-db-utils-address';\nimport { TSecretStorageAuthorizazionOptions } from '../../../secret-storage-class/secret-storage-class.types';\nimport assert from 'assert';\nimport { ISwarmStoreConnectorOrbitDbConnecectionBasicFabric } from './swarm-store-connector-orbit-db.types';\nimport { TSwarmStoreDatabaseOptions, TSwarmStoreConnectorConnectionOptions } from '../../swarm-store-class.types';\nimport { ISwarmStoreConnector, TSwarmStoreValueTypes } from '../../swarm-store-class.types';\nimport { ESwarmStoreConnector, ESwarmStoreEventNames } from '../../swarm-store-class.const';\nimport { TSwarmMessageUserIdentifierSerialized } from '../../../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\n\nexport class SwarmStoreConnectorOrbitDB<\n    ItemType extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>,\n    DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>,\n    DBO extends TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, ItemType, DbType>,\n    ConnectorBasic extends ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>,\n    PO extends TSwarmStoreConnectorConnectionOptions<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO, ConnectorBasic>\n  >\n  extends EventEmitter<ISwarmStoreConnectorOrbitDBEvents<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>>\n  implements ISwarmStoreConnector<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO, ConnectorBasic, PO> {\n  private static isLoadedCustomIdentityProvider: boolean = false;\n\n  private static isLoadedCustomAccessController: boolean = false;\n\n  private static loadCustomIdentityProvider() {\n    if (!SwarmStoreConnectorOrbitDB.isLoadedCustomIdentityProvider) {\n      Identities.addIdentityProvider(SwarmStoreConnectorOrbitDBSubclassIdentityProvider);\n      SwarmStoreConnectorOrbitDB.isLoadedCustomIdentityProvider = true;\n    }\n  }\n\n  private static loadCustomAccessController() {\n    if (!SwarmStoreConnectorOrbitDB.isLoadedCustomAccessController) {\n      AccessControllers.addAccessController({\n        AccessController: SwarmStoreConnectorOrbitDBSubclassAccessController,\n      });\n      SwarmStoreConnectorOrbitDB.isLoadedCustomAccessController = true;\n    }\n  }\n\n  public isReady: boolean = false;\n\n  public isClosed: boolean = false;\n\n  protected userId: TSwarmMessageUserIdentifierSerialized = '';\n\n  protected directory: string = SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DIRECTORY;\n\n  protected rootPath?: string;\n\n  protected identity?: any;\n\n  protected connectionOptions?: ISwarmStoreConnectorOrbitDBConnectionOptions<ItemType, DbType, DBO, ConnectorBasic>;\n\n  protected options?: ISwarmStoreConnectorOrbitDBOptions<ItemType, DbType>;\n\n  protected ipfs?: IPFS; // instance of the IPFS connected through\n\n  protected orbitDb?: OrbitDB; // instance of the OrbitDB\n\n  protected databases: ConnectorBasic[] = [];\n\n  protected identityKeystore?: Keystore;\n\n  protected storage?: ISwarmStoreConnectorOrbitDBSubclassStorageFabric;\n\n  protected initializationPromise: Promise<void> | undefined;\n\n  private dbCloseListeners: ((...args: any[]) => any)[] = [];\n\n  protected _connectorBasicFabric:\n    | ISwarmStoreConnectorOrbitDbConnecectionBasicFabric<ItemType, DbType, DBO, ConnectorBasic>\n    | undefined;\n\n  public constructor(options: ISwarmStoreConnectorOrbitDBOptions<ItemType, DbType>) {\n    super();\n    SwarmStoreConnectorOrbitDB.loadCustomIdentityProvider();\n    SwarmStoreConnectorOrbitDB.loadCustomAccessController();\n    this.applyOptions(options);\n    this.createInitializationPromise(options);\n  }\n\n  /**\n     * waiting for the connection to the swarm, load the database locally\n     * and ready to use it\n    /**\n     *\n     *\n     * @param {ISwarmStoreConnectorOrbitDBConnectionOptions} connectionOptions\n     * @returns {(Promise<void | Error>)}\n     * @memberof SwarmStoreConnectorOrbitDB\n     */\n  public async connect(\n    connectionOptions: ISwarmStoreConnectorOrbitDBConnectionOptions<ItemType, DbType, DBO, ConnectorBasic>\n  ): Promise<void | Error> {\n    // waiting for the instance initialization\n    await this.initializationPromise;\n    const resultCreateIdentity = await this.createIdentity();\n\n    if (resultCreateIdentity instanceof Error) {\n      console.error(resultCreateIdentity);\n      return this.emitError('Failed to create an identity');\n    }\n\n    const disconnectFromSwarmResult = await this.disconnectFromSwarm();\n\n    if (disconnectFromSwarmResult instanceof Error) {\n      return disconnectFromSwarmResult;\n    }\n\n    const setConnectionOptionsResult = this.setConnectionOptions(connectionOptions);\n\n    if (setConnectionOptionsResult instanceof Error) {\n      return setConnectionOptionsResult;\n    }\n\n    const connectToSwarmResult = await this.connectToSwarm();\n\n    if (connectToSwarmResult instanceof Error) {\n      return connectToSwarmResult;\n    }\n\n    // close the current connections to the databases if exists\n    const closeExistingDatabaseesOpened = await this.closeDatabases();\n\n    if (closeExistingDatabaseesOpened instanceof Error) {\n      return this.emitError(closeExistingDatabaseesOpened, 'openDatabases');\n    }\n\n    // stop the current instance of OrbitDB\n    // if it exists\n    const stopOrbitDBResult = await this.stopOrbitDBInsance();\n\n    if (stopOrbitDBResult instanceof Error) {\n      return stopOrbitDBResult;\n    }\n\n    // create a new OrbitDB instance\n    const createOrbitDbResult = await this.createOrbitDBInstance();\n\n    if (createOrbitDbResult instanceof Error) {\n      return createOrbitDbResult;\n    }\n\n    // create OrbitDB databases\n    const createDatabases = await this.openDatabases();\n\n    if (createDatabases instanceof Error) {\n      return createDatabases;\n    }\n    this._setConnectorBasicFabric(connectionOptions);\n    // set the database is ready to query\n    this.setReady();\n  }\n\n  public async openDatabase(\n    dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<ItemType, DbType>,\n    openAttempt: number = 0,\n    checkOptionsIsExists: boolean = true\n  ): Promise<void | Error> {\n    const { orbitDb, isClosed } = this;\n\n    if (!orbitDb) {\n      return new Error('There is no instance of OrbitDB');\n    }\n    if (isClosed) {\n      return new Error(\"Can't open a database for the connection opened\");\n    }\n\n    // add options in the main setting only\n    // if options are not exists already\n    // in the list. If options are exists\n    // this may mean that the database was\n    // opened but still not ready to use and\n    // waiting when it will be ready to use.\n    const checkDbOptionsResult = checkOptionsIsExists ? this.setDbOptionsIfNotExists(dbOptions) : this.setDbOptions(dbOptions);\n\n    // options checked and set for valid\n    // calculation of the progress percent\n    if (checkDbOptionsResult instanceof Error) {\n      return checkDbOptionsResult;\n    }\n\n    const { dbName, useEncryptedStorage } = dbOptions;\n    const db = this.getDbConnectionExists(dbName);\n\n    if (db) {\n      this.unsetOptionsForDatabase(dbName);\n      return new Error(`A database named as ${dbName} is already exists`);\n    }\n\n    if (useEncryptedStorage) {\n      await this.addDatabaseNameToListOfUsingSecretStorage(dbName);\n    }\n\n    const database = await this.createDatabaseConnectorImplementation(dbOptions, dbName, orbitDb);\n\n    await this.setListenersDatabaseEvents(database);\n\n    const databaseOpenResult = await this.waitDatabaseOpened(database);\n\n    if (databaseOpenResult instanceof Error) {\n      await this.closeDb(database, false); // close the connection to the database\n      await delay(300);\n      if (openAttempt > SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_RECONNECTION_ATTEMPTS_MAX) {\n        return this.handleErrorOnDbOpen(database, 'The max nunmber of connection attempts has reached');\n      }\n\n      const openDatabaseResult = await this.openDatabase(dbOptions, (openAttempt += 1));\n\n      if (openDatabaseResult instanceof Error) {\n        return this.handleErrorOnDbOpen(database, openDatabaseResult);\n      }\n    }\n    console.log('openDatabase', dbName);\n    this.databases.push(database);\n    this.emit(ESwarmStoreEventNames.READY, dbOptions.dbName);\n  }\n\n  public async dropDatabase(dbName: string) {\n    const db = this.getDbConnection(dbName);\n\n    if (!db) {\n      return new Error(`The database named ${dbName} was not found`);\n    }\n    try {\n      await this.unsetListenersDatabaseEvents(db);\n      await db.drop();\n      await this.closeDb(db);\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  public async closeDatabase(dbName: string): Promise<Error | void> {\n    const db = this.getDbConnection(dbName);\n\n    if (db) {\n      return this.closeDb(db);\n    }\n    return new Error(`The database named ${dbName} was not found`);\n  }\n\n  /**\n   * make a request to a database by it's name\n   * and a method to execute\n   * @memberof SwarmStoreConnctotOrbitDB\n   */\n  public request = async <ISwarmDatabaseValueTypes>(\n    dbName: string,\n    dbMethod: TSwarmStoreConnectorOrbitDbDatabaseMethodNames,\n    arg: TSwarmStoreConnectorOrbitDbDatabaseMethodArgument<ISwarmDatabaseValueTypes, DbType>\n  ): Promise<Error | any> => {\n    const { isClosed } = this;\n\n    if (isClosed) {\n      return new Error('The Swarm connection was closed');\n    }\n\n    const dbConnection = await this.waitingDbOpened(dbName);\n\n    if (dbConnection instanceof Error) {\n      console.error(dbConnection);\n      return this.emitError(new Error('Failed to get an opened connection to the database'));\n    }\n    return dbConnection[dbMethod](arg as unknown);\n  };\n\n  /**\n   * close all connections with databases\n   * and the Swarm store\n   * @memberof SwarmStoreConnctotOrbitDB\n   */\n  public close = async (): Promise<Error | void> => {\n    this.setIsClosed();\n\n    const closeAllDatabasesResult = await this.closeDatabases();\n    const stopOrbitDBResult = await this.stopOrbitDBInsance();\n    let err;\n\n    if (closeAllDatabasesResult instanceof Error) {\n      err = true;\n      console.error(closeAllDatabasesResult);\n      this.emitError('Failed to close all databases connections');\n    }\n    if (stopOrbitDBResult instanceof Error) {\n      err = true;\n      console.error(closeAllDatabasesResult);\n      this.emitError('Failed to close the current instanceof OrbitDB');\n    }\n    this.unsetAllListenersForEvents();\n    if (err) {\n      return this.emitError('Failed to close normally the connection to the swarm store');\n    }\n  };\n\n  protected setIsClosed = () => {\n    this.setNotReady();\n    this.isClosed = true;\n    this.emit(ESwarmStoreEventNames.CLOSE, true);\n  };\n\n  /**\n   * return an opened connection with the database by it's name\n   * if exists and undefined if it is not exists\n   * @readonly\n   * @protected\n   * @type {(SwarmStoreConnectorOrbitDBDatabase<ItemType> | void)}\n   * @memberof SwarmStoreConnctotOrbitDB\n   */\n  protected getDbConnection = (dbName: string, checkIsOpen: boolean = true): ConnectorBasic | undefined => {\n    const { databases } = this;\n\n    return databases.find((db) => {\n      return db && db.dbName === dbName && (!checkIsOpen || (!db.isClosed && !!db.isReady));\n    });\n  };\n\n  /**\n   * returns a database if exists into the list\n   * of the databases which were opened.\n   * This method do not check whether db\n   * closed and ready.\n   * @protected\n   * @param {string} dbName\n   * @returns {ConnectorBasic | undefiend}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected getDbConnectionExists(dbName: string): ConnectorBasic | undefined {\n    return this.getDbConnection(dbName, false);\n  }\n\n  protected async handleDbClose(\n    database: ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>\n  ): Promise<void> {\n    if (database) {\n      const { dbName } = database;\n\n      await this.unsetListenersDatabaseEvents(database);\n      this.unsetOptionsForDatabase(dbName);\n      this.deleteDatabaseFromList(database);\n    }\n  }\n\n  protected async handleErrorOnDbOpen(\n    database: ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>,\n    error: Error | string\n  ): Promise<Error> {\n    if (database) {\n      const { dbName } = database;\n\n      await this.handleDbClose(database);\n      console.error(`An error has occurred while database named ${dbName} opening`);\n      console.error(error);\n    }\n    return this.emitError(error);\n  }\n\n  /**\n   * waiting till connection to the database\n   * will be opened or failed. If a db will\n   * not be ready during a timeout return error.\n   * @protected\n   * @param {string} dbName\n   * @returns {(Promise<Error | ISwarmStoreConnectorBasic<\n      ESwarmStoreConnector.OrbitDB,\n      ItemType,\n      DbType\n    >>)}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected async waitingDbOpened(\n    dbName: string\n  ): Promise<Error | ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>> {\n    const { getDbConnection } = this;\n    const db = getDbConnection(dbName);\n    const dbOptsIdx = this.getIdxDbOptions(dbName);\n\n    if (db) {\n      return db;\n    } else if (dbOptsIdx === -1) {\n      return new Error(`A database with the name ${dbName} was not found`);\n    } else {\n      const removeListener = this.removeListener.bind(this);\n\n      return new Promise((res) => {\n        let timeout: undefined | NodeJS.Timer;\n        function removeListners() {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = undefined;\n          }\n          removeListener(ESwarmStoreEventNames.READY, onReady);\n          removeListener(ESwarmStoreEventNames.CLOSE, onClose);\n        }\n        function onReady(dbNameReady: string) {\n          if (dbNameReady === dbName) {\n            const db = getDbConnection(dbName);\n\n            if (db) {\n              removeListners();\n              res(db);\n            }\n          }\n        }\n        function onClose() {\n          removeListners();\n          res(new Error('The Swarm store was closed'));\n        }\n\n        timeout = setTimeout(() => {\n          removeListners();\n          res(new Error());\n        }, SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONNECTION_TIMEOUT_MS);\n        this.once(ESwarmStoreEventNames.READY, onReady);\n        this.once(ESwarmStoreEventNames.CLOSE, onClose);\n      });\n    }\n  }\n\n  protected unsetAllListenersForEvents = () => {\n    Object.values(ESwarmStoreEventNames).forEach(this[COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_UNSET_ALL_LISTENERS].bind(this));\n  };\n\n  protected emitDatabaseClose(database: ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>) {\n    if (database) {\n      const { dbName } = database;\n\n      console.warn(`Database named ${dbName} was closed`);\n      this.emit(ESwarmStoreEventNames.CLOSE_DATABASE, dbName, database);\n    }\n  }\n\n  protected emitError(error: Error | string, mehodName?: string): Error {\n    const err = typeof error === 'string' ? new Error(error) : error;\n\n    console.error(`${SWARM_STORE_CONNECTOR_ORBITDB_LOG_PREFIX}::error${mehodName ? `::${mehodName}` : ''}`, err);\n    this.emit(ESwarmStoreEventNames.ERROR, err);\n    return err;\n  }\n\n  private setIsReady(isReady: boolean = false) {\n    this.isReady = isReady;\n    this.emit(ESwarmStoreEventNames.STATE_CHANGE, isReady);\n  }\n\n  /**\n   * set the flag this instance\n   * is not ready to make a\n   * request to databases\n   * @protected\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected setReady() {\n    this.setIsReady(true);\n  }\n\n  protected setNotReady() {\n    this.setIsReady(false);\n  }\n\n  /**\n   * delete the database from the list\n   * of opened databases\n   * @protected\n   * @param {SwarmStoreConnectorOrbitDBDatabase<ItemType>} database\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected deleteDatabaseFromList(database: ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>) {\n    const { databases } = this;\n\n    if (databases && databases instanceof Array) {\n      commonUtilsArrayDeleteFromArray(databases, database);\n    }\n  }\n\n  protected checkDbOptions(options: unknown): options is ISwarmStoreConnectorOrbitDbDatabaseOptions<ItemType, DbType> {\n    if (options != null && typeof options === 'object') {\n      const { dbName } = options as { dbName: string };\n\n      return !!dbName && typeof dbName === 'string';\n    }\n    return false;\n  }\n\n  /**\n   * apply options provided for the\n   * instance\n   *\n   * @private\n   * @param {ISwarmStoreConnectorOrbitDBOptions} options\n   * @memberof SwarmStoreConnectorOrbitDB\n   * @throws Error - throw an error if the options are not valid\n   */\n  private applyOptions(options: ISwarmStoreConnectorOrbitDBOptions<ItemType, DbType>) {\n    if (!options || typeof options !== 'object') {\n      throw new Error('The options must be an object');\n    }\n    this.options = options;\n\n    const { userId, directory } = options;\n\n    if (!userId) {\n      console.warn(new Error('The user id is not provided'));\n    } else {\n      this.userId = userId;\n    }\n    if (typeof directory === 'string') {\n      this.directory = directory;\n    }\n  }\n\n  private createStorages(credentials?: TSecretStorageAuthorizazionOptions): void {\n    if (credentials) {\n      // if credentials provided, then\n      // create the secret keystorage\n      this.createIdentityKeystores(credentials);\n    }\n    // create secret storage fabric\n    this.createStorageFabric(credentials);\n  }\n\n  protected getParamsForStoreRootPath(): ISwarmStoreConnectorOrbitDbUtilsAddressCreateRootPathOptions {\n    return {\n      directory: this.directory,\n      userId: String(this.userId),\n    };\n  }\n\n  protected async createStoreRootPath(): Promise<void> {\n    const rootPathParams = this.getParamsForStoreRootPath();\n    this.rootPath = await swarmStoreConnectorOrbitDbUtilsAddressCreateRootPath(rootPathParams);\n  }\n\n  protected async initialize(credentials?: TSecretStorageAuthorizazionOptions): Promise<void> {\n    await this.createStoreRootPath();\n    this.createStorages(credentials);\n  }\n\n  protected unsetInitializationPromise = (): void => {\n    this.initializationPromise = undefined;\n  };\n\n  protected createInitializationPromise(options: ISwarmStoreConnectorOrbitDBOptions<ItemType, DbType>): void {\n    this.initializationPromise = this.initialize(options.credentials).finally(this.unsetInitializationPromise);\n  }\n\n  /**\n   * create keystores for identity provider\n   * throw an error if not valid\n   *\n   * @private\n   * @param {(ISwarmStoreConnectorOrbitDBOptions<ItemType>)['credentials']} credentials\n   * @returns {void}\n   * @memberof SwarmStoreConnectorOrbitDB\n   * @throws Error\n   */\n  private createIdentityKeystores(credentials: TSecretStorageAuthorizazionOptions): void {\n    const { directory, userId } = this;\n    const identityKeystorePrefix = `${directory}/${userId}`;\n    const identityKeystore = this.createKeystore(credentials, identityKeystorePrefix);\n\n    if (identityKeystore instanceof Error) {\n      console.error(identityKeystore);\n      throw new Error('Failed on create identity keystore');\n    }\n    this.identityKeystore = identityKeystore;\n  }\n\n  private getOptionsForSwarmStoreConnectorOrbitDBSubclassStorageFabric(\n    credentials?: TSecretStorageAuthorizazionOptions\n  ): ISwarmStoreConnectorOrbitDbSubclassStorageFabricConstructorOptions {\n    const { rootPath } = this;\n\n    if (typeof rootPath !== 'string') {\n      throw new Error('createIdentityKeystores::rootPath must be a string');\n    }\n    return {\n      rootPath,\n      credentials,\n    };\n  }\n\n  /**\n   * create a Storage fabric which is\n   * used by the OrbitDB instance\n   * to generate Cache for a\n   * Keystore and various databases\n   * to read/write values from the\n   * local persistent Cache\n   *\n   * @private\n   * @param {(ISwarmStoreConnectorOrbitDBOptions<ItemType>)['credentials']} credentials\n   * @memberof SwarmStoreConnectorOrbitDB\n   * @throws\n   */\n  private createStorageFabric(credentials?: TSecretStorageAuthorizazionOptions): void {\n    const options = this.getOptionsForSwarmStoreConnectorOrbitDBSubclassStorageFabric(credentials);\n    this.storage = new SwarmStoreConnectorOrbitDBSubclassStorageFabric(options);\n  }\n\n  protected createKeystore(credentials: TSecretStorageAuthorizazionOptions, keystoreNamePrefix?: string): Keystore | Error {\n    const keystoreName = `${keystoreNamePrefix || ''}${SWARM_STORE_CONNECTOR_ORBITDB_KEYSTORE_DEFAULT_DBNAME}`;\n\n    if (!credentials) {\n      return this.emitError('createKeystore::A Credentials must be provided');\n    }\n    return new SwarmStorageConnectorOrbitDBSublassKeyStore({\n      credentials,\n      store: keystoreName,\n    }) as Keystore;\n  }\n\n  /**\n   * create identity for the user. If the userid\n   * is provided then the identity will be created\n   * by the value of the user id.\n   *\n   * @private\n   * @returns {(Promise<Error | void>)}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  private async createIdentity(): Promise<Error | void> {\n    const { userId } = this;\n\n    try {\n      const identity = await Identities.createIdentity({\n        type: SWARM_STORE_CONNECTOR_ORBITDB_IDENTITY_TYPE,\n        id: userId ? userId : undefined,\n        keystore: this.identityKeystore,\n      });\n\n      if (!userId) {\n        this.userId = identity.id;\n        console.warn(`The user id created automatically is ${userId}`);\n      }\n      if (identity instanceof Error) {\n        return identity;\n      }\n      this.identity = identity;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * return index of the options\n   * for a database name is exists\n   * in the main databases options\n   * (in this.options.databases)\n   * @protected\n   * @param {string} dbName\n   * @returns {number | -1}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected getIdxDbOptions(dbName: string): number {\n    const { options } = this;\n\n    if (options) {\n      const { databases } = options;\n\n      if (databases instanceof Array) {\n        return databases.findIndex((db) => !!db && typeof db === 'object' && db.dbName === dbName);\n      }\n    }\n    return -1;\n  }\n\n  protected unsetOptionsForDatabase(dbName: string) {\n    const { options } = this;\n\n    if (options) {\n      const { databases } = options;\n\n      if (databases instanceof Array) {\n        const idx = this.getIdxDbOptions(dbName);\n\n        databases.splice(idx, 1);\n      }\n    }\n  }\n\n  /**\n   * set the Database store options in\n   * the main options (this.options.databases)\n   * of all databases\n   * @protected\n   * @param {ISwarmStoreConnectorOrbitDbDatabaseOptions} dbOptions\n   * @param {boolean} [checkIfExists=false]\n   * @returns {(void | Error)}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  protected setDbOptions(\n    dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<ItemType, DbType>,\n    checkIfExists: boolean = false\n  ): void | Error {\n    if (!this.checkDbOptions(dbOptions)) {\n      return new Error('The database options have a wrong format');\n    }\n\n    if (checkIfExists) {\n      const { dbName } = dbOptions;\n      const idxExisting = this.getIdxDbOptions(dbName);\n\n      if (idxExisting !== -1) {\n        return new Error(`\n          Options for the database ${dbName} is already exists.\n          May be the database was opened but still not be in ready state\n        `);\n      }\n    }\n\n    const { options } = this;\n\n    if (!options) {\n      this.applyOptions({\n        ...this.options,\n        userId: '',\n        databases: [dbOptions],\n      } as ISwarmStoreConnectorOrbitDBOptions<ItemType, DbType>);\n      return;\n    }\n\n    const { databases } = options;\n\n    if (databases instanceof Array) {\n      const { dbName } = dbOptions;\n\n      this.unsetOptionsForDatabase(dbName);\n      databases.push(dbOptions);\n    } else {\n      options.databases = [dbOptions];\n    }\n  }\n\n  protected setDbOptionsIfNotExists(dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<ItemType, DbType>): void | Error {\n    return this.setDbOptions(dbOptions, true);\n  }\n\n  /**\n   *\n   *\n   * @private\n   * @param {SwarmStoreConnectorOrbitDBDatabase<ItemType>} database - db to close\n   * @param {boolean} [flEmit=true] - whether to emit an events during execution\n   * @returns {(Promise<Error | void>)}\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  private async closeDb(\n    database: ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>,\n    flEmit: boolean = true\n  ): Promise<Error | void> {\n    await this.unsetListenersDatabaseEvents(database);\n\n    const { dbName } = database;\n\n    this.unsetOptionsForDatabase(dbName);\n    this.deleteDatabaseFromList(database);\n\n    const closeDatabaseResult = await database.close();\n\n    if (closeDatabaseResult instanceof Error) {\n      if (flEmit) {\n        return this.emitError(closeDatabaseResult);\n      }\n      return closeDatabaseResult;\n    }\n    if (flEmit) {\n      this.emitDatabaseClose(database);\n    }\n  }\n\n  private setConnectionOptions(\n    connectionOptions: ISwarmStoreConnectorOrbitDBConnectionOptions<ItemType, DbType, DBO, ConnectorBasic>\n  ): void | Error {\n    if (!connectionOptions) {\n      return this.emitError('Connection options must be specified');\n    }\n\n    const { ipfs } = connectionOptions;\n\n    if (!ipfs) {\n      return this.emitError('An instance of ipfs must be specified in the connection options');\n    }\n    this.ipfs = ipfs;\n  }\n\n  private unsetSwarmConnectionOptions() {\n    this.ipfs = undefined;\n    this.connectionOptions = undefined;\n  }\n\n  private async disconnectFromSwarm(): Promise<Error | void> {\n    console.warn(`${SWARM_STORE_CONNECTOR_ORBITDB_LOG_PREFIX}::disconnectFromTheSwarm`);\n    this.unsetSwarmConnectionOptions();\n    this.setNotReady();\n  }\n\n  private async connectToSwarm(): Promise<Error | void> {\n    const { ipfs } = this;\n\n    if (!ipfs) {\n      return this.emitError('An instance of the IPFS must be specified');\n    }\n    try {\n      // wait when the ipfs will be ready to use\n      await Promise.race([ipfs.ready, timeout(SWARM_STORE_CONNECTOR_ORBITDB_CONNECTION_TIMEOUT_MS)]);\n    } catch (err) {\n      return this.emitError(err);\n    }\n  }\n\n  private async stopOrbitDBInsance(): Promise<Error | void> {\n    const { orbitDb } = this;\n\n    if (orbitDb) {\n      try {\n        await orbitDb.stop();\n        this.setNotReady();\n        this.orbitDb = undefined;\n      } catch (err) {\n        return this.emitError(err, 'stopOrbitDBInsance');\n      }\n    }\n  }\n\n  private async createOrbitDBInstance(): Promise<Error | void> {\n    const { ipfs, identity, storage } = this;\n\n    if (!ipfs) {\n      return this.emitError('An instance of IPFS must exists', 'createOrbitDBInstance');\n    }\n    try {\n      if (!OrbitDB) {\n        return this.emitError('A constructor of the OrbitDb is not provided');\n      }\n      if (!identity) {\n        return this.emitError('An identity must be specified');\n      }\n\n      const instanceOfOrbitDB = await OrbitDB.createInstance(ipfs, {\n        identity,\n        storage,\n      } as any); // TODO - correct typing must be specified\n\n      if (instanceOfOrbitDB instanceof Error) {\n        return this.emitError(instanceOfOrbitDB, 'createOrbitDBInstance::error has occurred in the \"createInstance\" method');\n      }\n      this.orbitDb = instanceOfOrbitDB;\n    } catch (err) {\n      return this.emitError(err, 'createOrbitDBInstance::failed to create the instance of OrbitDB');\n    }\n  }\n\n  protected getDbOptions(dbName: string): ISwarmStoreConnectorOrbitDbDatabaseOptions<ItemType, DbType> | void | Error {\n    const { options } = this;\n\n    if (!options) {\n      return this.emitError('An options is not specified for the database', `getDbOptions::${dbName}`);\n    }\n\n    const { databases } = options;\n\n    return databases.find((option) => option && option.dbName === dbName);\n  }\n\n  protected stop(): Promise<Error | void> {\n    this.setNotReady();\n    return this.closeDatabases();\n  }\n\n  /**\n   * open database and not check if an options are\n   * exists for the database (replace if exists)\n   * @private\n   * @param {ISwarmStoreConnectorOrbitDbDatabaseOptions} optionsForDb\n   * @returns\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  private openDatabaseNotCheckOptionsExists(\n    optionsForDb: ISwarmStoreConnectorOrbitDbDatabaseOptions<ItemType, DbType>\n  ): Promise<void | Error> {\n    return this.openDatabase(optionsForDb, 0, false);\n  }\n\n  private async restartDbConnection(\n    dbName: string,\n    database: ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>\n  ): Promise<void | Error> {\n    //try to restart the database\n    const optionsForDb = this.getDbOptions(dbName);\n\n    await this.unsetListenersDatabaseEvents(database);\n    if (optionsForDb instanceof Error || !optionsForDb) {\n      this.emitError('Failed to get options to open a new db store', `restartDbConnection::${dbName}`);\n      return this.stop();\n    }\n\n    const startDbResult = await this.openDatabaseNotCheckOptionsExists(optionsForDb);\n\n    if (startDbResult instanceof Error) {\n      this.emitError('Failed to open a new db store', `restartDbConnection::${dbName}`);\n      return this.stop();\n    }\n  }\n\n  protected removeDbFromList(database: ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>) {\n    if (this.databases instanceof Array) {\n      commonUtilsArrayDeleteFromArray(this.databases, database);\n    }\n  }\n\n  private handleDatabaseStoreClosed = async (\n    database: ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>,\n    error: Error\n  ) => {\n    if (database) {\n      const { dbName } = database;\n\n      this.emitError(`Database closed unexpected: ${error.message}`, `handleDatabaseStoreClosed::${dbName}`);\n      await this.handleDbClose(database);\n      await this.restartDbConnection(dbName, database);\n    }\n  };\n\n  private handleLoadingProgress = (dbName: string, progress: number): void => {\n    /* \n            databases - is a list of the databases opened already\n            it means that the loading progress for this databases\n            is 100%\n        */\n    const { databases, options } = this;\n    let currentProgressInPercent = 0;\n\n    if (options) {\n      /* \n                overallDatabases - is a list of all databases\n                which are must be opened\n            */\n      const { databases: overallDatabases } = options;\n      // the progress which will be reached\n      // on all the databases will be opened\n      const overallProgressToReach = overallDatabases.length * 100;\n      // progress reached at this time\n      const currentProgress = (databases ? databases.length : 0) * 100 + progress;\n      // the progress reached at this time in a percentage\n      currentProgressInPercent = currentProgress ? (overallProgressToReach / currentProgress) * 100 : 0;\n    }\n    console.log(`Swarm store connector::handleLoadingProgress::${dbName}::progress::${progress}`);\n    this.emit(ESwarmStoreEventNames.LOADING, currentProgressInPercent);\n    this.emit(ESwarmStoreEventNames.DB_LOADING, [dbName, progress]);\n  };\n\n  private handleDatabaseUpdated = (dbName: string) => {\n    this.emit(ESwarmStoreEventNames.UPDATE, dbName);\n  };\n\n  /**\n   * write\n   * db.events.on('write', (address, entry, heads) => ... )\n   * Emitted after an entry was added locally to the database. hash is the IPFS hash of the latest state of the database.\n   * entry is the added database op.\n   *\n   * @private\n   * @memberof SwarmStoreConnectorOrbitDB\n   */\n  private handleNewEntryAddedToDatabase = ([dbName, entry, address, heads, dbType]: [\n    string,\n    LogEntry<ItemType>,\n    string,\n    any,\n    ESwarmStoreConnectorOrbitDbDatabaseType\n  ]) => {\n    // TODO - FOR KEY VALUE STOE. If added two different values for the same key,\n    // then two messages related to this values will be emitted anyway\n    // not just one, which is the latest one, but both messages.\n    // Both two messages will be emitted after the instance was preloaded\n    console.log(`SwarmStoreConnectorOrbitDB::handleNewEntryAddedToDatabase:emit NEW_ENTRY`, {\n      dbName,\n      entry,\n      address,\n      heads,\n    });\n    this.emit(ESwarmStoreEventNames.NEW_ENTRY, [dbName, entry, address, heads, dbType]);\n  };\n\n  private async setListenersDatabaseEvents(\n    database: ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>,\n    isSet: boolean = true\n  ): Promise<Error | void> {\n    const methodName = isSet ? COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_ON : COMMON_VALUE_EVENT_EMITTER_METHOD_NAME_OFF;\n\n    if (isSet) {\n      const dbCloseHandler = (err: Error) => {\n        void this.handleDatabaseStoreClosed(database, err);\n      };\n\n      database[methodName](ESwarmStoreEventNames.CLOSE, dbCloseHandler);\n      database[methodName](ESwarmStoreEventNames.FATAL, dbCloseHandler);\n      this.dbCloseListeners.push(dbCloseHandler);\n    } else {\n      this.dbCloseListeners.forEach((dbCloseHandler) => {\n        database[methodName](ESwarmStoreEventNames.CLOSE, dbCloseHandler);\n        database[methodName](ESwarmStoreEventNames.FATAL, dbCloseHandler);\n      });\n    }\n    database[methodName](ESwarmStoreEventNames.LOADING, this.handleLoadingProgress);\n    database[methodName](ESwarmStoreEventNames.UPDATE, this.handleDatabaseUpdated);\n    database[methodName](ESwarmStoreEventNames.NEW_ENTRY, this.handleNewEntryAddedToDatabase);\n  }\n\n  private async unsetListenersDatabaseEvents(\n    database: ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>\n  ): Promise<Error | void> {\n    await this.setListenersDatabaseEvents(database, false);\n  }\n\n  private async closeDatabases(): Promise<Error | void> {\n    const { databases } = this;\n\n    // set that the orbit db is not ready to use\n    this.setNotReady();\n    if (!databases || !databases.length) {\n      return;\n    }\n\n    try {\n      let idx = 0;\n      const databasesToClose = [...databases];\n      const len = databasesToClose.length;\n\n      for (; idx < len; idx += 1) {\n        const db = databasesToClose[idx];\n        const dbCloseResult = await this.closeDb(db);\n\n        if (dbCloseResult instanceof Error) {\n          console.error(this.emitError(dbCloseResult));\n          this.emitError('An error has occurred on closing the database', 'closeDatabases');\n        }\n      }\n      this.databases = [];\n    } catch (err) {\n      return err;\n    }\n  }\n\n  private waitDatabaseOpened(\n    database: ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>\n  ): Promise<Error | boolean> {\n    return new Promise<Error | boolean>(async (res) => {\n      let timeout: NodeJS.Timer | undefined = undefined;\n\n      function usetListeners() {\n        database.removeListener(ESwarmStoreEventNames.READY, res);\n        database.removeListener(ESwarmStoreEventNames.CLOSE, res);\n        database.removeListener(ESwarmStoreEventNames.FATAL, res);\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        timeout = undefined;\n      }\n\n      timeout = setTimeout(async () => {\n        usetListeners();\n        res(new Error('Failed to open the database cause the timeout has reached'));\n      }, SWARM_STORE_CONNECTOR_ORBITDB_DATABASE_CONNECTION_TIMEOUT_MS);\n      try {\n        database.once(ESwarmStoreEventNames.CLOSE, () => {\n          usetListeners();\n          res(new Error('Database was closed'));\n        });\n        database.once(ESwarmStoreEventNames.FATAL, () => {\n          usetListeners();\n          res(new Error('A fatal error has occurred while open the database'));\n        });\n        database.once(ESwarmStoreEventNames.READY, () => {\n          usetListeners();\n          console.log('dbReady', database.dbName);\n          res(true);\n        });\n\n        //connect to the database\n        // and wait for an events from it\n        const connectResult = await database.connect();\n\n        if (connectResult instanceof Error) {\n          usetListeners();\n          console.error(connectResult);\n          return this.emitError('The database.connect method was failed');\n        }\n      } catch (err) {\n        console.error(err);\n        usetListeners();\n        res(err);\n      }\n    });\n  }\n\n  private async openDatabases(): Promise<Error | void> {\n    const { options } = this;\n\n    if (!options) {\n      return this.emitError('The options must be specified to open the databases');\n    }\n\n    const { databases } = options;\n    const databasesOptions = [...databases];\n\n    if (!(databasesOptions instanceof Array)) {\n      return this.emitError('The options for databases must be specified');\n    }\n    if (!databasesOptions.length) {\n      return;\n    }\n    try {\n      let idx = 0;\n      const len = databasesOptions.length;\n\n      for (; idx < len; idx += 1) {\n        const options = databasesOptions[idx];\n        const startResultStatus = await this.openDatabaseNotCheckOptionsExists(options);\n\n        if (startResultStatus instanceof Error) {\n          console.error(startResultStatus);\n          await this.closeDatabases();\n          return new Error('Failed to open the database');\n        }\n      }\n    } catch (err) {\n      await this.closeDatabases();\n      return this.emitError(err);\n    }\n  }\n\n  protected async extendDatabaseOptionsWithCache(\n    dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<ItemType, DbType>,\n    dbName: string\n  ): Promise<ISwarmStoreConnectorOrbitDbDatabaseOptions<ItemType, DbType>> {\n    const { storage } = this;\n\n    if (!storage) {\n      throw new Error('Storage is not exists in the connector');\n    }\n    return {\n      ...dbOptions,\n      cache: await storage.createStoreForDb(dbName),\n    };\n  }\n\n  protected async createDatabaseConnectorImplementation(\n    dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<ItemType, DbType>,\n    dbName: string,\n    orbitDb: OrbitDB\n  ): Promise<ConnectorBasic> {\n    const optionsWithCachestore = await this.extendDatabaseOptionsWithCache(dbOptions, dbName);\n    const { _connectorBasicFabric: _connectorFabric } = this;\n\n    if (!_connectorFabric) {\n      throw new Error('Connector to the swarm storage is not defined');\n    }\n    return _connectorFabric(optionsWithCachestore, orbitDb);\n  }\n\n  protected async addDatabaseNameToListOfUsingSecretStorage(dbName: string): Promise<void> {\n    if (!this.storage) {\n      throw new Error('There is no storage instance');\n    }\n\n    // Add the database name in the Storage fabric\n    // as the enctypted db. The storage fabric\n    // will create the encrypted storage\n    // for this database\n    await this.storage.addSecretDatabaseName(dbName);\n  }\n\n  protected _setConnectorBasicFabric(\n    connectionOptions: ISwarmStoreConnectorOrbitDBConnectionOptions<ItemType, DbType, DBO, ConnectorBasic>\n  ): void {\n    const { connectorBasicFabric: connectorFabric } = connectionOptions;\n    assert(connectorFabric, 'Basic connector for OrbitDb must be defined in the options');\n    this._connectorBasicFabric = connectorFabric;\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types.ts",["3225"],"import { IPFS } from 'types/ipfs.types';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseOptions,\n  TSwarmStoreConnectorOrbitDbDatabaseEntityIndex,\n} from './swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport {\n  ISwarmStoreConnectorBasic,\n  ISwarmStoreEvents,\n  ISwarmStoreMainOptions,\n  TSwarmStoreDatabaseOptions,\n  TSwarmStoreDatabaseType,\n  TSwarmStoreValueTypes,\n} from '../../swarm-store-class.types';\nimport { ESwarmStoreConnector } from '../../swarm-store-class.const';\nimport OrbitDB from 'orbit-db';\n\nexport interface ISwarmStoreConnectorOrbitDBEvents<\n  P extends ESwarmStoreConnector.OrbitDB,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>\n> extends ISwarmStoreEvents<P, ItemType, DbType, DBO> {}\n\n/**\n * directory - this string will be used as a\n * part of keynames for all storages and databases.\n * If the credentials property does not specified\n * then the local secret storage will not be used\n * and all data will be stored in the default,\n * not safe, storages of the OrbitDB.\n *\n * @export\n * @interface ISwarmStoreConnectorOrbitDBOptions\n * @template TFeedStoreTypes\n */\nexport interface ISwarmStoreConnectorOrbitDBOptions<\n  ItemType extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>,\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>\n> extends ISwarmStoreMainOptions<ESwarmStoreConnector.OrbitDB, ItemType, DbType> {\n  // databases which must be started when the orbit db\n  // instance will be ready to use\n  databases: ISwarmStoreConnectorOrbitDbDatabaseOptions<ItemType, DbType>[];\n}\n\nexport interface ISwarmStoreConnectorOrbitDbConnecectionBasicFabric<\n  T extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>,\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>,\n  DBO extends TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, T, DbType, DBO>\n> {\n  (dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<T, DbType>, orbitDb: OrbitDB): ConnectorBasic;\n}\n\nexport interface ISwarmStoreConnectorOrbitDBSpecificConnectionOptions {\n  ipfs: IPFS; // instance of IPFS connection\n}\n\nexport interface ISwarmStoreConnectorOrbitDBConnectionOptions<\n  T extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>,\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>,\n  DBO extends TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, T, DbType, DBO>\n> extends ISwarmStoreConnectorOrbitDBSpecificConnectionOptions {\n  connectorBasicFabric: ISwarmStoreConnectorOrbitDbConnecectionBasicFabric<T, DbType, DBO, ConnectorBasic>;\n}\n\nexport interface ISwarmStoreConnectorOrbitDBLogEntity<T> {\n  op?: string;\n  key?: string;\n  value: T;\n}\n\nexport type TSwarmStoreConnectorOrbitDBEnityKey = TSwarmStoreConnectorOrbitDbDatabaseEntityIndex;\n\nexport enum ESwarmStoreConnectorOrbitDbDatabaseMethodNames {\n  'get' = 'get',\n  'add' = 'add',\n  'remove' = 'remove',\n  'iterator' = 'iterator',\n  'close' = 'close',\n  'load' = 'load',\n}\n","/home/paul/projects/protocol/src/components/app-render.tsx",[],"/home/paul/projects/protocol/src/components/app.tsx",["3226","3227","3228","3229"],"import React from 'react';\nimport { FileStoreAddFile } from 'components/filestore-add-file/filestore-add-file';\nimport { ConnectToSwarm } from 'components/connect-to-swarm';\nimport { SensitiveDataStorage } from 'components/sensitive-data-storage';\nimport { ConnectToSwarmImmediate } from './connect-to-swarm-immediate/connect-to-swarm-immediate';\nimport { CONNECT_TO_SWARM_IMMEDIATE_DATABASE_OPTIONS_KEY_VALUE } from './const/connect-to-swarm-immediate.const';\nimport { CONNECTO_TO_SWARM_OPTIONS_SWARM_MESSAGES_DATABASE_CACHE_OPTIONS } from './const/connect-to-swarm.const';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport {\n  TSwarmMessageSerialized,\n  TSwarmMessageInstance,\n  ISwarmMessageInstanceDecrypted,\n} from '../classes/swarm-message/swarm-message-constructor.types';\nimport {\n  CONNECT_TO_SWARM_CONNECTION_OPTIONS,\n  CONNECT_TO_SWARM_AUTH_CREDENTIALS_USEDID_2,\n  CONNECT_TO_SWARM_AUTH_CREDENTIALS_1,\n} from './const/connect-to-swarm.const';\n\nexport class App extends React.Component {\n  render() {\n    // return <FileStoreAddFile />;\n    // return <SensitiveDataStorage />;\n    // return <ConnectToSwarm />;\n    return (\n      <ConnectToSwarmImmediate<\n        ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE | ESwarmStoreConnectorOrbitDbDatabaseType.FEED,\n        TSwarmMessageSerialized,\n        typeof CONNECT_TO_SWARM_IMMEDIATE_DATABASE_OPTIONS_KEY_VALUE,\n        typeof CONNECT_TO_SWARM_CONNECTION_OPTIONS,\n        TSwarmMessageInstance,\n        ISwarmMessageInstanceDecrypted\n      >\n        dbOptions={CONNECT_TO_SWARM_IMMEDIATE_DATABASE_OPTIONS_KEY_VALUE}\n        connectionBridgeOptions={CONNECT_TO_SWARM_CONNECTION_OPTIONS}\n        userCredentials={CONNECT_TO_SWARM_AUTH_CREDENTIALS_1}\n        userIdReceiverSwarmMessages={CONNECT_TO_SWARM_AUTH_CREDENTIALS_USEDID_2}\n        swarmMessagesDatabaseCacheOptions={CONNECTO_TO_SWARM_OPTIONS_SWARM_MESSAGES_DATABASE_CACHE_OPTIONS}\n      />\n    );\n  }\n}\n\nexport default App;\n","/home/paul/projects/protocol/src/components/connect-to-swarm/connect-to-swarm.tsx",["3230","3231","3232","3233","3234","3235","3236","3237","3238","3239","3240","3241","3242","3243","3244","3245","3246","3247","3248","3249","3250","3251","3252","3253","3254","3255","3256","3257","3258","3259","3260","3261","3262","3263","3264","3265","3266","3267"],"import React from 'react';\nimport { connectToSwarmUtil } from './connect-to-swarm.utils';\nimport { CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY } from '../const/connect-to-swarm.const';\nimport { CONNECT_TO_SWARM_AUTH_CREDENTIALS_SESSION_STORAGE_KEY } from '../const/connect-to-swarm.const';\nimport {\n  ESwarmStoreConnectorOrbitDbDatabaseMethodNames,\n  ISwarmStoreDatabasesCommonStatusList,\n  ESwarmStoreEventNames,\n} from 'classes';\nimport { SwarmStoreDbComponent } from '../swarm-store-db-component/swarm-store-db-component';\nimport { ESwarmMessageStoreEventNames } from '../../classes/swarm-message-store/swarm-message-store.const';\nimport { ESwarmStoreConnector } from '../../classes/swarm-store-class/swarm-store-class.const';\nimport {\n  TSwarmMessageInstance,\n  TSwarmMessageSerialized,\n  ISwarmMessageInstanceEncrypted,\n} from '../../classes/swarm-message/swarm-message-constructor.types';\nimport { ISwarmMessageInstanceDecrypted } from '../../classes/swarm-message/swarm-message-constructor.types';\nimport { ISecretStorage } from '../../classes/secret-storage-class/secret-storage-class.types';\nimport { ICentralAuthorityUserProfile } from '../../classes/central-authority-class/central-authority-class-types/central-authority-class-types-common';\nimport { UserProfile } from '../userProfile/userProfile';\nimport { TSwarmStoreDatabaseType, TSwarmStoreDatabaseOptions } from '../../classes/swarm-store-class/swarm-store-class.types';\nimport { SwarmMessagesDatabaseComponent } from '../swarm-messages-database-component/swarm-messages-database-component';\nimport { IPromiseResolveType } from '../../types/promise.types';\nimport {\n  IConnectionBridgeOptionsDefault,\n  IConnectionBridgeUnknown,\n} from '../../classes/connection-bridge/connection-bridge.types';\nimport { TSwarmStoreDatabaseEntityKey } from '../../classes/swarm-store-class/swarm-store-class.types';\nimport { swarmMessagesDatabaseConnectedFabric } from '../../classes/swarm-messages-database/swarm-messages-database-fabric/swarm-messages-database-fabric';\nimport { ISwarmMessagesDatabaseConnectedFabric } from '../../classes/swarm-messages-database/swarm-messages-database-fabric/swarm-messages-database-fabric.types';\nimport { IUserCredentialsCommon } from '../../types/credentials.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../../classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions } from '../../classes/swarm-messages-database/swarm-messages-database.types';\n\ntype P = ESwarmStoreConnector.OrbitDB;\n\nexport interface IMessageDescription<P extends ESwarmStoreConnector> {\n  id: string;\n  key?: TSwarmStoreDatabaseEntityKey<P>;\n  message: ISwarmMessageInstanceDecrypted;\n}\n\nexport interface IConnectToSwarmProps<\n  DbType extends TSwarmStoreDatabaseType<P>,\n  T extends TSwarmMessageSerialized,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  CBO extends IConnectionBridgeOptionsDefault<P, T, DbType, any>,\n  MD extends ISwarmMessageInstanceDecrypted\n> {\n  connectionBridgeOptions: CBO;\n  userCredentialsList: Array<IUserCredentialsCommon>;\n  dbo: DBO;\n  userIdReceiverSwarmMessages: TSwarmMessageUserIdentifierSerialized;\n  swarmMessagesDatabaseCacheOptions: ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions<P, T, DbType, DBO, MD>;\n  userCredentialsToConnectImmediate?: IUserCredentialsCommon;\n}\n\nexport class ConnectToSwarm<\n  DbType extends TSwarmStoreDatabaseType<P>,\n  T extends TSwarmMessageSerialized,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  CBO extends IConnectionBridgeOptionsDefault<P, T, DbType, any>,\n  MI extends TSwarmMessageInstance = TSwarmMessageInstance,\n  MD extends ISwarmMessageInstanceDecrypted = Exclude<MI, ISwarmMessageInstanceEncrypted>\n> extends React.PureComponent<IConnectToSwarmProps<DbType, T, DBO, CBO, MD>> {\n  public state = {\n    isConnecting: false,\n    messagingSending: undefined as NodeJS.Timeout | undefined,\n    error: undefined as Error | undefined,\n    connectionBridge: undefined as IConnectionBridgeUnknown<P, T, DbType, any, DBO, MI | T> | undefined,\n    userId: undefined as string | undefined,\n    // was the database main removed by the user\n    dbRemoved: false,\n    dbRemoving: false,\n    messages: [] as any[],\n    messagesReceived: new Map() as Map<string, Map<string, IMessageDescription<P>>>,\n    databasesList: undefined as ISwarmStoreDatabasesCommonStatusList<P, T, DbType, DBO> | undefined,\n    swarmStoreMessagesDbOptionsList: [] as DBO[],\n    databaseOpeningStatus: false as boolean,\n    secretStorage: undefined as undefined | ISecretStorage,\n    userProfileData: undefined as undefined | Partial<ICentralAuthorityUserProfile>,\n    userCredentialsActive: undefined as IUserCredentialsCommon | undefined,\n  };\n\n  protected get defaultDbOptions(): DBO {\n    const { dbo } = this.props;\n\n    if (!dbo) {\n      throw new Error('Ther is no options passed in the props');\n    }\n    return dbo;\n  }\n\n  protected get swarmMessageStore(): Required<IConnectionBridgeUnknown<P, T, DbType, any, DBO>>['swarmMessageStore'] {\n    const { connectionBridge } = this.state;\n\n    if (!connectionBridge) {\n      throw new Error('There is no connection to the connection bridge instance');\n    }\n\n    const { swarmMessageStore } = connectionBridge;\n\n    if (!swarmMessageStore) {\n      throw new Error('There is no connection to a swarm message stor');\n    }\n    return swarmMessageStore;\n  }\n\n  protected get mainDatabaseOptions(): DBO {\n    if (!this.props.dbo) {\n      throw new Error('The main database options are not defined in the props');\n    }\n    return this.props.dbo;\n  }\n\n  protected get mainDatabaseName(): string {\n    return this.mainDatabaseOptions.dbName;\n  }\n\n  protected sendSwarmMessage = async () => {\n    throw new Error('sendSwarmMessage is not implemented yet');\n    // try {\n    //   const key = 'test_message';\n    //   await this.swarmMessageStoreOrUndefined?.addMessage(\n    //     this.props.dboMain.dbName,\n    //     {\n    //       ...CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY,\n    //     },\n    //     key\n    //   );\n    // } catch (err) {\n    //   console.error(err);\n    // }\n  };\n\n  protected sendPrivateSwarmMessage = async () => {\n    try {\n      await this.swarmMessageStore?.addMessage(this.mainDatabaseName, {\n        ...CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY,\n        receiverId: this.props.userIdReceiverSwarmMessages,\n      });\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\n  protected toggleMessagesSending = (isPrivate: boolean = false) => {\n    this.setState((state: any) => {\n      if (state.messagingSending) {\n        clearInterval(state.messagingSending);\n        return {\n          messagingSending: undefined,\n        };\n      }\n\n      const method = isPrivate ? this.sendPrivateSwarmMessage : this.sendSwarmMessage;\n\n      void method();\n      return {\n        messagingSending: setInterval(method, 1000),\n      };\n    });\n  };\n\n  public handleDatabaseRemove = async () => {\n    const { swarmMessageStore: swarmMessageStoreOrUndefined } = this;\n\n    if (swarmMessageStoreOrUndefined) {\n      this.setState({\n        dbRemoving: true,\n      });\n      await swarmMessageStoreOrUndefined.dropDatabase(this.mainDatabaseName);\n      this.setState({\n        dbRemoved: true,\n        dbRemoving: false,\n      });\n    }\n  };\n\n  protected renderConnectToDatabase() {\n    return (\n      <div>\n        <h2>Database connection</h2>\n        <button onClick={this.handleDatabaseRemove}>Remove the database</button>\n      </div>\n    );\n  }\n\n  public connectToDb = async () => {\n    const { swarmMessageStore: swarmMessageStoreOrUndefined } = this;\n\n    if (swarmMessageStoreOrUndefined) {\n      await swarmMessageStoreOrUndefined.openDatabase(this.mainDatabaseOptions);\n      this.setState({\n        dbRemoved: false,\n      });\n    }\n  };\n\n  public loadNextMessages = async () => {\n    const { swarmMessageStore: swarmMessageStoreOrUndefined } = this;\n\n    if (swarmMessageStoreOrUndefined) {\n      const result = await swarmMessageStoreOrUndefined.request(\n        this.mainDatabaseName,\n        ESwarmStoreConnectorOrbitDbDatabaseMethodNames.load,\n        10\n      );\n      console.log(result);\n    }\n  };\n\n  public renderLoadMessages() {\n    return (\n      <div>\n        <button onClick={this.loadNextMessages}>Load next 10 messages</button>\n      </div>\n    );\n  }\n  public renderConnectedState() {\n    const { messagingSending, userId, dbRemoved, dbRemoving } = this.state;\n\n    if (dbRemoved) {\n      return <div onClick={this.connectToDb}>Connect to database</div>;\n    }\n    if (dbRemoving) {\n      return <span>Database removing...</span>;\n    }\n    return (\n      <div>\n        <div>Is connected with user identity ${userId}</div>\n        <button onClick={() => this.toggleMessagesSending()}>{messagingSending ? 'Stop' : 'Start'} messages sending</button>\n        <button onClick={() => this.toggleMessagesSending(true)}>\n          {messagingSending ? 'Stop' : 'Start'} private messages sending\n        </button>\n        {this.renderUserProfile()}\n        {this.renderDatabasesList()}\n        {this.renderSwarmMessagesDatabasesList()}\n        {this.renderConnectToDatabase()}\n        {this.renderLoadMessages()}\n      </div>\n    );\n  }\n\n  public componentDidMount() {\n    const { userCredentialsToConnectImmediate } = this.props;\n    if (userCredentialsToConnectImmediate) {\n      void this.connectToSwarm(userCredentialsToConnectImmediate);\n    }\n  }\n\n  public render() {\n    const { connectionBridge, isConnecting, error } = this.state;\n\n    if (error) {\n      return <span>Error: {error.message}</span>;\n    }\n    if (connectionBridge) {\n      return this.renderConnectedState();\n    }\n    if (!connectionBridge && !isConnecting) {\n      return (\n        <div>\n          {this.props.userCredentialsList.map((credentials) => (\n            <button key={credentials.login} onClick={() => this.connectToSwarm(credentials)}>\n              Connect cred {credentials.login}\n            </button>\n          ))}\n        </div>\n      );\n    }\n    return <span>Connecting...</span>;\n  }\n\n  protected handleDatabasesListUpdate = (\n    databasesList: ISwarmStoreDatabasesCommonStatusList<P, T, DbType, TSwarmStoreDatabaseOptions<P, T, DbType>>\n  ) => {\n    this.setState({\n      databasesList: { ...databasesList },\n    });\n  };\n\n  protected handleMessage = (dbName: DBO['dbName'], message: MI, id: string, key: string) => {\n    const { messagesReceived } = this.state;\n    const messagesMap = messagesReceived.get(dbName) || new Map();\n    // TODO - to get all of actual values for KV-store it is necessary\n    // to iterate overall database. Cause for a KV store implemented\n    // by the OrbitDB only the \"db.all\" method returns all keys, so\n    // in this implementation only thught the iterate method of a db\n    // this is able to iterate over all items(db.all)\n\n    if (!messagesMap.get(id)) {\n      messagesMap.set(id, {\n        message,\n        id,\n        key,\n      });\n      messagesReceived.set(dbName, messagesMap);\n      this.forceUpdate();\n    }\n  };\n\n  protected setListenersConnectionBridge(connectionBridge: IPromiseResolveType<ReturnType<typeof connectToSwarmUtil>>) {\n    const { swarmMessageStore } = connectionBridge;\n\n    if (!swarmMessageStore) {\n      throw new Error('Swarm message store insatnce is not exists in the connection bridge instance');\n    }\n    swarmMessageStore.addListener(ESwarmStoreEventNames.DATABASES_LIST_UPDATED, this.handleDatabasesListUpdate);\n    swarmMessageStore.addListener(ESwarmMessageStoreEventNames.NEW_MESSAGE, this.handleMessage);\n  }\n\n  protected connectToSwarm = async (credentials: IUserCredentialsCommon) => {\n    if (!credentials) {\n      throw new Error('Credentials should be defined to connect to swarm');\n    }\n\n    this.setState({\n      isConnecting: true,\n      userCredentialsActive: credentials,\n    });\n    try {\n      const connectionBridge = await connectToSwarmUtil<P, DbType, T>(this.props.connectionBridgeOptions, credentials);\n\n      sessionStorage.setItem(CONNECT_TO_SWARM_AUTH_CREDENTIALS_SESSION_STORAGE_KEY, 'true');\n\n      const userId = connectionBridge?.centralAuthorityConnection?.getUserIdentity();\n      const userProfileData = await connectionBridge?.centralAuthorityConnection?.getCAUserProfile();\n\n      this.setState({\n        connectionBridge,\n        userId,\n        databasesList: connectionBridge.swarmMessageStore?.databases,\n        secretStorage: connectionBridge.secretStorage,\n        userProfileData,\n      });\n      this.setListenersConnectionBridge(\n        (connectionBridge as unknown) as IPromiseResolveType<ReturnType<typeof connectToSwarmUtil>>\n      );\n\n      const { dbo } = this.props;\n\n      if (!dbo) {\n        throw new Error('Database options shoul be defined to connect with it');\n      }\n      await this.handleOpenNewSwarmStoreMessagesDatabase(dbo);\n    } catch (error) {\n      this.setState({\n        error,\n      });\n    }\n  };\n\n  public handleOpenDatabase = async (dbName?: string) => {\n    try {\n      this.setState({\n        databaseOpeningStatus: true,\n      });\n      await this.swarmMessageStore?.openDatabase({\n        ...this.defaultDbOptions,\n        dbName: dbName || this.defaultDbOptions.dbName,\n      });\n    } catch (err) {\n      console.error(err);\n    } finally {\n      this.setState({\n        databaseOpeningStatus: false,\n      });\n    }\n  };\n\n  public handleClickOpenNewSwarmStoreMessagesDatabase = async () => {\n    await this.handleOpenNewSwarmStoreMessagesDatabase();\n  };\n\n  public handleOpenNewDatabase = async () => {\n    const dbName = window.prompt('Enter database name', '');\n\n    if (dbName) {\n      await this.handleOpenDatabase(dbName);\n    }\n  };\n\n  protected handleOpenNewSwarmStoreMessagesDatabase = async (dbOptionsToConnectImmediate?: Partial<DBO>) => {\n    const dbNameToOpen = dbOptionsToConnectImmediate?.dbName;\n    const dbName = dbNameToOpen || window.prompt('Enter database name', '');\n\n    if (dbName) {\n      const dbOptions = {\n        ...this.defaultDbOptions,\n        ...dbOptionsToConnectImmediate,\n        dbName: dbName || this.defaultDbOptions.dbName,\n      };\n      this.setState(({ swarmStoreMessagesDbOptionsList }: any) => ({\n        swarmStoreMessagesDbOptionsList: [...swarmStoreMessagesDbOptionsList, dbOptions],\n      }));\n    }\n  };\n\n  protected renderUserProfile() {\n    const { userId, userProfileData } = this.state;\n    return <UserProfile id={userId} profile={userProfileData} />;\n  }\n\n  protected renderDatabasesList() {\n    const { databasesList, connectionBridge, databaseOpeningStatus } = this.state;\n    const dbsOptions = databasesList?.options;\n    const isDefaultDatabaseWasOpenedBeforeOrOpening =\n      !databaseOpeningStatus && !dbsOptions?.[this.defaultDbOptions.dbName as DBO['dbName']];\n\n    return (\n      <div>\n        <div>\n          <h4>List of databases:</h4>\n          {!!databasesList &&\n            !!dbsOptions &&\n            Object.keys(dbsOptions).map((databaseName) => {\n              const databaseOptions = dbsOptions[databaseName as DBO['dbName']];\n              const isOpened = databasesList.opened[databaseName];\n              const dbMessages = this.state.messagesReceived.get(databaseName);\n\n              return (\n                <SwarmStoreDbComponent<P, T, DbType, DBO>\n                  key={databaseName}\n                  databaseOptions={databaseOptions}\n                  isOpened={isOpened}\n                  connectionBridge={connectionBridge}\n                  messages={Array.from(dbMessages?.values() || [])}\n                />\n              );\n            })}\n        </div>\n        {!!isDefaultDatabaseWasOpenedBeforeOrOpening ? (\n          <button onClick={() => this.handleOpenDatabase()}>Open default database</button>\n        ) : (\n          <button onClick={this.handleOpenNewDatabase}>Open new database</button>\n        )}\n      </div>\n    );\n  }\n\n  protected getSwarmMessagesDatabaseConnectedFabric(): ISwarmMessagesDatabaseConnectedFabric<P, T, DbType, DBO, MI | T, any, MD> {\n    return swarmMessagesDatabaseConnectedFabric as ISwarmMessagesDatabaseConnectedFabric<P, T, DbType, DBO, MI | T, any, MD>;\n  }\n\n  protected renderSwarmMessagesDatabasesList() {\n    const { swarmStoreMessagesDbOptionsList, connectionBridge } = this.state;\n    const { dbo, swarmMessagesDatabaseCacheOptions } = this.props;\n\n    if (!connectionBridge) {\n      throw new Error('Connection bridge should be defined');\n    }\n    return (\n      <div>\n        <div>\n          <h4>List of swarm messages databases:</h4>\n          {swarmStoreMessagesDbOptionsList.map((dbsOptions) => {\n            const { userId } = this.state;\n            if (!userId) {\n              throw new Error('User identity should not be empty');\n            }\n            return (\n              <SwarmMessagesDatabaseComponent<\n                T,\n                DbType,\n                IConnectionBridgeUnknown<P, T, DbType, any, DBO, MI | T>,\n                DBO,\n                MI | T,\n                MD\n              >\n                key={dbsOptions.dbName}\n                userId={userId}\n                databaseOptions={dbsOptions}\n                connectionBridge={connectionBridge}\n                isOpenImmediate={dbsOptions.dbName === dbo?.dbName}\n                swarmMessagesDatabaseConnectedFabric={this.getSwarmMessagesDatabaseConnectedFabric()}\n                swarmMessagesDatabaseCacheOptions={swarmMessagesDatabaseCacheOptions}\n              />\n            );\n          })}\n        </div>\n        <button onClick={this.handleClickOpenNewSwarmStoreMessagesDatabase}>Open new swarm store database</button>\n      </div>\n    );\n  }\n}\n","/home/paul/projects/protocol/src/components/connect-to-swarm/connect-to-swarm.utils.ts",["3268"],"import { createConnectrionBridgeConnection } from '../../classes/connection-bridge/connection-bridge-fabric/connection-bridge-fabric';\nimport { ESwarmStoreConnector } from '../../classes/swarm-store-class/swarm-store-class.const';\nimport { TSwarmStoreDatabaseType } from '../../classes/swarm-store-class/swarm-store-class.types';\nimport {\n  TConnectionBridgeOptionsAuthCredentials,\n  IConnectionBridgeOptionsDefault,\n} from '../../classes/connection-bridge/connection-bridge.types';\nimport { TSwarmMessageSerialized } from '../../classes/swarm-message/swarm-message-constructor.types';\n\nexport async function connectToSwarmUtil<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  T extends TSwarmMessageSerialized,\n  CD extends boolean = false\n>(options: IConnectionBridgeOptionsDefault<P, T, DbType, CD>, credentials: TConnectionBridgeOptionsAuthCredentials) {\n  const optionsWithCredentials = {\n    ...options,\n    auth: {\n      ...options.auth,\n      credentials,\n    },\n  } as IConnectionBridgeOptionsDefault<P, T, DbType, true>;\n  const connectionBridgeInstance = await createConnectrionBridgeConnection<P, T, DbType, true>(optionsWithCredentials, true);\n\n  return connectionBridgeInstance;\n}\n","/home/paul/projects/protocol/src/components/connect-to-swarm/index.ts",[],"/home/paul/projects/protocol/src/components/filestore-add-file/filestore-add-file.tsx",["3269","3270","3271","3272","3273","3274","3275","3276","3277"],"import React, { MouseEvent } from 'react';\nimport { downloadFile } from '../../utils/files-utils/files-utils-download';\nimport { IFileStorage } from '../../classes/filestorage-class/filestorage-class.types';\nimport { FILE_STORAGE_SERVICE_TYPE } from '../../classes/filestorage-class/filestorage-class.const';\nimport { connectToFileStorage } from './filestore-add-file.utils';\n\nexport class FileStoreAddFile extends React.Component {\n  protected fileStorage: IFileStorage<FILE_STORAGE_SERVICE_TYPE.HTTP | FILE_STORAGE_SERVICE_TYPE.IPFS> | undefined;\n\n  protected loadingProgress: number | undefined = undefined;\n\n  protected uploadedFiles: string[] = [];\n\n  protected styles = {\n    filesLoadedContainer: {\n      paddingBottom: '10px',\n    },\n  };\n\n  public componentDidMount() {\n    void this.createFilestoreInstance();\n  }\n\n  public render() {\n    const { fileStorage: fileStore } = this;\n\n    if (!fileStore) {\n      return <div>Not ready</div>;\n    }\n    return (\n      <>\n        {this.renderFileDownload()}\n        {this.renderFileUpload()}\n      </>\n    );\n  }\n\n  protected async createFilestoreInstance() {\n    this.fileStorage = await connectToFileStorage();\n    this.forceUpdate();\n  }\n\n  protected handleFileChosen = async (ev: React.ChangeEvent<HTMLInputElement>) => {\n    if (this.loadingProgress != null) {\n      return;\n    }\n\n    const { target } = ev;\n    const { fileStorage: fileStore } = this;\n\n    if (fileStore && target.files) {\n      const file = target.files[0];\n\n      this.loadingProgress = 0;\n      try {\n        console.dir(file);\n        const [loadedAddr] = await Promise.all([\n          fileStore.add(FILE_STORAGE_SERVICE_TYPE.IPFS, file.name, file, {\n            progress: (progress: number) => {\n              this.loadingProgress = progress;\n              this.forceUpdate();\n            },\n          }),\n          Promise.resolve().then(() => {\n            this.forceUpdate();\n          }),\n        ]);\n        this.uploadedFiles.push(loadedAddr);\n      } catch (err) {\n        console.error(err);\n      } finally {\n        this.loadingProgress = undefined;\n        this.forceUpdate();\n      }\n    }\n  };\n\n  private handleFileDownload = async (ev: MouseEvent<HTMLAnchorElement>) => {\n    const { target } = ev;\n    const { textContent } = target as HTMLAnchorElement;\n\n    ev.preventDefault();\n    if (textContent) {\n      await this.fileStorage?.download(textContent);\n    }\n  };\n\n  protected handleFileDownloadByURL = async () => {\n    const inpEl = document.getElementById('fileDownload');\n    const url = (inpEl as HTMLInputElement)?.value;\n\n    if (url) {\n      try {\n        const result = await this.fileStorage?.get(`/file/${url}`);\n\n        if (!(result instanceof File)) {\n          throw new Error('Failed to get the file');\n        }\n        downloadFile(result);\n      } catch (err) {\n        console.error(err);\n      }\n    }\n  };\n\n  protected renderFilesLoadedList() {\n    const { uploadedFiles } = this;\n\n    return uploadedFiles.map((fileAddr, idx) => (\n      <div key={fileAddr}>\n        <pre>{idx}. </pre>\n        <a href=\"#\" role=\"button\" data-name={fileAddr} onClick={this.handleFileDownload}>\n          {fileAddr}\n        </a>\n      </div>\n    ));\n  }\n\n  protected renderFileUpload() {\n    if (this.loadingProgress != null) {\n      return <div>Upload progress: {this.loadingProgress}</div>;\n    }\n    return (\n      <div>\n        <div style={this.styles.filesLoadedContainer}>{this.renderFilesLoadedList()}</div>\n        <label htmlFor=\"fileUpload\">File: </label>\n        <input id=\"fileUpload\" type=\"file\" onChange={this.handleFileChosen} />\n      </div>\n    );\n  }\n\n  protected renderFileDownload() {\n    return (\n      <div>\n        <label htmlFor=\"fileUpload\">Url: </label>\n        <input id=\"fileDownload\" type=\"text\" />\n        <button onClick={this.handleFileDownloadByURL}>Download</button>\n      </div>\n    );\n  }\n}\n","/home/paul/projects/protocol/src/components/filestore-add-file/filestore-add-file.utils.ts",["3278","3279","3280","3281","3282","3283"],"import { FileStorageClassProviderIPFS } from 'classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-ipfs/filestorage-class-provider-ipfs';\nimport { ipfsUtilsConnectBasic } from 'utils/ipfs-utils/ipfs-utils';\nimport { IFileStorageService } from '../../classes/filestorage-class/filestorage-class.types';\nimport { FileStorageClassProviderHTTP } from '../../classes/filestorage-class/filestorage-class-providers/filestorage-class-provider-http/filestorage-class-provider-http';\nimport { FileStorage, FILE_STORAGE_SERVICE_TYPE } from 'classes/filestorage-class';\n\nexport const connectToFileStorage = async () => {\n  const ipfs = await ipfsUtilsConnectBasic();\n  const optionsIpfs = {\n    ipfs,\n  };\n  const optionsHTTP = {};\n  const fileStoreProvider = new FileStorage();\n\n  await fileStoreProvider.connect([\n    {\n      type: FILE_STORAGE_SERVICE_TYPE.IPFS,\n      options: optionsIpfs,\n    },\n    {\n      type: FILE_STORAGE_SERVICE_TYPE.HTTP,\n      options: optionsHTTP,\n    },\n  ]);\n  return fileStoreProvider;\n};\n","/home/paul/projects/protocol/src/components/filestore-add-file/index.ts",[],"/home/paul/projects/protocol/src/components/sensitive-data-storage/index.ts",[],"/home/paul/projects/protocol/src/components/sensitive-data-storage/sensitive-data-storage.tsx",["3284","3285","3286","3287","3288","3289","3290"],"import React from 'react';\nimport { SensitiveDataSessionStorage } from 'classes/sensitive-data-session-storage';\n\nconst storageK = 'key';\n\nexport class SensitiveDataStorage extends React.PureComponent {\n  public state = {\n    value: '',\n    pinCode: undefined as string | undefined,\n    isConnected: false,\n  };\n\n  public st = new SensitiveDataSessionStorage();\n\n  public onValueChange = (ev: React.ChangeEvent<HTMLInputElement>) => {\n    const { target } = ev;\n    const { value } = target;\n\n    this.setState({\n      value,\n    });\n  };\n\n  public saveValue = async () => {\n    await this.st.setItem(storageK, this.state.value);\n  };\n\n  public readValue = async () => {\n    const value = await this.st.getItem(storageK);\n\n    console.log(`value = ${value}`);\n    this.setState({\n      value,\n    });\n  };\n\n  public async componentDidMount() {\n    const pinCode = prompt('Pin code') || undefined;\n\n    this.setState({\n      pinCode,\n    });\n    await this.st.connect({\n      pinCode,\n    });\n    this.setState({\n      isConnected: true,\n    });\n  }\n\n  public render() {\n    const { value, isConnected } = this.state;\n\n    return (\n      <div>\n        <input type=\"text\" onChange={this.onValueChange} value={value} />\n        <button onClick={this.saveValue}>Save</button>\n        <button onClick={this.readValue} disabled={!isConnected}>\n          Read\n        </button>\n      </div>\n    );\n  }\n}\n","/home/paul/projects/protocol/src/const/common-date-time/common-date-time-main.ts",[],"/home/paul/projects/protocol/src/const/common-date-time/common-date-time-ntp-servers.const.ts",[],"/home/paul/projects/protocol/src/const/common-date-time/common-date-time-timezone.const.ts",[],"/home/paul/projects/protocol/src/const/common-date-time/index.ts",[],"/home/paul/projects/protocol/src/const/common-values/common-values-env.ts",[],"/home/paul/projects/protocol/src/const/common-values/common-values.ts",[],"/home/paul/projects/protocol/src/const/common-values/index.ts",[],"/home/paul/projects/protocol/src/const/const-api-conf.ts",[],"/home/paul/projects/protocol/src/const/const-crypto-keys/const-crypto-keys.ts",[],"/home/paul/projects/protocol/src/const/const-crypto-keys/index.ts",[],"/home/paul/projects/protocol/src/const/const-validation-regex/const-validation-regex-common.ts",[],"/home/paul/projects/protocol/src/const/const-validation-regex/index.ts",[],"/home/paul/projects/protocol/src/const/const-validation-schemes/const-validation-schemes-common.ts",[],"/home/paul/projects/protocol/src/const/const-validation-schemes/const-validation-schemes-credentials.ts",[],"/home/paul/projects/protocol/src/const/const-validation-schemes/const-validation-schemes.ts",[],"/home/paul/projects/protocol/src/const/const-validation-schemes/index.ts",[],"/home/paul/projects/protocol/src/const/const-validation-values/const-validation-values-messaging-date.ts",[],"/home/paul/projects/protocol/src/const/const-validation-values/index.ts",[],"/home/paul/projects/protocol/src/const/const-values-restrictions-common.ts",[],"/home/paul/projects/protocol/src/dev.ts",[],"/home/paul/projects/protocol/src/index.ts",[],"/home/paul/projects/protocol/src/prod.ts",[],"/home/paul/projects/protocol/src/react-app-env.d.ts",[],"/home/paul/projects/protocol/src/types/channels.types.ts",[],"/home/paul/projects/protocol/src/types/common.types.ts",[],"/home/paul/projects/protocol/src/types/encryption-keys.types.ts",[],"/home/paul/projects/protocol/src/types/helper.types.ts",["3291","3292","3293","3294","3295","3296","3297","3298","3299","3300","3301","3302","3303","3304","3305","3306","3307","3308","3309"],"// eslint-disable-next-line @typescript-eslint/ban-types\nexport type TPrototypeKeys = keyof Object;\n\nexport type ownKeyOf<T extends object> = keyof T extends TPrototypeKeys ? never : keyof T;\n\n// onlye own properties values\nexport type ownValueOf<T extends object> = keyof T extends ownKeyOf<T> ? T[keyof T] : never;\n\nexport type ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\n\nexport type FirstPrameter<F extends (arg: any) => any> = Parameters<F> extends Array<infer FirstArg> ? FirstArg : never;\ntype FirstPrameter<F extends (arg: any) => any> = Parameters<F> extends Array<infer FirstArg> ? FirstArg : never;\n\nexport type OmitTypeProp<T extends {}, E> = {\n  [k in keyof T]: T[k] extends E ? never : T[k];\n};\n\nexport type OmitType<T, O> = T extends O ? never : T;\n\nexport type ConstructorType<R, A extends Array<any> = any[]> = new (...args: A) => R;\n\nexport type ArrayFirst<T extends any[]> = T extends Array<infer F> ? F : never;\n\nexport type Defined<T extends {}> = {\n  [k in keyof T]: T[k] extends undefined ? NonNullable<T[k]> : T[k];\n};\n\nexport type ParametersWithoutFirst<F extends (...args: any[]) => any> = F extends (arg0: any, ...array: infer U) => any\n  ? U\n  : never;\n\nexport type OmitFirstArg<F extends Function> = F extends (x: any, ...args: infer P) => infer R ? (...args: P) => R : never;\n\nexport type ArrayElement<ArrayType extends readonly unknown[]> = ArrayType[number];\n\nexport type PromiseResolveType<T> = T extends PromiseLike<infer U> ? U : T;\n","/home/paul/projects/protocol/src/types/index.d.ts",[],"/home/paul/projects/protocol/src/types/ipfs.d.ts",[],"/home/paul/projects/protocol/src/types/ipfs.types.d.ts",["3310","3311","3312","3313","3314","3315","3316"],"/* eslint-disable @typescript-eslint/member-ordering */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { EventEmitter } from 'events';\n\ndeclare module 'ipfs' {}\n\ntype Callback<T> = (error: Error, result?: T) => void;\n\nexport class IPFS extends EventEmitter {\n  constructor(options?: Options);\n\n  types: Types;\n\n  init(options: InitOptions, callback: Callback<boolean>): void;\n  init(callback: Callback<boolean>): void;\n\n  add(data: FileContent | FileObject, options: any, callback: Callback<IPFSFile[]>): void;\n  add(data: FileContent | FileObject, options: any): Promise<IPFSFile[]>;\n  add(data: FileContent | FileObject, callback: Callback<IPFSFile[]>): void;\n  add(data: FileContent | FileObject): Promise<IPFSFile[]>;\n\n  get(hash: Multihash, callback: Callback<IPFSFile | IPFSGetResult[]>): void;\n  get(hash: Multihash): Promise<IPFSFile | IPFSGetResult[]>;\n\n  preStart(callback: Callback<any>): void;\n  start(callback?: Callback<any>): void;\n  stop(callback?: (error?: Error) => void): Pomise<void>;\n  isOnline(): boolean;\n\n  version(options: any, callback: (error: Error, version: Version) => void): void;\n  version(options: any): Promise<Version>;\n  version(callback: (error: Error, version: Version) => void): void;\n  version(): Promise<Version>;\n\n  id(options: any, callback: (error: Error, version: Id) => void): void;\n  id(options: any): Promise<Id>;\n  id(callback: (error: Error, version: Id) => void): void;\n  id(): Promise<Id>;\n\n  ready: Promise<boolean>;\n  repo: RepoAPI;\n  bootstrap: any;\n  config: any;\n  block: any;\n  object: ObjectAPI;\n  dag: DagAPI;\n  libp2p: any;\n  swarm: SwarmAPI;\n  files: FilesAPI;\n  bitswap: Bitswap;\n\n  ping(callback: (error: Error) => void): void;\n  ping(): Promise<void>;\n\n  pubsub: Pubsub;\n\n  on(event: string, callback: () => void): this;\n  on(event: 'error', callback: (error: Error) => void): this;\n  once(event: string, callback: () => void): this;\n}\n\nexport type InstanceIPFS = InstanceType<IPFS>;\n\nexport interface Options {\n  init?: boolean;\n  start?: boolean;\n  EXPERIMENTAL?: any;\n  repo?: string;\n  config?: any;\n}\n\nexport interface InitOptions {\n  emptyRepo?: boolean;\n  bits?: number;\n  log?: Function;\n}\n\nexport interface Multiaddr {\n  buffer: Uint8Array;\n}\n\nexport type Multihash = any | string;\nexport type CID = any;\n\nexport interface Types {\n  Buffer: any;\n  PeerId: string | any;\n  PeerInfo: any;\n  multiaddr: Multiaddr;\n  multihash: Multihash;\n  CID: CID;\n}\n\nexport interface Version {\n  version: string;\n  repo: string;\n  commit: string;\n}\n\nexport interface Id {\n  id: string;\n  publicKey: string;\n  addresses: Multiaddr[];\n  agentVersion: string;\n  protocolVersion: string;\n}\n\nexport interface RepoAPI {\n  init(bits: number, empty: boolean, callback: Callback<any>): void;\n\n  version(options: any, callback: Callback<any>): void;\n  version(callback: Callback<any>): void;\n\n  gc(): void;\n  path(): string;\n}\n\nexport type UnixTime = { secs: number; nsecs: number };\n\nexport type FileObject = {\n  path?: string;\n  // The contents of the file (see below for definition)\n  content?: FileContent;\n  // File mode to store the entry with (see https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation)\n  mode?: number | string;\n  // The modification time of the entry (see below for definition)\n  mtime?: UnixTime | Date;\n};\n\nexport type FileContent = Record<string, any> | Blob | string;\n\n/** old version? */\nexport interface IPFSFile {\n  path: string;\n  hash: string;\n  size: number;\n  content?: FileContent;\n  mtime?: UnixTime;\n}\n\nexport interface IPFSGetResult {\n  depth: number;\n  name: string;\n  path: string;\n  size: number;\n  hash: Buffer;\n  content: Buffer;\n  type: 'file' | string;\n  mtime?: UnixTime;\n}\n\nexport interface FilesAPI {\n  createAddStream(options: any, callback: Callback<any>): void;\n  createAddStream(callback: Callback<any>): void;\n\n  createPullStream(options: any): any;\n\n  cat(hash: Multihash, callback: Callback<FileContent>): void;\n  cat(hash: Multihash): Promise<FileContent>;\n\n  getPull(hash: Multihash, callback: Callback<any>): void;\n}\n\nexport interface PeersOptions {\n  v?: boolean;\n  verbose?: boolean;\n}\n\nexport type PeerId = any;\n\nexport interface PeerInfo {\n  id: PeerId;\n  multiaddr: Multiaddr;\n  multiaddrs: Multiaddr[];\n  distinctMultiaddr(): Multiaddr[];\n}\n\nexport interface Peer {\n  addr: Multiaddr;\n  peer: PeerInfo;\n}\n\nexport interface SwarmAPI {\n  peers(options: PeersOptions, callback: Callback<Peer[]>): void;\n  peers(options: PeersOptions): Promise<Peer[]>;\n  peers(callback: Callback<Peer[]>): void;\n  peers(): Promise<Peer[]>;\n\n  addrs(callback: Callback<PeerInfo[]>): void;\n  addrs(): Promise<PeerInfo[]>;\n\n  localAddrs(callback: Callback<Multiaddr[]>): void;\n  localAddrs(): Promise<Multiaddr[]>;\n\n  connect(maddr: Multiaddr | string, callback: Callback<any>): void;\n  connect(maddr: Multiaddr | string): Promise<any>;\n\n  disconnect(maddr: Multiaddr | string, callback: Callback<any>): void;\n  disconnect(maddr: Multiaddr | string): Promise<any>;\n\n  filters(callback: Callback<void>): never;\n}\n\nexport type DAGNode = any;\nexport type DAGLink = any;\nexport type DAGLinkRef = DAGLink | any;\nexport type Obj = BufferSource | Record<string, any>;\n\nexport interface ObjectStat {\n  Hash: Multihash;\n  NumLinks: number;\n  BlockSize: number;\n  LinksSize: number;\n  DataSize: number;\n  CumulativeSize: number;\n}\n\nexport interface PutObjectOptions {\n  enc?: any;\n}\n\nexport interface GetObjectOptions {\n  enc?: any;\n}\n\nexport interface ObjectPatchAPI {\n  addLink(multihash: Multihash, link: DAGLink, options: GetObjectOptions, callback: Callback<any>): void;\n  addLink(multihash: Multihash, link: DAGLink, options: GetObjectOptions): Promise<any>;\n  addLink(multihash: Multihash, link: DAGLink, callback: Callback<any>): void;\n  addLink(multihash: Multihash, link: DAGLink): Promise<any>;\n\n  rmLink(multihash: Multihash, linkRef: DAGLinkRef, options: GetObjectOptions, callback: Callback<any>): void;\n  rmLink(multihash: Multihash, linkRef: DAGLinkRef, options: GetObjectOptions): Promise<any>;\n  rmLink(multihash: Multihash, linkRef: DAGLinkRef, callback: Callback<any>): void;\n  rmLink(multihash: Multihash, linkRef: DAGLinkRef): Promise<any>;\n\n  appendData(multihash: Multihash, data: any, options: GetObjectOptions, callback: Callback<any>): void;\n  appendData(multihash: Multihash, data: any, options: GetObjectOptions): Promise<any>;\n  appendData(multihash: Multihash, data: any, callback: Callback<any>): void;\n  appendData(multihash: Multihash, data: any): Promise<any>;\n\n  setData(multihash: Multihash, data: any, options: GetObjectOptions, callback: Callback<any>): void;\n  setData(multihash: Multihash, data: any, options: GetObjectOptions): Promise<any>;\n  setData(multihash: Multihash, data: any, callback: Callback<any>): void;\n  setData(multihash: Multihash, data: any): Promise<any>;\n}\n\nexport interface ObjectAPI {\n  'new'(template: 'unixfs-dir', callback: Callback<DAGNode>): void;\n  'new'(callback: Callback<DAGNode>): void;\n  'new'(): Promise<DAGNode>;\n\n  put(obj: Obj, options: PutObjectOptions, callback: Callback<any>): void;\n  put(obj: Obj, options: PutObjectOptions): Promise<any>;\n  put(obj: Obj, callback: Callback<any>): void;\n  put(obj: Obj): Promise<any>;\n\n  get(multihash: Multihash, options: GetObjectOptions, callback: Callback<any>): void;\n  get(multihash: Multihash, options: GetObjectOptions): Promise<any>;\n  get(multihash: Multihash, callback: Callback<any>): void;\n  get(multihash: Multihash): Promise<any>;\n\n  data(multihash: Multihash, options: GetObjectOptions, callback: Callback<any>): void;\n  data(multihash: Multihash, options: GetObjectOptions): Promise<any>;\n  data(multihash: Multihash, callback: Callback<any>): void;\n  data(multihash: Multihash): Promise<any>;\n\n  links(multihash: Multihash, options: GetObjectOptions, callback: Callback<DAGLink[]>): void;\n  links(multihash: Multihash, options: GetObjectOptions): Promise<DAGLink[]>;\n  links(multihash: Multihash, callback: Callback<DAGLink[]>): void;\n  links(multihash: Multihash): Promise<DAGLink[]>;\n\n  stat(multihash: Multihash, options: GetObjectOptions, callback: Callback<ObjectStat>): void;\n  stat(multihash: Multihash, options: GetObjectOptions): Promise<ObjectStat>;\n  stat(multihash: Multihash, callback: Callback<ObjectStat>): void;\n  stat(multihash: Multihash): Promise<ObjectStat>;\n\n  patch: ObjectPatchAPI;\n}\n\nexport interface DagAPI {\n  put(dagNode: any, options: any, callback: Callback<any>): void;\n  put(dagNode: any, options: any): Promise<any>;\n\n  get(cid: string | CID, path: string, options: any, callback: Callback<any>): void;\n  get(cid: string | CID, path: string, options: any): Promise<any>;\n  get(cid: string | CID, path: string, callback: Callback<any>): void;\n  get(cid: string | CID, path: string): Promise<any>;\n  get(cid: string | CID, callback: Callback<any>): void;\n  get(cid: string | CID): Promise<any>;\n\n  tree(cid: string | CID, path: string, options: any, callback: Callback<any>): void;\n  tree(cid: string | CID, path: string, options: any): Promise<any>;\n  tree(cid: string | CID, path: string, callback: Callback<any>): void;\n  tree(cid: string | CID, path: string): Promise<any>;\n  tree(cid: string | CID, options: any, callback: Callback<any>): void;\n  tree(cid: string | CID, options: any): Promise<any>;\n  tree(cid: string | CID, callback: Callback<any>): void;\n  tree(cid: string | CID): Promise<any>;\n}\n\ntype TPubSubTopic = string;\n\ntype TpubSubTopicHandler = (msg: any) => void;\n\ntype TPubSubTopicOptions = {\n  discover: boolean;\n};\n\ntype TPubSubData = string | Buffer;\n\nexport interface Pubsub {\n  subscribe(topic: TPubSubTopic, handler: TpubSubTopicHandler, options: TPubSubTopicOptions, callback: Callback<any>): void;\n  subscribe(topic: TPubSubTopic, handler: TpubSubTopicHandler, options: TPubSubTopicOptions): Promise<void>;\n\n  unsubscribe(topic: TPubSubTopic, handler: TpubSubTopicHandler, callback: Callback<void>): void;\n  unsubscribe(topic: TPubSubTopic, handler: TpubSubTopicHandler): Promise<void>;\n\n  publish(topic: TPubSubTopic, data: TPubSubData, callback: Callback<any>): void;\n  publish(topic: TPubSubTopic, data: TPubSubData): Promise<any>;\n\n  ls(callback: Callback<any>): void;\n  ls(): Promise<any>;\n\n  peers(topic: TPubSubTopic, callback: Callback<any>): void;\n  peers(topic: TPubSubTopic): Promise<any>;\n\n  setMaxListeners(n: number): void;\n}\n\nexport interface WantListItem {\n  '/': string;\n}\nexport interface WantList {\n  Keys: WantListItem[];\n}\n\n/* class object */\nexport type Big = any;\nexport interface Stat {\n  provideBufLen: number;\n  blocksReceived: Big;\n  wantlist: WantListItem[];\n  peers: string[];\n  dupBlksReceived: Big;\n  dupDataReceived: Big;\n  dataReceived: Big;\n  blocksSent: Big;\n  dataSent: Big;\n}\n\nexport type KeyType = string | Buffer | CID | any;\nexport interface Bitswap {\n  wantlist(peerId: string, callback: Callback<WantList>): void;\n  wantlist(peerId: string): Promise<WantList>;\n  wantlist(callback: Callback<WantList>): void;\n  wantlist(): Promise<WantList>;\n\n  stat(callback: Callback<Stat>): void;\n  stat(): Promise<Stat>;\n\n  unwant(keys: KeyType | KeyType[], callback: Callback<any>): void;\n  unwant(keys: KeyType | KeyType[]): Promise<any>;\n}\n\nexport function create(options: Options): Promise<IPFS>;\n\nexport as namespace Ipfs;\n","/home/paul/projects/protocol/src/types/libp2p-bootstrap.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-delegated-content-routing.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-delegated-peer-routing.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-gossipsub.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-kad-dht.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-mdns.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-secio.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-spdy.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-stardust.d.ts",["3317","3318","3319"],"/** Declaration file generated by dts-gen */\n\ndeclare module 'libp2p-stardust' {\n  export = libp2p_stardust;\n\n  function libp2p_stardust(...args: any[]): any;\n\n  function isstardust(obj: any): void;\n\n  libp2p_stardust.isstardust = isstardust;\n}\n","/home/paul/projects/protocol/src/types/libp2p-tcp.d.ts",["3320","3321","3322"],"/** Declaration file generated by dts-gen */\ndeclare module 'libp2p-tcp' {\n  export = libp2p_tcp;\n\n  declare function libp2p_tcp(...args: any[]): any;\n\n  declare namespace libp2p_tcp {\n    function isTCP(obj: any): void;\n  }\n}\n","/home/paul/projects/protocol/src/types/libp2p-webrtc-direct.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-webrtc-star.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-websocket-star.d.ts",[],"/home/paul/projects/protocol/src/types/libp2p-websockets.d.ts",["3323","3324","3325"],"/** Declaration file generated by dts-gen */\n\ndeclare module 'libp2p-websockets' {\n  export = libp2p_websockets;\n\n  declare function libp2p_websockets(...args: any[]): any;\n\n  declare namespace libp2p_websockets {\n    function isWebSockets(obj: any): void;\n  }\n}\n","/home/paul/projects/protocol/src/types/libp2p.d.ts",[],"/home/paul/projects/protocol/src/types/main.types.ts",["3326"],"export type TTypedArraysNative =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n  | BigInt64Array\n  | BigUint64Array;\n\nexport type TTypedArrays = TTypedArraysNative | DataView | ArrayBuffer;\n\nexport type TArrayBufferView = TTypedArrays;\n\nexport type TMainDataTypes = object | number | string;\n","/home/paul/projects/protocol/src/types/multiaddr.d.ts",[],"/home/paul/projects/protocol/src/types/orbit-db-cache.d.ts",[],"/home/paul/projects/protocol/src/types/orbit-db-identity-provider-ext.d.ts",[],"/home/paul/projects/protocol/src/types/orbit-db-keystore.d.ts",["3327","3328","3329","3330","3331","3332","3333","3334","3335"],"import 'orbit-db-keystore';\n\nexport interface IOrbitDBKeystoreStoreCustom {\n  status: string;\n  open(): Promise<void>;\n  close(): Promise<void>;\n  put(k: string, v: any): Promise<void>;\n  get(k: string): string | Uint8Array;\n  verify(publicKeySignature: string, publicKey: string, publicKeyAndId: string): Promise<boolen>;\n}\n\ndeclare module 'orbit-db-keystore' {\n  export interface IOrbitDBKeystoreStore extends IOrbitDBKeystoreStoreCustom {}\n\n  export interface IOrbitDBKeystoreCache {\n    length: number;\n    keys: string[];\n    set(k: string, v: any): void;\n    get(k: string): any;\n    remove(k: string): void;\n    clear(): void;\n  }\n\n  /**\n   *\n   *\n   * @export\n   * @interface IOrbitDBKeystoreOptionsForSecretStorage\n   * @property {string} path - the custom name of the storage\n   */\n  export interface IOrbitDBKeystoreOptionsForSecretStorage {\n    store?: string | IOrbitDBKeystoreStoreCustom;\n    cache?: IOrbitDBKeystoreCache;\n    path?: string;\n    credentials:\n      | {\n          password: string;\n        }\n      | {\n          key: CryptoKey;\n        }\n      | {\n          session: {};\n        };\n  }\n\n  export type TOrbitDBKeystoreOptions = IOrbitDBKeystoreOptionsForSecretStorage | string;\n\n  export = class Keystore implements IOrbitDBKeystoreStore {\n    constructor(options: any) {}\n  };\n}\n","/home/paul/projects/protocol/src/types/orbit-db-storage-adapter.d.ts",[],"/home/paul/projects/protocol/src/types/pull-mplex.d.ts",[],"/home/paul/projects/protocol/src/types/storage.types.ts",["3336"],"export interface IStorageCommon<V = string> {\n  get(key: string): Promise<V | undefined | null | Error>;\n  set(key: string, value: V | undefined | null): Promise<void | boolean | Error>;\n}\n\nexport interface IStorage<V> extends IStorageCommon<V> {}\n","/home/paul/projects/protocol/src/types/users.types.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/common-utils-array.ts",["3337","3338","3339","3340","3341","3342","3343","3344","3345","3346","3347","3348","3349","3350","3351","3352","3353","3354"],"import { bytesInInteger } from './common-utils-number';\nimport { isDefined } from './common-utils-main';\n\nexport const commonUtilsIsInstanceOfArray = (a: any): a is Array<any> => !a || typeof a !== 'object' || a instanceof Array;\n/**\n * Checks whether two array items are equal\n *\n * @param {Array<any>} firstArray\n * @param {Array<any>} secondArray\n * @returns {boolean}\n */\n\n/**\n * Checks whether two arrays have the same items.\n * Order doesn't matter.\n *\n * @param {Array<any>} firstArray\n * @param {Array<any>} secondArray\n * @returns {boolean}\n */\nexport const commonUtilsIsTwoArraysHaveSameItems = (firstArray: Array<any>, secondArray: Array<any>): boolean => {\n  if (firstArray === secondArray) {\n    return true;\n  }\n  if (firstArray.length !== secondArray.length) {\n    return false;\n  }\n  return !firstArray.some((firstArrayItem) => {\n    return !secondArray.includes(firstArrayItem);\n  }, true);\n};\n/**\n * Checks whether two array items are equal and all items in the same order\n *\n * @param {Array<any>} firstArray\n * @param {Array<any>} secondArray\n * @returns {boolean}\n */\nexport const commonUtilsIsTwoArraysEquals = (firstArray: Array<any>, secondArray: Array<any>): boolean => {\n  if (firstArray === secondArray) {\n    return true;\n  }\n  if (firstArray.length !== secondArray.length) {\n    return false;\n  }\n  return !firstArray.some((firstArrayItem, firstArrayItemIndex) => {\n    return firstArrayItem !== secondArray[firstArrayItemIndex];\n  }, true);\n};\n/**\n * Checks whether two items are arrays and the two array items are equal and all items in the same order and return the second\n * one if equals.\n * Returns the second array if two arrays are equal or returns false otherwise.\n *\n * @template S\n * @template F\n * @param {F} firstArray\n * @param {S} secondArray\n * @returns {S | false}\n */\nexport const commonUtilsReturnArrayIfTwoArraysEquals = <S>(firstArray: any, secondArray: S): S extends Array<any> ? S : false =>\n  (commonUtilsIsInstanceOfArray(firstArray) &&\n  commonUtilsIsInstanceOfArray(secondArray) &&\n  commonUtilsIsTwoArraysEquals(firstArray, secondArray)\n    ? secondArray\n    : false) as S extends Array<any> ? S : false;\n\n/**\n * Checks whether all arrays has the same items in the same order\n *\n * @param {...Array<Array<any>>} arrays\n * @returns {boolean}\n */\nexport const commonUtilsAreAllArraysEqual = (...arrays: Array<Array<any>>): boolean => {\n  if (!arrays.length) {\n    return true;\n  }\n  if (arrays.length === 1) {\n    return commonUtilsIsInstanceOfArray(arrays[0]);\n  }\n  return !!arrays.reduce(commonUtilsReturnArrayIfTwoArraysEquals, arrays[0]);\n};\n\nexport const commonUtilsArrayOrderByDecComparationFunction = <T>(a: T, b: T): number => Number(b) - Number(a);\n\n/**\n * sort array by decreasing\n * value on increased index\n * @param {any[]} arr\n */\nexport const commonUtilsArrayOrderByDec = <T>(arr: T[]): T[] => arr.sort(commonUtilsArrayOrderByDecComparationFunction);\n\n/**\n * delete an item from the array\n * @param {Array} arr\n * @param {any} item\n */\n\nexport const commonUtilsArrayDeleteFromArray = <T>(arr: T[], item: T) => {\n  if (arr instanceof Array && arr.length) {\n    const idxOfItem = arr.findIndex((el: T) => el === item);\n\n    if (idxOfItem !== -1) {\n      arr.splice(idxOfItem, 1);\n    }\n  }\n};\n\n/**\n * call a callback function for an each item in the\n * array till the result is not an intstance of the\n * Error. If any callback resulted with an Error\n * then the execution will break.\n */\nexport const commonUtilsArrayDoCallbackTillNoError = <T>(arr: T[], cb: (v: T) => Error | any): Error | void => {\n  if (!(arr instanceof Array)) {\n    return new Error('The array value must be an instance of Array');\n  }\n\n  const len = arr.length;\n  let idx = 0;\n  let r: Error | any;\n\n  for (; idx < len; idx += 1) {\n    r = cb(arr[idx]);\n\n    if (r instanceof Error) {\n      return r;\n    }\n  }\n};\n\n/**\n * calculate the overall lenght\n * of the numeric array in bytes\n * @param {number[]} arr\n * @param {number} [maxNumber] - maximum value of the valid number\n * @param {number} [minNumber] - minimum value of the valid number\n * @returns {number | Error} - return a length of the array or an Error\n * if a non-finite or an unsafe number will be met\n */\nexport const commonUtilsArrayCalculateLengthOfIntegerArray = (\n  arr: number[],\n  maxNumber?: number,\n  minNumber?: number\n): number | Error => {\n  if (!(arr instanceof Array)) {\n    return new Error('The array value must be an instance of Array');\n  }\n\n  const maxNumberRes = typeof maxNumber === 'number' ? maxNumber : Number.MAX_SAFE_INTEGER;\n  const minNumberRes = typeof minNumber === 'number' ? minNumber : 0;\n  const len = arr.length;\n  let idx = 0;\n  let item;\n  let result = 0;\n  let bytesInIntem;\n\n  for (; idx < len; idx += 1) {\n    item = arr[idx];\n\n    if (typeof item !== 'number') {\n      return new Error('The value is not a number');\n    }\n    if (!Number.isInteger(item)) {\n      return new Error('The value is not an integer number');\n    }\n    if (item < 0) {\n      return new Error('The number must be greater than 0');\n    }\n    if (!Number.isFinite(item)) {\n      return new Error('The value is not a finite number');\n    }\n    if (item > maxNumberRes) {\n      return new Error('The number is too big');\n    }\n    if (item < minNumberRes) {\n      return new Error('The number is too small');\n    }\n    bytesInIntem = bytesInInteger(item);\n    if (bytesInIntem instanceof Error) {\n      return bytesInIntem;\n    }\n    result += bytesInIntem;\n  }\n  return result;\n};\n\n/**\n * check wherether the array\n * includes all items\n * @param testedArray\n * @param requiredItems\n */\nexport const commonUtilsArrayIncludesAll = (testedArray: any[], requiredItems: any[]): boolean => {\n  const len = requiredItems.length;\n  let idx = 0;\n\n  while (idx < len) {\n    if (!testedArray.includes(requiredItems[idx])) {\n      return false;\n    }\n    idx++;\n  }\n  return true;\n};\n\n/**\n * Returns only defined items of an array\n *\n * @template T\n * @param {T[]} arr\n * @returns {T[]}\n */\nexport const commonUtilsArrayDefinedOnly = <T>(arr: T[]): NonNullable<T>[] => arr.filter(isDefined);\n\n/**\n * Returns uniq items of an array\n *\n * @template T\n * @param {T[]} arr\n * @returns {T[]}\n */\nexport const commonUtilsArrayUniq = <T>(arr: T[]): T[] => Array.from(new Set(arr));\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-check-value.ts",["3355","3356"],"export const checkIsError = (v: any): v is Error => v instanceof Error;\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-date-time-synced.ts",["3357"],"import addSeconds from 'date-fns/addSeconds';\nimport { PseudoNTPClass as PseudoNTP } from 'classes/pseudo-ntp-class';\nimport { COMMON_DATE_TIME_NTP_SERVERS_POOL } from 'const/common-date-time/common-date-time-ntp-servers.const';\nimport { DATE_TIME_COMMON_CURRENT_DATE_UPDATE_INTERVAL_SECONDS } from 'const/common-date-time/common-date-time-main';\nimport { CONST_VALUES_RESTRICTIONS_COMMON_CURRENT_DATE_MAX_ERROR_SECONDS } from 'const/const-values-restrictions-common';\nimport { getSecondsByMilliseconds } from './common-utils-date-time';\n\n/**\n * returns a signed difference with the\n * date time sync server in seconds.\n *\n * @export\n * @returns {number}\n */\nexport const getTimeDiffWithSyncServerSeconds = (() => {\n  let offsetSeconds: number = 0;\n  const pseudoNTP = new PseudoNTP({\n    serversPool: COMMON_DATE_TIME_NTP_SERVERS_POOL,\n    maxOffsetErrorS: CONST_VALUES_RESTRICTIONS_COMMON_CURRENT_DATE_MAX_ERROR_SECONDS,\n  });\n\n  pseudoNTP.on(PseudoNTP.Event.TIME_SYNC, (differenceInSeconds) => {\n    offsetSeconds = differenceInSeconds;\n  });\n  return () => offsetSeconds;\n})();\n\n/**\n * returns date given including the\n * offset from the sync server.\n *\n * @export\n * @param {Date} d\n * @returns {Date}\n */\nexport const getDateWithTimeSyncOffset = (d: Date): Date => {\n  return addSeconds(d, getTimeDiffWithSyncServerSeconds());\n};\n\n/**\n * returns the current date and time\n * which is syncronized with the server.\n * To increase the performance and\n * avoid unnecessary calculations the\n * current date updated peridiocally\n * and the cached value returned by this\n * function.\n *\n * @export\n * @returs {Date}\n */\nexport const getCurrentDateSynced = (() => {\n  let currentDate = getDateWithTimeSyncOffset(new Date());\n\n  setInterval(() => {\n    currentDate = getDateWithTimeSyncOffset(new Date());\n  }, DATE_TIME_COMMON_CURRENT_DATE_UPDATE_INTERVAL_SECONDS * 1000);\n  return () => currentDate;\n})();\n\n/**\n * returns milliseconds since 1970\n * cached and changes only on the current\n * date synced will change\n */\nexport const getDateNowInSeconds = (() => {\n  let prevReturnValue = getSecondsByMilliseconds(Date.now());\n  let prevDateSynced = getCurrentDateSynced();\n\n  return () => {\n    const currentDateSynced = getCurrentDateSynced();\n\n    if (currentDateSynced !== prevDateSynced) {\n      prevDateSynced = currentDateSynced;\n      prevReturnValue = getSecondsByMilliseconds(Date.now());\n    }\n    return prevReturnValue;\n  };\n})();\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-date-time.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/common-utils-main.ts",["3358","3359","3360","3361","3362"],"import { isTypedArray } from '../typed-array-utils';\nimport { TTypedArrays } from '../../types/main.types';\n\nexport const isDefined = <T>(v: T): v is NonNullable<T> => v != null;\n\n/**\n * Count of items\n *\n * @template T\n * @param {T} arg - argument which is able to count it's items number\n * @returns {number} - chars in string, bytes in typed arrays, keys in object, members in map, items in set, items in array\n */\nexport const getItemsCount = <T extends Map<any, any> | Set<any> | Array<any> | {} | string | TTypedArrays>(arg: T): number => {\n  if (arg instanceof Map || arg instanceof Set) {\n    return arg.size;\n  } else if (Array.isArray(arg)) {\n    return arg.length;\n  } else if (arg && typeof arg === 'object') {\n    return Object.keys(arg).length;\n  } else if (typeof arg === 'string') {\n    return arg.length;\n  } else if (isTypedArray(arg)) {\n    return arg.byteLength;\n  }\n  throw new Error('Unsupported type');\n};\n\n/**\n * Return a Promise which will be resolved\n * when the callback returns any value\n * which is defined(not null, ubdefined, NaN).\n *\n * @template R - resolved type return by the callback function\n * @param {() => R | undefined} cb - callback function called each interval till not trow or return somethind\n * @param {number} [checkIntervalMs=100] - interval when the callback will be called\n * @param {number} [timeoutMs = 360000] - timeout when the promise will be rejected if not resolved before\n * @returns {Promise<R>}\n * @throw - rejects on timeout or if the callback thrown an error\n */\nexport const waitFor = <R>(\n  cb: () => NonNullable<R> | undefined,\n  checkIntervalMs: number = 100,\n  timeoutMs: number = 360000\n): Promise<R> => {\n  return new Promise((res, rej) => {\n    let timeout: NodeJS.Timer | undefined;\n    let checkInterval: NodeJS.Timeout | undefined;\n    const clearTimers = () => {\n      checkInterval && clearInterval(checkInterval);\n      timeout && clearTimeout(timeout);\n      checkInterval = undefined;\n      timeout = undefined;\n    };\n\n    if (timeoutMs) {\n      timeout = setTimeout(() => {\n        clearTimers();\n        rej(new Error('Timeout'));\n      }, timeoutMs);\n    }\n    checkInterval = setInterval(() => {\n      let result;\n      try {\n        result = cb();\n      } catch (err) {\n        clearTimers();\n        rej(err);\n        return;\n      }\n      if (isDefined(result)) {\n        clearTimers();\n        res(result);\n      }\n    }, checkIntervalMs);\n  });\n};\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-number.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/common-utils-objects.ts",["3363","3364","3365","3366","3367","3368","3369","3370","3371","3372","3373"],"import { TObjectKeys, TDictionary } from 'types/common.types';\nimport { isDefined } from './common-utils-main';\n\nexport const isNotEmptyObject = (o: any): o is object => {\n  return !!o && typeof o === 'object' && !!Object.keys(o).length;\n};\n\nexport const isEmptyObject = (o: any): boolean => {\n  return !isNotEmptyObject(o);\n};\n\nexport const getObjectKeys = (o: object): Array<TObjectKeys> =>\n  (Object.keys(o) as Array<TObjectKeys>).concat(Object.getOwnPropertySymbols(o));\n\nexport const isSimpleObject = (o: any): o is object => typeof o === 'object' && Object.getPrototypeOf(o) === Object.prototype;\n\n/**\n * extends object with another object if the object\n * have no properties\n *\n * @export\n * @template T\n * @template E\n * @param {T} o\n * @param {E} ext\n * @returns {T}\n */\nexport function extend<T extends TDictionary<any>, E extends TDictionary<any>>(\n  o: T | undefined,\n  ext: E,\n  replaceExisting?: boolean\n): T & E {\n  if (!o) {\n    return ext;\n  }\n  if (!isSimpleObject(o) || !isSimpleObject(ext)) {\n    if (replaceExisting && ext) {\n      return ext;\n    }\n    return (!o || isEmptyObject(o)) && ext ? ext : o;\n  }\n\n  const keys = getObjectKeys(ext);\n  let idx = 0;\n  let k: keyof E;\n  const len = keys.length;\n\n  while (idx < len) {\n    k = keys[idx];\n    idx++;\n    if (!isDefined(ext[k])) {\n      continue;\n    }\n    if (replaceExisting || !isDefined(o[k])) {\n      o[k] = ext[k];\n    } else if (typeof o[k] === 'object' && typeof ext[k] === 'object') {\n      o[k] = extend(o[k], ext[k]);\n    }\n  }\n  return o;\n}\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-timer.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/common-utils-url.ts",["3374"],"import normalizeUrlModule, { Options } from 'normalize-url';\n\n/**\n * normalize the url string\n * by\n *\n * @param {string} url\n */\nexport const normalizeUrl = (url: string, options?: Options): string | Error => {\n  try {\n    return normalizeUrlModule(url, {\n      defaultProtocol: 'https:', // the default protocol must be https:\n      normalizeProtocol: true,\n      stripWWW: true,\n      sortQueryParameters: true, // it is necessary to compare two urls\n      ...options,\n    });\n  } catch (err) {\n    return err;\n  }\n};\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.const.ts",[],"/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.ts",["3375","3376","3377","3378"],"import {\n  IDataCachingDecoratorDecoratedFunction,\n  IDataCachingDecoratorCachedValue,\n} from './data-cache-utils-caching-decorator.types';\nimport { commonUtilsArrayOrderByDec } from 'utils/common-utils/common-utils';\nimport { DATA_CACHING_DECORATOR_DEFAULT_CACHE_CAPACITY } from './data-cache-utils-caching-decorator.const';\n\n/**\n * decorator for a method, will be wrapped for\n * caching values of a mostly used keys.\n * Must be used only for immutable\n * key-value stores\n * @property {number} cachedValuesCount - number\n * of a cached values\n */\nexport const dataCachingUtilsCachingDecorator = <T, V, I extends object>(\n  cacheItemsCapacity: number = DATA_CACHING_DECORATOR_DEFAULT_CACHE_CAPACITY\n) => {\n  /**\n   *\n   *\n   * @param {object} target\n   * @param {string} propertyKey\n   * @param {PropertyDescriptor} descriptor\n   * @returns\n   */\n  return (target: object, propertyKey: string, descriptor: PropertyDescriptor) => {\n    let newDescriptor;\n    // the original method, will be wrapped\n    const methodOrigin: IDataCachingDecoratorDecoratedFunction<T, V> = descriptor.value;\n    // key - rating\n    const keysRaiting = new Map<T, number>();\n    let keysHighestRatings: number[] = [];\n    const cache = new Map<T, IDataCachingDecoratorCachedValue<V>>();\n    const cachedValuesCountLastIndex = cacheItemsCapacity - 1;\n\n    if (typeof methodOrigin !== 'function') {\n      throw new Error('dataCachingUtilsCachingDecorator failed to decorate a non function property');\n    }\n\n    async function cachingWrapper(this: I, key: T): Promise<V> {\n      const cachedValueForKey = cache.get(key);\n\n      // check if the value of the\n      // key was cached\n      if (cachedValueForKey != null) {\n        return cachedValueForKey.value;\n      }\n\n      const resultedValue = await methodOrigin.call(this, key);\n\n      if (!(resultedValue instanceof Error) && resultedValue != null) {\n        const theMinimalRaitingValue = keysHighestRatings[cachedValuesCountLastIndex];\n        // increase the key raiting on each read of the key\n        const keyRaiting = Number(keysRaiting.get(key) || 0) + 1;\n\n        keysRaiting.set(key, keyRaiting);\n        if (!theMinimalRaitingValue || theMinimalRaitingValue < keyRaiting) {\n          // put the key rating on the last index\n          keysHighestRatings[Math.min(cachedValuesCountLastIndex, keysHighestRatings.length)] = keyRaiting;\n          // sort the resulted array an replace the highest rating\n          // array with the ordered copy of it\n          keysHighestRatings = commonUtilsArrayOrderByDec<number>(keysHighestRatings);\n\n          // if the minimal rating value is exists.\n          // Means that the cache is overflow\n          // and it's necessary to delete\n          // a value for the key with the minimal rating\n          // from the cache.\n          if (theMinimalRaitingValue) {\n            // find the key with the minimal value of the rating\n            // which value was stored in the cache\n            for (const entry of cache) {\n              if (entry[1].rating === theMinimalRaitingValue) {\n                // if found the key with the minimal\n                // rating delete it from the cache\n                cache.delete(entry[0]);\n                break;\n              }\n            }\n          }\n\n          // cache the key value\n          cache.set(key, {\n            rating: keyRaiting,\n            value: resultedValue,\n          });\n        }\n      }\n      return resultedValue;\n    }\n\n    if (descriptor.writable) {\n      descriptor.value = cachingWrapper;\n      newDescriptor = descriptor;\n    } else {\n      newDescriptor = {\n        writable: false,\n        enumerable: true,\n        configurable: false,\n        value: cachingWrapper,\n      };\n    }\n    return newDescriptor;\n  };\n};\n","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/data-cache-utils-caching-decorator.types.ts",[],"/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-caching-decorator/index.ts",[],"/home/paul/projects/protocol/src/utils/data-cache-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/data-compression-utils/data-compression-utils-strings.ts",[],"/home/paul/projects/protocol/src/utils/data-compression-utils/data-compression-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/data-compression-utils/data-compression-utils.ts",[],"/home/paul/projects/protocol/src/utils/data-compression-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/data-sign-utils/data-sign-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/data-sign-utils/data-sign-utils.ts",[],"/home/paul/projects/protocol/src/utils/data-sign-utils/data-sign-utils.types.ts",["3379","3380"],"import { TTypedArrays } from 'types/main.types';\nimport { DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME } from './data-sign-utils.const';\nimport {\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME,\n} from './data-sign-utils.const';\n\nexport type TDATA_SIGN_UTIL_KEY_EXPORT_FORMAT_TYPE = JsonWebKey;\n\nexport type TDATA_SIGN_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE = {\n  [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: CryptoKey;\n  [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]?: CryptoKey;\n};\n\nexport type TDATA_SIGN_UTIL_SIGN_DATA_TYPES_NATIVE = TTypedArrays;\n\nexport type TDATA_SIGN_UTIL_SIGN_DATA_TYPES = object | string | number | TDATA_SIGN_UTIL_SIGN_DATA_TYPES_NATIVE;\n\nexport type TDATA_SIGN_UTIL_SIGN_KEY_TYPES =\n  | CryptoKey\n  | CryptoKeyPair\n  | string\n  | TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE\n  | TDATA_SIGN_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE;\n\nexport type TDATA_SIGN_UTIL_VERIFY_KEY_TYPES =\n  | CryptoKey\n  | CryptoKeyPair\n  | string\n  | TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE\n  | TDATA_SIGN_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE;\n\nexport type TDATA_SIGN_UTIL_IMPORT_KEY_TYPES =\n  | JsonWebKey\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Uint8ClampedArray\n  | Float32Array\n  | Float64Array\n  | DataView\n  | ArrayBuffer;\n\nexport type TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_NATIVE = TTypedArrays;\n\nexport type TDATA_SIGN_UTIL_VERIFY_DATA_TYPES = string | TTypedArrays;\n\nexport type TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_EXTENDED = TDATA_SIGN_UTIL_VERIFY_DATA_TYPES | {};\n\nexport type TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE = {\n  [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: TDATA_SIGN_UTIL_IMPORT_KEY_TYPES;\n  [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]?: string | TDATA_SIGN_UTIL_IMPORT_KEY_TYPES;\n  [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME]?: string | TDATA_SIGN_UTIL_IMPORT_KEY_TYPES;\n};\n\nexport type TDATA_SIGN_UTIL_KEYPAIR_IMPORT_TYPE = {\n  [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: TDATA_SIGN_UTIL_IMPORT_KEY_TYPES;\n  [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]?: TDATA_SIGN_UTIL_IMPORT_KEY_TYPES;\n  [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME]?: TDATA_SIGN_UTIL_IMPORT_KEY_TYPES;\n};\n","/home/paul/projects/protocol/src/utils/data-sign-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/data-sign-utils/keys.data-sign-utils.ts",["3381","3382","3383","3384","3385","3386","3387","3388","3389","3390","3391","3392","3393","3394","3395","3396","3397","3398","3399","3400","3401","3402","3403","3404","3405","3406","3407","3408","3409","3410","3411","3412"],"import {\n  DATA_SIGN_CRYPTO_UTIL_GENERATE_KEYPAIR_OPTIONS,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_USAGES,\n  DATA_SIGN_CRYPTO_UTIL_PUBLIC_KEY_USAGE,\n  DATA_SIGN_CRYPTO_UTIL_PRIVATE_KEY_USAGE,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n  DATA_SIGN_CRYPTO_UTIL_KEY_DESC,\n  DATA_SIGN_CRYPTO_UTIL_KEYS_EXTRACTABLE,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME,\n  DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME,\n  KEY_NOT_FOUND_ERROR_MESSAGE,\n} from './data-sign-utils.const';\nimport { cryptoModuleDataSign } from './main.data-sign-utils.const';\nimport {\n  TDATA_SIGN_UTIL_KEY_EXPORT_FORMAT_TYPE,\n  TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE,\n  TDATA_SIGN_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE,\n  TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n  TDATA_SIGN_UTIL_IMPORT_KEY_TYPES,\n} from './data-sign-utils.types';\nimport { isCryptoKeyPair, getJWKOrBool } from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport { TEncryptionKeyStoreFormatType } from 'types/encryption-keys.types';\nimport { isTypedArray } from 'utils/typed-array-utils';\nimport { stringify } from 'utils/main-utils';\nimport { decryptDataByPassword } from '../password-utils/decrypt.password-utils';\nimport { DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME } from './data-sign-utils.const';\nimport { generateSalt } from '../encryption-utils/salt-utils';\nimport { encryptDataWithPassword } from '../password-utils/encrypt.password-utils';\nimport { TDATA_SIGN_UTIL_KEYPAIR_IMPORT_TYPE } from './data-sign-utils.types';\nimport { typedArrayToString } from '../typed-array-utils';\n\nexport const dataSignIsCryptoKeyPairImported = (\n  key: any,\n  checkPrivateKey: boolean = true\n): key is TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE => {\n  return (\n    typeof key === 'object' &&\n    !!key[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME] &&\n    (!checkPrivateKey || !!key[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME])\n  );\n};\n\nexport const dataSignGenerateKeyPair = (): PromiseLike<CryptoKeyPair> =>\n  cryptoModuleDataSign.generateKey(\n    DATA_SIGN_CRYPTO_UTIL_GENERATE_KEYPAIR_OPTIONS,\n    DATA_SIGN_CRYPTO_UTIL_KEYS_EXTRACTABLE,\n    DATA_SIGN_CRYPTO_UTIL_KEYPAIR_USAGES\n  );\n\nexport const dataSignExportKey = async (key: CryptoKey): Promise<TDATA_SIGN_UTIL_KEY_EXPORT_FORMAT_TYPE | Error> => {\n  try {\n    return await cryptoModuleDataSign.exportKey(DATA_SIGN_CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT, key);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignExportKeyAsString = async (key: CryptoKey): Promise<string | Error> => {\n  const keyExported = await dataSignExportKey(key);\n\n  if (keyExported instanceof Error) {\n    return keyExported;\n  }\n  try {\n    return stringify(keyExported);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignExportPublicKey = async (\n  keyPair: CryptoKeyPair\n): Promise<TDATA_SIGN_UTIL_KEY_EXPORT_FORMAT_TYPE | Error> => {\n  if (isCryptoKeyPair(keyPair)) {\n    return dataSignExportKey(keyPair.publicKey);\n  }\n  return new Error('Argument must be a CryptoKeyPair');\n};\n\nexport const dataSignExportPublicKeyAsString = async (keyPair: CryptoKeyPair): Promise<Error | string> => {\n  try {\n    const keyPublicExported = await dataSignExportPublicKey(keyPair);\n\n    if (keyPublicExported instanceof Error) {\n      return keyPublicExported;\n    }\n    return stringify(keyPublicExported);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignExportKeyPair = async (\n  keyPair: CryptoKeyPair,\n  password?: string\n): Promise<TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (isCryptoKeyPair(keyPair, !!password)) {\n      // do it in parallel\n      const [privateKey, publicKey] = await Promise.all([\n        password || keyPair.privateKey ? dataSignExportKey(keyPair.privateKey) : Promise.resolve(undefined),\n        dataSignExportKey(keyPair.publicKey),\n      ]).catch((err) => [err, err]);\n\n      if (privateKey instanceof Error) {\n        return privateKey;\n      }\n      if (publicKey instanceof Error) {\n        return publicKey;\n      }\n\n      const result: TDATA_SIGN_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE = {\n        [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: publicKey,\n        [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: privateKey,\n      };\n\n      if (password) {\n        const salt = generateSalt();\n\n        if (salt instanceof Error) {\n          return new Error('Failed to generate a unique salt value');\n        }\n\n        const encryptedPrivateKey = await encryptDataWithPassword(password, salt, privateKey);\n\n        if (encryptedPrivateKey instanceof Error) {\n          return new Error('Failed to encrypt private key with password provided');\n        }\n\n        const saltStringified = typedArrayToString(salt);\n\n        if (saltStringified instanceof Error) {\n          return new Error('Failed to stringify the salt value for the private data sign key');\n        }\n\n        const decryptedPrivateKey = await decryptDataByPassword(password, saltStringified, encryptedPrivateKey);\n\n        if (decryptedPrivateKey instanceof Error) {\n          return new Error('Failed to decrypt private key for data encryption');\n        }\n        result[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME] = saltStringified;\n        result[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME] = encryptedPrivateKey;\n      }\n      return result;\n    }\n    return new Error('Argument given must be a CryptoKeyPair');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignExportKeyPairAsString = async (keyPair: CryptoKeyPair, password?: string): Promise<string | Error> => {\n  try {\n    const res = await dataSignExportKeyPair(keyPair, password);\n\n    if (res instanceof Error) {\n      return res;\n    }\n    return stringify(res);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignImportKey = async (\n  key: TDATA_SIGN_UTIL_IMPORT_KEY_TYPES,\n  isPublic: boolean = true\n): Promise<CryptoKey | Error> => {\n  try {\n    if (typeof key !== 'object') {\n      return new Error('Unsupported argument type');\n    }\n    const res = await cryptoModuleDataSign.importKey(\n      DATA_SIGN_CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n      key,\n      DATA_SIGN_CRYPTO_UTIL_KEY_DESC,\n      DATA_SIGN_CRYPTO_UTIL_KEYS_EXTRACTABLE,\n      [isPublic ? DATA_SIGN_CRYPTO_UTIL_PUBLIC_KEY_USAGE : DATA_SIGN_CRYPTO_UTIL_PRIVATE_KEY_USAGE]\n    );\n\n    if (!(res instanceof CryptoKey)) {\n      return new Error(\"Can't import the key\");\n    }\n    return res;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignImportPublicKey = (key: TDATA_SIGN_UTIL_IMPORT_KEY_TYPES): PromiseLike<CryptoKey | Error> =>\n  dataSignImportKey(key, true);\n\nexport const dataSignImportPrivateKey = (key: TDATA_SIGN_UTIL_IMPORT_KEY_TYPES): PromiseLike<CryptoKey | Error> =>\n  dataSignImportKey(key, false);\n\nexport const dataSignImportKeyPair = async (\n  keyPair: TDATA_SIGN_UTIL_KEYPAIR_IMPORT_TYPE,\n  checkPrivateKey: boolean = true\n): Promise<TDATA_SIGN_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (dataSignIsCryptoKeyPairImported(keyPair, checkPrivateKey)) {\n      const privateKeyToImport = keyPair[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME];\n      if (checkPrivateKey && !privateKeyToImport) {\n        return new Error('The private key is empty');\n      }\n      const importResult = await Promise.all([\n        dataSignImportPublicKey(keyPair[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]),\n        checkPrivateKey || privateKeyToImport\n          ? dataSignImportPrivateKey(privateKeyToImport!)\n          : (Promise.resolve(undefined) as any),\n      ]).catch((err) => [err, err]);\n      const publicKey = importResult[0];\n      let privateKey = importResult[1];\n\n      if (publicKey instanceof Error) {\n        return publicKey;\n      }\n      if (privateKey instanceof Error) {\n        if (checkPrivateKey) {\n          return privateKey;\n        }\n        privateKey = undefined;\n      }\n      return {\n        [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: publicKey,\n        [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: privateKey,\n      };\n    }\n    return new Error('The argument must be an instance of CryptoKeyPair');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignImportKeyPairFromString = async (\n  keyPairString: string,\n  password?: string\n): Promise<TDATA_SIGN_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (typeof keyPairString === 'string') {\n      const keyPairObject = JSON.parse(keyPairString);\n\n      if (password && keyPairObject[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME]) {\n        if (typeof keyPairObject[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME] !== 'string') {\n          return new Error('A salt value must be a string');\n        }\n\n        const decryptedPrivateKey = await decryptDataByPassword(\n          password,\n          keyPairObject[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME],\n          keyPairObject[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]\n        );\n\n        if (decryptedPrivateKey instanceof Error) {\n          console.error('Failed to decrypt the data sign private key');\n          return decryptedPrivateKey;\n        }\n        try {\n          keyPairObject[DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME] = JSON.parse(decryptedPrivateKey);\n        } catch (err) {\n          console.error(err);\n          return new Error('Failed to parse datasign Private key from the string decrypted');\n        }\n      }\n      if (dataSignIsCryptoKeyPairImported(keyPairObject, !!password)) {\n        return await dataSignImportKeyPair(keyPairObject as TDATA_SIGN_UTIL_KEYPAIR_IMPORT_TYPE, !!password);\n      }\n      return new Error('There is a wrong format for the imported key pair');\n    }\n    return new Error('The key must be a string');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignImportKeyFromString = (\n  keyString: string,\n  isPublic: boolean = true\n): PromiseLike<CryptoKey | Error> | Error => {\n  try {\n    if (typeof keyString !== 'string') {\n      return new Error('The key must be a string');\n    }\n\n    const parsedKey = JSON.parse(keyString);\n\n    return dataSignImportKey(parsedKey, isPublic);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const dataSignImportPublicKeyFromString = (key: string): PromiseLike<CryptoKey | Error> | Error =>\n  dataSignImportKeyFromString(key, true);\n\nexport const dataSignImportPrivateKeyFromString = (key: string): PromiseLike<CryptoKey | Error> | Error =>\n  dataSignImportKeyFromString(key, false);\n\nexport const dataSignCheckIfStringIsKeyPair = (keyString: string): boolean => {\n  return (\n    keyString.includes(DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME) &&\n    keyString.includes(DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME)\n  );\n};\n\nexport const dataSignGetKeyOfType = async (key: TDATA_SIGN_UTIL_SIGN_KEY_TYPES, type: KeyType): Promise<CryptoKey | Error> => {\n  if (typeof key === 'string') {\n    if (dataSignCheckIfStringIsKeyPair(key)) {\n      const keyPair = await dataSignImportKeyPairFromString(key);\n\n      if (keyPair instanceof Error) {\n        return keyPair;\n      }\n      return dataSignGetKeyOfType(keyPair, type);\n    } else {\n      const keyFromString = await dataSignImportKeyFromString(key, type === 'public');\n\n      if (keyFromString instanceof Error) {\n        return keyFromString;\n      }\n      return dataSignGetKeyOfType(keyFromString, type);\n    }\n  }\n  if (key instanceof CryptoKey) {\n    return key.type === type ? key : new Error(KEY_NOT_FOUND_ERROR_MESSAGE);\n  }\n  if (typeof key === 'object') {\n    const keys = Object.values(key);\n    const keyResulted = keys.find((k: CryptoKey) => k && k.type && k.type === type);\n\n    return keyResulted || new Error(KEY_NOT_FOUND_ERROR_MESSAGE);\n  }\n  return new Error('There is an unsupported type of the key given');\n};\n\n/**\n * import an encryption key from a\n * supported format of an exported key\n * and returns a crypto key in native\n * format\n * @param {} key\n */\nexport const dataSignImportEncryptionKey = async (key: TEncryptionKeyStoreFormatType): Promise<CryptoKey | Error> => {\n  if (isTypedArray(key)) {\n    return dataSignImportKey(key);\n  } else {\n    const jwk = getJWKOrBool(key);\n\n    if (typeof jwk === 'object') {\n      return dataSignImportKey(jwk);\n    } else if (typeof key === 'string') {\n      return dataSignImportKeyFromString(key);\n    }\n  }\n  return new Error('There is an unknown key format');\n};\n\n/**\n * import an encryption key from a\n * supported format of an exported key\n * and returns a crypto key as a string\n * @param {} key\n */\nexport const dataSignConvertAndExportKeyAsString = async (key: TEncryptionKeyStoreFormatType): Promise<string | Error> => {\n  const cryptoKeyImported = await dataSignImportEncryptionKey(key);\n\n  if (cryptoKeyImported instanceof Error) {\n    return cryptoKeyImported;\n  }\n  return dataSignExportKeyAsString(cryptoKeyImported);\n};\n","/home/paul/projects/protocol/src/utils/data-sign-utils/main.data-sign-utils.const.ts",["3413","3414","3415","3416","3417"],"if (!window.crypto) {\n  window.CryptoKey = require('@trust/webcrypto/src/keys/CryptoKey');\n  window.CryptoKeyPair = require('@trust/webcrypto/src/keys/CryptoKeyPair');\n  (window as any).JsonWebKey = require('@trust/webcrypto/src/keys/JsonWebKey');\n}\n\nexport const ENCRYPTION_FORMAT_SUPPORTED = !window.crypto ? 'SHA-1' : undefined;\n// TODO - check isomorphic-webcrypto to use\n\nexport const crypto = window.crypto || require('@trust/webcrypto');\n\nexport const cryptoModuleDataSign = crypto.subtle;\n","/home/paul/projects/protocol/src/utils/data-sign-utils/sign-data.encryption-utils.ts",["3418","3419"],"import { cryptoModuleDataSign } from './main.data-sign-utils.const';\nimport { DATA_SIGN_CRYPTO_UTIL_DATA_SIGN_AND_VERIFY_PARAMS, DATA_SIGN_CRYPTO_UTIL_SIGN_KEY_TYPE } from './data-sign-utils.const';\nimport {\n  TDATA_SIGN_UTIL_SIGN_DATA_TYPES,\n  TDATA_SIGN_UTIL_SIGN_DATA_TYPES_NATIVE,\n  TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n} from './data-sign-utils.types';\nimport { dataSignGetKeyOfType, dataSignExportKey } from './keys.data-sign-utils';\nimport { convertToTypedArray, typedArrayToString } from 'utils/typed-array-utils';\n\nexport const signNative = async (key: CryptoKey, data: TDATA_SIGN_UTIL_SIGN_DATA_TYPES_NATIVE): Promise<ArrayBuffer | Error> => {\n  if (key.type !== DATA_SIGN_CRYPTO_UTIL_SIGN_KEY_TYPE) {\n    return new Error(`The type of the key ${key.type} may not be used for data signing`);\n  }\n  try {\n    const res = await cryptoModuleDataSign.sign({ ...DATA_SIGN_CRYPTO_UTIL_DATA_SIGN_AND_VERIFY_PARAMS }, key, data);\n\n    return res;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const signToTypedArray = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n  data: TDATA_SIGN_UTIL_SIGN_DATA_TYPES\n): Promise<ArrayBuffer | Error> => {\n  const k = await dataSignGetKeyOfType(key, DATA_SIGN_CRYPTO_UTIL_SIGN_KEY_TYPE);\n\n  if (k instanceof Error) {\n    return k;\n  }\n\n  const d = convertToTypedArray(data);\n\n  if (d instanceof Error) {\n    return d;\n  }\n\n  return signNative(k, d);\n};\n\nexport const signToString = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: TDATA_SIGN_UTIL_SIGN_KEY_TYPES,\n  data: TDATA_SIGN_UTIL_SIGN_DATA_TYPES\n): Promise<string | Error> => {\n  const signedHashData = await signToTypedArray(key, data);\n\n  if (signedHashData instanceof Error) {\n    return signedHashData;\n  }\n\n  return typedArrayToString(signedHashData);\n};\n","/home/paul/projects/protocol/src/utils/data-sign-utils/verify-data.encryption-utils.ts",["3420","3421"],"import { isTypedArray, stringToTypedArray, typedArrayToString } from 'utils/typed-array-utils';\nimport { stringify } from 'utils/main-utils';\nimport { cryptoModuleDataSign } from './main.data-sign-utils.const';\nimport {\n  DATA_SIGN_CRYPTO_UTIL_VERIFY_KEY_TYPE,\n  DATA_SIGN_CRYPTO_UTIL_DATA_SIGN_AND_VERIFY_PARAMS,\n} from './data-sign-utils.const';\nimport {\n  TDATA_SIGN_UTIL_VERIFY_DATA_TYPES,\n  TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_EXTENDED,\n  TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_NATIVE,\n  TDATA_SIGN_UTIL_VERIFY_KEY_TYPES,\n} from './data-sign-utils.types';\nimport { dataSignGetKeyOfType } from './keys.data-sign-utils';\n\nexport const verifyNative = async (\n  key: CryptoKey,\n  data: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_NATIVE,\n  signature: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_NATIVE\n): Promise<true | Error> => {\n  if (key.type !== DATA_SIGN_CRYPTO_UTIL_VERIFY_KEY_TYPE) {\n    return new Error(`The type of the key ${key.type} may not be used for data decryption`);\n  }\n  if (!isTypedArray(data)) {\n    return new Error('The data type is not supported');\n  }\n  try {\n    const res = await cryptoModuleDataSign.verify({ ...DATA_SIGN_CRYPTO_UTIL_DATA_SIGN_AND_VERIFY_PARAMS }, key, signature, data);\n\n    return res !== true ? new Error('The signature for the data is not valid') : true;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const verifyData = async (\n  key: TDATA_SIGN_UTIL_VERIFY_KEY_TYPES,\n  data: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES_EXTENDED,\n  signature: TDATA_SIGN_UTIL_VERIFY_DATA_TYPES\n): Promise<true | Error> => {\n  const k = await dataSignGetKeyOfType(key, DATA_SIGN_CRYPTO_UTIL_VERIFY_KEY_TYPE);\n\n  if (k instanceof Error) {\n    return k;\n  }\n\n  let d;\n\n  if (isTypedArray(data)) {\n    d = data;\n  } else if (typeof data === 'object' && !(data instanceof Error)) {\n    d = stringify(data);\n\n    if (d instanceof Error) {\n      return d;\n    }\n    d = stringToTypedArray(d);\n  } else if (typeof data === 'string') {\n    d = stringToTypedArray(data);\n  } else {\n    return new Error('Unsupported data type');\n  }\n  if (d instanceof Error) {\n    return d;\n  }\n\n  const s = typeof signature === 'string' ? stringToTypedArray(signature) : signature;\n\n  if (s instanceof Error) {\n    return s;\n  }\n  return verifyNative(k, d, s);\n};\n","/home/paul/projects/protocol/src/utils/data-validators-utils/data-validators-utils-common.ts",["3422","3423","3424","3425","3426","3427","3428","3429","3430","3431"],"import {\n  CONST_VALIDATION_SCHEMES_URI,\n  CONST_VALIDATION_SCHEMES_URL,\n  CONST_VALIDATION_SCHEMES_UUID_V4,\n  CONST_VALIDATION_SCHEMES_EMAIL,\n  CONST_VALIDATION_SCHEMES_LOGIN,\n} from 'const/const-validation-schemes/const-validation-schemes-common';\nimport { validateBySchema } from 'utils/validation-utils/validation-utils';\n\nexport const dataValidatorUtilURI = (v: any): boolean => {\n  return validateBySchema(CONST_VALIDATION_SCHEMES_URI, v);\n};\n\nexport const dataValidatorUtilURL = (v: any): boolean => {\n  const result = validateBySchema(CONST_VALIDATION_SCHEMES_URL, v);\n\n  return result;\n};\n\nexport const dataValidatorUtilUUIDV4 = (v: any): boolean => {\n  return validateBySchema(CONST_VALIDATION_SCHEMES_UUID_V4, v);\n};\n\nexport const dataValidatorUtilEmail = (v: any): boolean => {\n  return validateBySchema(CONST_VALIDATION_SCHEMES_EMAIL, v);\n};\n\nexport const dataValidatorUtilSafeLogin = (v: any): boolean => {\n  return validateBySchema(CONST_VALIDATION_SCHEMES_LOGIN, v);\n};\n","/home/paul/projects/protocol/src/utils/data-validators-utils/data-validators-utils.ts",[],"/home/paul/projects/protocol/src/utils/data-validators-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/encryption-keys-utils/encryption-keys-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/encryption-keys-utils/encryption-keys-utils.ts",["3432","3433","3434","3435","3436","3437","3438","3439","3440","3441","3442","3443","3444","3445","3446","3447","3448","3449","3450","3451","3452","3453","3454","3455","3456","3457"],"import { CONST_CRYPTO_KEYS_TYPES, CONST_CRYPTO_KEYS_TYPES_EXPORT_FORMATS } from 'const/const-crypto-keys/const-crypto-keys';\nimport {\n  HASH_CALCULATION_UTILS_DEFAULT_HASH_ALHORITHM,\n  HASH_CALCULATION_UTILS_HASH_ALHORITHM,\n} from 'utils/hash-calculation-utils/hash-calculation-utils.const';\nimport { encodeArrayBufferToDOMString } from 'utils/string-encoding-utils';\n\nimport { commonUtilsArrayIncludesAll } from '../common-utils/common-utils-array';\nimport { eCRYPTO_UTILS_KEYS_USAGES } from '../encryption-utils/crypto-utils.const';\nimport { calculateHash, calculateHashNative } from './../hash-calculation-utils/hash-calculation-utils';\nimport {\n  ENCRYPTIONS_KEYS_UTILS_JWK_FORMAT_OBJECT_KEYS,\n  MIN_JWK_PROPS_COUNT,\n  MIN_JWK_STRING_LENGTH,\n} from './encryption-keys-utils.const';\nimport { crypto } from '../data-sign-utils/main.data-sign-utils.const';\n\nexport const isCryptoKey = (v: any): v is CryptoKey => v instanceof CryptoKey;\n\nexport const isCryptoKeyPair = (keyPair: any, checkPrivateKeys: boolean = true): keyPair is CryptoKeyPair => {\n  return typeof keyPair === 'object' && isCryptoKey(keyPair.publicKey) && (!checkPrivateKeys || isCryptoKey(keyPair.privateKey));\n};\n\nexport const isCryptoKeyIncludesUsages = (\n  cryptoKey: CryptoKey,\n  expectedUsages: eCRYPTO_UTILS_KEYS_USAGES[] | eCRYPTO_UTILS_KEYS_USAGES\n): boolean => {\n  const { usages } = cryptoKey;\n\n  if (typeof expectedUsages === 'string') {\n    return usages.includes(expectedUsages);\n  }\n  return commonUtilsArrayIncludesAll(usages, expectedUsages as string[]);\n};\n\nexport const isCryptoKeyDataSign = (cryptoKey: any): cryptoKey is CryptoKey =>\n  isCryptoKey(cryptoKey) && isCryptoKeyIncludesUsages(cryptoKey, eCRYPTO_UTILS_KEYS_USAGES.sign);\n\nexport const isCryptoKeyDataVerify = (cryptoKey: any): cryptoKey is CryptoKey =>\n  isCryptoKey(cryptoKey) && isCryptoKeyIncludesUsages(cryptoKey, eCRYPTO_UTILS_KEYS_USAGES.verify);\n\nexport const isCryptoKeyDataEncryption = (cryptoKey: any): cryptoKey is CryptoKey =>\n  isCryptoKey(cryptoKey) && isCryptoKeyIncludesUsages(cryptoKey, eCRYPTO_UTILS_KEYS_USAGES.encrypt);\n\nexport const isCryptoKeyDataDecryption = (cryptoKey: any): cryptoKey is CryptoKey =>\n  isCryptoKey(cryptoKey) && isCryptoKeyIncludesUsages(cryptoKey, eCRYPTO_UTILS_KEYS_USAGES.decrypt);\n\nexport const isCryptoKeyPairExportedAsString = (keyPair: any): boolean => {\n  return typeof keyPair === 'string' && keyPair.length >= MIN_JWK_STRING_LENGTH;\n};\n\nexport const isJWK = (keyObject: object, isReturnError: boolean = false): Error | boolean => {\n  if (keyObject && typeof keyObject === 'object') {\n    const options = Object.keys(keyObject);\n    const optionsCount = options.length;\n\n    if (optionsCount > MIN_JWK_PROPS_COUNT) {\n      let idx = 0;\n      let optionName: string;\n\n      for (; idx < optionsCount; idx += 1) {\n        optionName = options[idx];\n        if (!ENCRYPTIONS_KEYS_UTILS_JWK_FORMAT_OBJECT_KEYS.includes(optionName)) {\n          return isReturnError ? new Error(`There is an unknown property ${optionName}`) : false;\n        }\n      }\n      return true;\n    }\n  }\n  return isReturnError ? new Error('There is a wrong format of JWK') : false;\n};\n\nexport const getJWK = (key: any, isReturnError: boolean = false): JsonWebKey | boolean | Error => {\n  let keyObject = key;\n\n  if (typeof key === 'string' && key.length > MIN_JWK_STRING_LENGTH) {\n    try {\n      keyObject = JSON.parse(key);\n    } catch (e) {\n      return e;\n    }\n  }\n\n  const isJWKValid = isJWK(keyObject, isReturnError);\n\n  if (isJWKValid === true) {\n    return keyObject as JsonWebKey;\n  }\n  return isJWKValid instanceof Error ? isJWKValid : new Error('There is a wrong format of JWK');\n};\n\nexport const getJWKOrError = (key: any): JsonWebKey | Error => getJWK(key, true) as JsonWebKey | Error;\n\nexport const getJWKOrBool = (key: any): JsonWebKey | boolean => getJWK(key, false) as JsonWebKey | boolean;\n\nexport const exportCryptokeyInFormat = async (\n  key: CryptoKey,\n  format: CONST_CRYPTO_KEYS_TYPES_EXPORT_FORMATS\n): Promise<ArrayBuffer | JsonWebKey | Error> => {\n  try {\n    const result = await crypto.subtle.exportKey(format, key);\n\n    if (result instanceof Error) {\n      console.error(result);\n      return new Error('exportCryptokeyInFormat::error returned from the exportKey');\n    }\n    return result;\n  } catch (err) {\n    console.error(err);\n    return new Error('exportCryptokeyInFormat::An error thrown when export the crypto key');\n  }\n};\n\n/**\n * calculates hash string of the crypto key\n * @param {CryptoKey} key\n */\nexport const calcCryptoKeyHash = async (\n  key: CryptoKey,\n  alg: HASH_CALCULATION_UTILS_HASH_ALHORITHM = HASH_CALCULATION_UTILS_DEFAULT_HASH_ALHORITHM\n): Promise<Error | string> => {\n  if (!(key instanceof CryptoKey)) {\n    return new Error('Key os not an instance of CryptoKey');\n  }\n  if (!key.extractable) {\n    return new Error('The crypto key is not extractable');\n  }\n\n  let format: CONST_CRYPTO_KEYS_TYPES_EXPORT_FORMATS = CONST_CRYPTO_KEYS_TYPES_EXPORT_FORMATS.RAW;\n  const keyAlgName = key.algorithm.name.toLowerCase();\n\n  if (keyAlgName.includes('rsa-') || keyAlgName.includes('ecdsa')) {\n    if (key.type.includes(CONST_CRYPTO_KEYS_TYPES.PUBLIC)) {\n      format = CONST_CRYPTO_KEYS_TYPES_EXPORT_FORMATS.SPKI;\n    } else {\n      format = CONST_CRYPTO_KEYS_TYPES_EXPORT_FORMATS.PKCS8;\n    }\n  }\n\n  const exportedCryptoKey = await exportCryptokeyInFormat(key, format);\n\n  if (exportedCryptoKey instanceof Error) {\n    console.error(exportedCryptoKey);\n    return new Error('Failed to export the crypto key in the RAW format');\n  }\n\n  const hashCalcResult = await calculateHashNative(exportedCryptoKey as ArrayBuffer, alg);\n\n  if (hashCalcResult instanceof Error) {\n    console.error(hashCalcResult);\n    return new Error('Failed to calculate a hash for the exported crypto key');\n  }\n  return encodeArrayBufferToDOMString(hashCalcResult);\n};\n\n// allow to absent for a private keys in a pairs\nexport const calcCryptoKeyPairHash = async (\n  cryptoPair: CryptoKeyPair,\n  alg?: HASH_CALCULATION_UTILS_HASH_ALHORITHM\n): Promise<Error | string> => {\n  const pending = [calcCryptoKeyHash(cryptoPair.publicKey)];\n\n  if (cryptoPair.privateKey) {\n    pending.push(calcCryptoKeyHash(cryptoPair.privateKey));\n  }\n\n  const results = await Promise.all(pending);\n\n  if (results[0] instanceof Error) {\n    return new Error('Failed to calculate hash of the private key');\n  }\n  if (results[1] instanceof Error) {\n    return new Error('Failed to calculate hash of the puclic key');\n  }\n  return calculateHash(`${results[0]}___${results[1]}`);\n};\n","/home/paul/projects/protocol/src/utils/encryption-keys-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/crypto-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/crypto-utils.types.ts",["3458","3459"],"import { TTypedArrays } from 'types/main.types';\nimport { CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME } from './crypto-utils.const';\nimport { CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME, CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME } from './crypto-utils.const';\n\nexport type TCRYPTO_UTIL_IMPORT_KEY_TYPES = TTypedArrays | ArrayBuffer;\n\nexport type TCRYPTO_UTIL_KEY_EXPORT_FORMAT_TYPE = object;\n\nexport type TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE = {\n  [CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: TCRYPTO_UTIL_IMPORT_KEY_TYPES;\n  [CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: string | TCRYPTO_UTIL_IMPORT_KEY_TYPES;\n  [CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME]?: string | TCRYPTO_UTIL_IMPORT_KEY_TYPES;\n};\n\nexport type TCRYPTO_UTIL_KEYPAIR_PREIMPORT_FORMAT_TYPE = {\n  [CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: TCRYPTO_UTIL_IMPORT_KEY_TYPES;\n  [CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: TCRYPTO_UTIL_IMPORT_KEY_TYPES;\n  [CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME]?: TCRYPTO_UTIL_IMPORT_KEY_TYPES;\n};\n\nexport type TCRYPTO_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE = {\n  [CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: CryptoKey;\n  [CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]?: CryptoKey;\n  [CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME]?: string;\n};\n\nexport type TCRYPTO_UTIL_ENCRYPT_DATA_TYPES_NATIVE = TTypedArrays;\n\nexport type TCRYPTO_UTIL_ENCRYPT_DATA_TYPES = object | string | number | TCRYPTO_UTIL_ENCRYPT_DATA_TYPES_NATIVE;\n\nexport type TCRYPTO_UTIL_ENCRYPT_KEY_TYPES =\n  | CryptoKey\n  | CryptoKeyPair\n  | string\n  | TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE\n  | TCRYPTO_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE;\n\nexport type TCRYPTO_UTIL_DECRYPT_KEY_TYPES =\n  | CryptoKey\n  | CryptoKeyPair\n  | string\n  | TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE\n  | TCRYPTO_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE;\n\nexport type TCRYPTO_UTIL_DECRYPT_DATA_TYPES_NATIVE = TTypedArrays;\n\nexport type TCRYPTO_UTIL_DECRYPT_DATA_TYPES = string | TTypedArrays;\n\nexport type TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG =\n  | string\n  | RsaOaepParams\n  | AesCtrParams\n  | AesCbcParams\n  | AesCmacParams\n  | AesGcmParams\n  | AesCfbParams;\n\nexport type TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR = {\n  iv: ArrayBuffer;\n  data: ArrayBuffer;\n};\n\nexport type TCRYPTO_UTILS_DECRYPT_DATA_KEY_CONFIG =\n  | string\n  | RsaOaepParams\n  | AesCtrParams\n  | AesCbcParams\n  | AesCmacParams\n  | AesGcmParams\n  | AesCfbParams;\n","/home/paul/projects/protocol/src/utils/encryption-utils/decrypt-data.encryption-utils.ts",["3460","3461"],"import { isTypedArray, stringToTypedArray, typedArrayToString } from 'utils/typed-array-utils';\nimport { cryptoModule } from './main.crypto-utils.const';\nimport { CRYPTO_UTIL_DECRIPTION_KEY_TYPE, CRYPTO_UTIL_KEY_DESC } from './crypto-utils.const';\nimport {\n  TCRYPTO_UTIL_DECRYPT_DATA_TYPES,\n  TCRYPTO_UTIL_DECRYPT_DATA_TYPES_NATIVE,\n  TCRYPTO_UTIL_DECRYPT_KEY_TYPES,\n  TCRYPTO_UTILS_DECRYPT_DATA_KEY_CONFIG,\n} from './crypto-utils.types';\nimport { getKeyOfType } from './keys.encryption-utils';\nimport { stringify } from 'utils/main-utils';\n\nexport const decryptNative = async (\n  key: CryptoKey,\n  data: TCRYPTO_UTIL_DECRYPT_DATA_TYPES_NATIVE,\n  decryptKeyParams: TCRYPTO_UTILS_DECRYPT_DATA_KEY_CONFIG = CRYPTO_UTIL_KEY_DESC\n): Promise<ArrayBuffer | Error> => {\n  if (!isTypedArray(data)) {\n    return new Error('The data type is not supported');\n  }\n  try {\n    const res = await cryptoModule.decrypt(decryptKeyParams, key, data);\n\n    return res;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const decryptDataFromString = async (\n  key: TCRYPTO_UTIL_DECRYPT_KEY_TYPES,\n  data: TCRYPTO_UTIL_DECRYPT_DATA_TYPES | object,\n  decryptKeyParams?: TCRYPTO_UTILS_DECRYPT_DATA_KEY_CONFIG\n): Promise<ArrayBuffer | Error> => {\n  let k;\n\n  if (key instanceof CryptoKey) {\n    k = key;\n  } else {\n    k = await getKeyOfType(key, CRYPTO_UTIL_DECRIPTION_KEY_TYPE);\n  }\n  if (k instanceof Error) {\n    return k;\n  }\n\n  let d;\n\n  if (isTypedArray(data)) {\n    d = data;\n  } else if (typeof data === 'object' && !(data instanceof Error)) {\n    d = stringify(data);\n\n    if (d instanceof Error) {\n      return d;\n    }\n    d = stringToTypedArray(d);\n  } else if (typeof data === 'string') {\n    d = stringToTypedArray(data);\n  } else {\n    return new Error('Unsupported data type');\n  }\n  if (d instanceof Error) {\n    return d;\n  }\n  return decryptNative(k, d, decryptKeyParams);\n};\n\nexport const decryptData = async (\n  key: TCRYPTO_UTIL_DECRYPT_KEY_TYPES,\n  data: TCRYPTO_UTIL_DECRYPT_DATA_TYPES,\n  decryptKeyParams?: TCRYPTO_UTILS_DECRYPT_DATA_KEY_CONFIG\n): Promise<string | Error> => {\n  const decryptedData = await decryptDataFromString(key, data, decryptKeyParams);\n\n  if (decryptedData instanceof Error) {\n    return decryptedData;\n  }\n  return typedArrayToString(decryptedData);\n};\n","/home/paul/projects/protocol/src/utils/encryption-utils/encrypt-data.encryption-utils.ts",["3462","3463","3464","3465","3466"],"import { cryptoModule } from './main.crypto-utils.const';\nimport { crypto } from '../data-sign-utils/main.data-sign-utils.const';\nimport {\n  CRYPTO_UTIL_KEY_DESC,\n  CRYPTO_UTIL_ENCRYPTION_KEY_TYPE,\n  INITIALIZATION_VECTOR_DEFAULT_LENGTH,\n} from './crypto-utils.const';\nimport {\n  TCRYPTO_UTIL_ENCRYPT_DATA_TYPES,\n  TCRYPTO_UTIL_ENCRYPT_DATA_TYPES_NATIVE,\n  TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n  TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG,\n  TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR,\n} from './crypto-utils.types';\nimport { getKeyOfType, exportKey } from './keys.encryption-utils';\nimport {\n  convertToTypedArray,\n  typedArrayToString,\n  arrayBufferFromTypedArray,\n  concatArrayBuffers,\n  getBytesFromArrayBuffer,\n} from 'utils/typed-array-utils';\nimport { decodeDOMStringToArrayBuffer } from 'utils/string-encoding-utils';\n\n/**\n * return a random vector, used e.g. for aes-gcm\n * encryption\n * @param vectorLength - lenght of the vector generated\n */\nexport const generateInitializationVectorNative = (\n  vectorLength: number = INITIALIZATION_VECTOR_DEFAULT_LENGTH\n): Uint8Array | Error => {\n  try {\n    return crypto.getRandomValues(new Uint8Array(vectorLength));\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const generateInitializationVectorNativeArrayBuffer = (vectorLength?: number): ArrayBuffer | Error => {\n  const iv = generateInitializationVectorNative(vectorLength);\n\n  if (iv instanceof Error) {\n    return iv;\n  }\n  return arrayBufferFromTypedArray(iv);\n};\n\nexport const concatDataWithInitializationVector = (\n  options: TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR\n): ArrayBuffer | Error => {\n  try {\n    return concatArrayBuffers(options.iv, options.data);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const getInitializationVectorFromData = (\n  arrayBuffer: ArrayBuffer,\n  ivLengthBytes: number = INITIALIZATION_VECTOR_DEFAULT_LENGTH\n): TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR | Error => {\n  try {\n    const iv = getBytesFromArrayBuffer(arrayBuffer, 0, ivLengthBytes);\n\n    if (iv instanceof Error) {\n      return iv;\n    }\n\n    const data = getBytesFromArrayBuffer(arrayBuffer, ivLengthBytes);\n\n    if (data instanceof Error) {\n      return data;\n    }\n    return {\n      iv,\n      data,\n    };\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const getInitializationVectorFromDataString = (\n  data: string,\n  ivLengthBytes?: number\n): TCRYPTO_UTILS_DATA_WITH_INITIALIZATION_VECTOR | Error => {\n  const dataArrayBuffer = decodeDOMStringToArrayBuffer(data);\n\n  if (dataArrayBuffer instanceof Error) {\n    return dataArrayBuffer;\n  }\n  return getInitializationVectorFromData(dataArrayBuffer, ivLengthBytes);\n};\n\nexport const encryptNative = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: CryptoKey,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES_NATIVE,\n  //an optional params for the encryption method\n  cryptoKeyConfig: TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG = CRYPTO_UTIL_KEY_DESC\n): Promise<ArrayBuffer | Error> => {\n  try {\n    const res = await cryptoModule.encrypt(cryptoKeyConfig, key, data);\n\n    return res;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const encryptToTypedArray = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES,\n  //an optional params for the encryption method\n  cryptoKeyConfig?: TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG\n): Promise<ArrayBuffer | Error> => {\n  let k;\n\n  if (key instanceof CryptoKey) {\n    k = key;\n  } else {\n    k = await getKeyOfType(key, CRYPTO_UTIL_ENCRYPTION_KEY_TYPE);\n  }\n  if (k instanceof Error) {\n    return k;\n  }\n\n  const d = convertToTypedArray(data);\n\n  if (d instanceof Error) {\n    return d;\n  }\n\n  return encryptNative(k, d, cryptoKeyConfig);\n};\n\nexport const encryptToString = async (\n  // crypto key using for data encryption\n  // a public key of the user in the current implementation\n  key: TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n  data: TCRYPTO_UTIL_ENCRYPT_DATA_TYPES,\n  //an optional params for the encryption method\n  cryptoKeyConfig?: TCRYPTO_UTILS_ENCRYPT_DATA_KEY_CONFIG\n): Promise<string | Error> => {\n  const encryptedData = await encryptToTypedArray(key, data);\n\n  if (encryptedData instanceof Error) {\n    return encryptedData;\n  }\n\n  return typedArrayToString(encryptedData);\n};\n","/home/paul/projects/protocol/src/utils/encryption-utils/encryption-utils.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/keys.encryption-utils.ts",["3467","3468","3469","3470","3471","3472","3473","3474","3475","3476","3477","3478","3479","3480","3481","3482","3483","3484","3485","3486","3487","3488","3489","3490","3491","3492","3493","3494","3495","3496","3497","3498","3499"],"import { isCryptoKeyPair } from 'utils/encryption-keys-utils/encryption-keys-utils';\nimport {\n  CRYPTO_UTIL_GENERATE_KEYPAIR_OPTIONS,\n  CRYPTO_UTIL_KEYPAIR_USAGES,\n  CRYPTO_UTIL_PUBLIC_KEY_USAGE,\n  CRYPTO_UTIL_PRIVATE_KEY_USAGE,\n  CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT,\n  CRYPTO_UTIL_KEY_DESC,\n  CRYPTO_UTIL_KEYS_EXTRACTABLE,\n  CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME,\n  CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME,\n} from './crypto-utils.const';\nimport { cryptoModule } from './main.crypto-utils.const';\nimport {\n  TCRYPTO_UTIL_KEY_EXPORT_FORMAT_TYPE,\n  TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE,\n  TCRYPTO_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE,\n  TCRYPTO_UTIL_ENCRYPT_KEY_TYPES,\n} from './crypto-utils.types';\nimport { stringify } from 'utils/main-utils';\nimport { decryptDataByPassword } from 'utils';\nimport { generateSalt } from './salt-utils';\nimport { CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME } from './crypto-utils.const';\nimport { encryptDataWithPassword } from '../password-utils/encrypt.password-utils';\nimport { encodeArrayBufferToDOMString } from '../string-encoding-utils';\nimport { TCRYPTO_UTIL_KEYPAIR_PREIMPORT_FORMAT_TYPE } from './crypto-utils.types';\nimport { typedArrayToString } from '../typed-array-utils';\n\nexport const isCryptoKeyPairImported = (\n  key: any,\n  checkPrivateKey: boolean = true\n): key is TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE => {\n  return (\n    typeof key === 'object' &&\n    !!key[CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME] &&\n    (!checkPrivateKey || !!key[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME])\n  );\n};\n\nexport const generateKeyPair = (): PromiseLike<CryptoKeyPair> =>\n  cryptoModule.generateKey(CRYPTO_UTIL_GENERATE_KEYPAIR_OPTIONS, CRYPTO_UTIL_KEYS_EXTRACTABLE, CRYPTO_UTIL_KEYPAIR_USAGES);\n\nexport const exportKey = (key: CryptoKey): PromiseLike<TCRYPTO_UTIL_KEY_EXPORT_FORMAT_TYPE | Error> => {\n  try {\n    return cryptoModule.exportKey(CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT, key);\n  } catch (err) {\n    console.error(err);\n    return err;\n  }\n};\n\nexport const exportKeyAsString = async (key: CryptoKey): Promise<Error | string> => {\n  return stringify(await exportKey(key));\n};\n\nexport const exportPublicKey = async (keyPair: CryptoKeyPair) => {\n  return exportKey(keyPair.publicKey);\n};\n\nexport const exportPublicKeyAsString = async (keyPair: CryptoKeyPair) => {\n  const publicKey = await exportPublicKey(keyPair);\n\n  if (publicKey instanceof Error) {\n    return publicKey;\n  }\n  return stringify(publicKey);\n};\n\nexport const exportKeyPair = async (\n  keyPair: CryptoKeyPair,\n  password?: string\n): Promise<TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (isCryptoKeyPair(keyPair, !!password)) {\n      // do it in parallel\n      const [privateKey, publicKey] = await Promise.all([\n        password || keyPair.privateKey ? exportKey(keyPair.privateKey) : Promise.resolve(undefined),\n        exportKey(keyPair.publicKey),\n      ]).catch((err) => [err, err]);\n\n      if (privateKey instanceof Error) {\n        return privateKey;\n      }\n      if (publicKey instanceof Error) {\n        return publicKey;\n      }\n\n      const result: TCRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT_TYPE = {\n        [CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: publicKey,\n        [CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: privateKey,\n      };\n\n      if (password) {\n        const salt = generateSalt();\n\n        if (salt instanceof Error) {\n          return new Error('Failed to generate a unique salt value');\n        }\n\n        const encryptedPrivateKey = await encryptDataWithPassword(password, salt, privateKey);\n\n        if (encryptedPrivateKey instanceof Error) {\n          return new Error('Failed to encrypt private key with password provided');\n        }\n\n        const saltStringified = typedArrayToString(salt);\n\n        if (saltStringified instanceof Error) {\n          return new Error('Failed to stringify the salt for the encryption private key');\n        }\n\n        const decryptedPrivateKey = await decryptDataByPassword(password, saltStringified, encryptedPrivateKey);\n\n        if (decryptedPrivateKey instanceof Error) {\n          return new Error('Failed to decrypt private key for data encryption');\n        }\n        result[CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME] = saltStringified;\n        result[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME] = encryptedPrivateKey;\n      }\n      return result;\n    }\n    return new Error('Argument given must be a CryptoKeyPair');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const exportKeyPairAsString = async (keyPair: CryptoKeyPair, password?: string): Promise<string | Error> => {\n  const exportedKeyPair = await exportKeyPair(keyPair, password);\n\n  if (exportedKeyPair instanceof Error) {\n    return exportedKeyPair;\n  }\n  try {\n    return stringify(exportedKeyPair);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importKey = (key: object, isPublic: boolean = true): PromiseLike<CryptoKey> => {\n  return cryptoModule.importKey(CRYPTO_UTIL_KEYPAIR_EXPORT_FORMAT, key, CRYPTO_UTIL_KEY_DESC, CRYPTO_UTIL_KEYS_EXTRACTABLE, [\n    isPublic ? CRYPTO_UTIL_PUBLIC_KEY_USAGE : CRYPTO_UTIL_PRIVATE_KEY_USAGE,\n  ]);\n};\n\nexport const importPublicKey = (key: object): PromiseLike<CryptoKey> => importKey(key, true);\n\nexport const importPrivateKey = (key: object): PromiseLike<CryptoKey> => importKey(key, false);\n\nexport const importKeyPair = async (\n  keyPair: TCRYPTO_UTIL_KEYPAIR_PREIMPORT_FORMAT_TYPE,\n  checkPrivateKey: boolean = true\n): Promise<TCRYPTO_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (isCryptoKeyPairImported(keyPair, checkPrivateKey)) {\n      const importResult = await Promise.all([\n        (async () => {\n          try {\n            return await importPublicKey(keyPair[CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]);\n          } catch (err) {\n            return err;\n          }\n        })(),\n        (async () => {\n          try {\n            if (checkPrivateKey || keyPair[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]) {\n              return await importPrivateKey(keyPair[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]);\n            }\n          } catch (err) {\n            return err;\n          }\n        })(),\n      ]);\n      const publicKey = importResult[0];\n      let privateKey = importResult[1];\n\n      if (publicKey instanceof Error) {\n        return publicKey;\n      }\n      if (privateKey instanceof Error) {\n        if (checkPrivateKey) {\n          return privateKey;\n        }\n        privateKey = undefined;\n      }\n      return {\n        [CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME]: publicKey,\n        [CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]: privateKey,\n      };\n    }\n    return new Error('The argument must be an instance of CryptoKeyPair');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importKeyPairFromString = async (\n  keyPairString: string,\n  password?: string\n): Promise<TCRYPTO_UTIL_KEYPAIR_IMPORT_FORMAT_TYPE | Error> => {\n  try {\n    if (typeof keyPairString === 'string') {\n      const keyPairObject = JSON.parse(keyPairString);\n\n      if (password && keyPairObject[CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME]) {\n        if (typeof keyPairObject[CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME] !== 'string') {\n          return new Error('A salt value must be a string');\n        }\n\n        const decryptedPrivateKey = await decryptDataByPassword(\n          password,\n          keyPairObject[CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME],\n          keyPairObject[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME]\n        );\n\n        if (decryptedPrivateKey instanceof Error) {\n          console.error('Failed to decrypt the data encryption private key');\n          return decryptedPrivateKey;\n        }\n        try {\n          keyPairObject[CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME] = JSON.parse(decryptedPrivateKey);\n        } catch (err) {\n          console.error(err);\n          return new Error('Failed to parse dataencryption Private key from the string decrypted');\n        }\n      }\n      return await importKeyPair(keyPairObject, !!password);\n    }\n    return new Error('A key pair must be a string');\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importKeyFromString = (keyString: string, isPublic: boolean = true): PromiseLike<CryptoKey> | Error => {\n  try {\n    return importKey(JSON.parse(keyString), isPublic);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importPublicKeyFromString = (key: string): PromiseLike<CryptoKey> | Error => importKeyFromString(key, true);\n\nexport const importPrivateKeyFromString = (key: string): PromiseLike<CryptoKey> | Error => importKeyFromString(key, false);\n\nexport const checkIfStringIsKeyPair = (keyString: string): boolean => {\n  return keyString.includes(CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME) && keyString.includes(CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME);\n};\n\nconst KEY_NOT_FOUND_ERROR_MESSAGE = 'A key of the required type was not found';\n\nexport const getKeyOfType = async (key: TCRYPTO_UTIL_ENCRYPT_KEY_TYPES, type: KeyType): Promise<CryptoKey | Error> => {\n  if (typeof key === 'string') {\n    if (checkIfStringIsKeyPair(key)) {\n      const keyPair = await importKeyPairFromString(key);\n\n      if (keyPair instanceof Error) {\n        return keyPair;\n      }\n      return getKeyOfType(keyPair, type);\n    } else {\n      const keyFromString = await importKeyFromString(key, type === 'public');\n\n      if (keyFromString instanceof Error) {\n        return keyFromString;\n      }\n      return getKeyOfType(keyFromString, type);\n    }\n  }\n  if (key instanceof CryptoKey) {\n    return key.type === type ? key : new Error(KEY_NOT_FOUND_ERROR_MESSAGE);\n  }\n  if (typeof key === 'object') {\n    const keys = Object.values(key);\n    const keyResulted = keys.find((k: CryptoKey) => k && k.type && k.type === type);\n\n    return keyResulted || new Error(KEY_NOT_FOUND_ERROR_MESSAGE);\n  }\n  return new Error('There is an unsupported type of the key given');\n};\n","/home/paul/projects/protocol/src/utils/encryption-utils/main.crypto-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/salt-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/encryption-utils/salt-utils.ts",["3500","3501"],"import { isTypedArrayNative, isEqualArrayBufferNative } from './../typed-array-utils';\nimport { TSaltUtilsSaltType } from './salt-utils.types';\nimport { isTypedArray, typedArrayToString, stringToTypedArray } from 'utils/typed-array-utils';\nimport {\n  SALT_GENERATION_UTILS_SALT_LENGTH_BYTES,\n  SALT_GENERATION_UTILS_SALT_MIN_LENGTH_BYTES,\n  SALT_GENERATION_UTILS_SALT_MAX_LENGTH_BYTES,\n} from './salt-utils.const';\n\nexport const generateSaltNative = (saltLength: number): Uint8Array | Error => {\n  try {\n    return crypto.getRandomValues(new Uint8Array(saltLength));\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const generateSalt = (saltLength: number = SALT_GENERATION_UTILS_SALT_LENGTH_BYTES): Uint8Array | Error => {\n  if (saltLength < SALT_GENERATION_UTILS_SALT_MIN_LENGTH_BYTES) {\n    return new Error(`The length ${saltLength} must not be less than the ${SALT_GENERATION_UTILS_SALT_MIN_LENGTH_BYTES}`);\n  }\n  if (saltLength > SALT_GENERATION_UTILS_SALT_MAX_LENGTH_BYTES) {\n    return new Error(`The length ${saltLength} should not be greater than ${SALT_GENERATION_UTILS_SALT_MAX_LENGTH_BYTES}`);\n  }\n  return generateSaltNative(saltLength);\n};\n\nexport const generateSaltString = (saltLength?: number): string | Error => {\n  const salt = generateSalt(saltLength);\n\n  if (salt instanceof Error) {\n    return salt;\n  }\n  return typedArrayToString(salt);\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isValidSalt = (salt: any): salt is TSaltUtilsSaltType => {\n  if (isTypedArrayNative(salt) || salt instanceof ArrayBuffer) {\n    const strFromTyped = typedArrayToString(salt);\n\n    if (strFromTyped instanceof Error) {\n      return false;\n    }\n\n    const typedFromStr = stringToTypedArray(strFromTyped);\n\n    if (typedFromStr instanceof Error) {\n      return false;\n    }\n    if (!isEqualArrayBufferNative(typedFromStr, salt)) {\n      return false;\n    }\n    return (\n      salt.byteLength >= SALT_GENERATION_UTILS_SALT_MIN_LENGTH_BYTES &&\n      salt.byteLength <= SALT_GENERATION_UTILS_SALT_MAX_LENGTH_BYTES\n    );\n  }\n  if (typeof salt === 'string') {\n    const typedFromStr = stringToTypedArray(salt);\n\n    if (typedFromStr instanceof Error) {\n      return false;\n    }\n\n    const strFromTyped = typedArrayToString(typedFromStr);\n\n    if (strFromTyped instanceof Error) {\n      return false;\n    }\n    if (salt !== strFromTyped) {\n      return false;\n    }\n    return (\n      typedFromStr.byteLength >= SALT_GENERATION_UTILS_SALT_MIN_LENGTH_BYTES &&\n      typedFromStr.byteLength <= SALT_GENERATION_UTILS_SALT_MAX_LENGTH_BYTES\n    );\n  }\n  return false;\n};\n\nexport const importSalt = (salt: TSaltUtilsSaltType): Uint8Array | Error => {\n  if (!isValidSalt(salt)) {\n    return new Error('The salt is not valid');\n  }\n\n  if (isTypedArray(salt)) {\n    // if a typed array then convert the salt directly\n    return new Uint8Array(salt);\n  }\n  // if a string then convert string to typed array\n  const saltImported = stringToTypedArray(salt);\n\n  if (saltImported instanceof Error) {\n    return saltImported;\n  }\n  return new Uint8Array(saltImported);\n};\n","/home/paul/projects/protocol/src/utils/encryption-utils/salt-utils.types.ts",[],"/home/paul/projects/protocol/src/utils/files-utils/files-utils-download.ts",["3502","3503"],"import path from 'path';\n\nexport const getFilenameByUrl = (url: string) => {\n  if (url.startsWith('data:')) {\n    return undefined;\n  }\n  return path.basename(url) || (url.split('/').pop() || '').split('#')[0].split('?')[0] || undefined;\n};\n\nexport const downloadFileByUrl = (url: string, filename: string = '') => {\n  const anchor = document.createElement('a');\n\n  anchor.download = filename || getFilenameByUrl(url) || 'unknown';\n  anchor.href = url;\n  anchor.target = '_blank';\n  document.body.appendChild(anchor);\n  anchor.click();\n  window.URL.revokeObjectURL(url);\n  document.body.removeChild(anchor);\n};\n\nexport const downloadFile = (file: File): void => {\n  const url = window.URL.createObjectURL(file);\n\n  downloadFileByUrl(url, file.name || url);\n};\n","/home/paul/projects/protocol/src/utils/files-utils/files-utils-size.ts",[],"/home/paul/projects/protocol/src/utils/files-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/firebase-utils/firebase-utils.ts",[],"/home/paul/projects/protocol/src/utils/firebase-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/hash-calculation-utils/hash-calculation-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/hash-calculation-utils/hash-calculation-utils.ts",["3504"],"import { TStringifyData, stringify } from 'utils/main-utils';\nimport { decodeDOMStringToArrayBuffer, encodeArrayBufferToDOMString } from 'utils/string-encoding-utils';\nimport { TTypedArrays } from 'types/main.types';\nimport {\n  HASH_CALCULATION_UTILS_DEFAULT_HASH_ALHORITHM,\n  HASH_CALCULATION_UTILS_HASH_ALHORITHM,\n} from './hash-calculation-utils.const';\nimport { cryptoModuleDataSign, crypto } from '../data-sign-utils/main.data-sign-utils.const';\n\nexport const hashCalculator = cryptoModuleDataSign.digest.bind(crypto.subtle);\n\nexport const calculateHashNative = async (\n  data: TTypedArrays,\n  alg: HASH_CALCULATION_UTILS_HASH_ALHORITHM\n): Promise<ArrayBuffer | Error> => {\n  try {\n    const hashString = await hashCalculator(alg, data);\n\n    return hashString;\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const calculateHash = async (\n  data: TStringifyData,\n  alg: HASH_CALCULATION_UTILS_HASH_ALHORITHM = HASH_CALCULATION_UTILS_DEFAULT_HASH_ALHORITHM\n): Promise<string | Error> => {\n  const dataAsString = stringify(data);\n\n  if (dataAsString instanceof Error) {\n    return dataAsString;\n  }\n\n  const dataAsArrayBuffer = decodeDOMStringToArrayBuffer(dataAsString);\n\n  if (dataAsArrayBuffer instanceof Error) {\n    return dataAsArrayBuffer;\n  }\n\n  const hashArrayBuffer = await calculateHashNative(dataAsArrayBuffer, alg);\n\n  if (hashArrayBuffer instanceof Error) {\n    return hashArrayBuffer;\n  }\n  return encodeArrayBufferToDOMString(hashArrayBuffer);\n};\n","/home/paul/projects/protocol/src/utils/hash-calculation-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/identity-utils/identity-utils.ts",["3505"],"import uuidV4 from 'uuid/v4';\n\nexport const generateUUID = () => uuidV4();\n","/home/paul/projects/protocol/src/utils/identity-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/index.ts",[],"/home/paul/projects/protocol/src/utils/ipfs-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils-libp2p/ipfs-utils-libp2p.const.ts",[],"/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils-libp2p/ipfs-utils-libp2p.ts",["3506","3507","3508","3509","3510","3511","3512","3513","3514","3515","3516","3517","3518","3519","3520","3521","3522","3523","3524","3525","3526","3527","3528","3529","3530","3531","3532","3533","3534","3535","3536"],"/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils.const.ts",["3537","3538","3539","3540"],"/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils.ts",["3541","3542","3543","3544","3545","3546","3547","3548","3549","3550","3551","3552","3553"],"/home/paul/projects/protocol/src/utils/lazy-loading-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/lazy-loading-utils/lazy-loading-utils.ts",[],"/home/paul/projects/protocol/src/utils/main-utils.ts",["3554"],"import sortKeys from 'sort-keys';\nimport { TMainDataTypes } from 'types/main.types';\n\nexport type TStringifyData = TMainDataTypes;\n\nexport const stringify = (data: TStringifyData): string | Error => {\n  const dataType = typeof data;\n\n  if (dataType === 'string') {\n    return data as string;\n  }\n  if (dataType === 'number') {\n    return String(data);\n  }\n  if (dataType === 'object') {\n    try {\n      // it's necessary to sort a keys of the object to give\n      // the same strings for all objects with the same keys\n      return JSON.stringify(sortKeys(data as { [key: string]: unknown }, { deep: true }));\n    } catch (err) {\n      return err;\n    }\n  }\n  return new Error('Unknown data type');\n};\n","/home/paul/projects/protocol/src/utils/password-utils/decrypt.password-utils.ts",[],"/home/paul/projects/protocol/src/utils/password-utils/derive-key.password-utils.ts",["3555","3556","3557","3558","3559","3560","3561"],"import { importSalt } from '../encryption-utils/salt-utils';\nimport { TSaltUtilsSaltType } from '../encryption-utils/salt-utils.types';\nimport {\n  TPASSWORD_ENCRYPTION_SUPPORTED_PASSWORD_NATIVE_TYPES,\n  TPASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_EXPORT_FORMAT,\n  TPASSWORD_ENCRYPTION_KEY_IMPORT_NATIVE_SUPPORTED_TYPES,\n} from './password-utils.types';\nimport { isTypedArray } from 'utils/typed-array-utils';\nimport {\n  PASSWORD_ENCRYPTION_UTILS_KEY_GENERATION_KEY_IMPORTED_FORMAT,\n  PASSWORD_ENCRYPTION_UTILS_KEY_GENERATION_IS_KEY_EXTRACTABLE,\n  PASSWORD_ENCRYPTON_UTILS_KEY_USAGES,\n  PASSWORD_ENCRYPTION_UTILS_KEY_GENERATION_ALHORITHM,\n  PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_BASE_KEY_CONFIG,\n  PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_CONFIG,\n  PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_USAGES,\n  PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_IS_EXPORTED,\n  PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_EXPORT_FORMAT,\n  PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_IMPORT_FORMAT,\n} from './password-utils.const';\nimport { decodeDOMStringToArrayBuffer } from 'utils/string-encoding-utils';\nimport { crypto, cryptoModuleDataSign } from '../data-sign-utils/main.data-sign-utils.const';\n\nexport const generatePasswordKey = async (\n  password: TPASSWORD_ENCRYPTION_SUPPORTED_PASSWORD_NATIVE_TYPES\n): Promise<CryptoKey | Error> => {\n  if (!isTypedArray(password)) {\n    return new Error('The password must have a TypedArray type');\n  }\n  try {\n    return await cryptoModuleDataSign.importKey(\n      PASSWORD_ENCRYPTION_UTILS_KEY_GENERATION_KEY_IMPORTED_FORMAT,\n      password,\n      PASSWORD_ENCRYPTION_UTILS_KEY_GENERATION_ALHORITHM,\n      PASSWORD_ENCRYPTION_UTILS_KEY_GENERATION_IS_KEY_EXTRACTABLE,\n      PASSWORD_ENCRYPTON_UTILS_KEY_USAGES\n    );\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const getDeriviationNative = async (passwordKey: CryptoKey, saltValue: Uint8Array): Promise<Error | CryptoKey> => {\n  if (!saltValue) {\n    return new Error('The generated random value of salt is empty');\n  }\n  if (!isTypedArray(saltValue)) {\n    return new Error('The password must have a TypedArray type');\n  }\n  if (!(passwordKey instanceof CryptoKey)) {\n    return new Error('A password key must be an instance of a CryptoKey');\n  }\n  try {\n    return await crypto.subtle.deriveKey(\n      {\n        ...PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_BASE_KEY_CONFIG,\n        salt: saltValue,\n      },\n      passwordKey,\n      {\n        ...PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_CONFIG,\n      },\n      PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_IS_EXPORTED,\n      PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_USAGES\n    );\n  } catch (err) {\n    console.log(err);\n    return err;\n  }\n};\n\nexport const generatePasswordKeyByPasswordString = async (\n  passwordString: string,\n  saltValue: TSaltUtilsSaltType\n): Promise<CryptoKey | Error> => {\n  const passwordArrayBuffer = decodeDOMStringToArrayBuffer(passwordString);\n\n  if (passwordArrayBuffer instanceof Error) {\n    return passwordArrayBuffer;\n  }\n\n  const passwordBaseKey = await generatePasswordKey(passwordArrayBuffer);\n\n  if (passwordBaseKey instanceof Error) {\n    return passwordBaseKey;\n  }\n\n  const saltImported = importSalt(saltValue);\n\n  if (saltImported instanceof Error) {\n    return saltImported;\n  }\n  return getDeriviationNative(passwordBaseKey, saltImported);\n};\n\nexport const exportPasswordKey = (\n  passwordKey: CryptoKey\n): PromiseLike<TPASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_EXPORT_FORMAT> | Error => {\n  try {\n    return cryptoModuleDataSign.exportKey(PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_EXPORT_FORMAT, passwordKey);\n  } catch (err) {\n    console.error(err);\n    return err;\n  }\n};\n\nexport const exportPasswordKeyAsString = async (passwordKey: CryptoKey): Promise<string | Error> => {\n  try {\n    const cryptoKey = await cryptoModuleDataSign.exportKey(\n      PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_EXPORT_FORMAT,\n      passwordKey\n    );\n\n    if (cryptoKey instanceof Error) {\n      return cryptoKey;\n    }\n    return JSON.stringify(cryptoKey);\n  } catch (err) {\n    console.error(err);\n    return err;\n  }\n};\n\nexport const generatePasswordKeyInExportFormat = async (\n  passwordString: string,\n  salt: TSaltUtilsSaltType\n): Promise<TPASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_EXPORT_FORMAT | Error> => {\n  const passwordKey = await generatePasswordKeyByPasswordString(passwordString, salt);\n\n  if (passwordKey instanceof Error) {\n    return passwordKey;\n  }\n\n  return exportPasswordKey(passwordKey);\n};\n\nexport const generatePasswordKeyAsString = async (passwordString: string, salt: TSaltUtilsSaltType): Promise<string | Error> => {\n  const passwordKeyExported = await generatePasswordKeyInExportFormat(passwordString, salt);\n\n  if (passwordKeyExported instanceof Error) {\n    return passwordKeyExported;\n  }\n\n  return JSON.stringify(passwordKeyExported);\n};\n\nexport const importPasswordKey = async (\n  passwordKey: TPASSWORD_ENCRYPTION_KEY_IMPORT_NATIVE_SUPPORTED_TYPES\n): Promise<CryptoKey | Error> => {\n  try {\n    return await cryptoModuleDataSign.importKey(\n      PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_IMPORT_FORMAT,\n      passwordKey,\n      {\n        ...PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_CONFIG,\n      },\n      PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_IS_EXPORTED,\n      PASSWORD_ENRYPTION_UTILS_KEY_DERIVED_TARGET_KEY_USAGES\n    );\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const importPasswordKeyFromString = async (passwordKey: string): Promise<CryptoKey | Error> => {\n  try {\n    const keyExportedFormat: TPASSWORD_ENCRYPTION_KEY_IMPORT_NATIVE_SUPPORTED_TYPES = JSON.parse(passwordKey);\n\n    return await importPasswordKey(keyExportedFormat);\n  } catch (err) {\n    console.error(err);\n\n    return err;\n  }\n};\n","/home/paul/projects/protocol/src/utils/password-utils/encrypt.password-utils.ts",[],"/home/paul/projects/protocol/src/utils/password-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/password-utils/password-utils.const.ts",[],"/home/paul/projects/protocol/src/utils/password-utils/password-utils.types.ts",[],"/home/paul/projects/protocol/src/utils/string-encoding-utils.ts",["3562","3563","3564"],"/**\n * The sulutions is right from the article\n * https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String\n */\n\nexport function encodeArrayBufferToDOMString(buf: ArrayBuffer) {\n  return String.fromCharCode.apply(null, new Uint16Array(buf) as any);\n}\nexport function decodeDOMStringToArrayBuffer(str: string) {\n  const buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n  const bufView = new Uint16Array(buf);\n  for (let i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n","/home/paul/projects/protocol/src/utils/string-utilities.ts",[],"/home/paul/projects/protocol/src/utils/typed-array-utils.ts",["3565","3566","3567","3568","3569"],"import { TTypedArraysNative } from 'types/main.types';\nimport { TTypedArrays, TMainDataTypes } from 'types/main.types';\nimport { stringify, TStringifyData } from './main-utils';\nimport { encodeArrayBufferToDOMString, decodeDOMStringToArrayBuffer } from 'utils/string-encoding-utils';\n\nexport const arrayBufferFromTypedArray = (typedArray: TTypedArrays | ArrayBuffer): ArrayBuffer | Error => {\n  if (typedArray instanceof ArrayBuffer) {\n    return typedArray;\n  }\n  if (ArrayBuffer.isView(typedArray)) {\n    return typedArray.buffer;\n  }\n  return new Error('The data given is not a typed array');\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype isTypedArrayData = any;\n\nexport const isTypedArrayNative = (data: isTypedArrayData): data is TTypedArraysNative =>\n  data instanceof Int8Array ||\n  data instanceof Uint8Array ||\n  data instanceof Uint8ClampedArray ||\n  data instanceof Int16Array ||\n  data instanceof Uint16Array ||\n  data instanceof Int32Array ||\n  data instanceof Uint32Array ||\n  data instanceof Float32Array ||\n  data instanceof Float64Array ||\n  data instanceof BigInt64Array ||\n  data instanceof BigUint64Array;\n\nexport const isTypedArray = (data: isTypedArrayData): data is TTypedArrays =>\n  data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n\nexport const isEqualArrayBufferNative = (arr1: TTypedArraysNative | ArrayBuffer, arr2: TTypedArraysNative | ArrayBuffer) => {\n  const arr1Uint8 = new Uint8Array(arr1);\n  const arr2Uint8 = new Uint8Array(arr2);\n\n  if (arr1Uint8.byteLength !== arr2Uint8.byteLength) {\n    return false;\n  }\n  for (let idx = 0; idx < arr1Uint8.byteLength; idx++) {\n    if (arr1Uint8[idx] !== arr2Uint8[idx]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const stringToTypedArray = (data: TMainDataTypes): ArrayBuffer | Error => {\n  const strData = stringify(data);\n\n  if (strData instanceof Error) {\n    return strData;\n  }\n  return decodeDOMStringToArrayBuffer(strData);\n};\n\nexport const typedArrayToString = (data: TTypedArrays | string): string | Error => {\n  if (typeof data === 'string') {\n    return data;\n  }\n  if (!isTypedArray(data)) {\n    return new Error('The data is not a typed array');\n  }\n\n  try {\n    const dataAsArrayBuffer = arrayBufferFromTypedArray(data);\n\n    if (dataAsArrayBuffer instanceof Error) {\n      return dataAsArrayBuffer;\n    }\n\n    return encodeArrayBufferToDOMString(dataAsArrayBuffer);\n  } catch (err) {\n    return err;\n  }\n};\n\ntype TConvertedToTypedArrayData = TStringifyData | TTypedArrays;\n\nexport const convertToTypedArray = (data: TConvertedToTypedArrayData): TTypedArrays | Error => {\n  if (isTypedArray(data)) {\n    return data;\n  }\n  return stringToTypedArray(data);\n};\n\nexport const getOverallLength = (...typedArrays: ArrayBuffer[]): number | Error => {\n  try {\n    return typedArrays.reduce((allLength, typedArray) => (allLength += typedArray.byteLength), 0);\n  } catch (err) {\n    return err;\n  }\n};\n\nexport const concatArrayBuffers = (...typedArrays: ArrayBuffer[]): ArrayBuffer | Error => {\n  const len = getOverallLength(...typedArrays);\n\n  if (len instanceof Error) {\n    return len;\n  }\n\n  const arrayResulted = new Uint8Array(len);\n  const count = typedArrays.length;\n  let idx = 0;\n  let arrayBuffer = null;\n  let currentLength = 0;\n  let newTypedArray;\n\n  try {\n    for (; idx < count; idx += 1) {\n      arrayBuffer = typedArrays[idx];\n      newTypedArray = new Uint8Array(arrayBuffer);\n      arrayResulted.set(newTypedArray, currentLength);\n      currentLength += newTypedArray.byteLength;\n    }\n  } catch (err) {\n    return err;\n  }\n  return arrayBufferFromTypedArray(arrayResulted);\n};\n\nexport const getBytesFromArrayBuffer = (typedArray: ArrayBuffer, from: number, to?: number): ArrayBuffer | Error => {\n  try {\n    const arrayResulted = new Uint8Array(typedArray);\n\n    return arrayBufferFromTypedArray(arrayResulted.slice(from, to));\n  } catch (err) {\n    return err;\n  }\n};\n","/home/paul/projects/protocol/src/utils/validation-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/validation-utils/validation-utils-timestamp.ts",[],"/home/paul/projects/protocol/src/utils/validation-utils/validation-utils-validation-error.ts",[],"/home/paul/projects/protocol/src/utils/validation-utils/validation-utils.ts",["3570","3571","3572","3573","3574","3575","3576","3577"],"import { ValidationError } from './validation-utils-validation-error';\nimport Ajv, { ValidateFunction } from 'ajv';\nimport ajvJSONSchemaDraft6 from 'ajv/lib/refs/json-schema-draft-06.json';\nimport memoize from 'lodash.memoize';\nimport { isDEV } from 'const/common-values/common-values-env';\n\nconst ajv = new Ajv({\n  allErrors: isDEV,\n  verbose: isDEV,\n});\n\najv.addMetaSchema(ajvJSONSchemaDraft6);\n\nconst ajvVerbose = new Ajv({\n  allErrors: true,\n  verbose: true,\n});\n\najvVerbose.addMetaSchema(ajvJSONSchemaDraft6);\n\nexport const getValidatorForJSONSchema = memoize((schema: object): ValidateFunction => ajv.compile(schema));\n\nexport const validateBySchema = (schema: object, value: any): boolean => {\n  return !!getValidatorForJSONSchema(schema)(value);\n};\n\nexport const getVerboseValidatorForJSONSchema = memoize((schema: object): ValidateFunction => ajvVerbose.compile(schema));\n\nexport const validateVerboseBySchema = (schema: object, value: any): Error | void => {\n  const validator = getVerboseValidatorForJSONSchema(schema);\n  const validationResult = validator(value);\n\n  if (!validationResult) {\n    return new ValidationError(validator.errors);\n  }\n};\n","/home/paul/projects/protocol/src/components/userProfile/index.ts",[],"/home/paul/projects/protocol/src/components/userProfile/userProfile.tsx",["3578"],"import React from 'react';\nimport { ICentralAuthorityUserProfile } from '../../classes/central-authority-class/central-authority-class-types/central-authority-class-types-common';\n\ntype TUserProfileComponentProps = {\n  id: string | undefined;\n  profile: ICentralAuthorityUserProfile | undefined;\n};\n\nexport class UserProfile extends React.PureComponent<TUserProfileComponentProps> {\n  render() {\n    const { id, profile } = this.props;\n    return (\n      !!id && (\n        <div>\n          <p>Id: {id}</p>\n          {profile?.name && <p>Name: {profile?.name}</p>}\n          {profile?.email && <p>Email: {profile?.email}</p>}\n          {profile?.phone && <p>Phone: {profile?.phone}</p>}\n          {profile?.photoURL && <p>Photo: {profile?.photoURL}</p>}\n        </div>\n      )\n    );\n  }\n}\n","/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/index.ts",[],"/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/statused-class-helper.const.ts",[],"/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/statused-class-helper.ts",["3579","3580","3581","3582"],"import { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport {\n  IStatusedClassHelperOptions,\n  TStatusClassHelperStatusChangesEmitter,\n  IStatusedClassHelperStatusEmitterEvents,\n  IStatusedClassHelper,\n} from './statused-class-helper.types';\nimport assert from 'assert';\nimport {\n  STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT,\n  STATUSED_CLASS_HELPER_STATUS_CHANGED_EVENT_NAME,\n} from './statused-class-helper.const';\n\nexport class StatusedClassHelper<StatusChangedEventName extends string, Status extends string>\n  implements IStatusedClassHelper<StatusChangedEventName, Status> {\n  public get currentStatus(): Status | undefined {\n    return this.__currentStatus || undefined;\n  }\n  protected __currentStatus?: Status;\n  /**\n   * is this instance ready to use.\n   *\n   * @protected\n   * @type {boolean}\n   * @memberof StatusedClassHelper\n   */\n  protected __isReadyStatusedClassHelper: boolean = false;\n  /**\n   * Emitter of a status changes.\n   * Used for inner purposes mostly.\n   *\n   * @protected\n   * @memberof StatusedClassHelper\n   */\n  protected __emitterInnerStatusChanged = new EventEmitter<IStatusedClassHelperStatusEmitterEvents<Status>>();\n  protected __emitterExternal?: TStatusClassHelperStatusChangesEmitter<StatusChangedEventName, Status>;\n  protected __emitterEventStatusChanged?: StatusChangedEventName;\n\n  constructor(options: IStatusedClassHelperOptions<StatusChangedEventName, Status>) {\n    this.__validateOptionsStatusClassHelper(options);\n    this.__setOptionsStatusClassHelper(options);\n    this.__setListenerForStatusChanges();\n    this.__setIsReady();\n  }\n  setStatus(status: Status): void {\n    this.__checkIsStatusedClassHelperReady();\n    this.__setNewStatus(status);\n    this.__emitExternalEmitterNewStatus(status);\n  }\n\n  waitTillStatus = async <S extends Status | undefined>(\n    currentStatus: S,\n    timeoutMs: number = STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT\n  ): Promise<Status | undefined> => {\n    this.__checkIsStatusedClassHelperReady();\n    if (this.__currentStatus !== currentStatus) {\n      return this.__currentStatus;\n    }\n    return this.__resolveOnCondition((newStatus: Status) => newStatus !== currentStatus, timeoutMs);\n  };\n  waitForStatus = async <S extends Status | undefined>(\n    trgetStatus: S,\n    timeoutMs: number = STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT\n  ): Promise<Status | undefined> => {\n    this.__checkIsStatusedClassHelperReady();\n    if (this.__currentStatus === trgetStatus) {\n      return this.__currentStatus;\n    }\n    return this.__resolveOnCondition((newStatus: Status) => newStatus === trgetStatus, timeoutMs);\n  };\n\n  listenForStatusChanged(timeoutMs: number = STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT) {\n    this.__checkIsStatusedClassHelperReady();\n    return this.__resolveOnCondition(() => true, timeoutMs);\n  }\n\n  clearStatus() {\n    this.__clearStatus();\n  }\n\n  stopStatusEmitter() {\n    this.__clearStatus();\n    this.__unsetIsReady();\n    this.__clearEventEmitters();\n    this.__clearOptions();\n  }\n\n  protected __setIsReady(): void {\n    this.__isReadyStatusedClassHelper = true;\n  }\n\n  protected __unsetIsReady(): void {\n    this.__isReadyStatusedClassHelper = false;\n  }\n\n  protected __emitStatusChaned(statusName: string): void {\n    this.__emitterInnerStatusChanged.emit(STATUSED_CLASS_HELPER_STATUS_CHANGED_EVENT_NAME, statusName);\n  }\n\n  protected __handleEmitterStatusChanged = (statusName: Status): void => {\n    this.__setNewStatus(statusName);\n    this.__emitStatusChaned(statusName);\n  };\n\n  protected __getEmitterEventStatusChanged = (): StatusChangedEventName => {\n    const emitterEventStatusChanged = this.__emitterEventStatusChanged;\n\n    if (!emitterEventStatusChanged) {\n      throw new Error('emitterEventStatusChanged must not be empty');\n    }\n    return emitterEventStatusChanged;\n  };\n\n  protected __setListenerForStatusChanges(): void {\n    this.__emitterExternal?.addListener(this.__getEmitterEventStatusChanged(), this.__handleEmitterStatusChanged);\n  }\n\n  protected __validateOptionsStatusClassHelper(options: IStatusedClassHelperOptions<StatusChangedEventName, Status>): void {\n    assert(!!options, 'Options must be provided');\n    assert(typeof options === 'object', 'Options must be an object');\n\n    const { statusChangedEventName, statusChangesEmitter: statusChanesEmitter } = options;\n\n    assert(!!statusChangedEventName, 'Status changed event name must be provided and not empty');\n    assert(typeof statusChangedEventName === 'string', 'Status changed event name must be a string');\n    assert(!!statusChanesEmitter, 'An event emitter must be provided for listening an event leads to a status chage');\n    assert(typeof statusChanesEmitter === 'object', 'An event emitter instance must be an object');\n    assert(typeof statusChanesEmitter.addListener === 'function', 'An event emitter instance must have \"addListener\" method');\n    assert(\n      statusChanesEmitter.addListener.length > 0,\n      'An event emitter instance must have \"addListener\" method which accepts an event name'\n    );\n    assert(typeof statusChanesEmitter.emit === 'function', 'An event emitter instance must have \"emit\" method');\n    assert(\n      statusChanesEmitter.emit.length > 1,\n      'An event emitter instance must have \"emit\" method which accepts an event name with a new status'\n    );\n  }\n\n  protected __setOptionsStatusClassHelper(options: IStatusedClassHelperOptions<StatusChangedEventName, Status>): void {\n    this.__emitterEventStatusChanged = options.statusChangedEventName;\n    this.__emitterExternal = options.statusChangesEmitter;\n  }\n\n  /**\n   *  Returns a Promise wich will be resolved\n   *  when the resolver callback return true.\n   *\n   * @param {(status: Status) => boolean} resolver\n   * @param {number} [timeoutMs] - if specified than will be rejected after this milliseconds count\n   * @returns {Promise<Status>} - promised will be resolved with a new status which is meets the requirements\n   * @throws - on timeout if the timeout value specified\n   */\n  protected __resolveOnCondition = async (resolver: (status: Status) => boolean, timeoutMs?: number): Promise<Status> => {\n    return new Promise((res, rej) => {\n      let timer: NodeJS.Timeout | undefined;\n      const listenerStatusChanged = (newStatus: Status) => {\n        if (this.__isReadyStatusedClassHelper) {\n          timer && clearTimeout(timer);\n          rej(new Error('The instance was closed'));\n        }\n        if (resolver(newStatus) === true) {\n          timer && clearTimeout(timer);\n          res(newStatus);\n        }\n      };\n\n      this.__emitterInnerStatusChanged.once(STATUSED_CLASS_HELPER_STATUS_CHANGED_EVENT_NAME, listenerStatusChanged);\n      if (timeoutMs) {\n        timer = setTimeout(() => {\n          timer = undefined;\n          this.__emitterInnerStatusChanged.removeListener(STATUSED_CLASS_HELPER_STATUS_CHANGED_EVENT_NAME, listenerStatusChanged);\n          rej(new Error(`Timed out waiting for a status`));\n        }, timeoutMs);\n      }\n    });\n  };\n\n  /**\n   * Checks whether the instance is ready to be used.\n   * If not, then throw an error.\n   *\n   * @protected\n   * @memberof StatusedClassHelper\n   */\n  protected __checkIsStatusedClassHelperReady(): void {\n    if (!this.__isReadyStatusedClassHelper) {\n      throw new Error('The instance is not ready to be used');\n    }\n  }\n\n  protected __setNewStatus(statusName: Status): void {\n    this.__currentStatus = statusName;\n  }\n\n  protected __emitExternalEmitterNewStatus(statusName: Status | undefined): void {\n    this.__emitterExternal?.emit(this.__getEmitterEventStatusChanged(), statusName);\n  }\n\n  protected __clearEventEmitters(): void {\n    this.__emitterExternal?.removeListener(this.__getEmitterEventStatusChanged(), this.__handleEmitterStatusChanged);\n    this.__emitterInnerStatusChanged.removeAllListeners();\n    (this.__emitterInnerStatusChanged as any) = undefined;\n    this.__emitterExternal = undefined;\n  }\n\n  protected __clearOptions(): void {\n    this.__emitterEventStatusChanged = undefined;\n  }\n\n  protected __clearStatus(): void {\n    this.__emitExternalEmitterNewStatus(undefined);\n    this.__currentStatus = undefined;\n  }\n}\n","/home/paul/projects/protocol/src/utils/classes-helpers/statused-class-helper/statused-class-helper.types.ts",["3583"],"import { EventEmitter } from 'classes/basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport { STATUSED_CLASS_HELPER_STATUS_CHANGED_EVENT_NAME } from './statused-class-helper.const';\n\nexport type TStatusClassHelperStatusChangesEmitter<SCE extends string, Status extends string> = EventEmitter<\n  { [key in SCE]: (status: Status, ...other: any[]) => void }\n>;\n\nexport interface IStatusedClassHelperOptions<SCE extends string, Status extends string> {\n  statusChangesEmitter: TStatusClassHelperStatusChangesEmitter<SCE, Status>;\n  statusChangedEventName: SCE;\n}\n\n/**\n * Events which can be emitted by the inner events emitter\n *\n * @export\n * @interface IStatusedClassHelperStatusEmitterEvents\n * @template Status\n */\nexport interface IStatusedClassHelperStatusEmitterEvents<Status extends string> {\n  /**\n   * Status changed event, emits with a new status value\n   * or undefined if the instance status was cleared.\n   *\n   * @memberof IStatusedClassHelperStatusEmitterEvents\n   */\n  [STATUSED_CLASS_HELPER_STATUS_CHANGED_EVENT_NAME]: (status: Status | undefined) => void;\n}\n\nexport interface IStatusedClassHelper<StatusChangedEventName extends string, Status extends string> {\n  /**\n   * The current status of the instance\n   * or undefined if there is no status.\n   *\n   * @type {(Status | undefined)}\n   * @memberof IStatusedClassHelper\n   */\n  readonly currentStatus: Status | undefined;\n  /**\n   * Set the current status value and\n   * emit an event on the external\n   * emitter, that the current\n   * status was changed.\n   *\n   * @param {Status} status\n   * @memberof IStatusedClassHelper\n   * @throws - e.g. the instance is not ready\n   */\n  setStatus(status: Status): void;\n  /**\n   * Retruns a promise which will be resolved\n   * when the current status changed from the status provided.\n   *\n   * @param {(Status | undefined)} status - waiting till the current status value won't changed on something else.\n   * @param {number} [timeoutMs = STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT] - timeout in milliseconds, if not specified the default value will be used\n   * @returns {(Promise<Status | undefined>)}\n   * @memberof IStatusedClassHelper\n   * @throws - e.g. if a status won't change within the time specified\n   */\n  waitTillStatus(status: Status | undefined, timeoutMs?: number): Promise<Status | undefined>;\n  /**\n   * Retruns a promise which will be resolved\n   * when the current status changed to the target value.\n   *\n   * @param {(Status | undefined)} status - waiting till the current status value won't changed on the provided.\n   * @param {number} [timeoutMs = STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT] - timeout in milliseconds, if not specified the default value will be used\n   * @returns {(Promise<Status | undefined>)}\n   * @memberof IStatusedClassHelper\n   * @throws - e.g. if a status won't change within the time specified\n   */\n  waitForStatus(status: Status | undefined, timeoutMs?: number): Promise<Status | undefined>;\n\n  /**\n   * Returns a promise which will be resolved\n   * when the instance's status changed\n   * to another value.\n   *\n   * @param {number} [timeoutMs=STATUSED_CLASS_HELPER_STATUS_WAITING_TIMEOUT_MS_DEFAULT] - will be rejected after this timeout\n   * @returns {(Promise<Status | undefined>)}\n   * @memberof IStatusedClassHelper\n   * @throws\n   */\n  listenForStatusChanged(timeoutMs?: number): Promise<Status | undefined>;\n\n  /**\n   * Release all emitters and stop listening for events.\n   *\n   * @memberof IStatusedClassHelper\n   */\n  stopStatusEmitter(): void;\n}\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database.ts",["3584","3585","3586","3587","3588","3589","3590","3591","3592","3593","3594","3595","3596","3597","3598","3599","3600","3601","3602","3603","3604","3605","3606"],"import {\n  ISwarmMessageDatabaseEvents,\n  ISwarmMessagesDatabaseConnectCurrentUserOptions,\n  ISwarmMessagesDatabaseConnectOptions,\n  ISwarmMessagesDatabaseReady,\n  TSwarmMessageDatabaseMessagesCached,\n  ISwarmMessagesDatabaseCacheOptionsDbInstance,\n} from './swarm-messages-database.types';\nimport { ESwarmStoreConnector, ESwarmStoreEventNames } from '../swarm-store-class/swarm-store-class.const';\nimport assert from 'assert';\nimport {\n  ISwarmMessageStore,\n  ISwarmMessageStoreDeleteMessageArg,\n  TSwarmMessagesStoreGrantAccessCallback,\n  ISwarmMessageStoreAccessControlOptions,\n  ISwarmMessageStoreOptionsWithConnectorFabric,\n} from '../swarm-message-store/swarm-message-store.types';\nimport { getEventEmitterInstance } from '../basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport { ESwarmMessageStoreEventNames } from '../swarm-message-store/swarm-message-store.const';\nimport {\n  TSwarmMessageSerialized,\n  TSwarmMessageInstance,\n  ISwarmMessageInstanceDecrypted,\n} from '../swarm-message/swarm-message-constructor.types';\nimport { TTypedEmitter } from '../basic-classes/event-emitter-class-base/event-emitter-class-base.types';\nimport {\n  TSwarmStoreDatabaseEntityAddress,\n  TSwarmStoreDatabaseEntityKey,\n  TSwarmStoreDatabaseOptions,\n  TSwarmStoreDatabaseType,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport validateUserIdentifier from '../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier';\nimport { TSwarmMessageUserIdentifierSerialized } from '../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport {\n  ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions,\n  ISwarmMessagesDatabaseCacheOptions,\n  ISwarmMessagesDatabaseCache,\n} from './swarm-messages-database.types';\nimport { isConstructor } from '../../utils/common-utils/common-utils-classes';\nimport {\n  ESwarmMessagesDatabaseCacheEventsNames,\n  SWARM_MESSAGES_DATABASE_MESSAGES_CACHE_UPDATE_RETRY_DELAY_MS,\n  SWARM_MESSAGES_DATABASE_MESSAGES_EMITTED_UNIQ_ID_ADDRESS_PREFIX,\n} from './swarm-messages-database.const';\nimport { ISwarmMessageStoreMessageWithMeta } from '../swarm-message-store/swarm-message-store.types';\nimport { delay } from '../../utils/common-utils/common-utils-timer';\nimport { SWARM_MESSAGES_DATABASE_MESSAGES_MAX_ATTEMPTS_CACHE_UPDATE } from './swarm-messages-database.const';\nimport {\n  ISwarmStoreConnectorBasic,\n  ISwarmStoreConnector,\n  TSwarmStoreConnectorConnectionOptions,\n  ISwarmStoreProviderOptions,\n  ISwarmStoreOptionsConnectorFabric,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { ISwarmMessageConstructorWithEncryptedCacheFabric } from '../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport { ISwarmMessageInstanceEncrypted } from '../swarm-message/swarm-message-constructor.types';\nimport { OmitFirstArg } from '../../types/helper.types';\nimport { ISwarmMessagesDatabaseConnector, ISwarmMessagesDatabaseCacheConstructor } from './swarm-messages-database.types';\n\nexport class SwarmMessagesDatabase<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, PO>,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>,\n  MSI extends TSwarmMessageInstance | T,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, T, MSI, GAC> | undefined,\n  O extends ISwarmMessageStoreOptionsWithConnectorFabric<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO\n  >,\n  SMS extends ISwarmMessageStore<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO, MSI, GAC, MCF, ACO, O>,\n  MD extends ISwarmMessageInstanceDecrypted\n> implements ISwarmMessagesDatabaseConnector<P, T, DbType, DBO, MSI, SMS, MD> {\n  get dbName(): DBO['dbName'] | undefined {\n    return this._dbName;\n  }\n\n  get dbType(): DbType {\n    return this._dbType as DbType;\n  }\n\n  get isReady(): boolean {\n    return this._isReady && !!this._swarmMessageStore;\n  }\n\n  get emitter(): TTypedEmitter<ISwarmMessageDatabaseEvents<P, T, DbType, DBO, MD>> {\n    return this._emitter;\n  }\n\n  get isMessagesListContainsAllMessages(): boolean {\n    return !!this._swarmMessagesCache?.whetherMessagesListContainsAllMessages;\n  }\n\n  get whetherMessagesListUpdateInProgress(): boolean {\n    return !!this._swarmMessagesCache?.isUpdating;\n  }\n\n  get cachedMessages(): TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined {\n    return this._messagesCached;\n  }\n\n  protected get _currentUserId(): TSwarmMessageUserIdentifierSerialized | undefined {\n    return this._currentUserOptons?.userId;\n  }\n\n  /**\n   * Is this instance is Key-Value database\n   *\n   * @readonly\n   * @protected\n   * @memberof SwarmMessagesDatabase\n   */\n  protected get _isKeyValueDatabase() {\n    return this._dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE;\n  }\n\n  protected get _swarmMessagesCacheClassFromOptions(): ISwarmMessagesDatabaseCacheConstructor<P, T, DbType, DBO, MD> {\n    const SwarmMessagesCacheConstructor = this._cacheOptions?.cacheConstructor;\n\n    if (!SwarmMessagesCacheConstructor) {\n      throw new Error('SwarmMessagesCacheConstructor should be defined in options');\n    }\n    return SwarmMessagesCacheConstructor;\n  }\n\n  /**\n   * name of the databasESwarmStoreConnectorOrbitDbDatabaseTypee\n   *\n   * @protected\n   * @type {string}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _dbName?: DBO['dbName'];\n\n  protected _dbType?: DbType;\n\n  protected _emitter = getEventEmitterInstance<ISwarmMessageDatabaseEvents<P, T, DbType, DBO, MD>>();\n\n  /**\n   * An instance implemented ISwarmMessageStore\n   * interface.\n   *\n   * @protected\n   * @type {ISwarmMessageStore<P>}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _swarmMessageStore?: SMS;\n\n  /**\n   * Implementation of a swarm messages cahce\n   *\n   * @protected\n   * @type {ISwarmMessagesDatabaseCache<P, DbType>}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _swarmMessagesCache?: ISwarmMessagesDatabaseCache<P, T, DbType, DBO, MD>;\n\n  /**\n   * Options for the database which used for\n   * database initialization via ISwarmMessageStore.\n   *\n   * @protectedimport { ISwarmMessagesDatabaseReady, } from './swarm-messages-database.types';\n   * @type {TSwarmStoreDatabaseOptions}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _dbOptions?: DBO;\n\n  protected _currentUserOptons?: ISwarmMessagesDatabaseConnectCurrentUserOptions;\n\n  protected _cacheOptions?: ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions<P, T, DbType, DBO, MD>;\n\n  protected _isReady: boolean = false;\n\n  protected _newMessagesEmitted = new Set<string>();\n\n  /**\n   * Swarm messages cached\n   *\n   * @protected\n   * @type {(TSwarmMessageDatabaseMessagesCached<P, DbType> | undefined)}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _messagesCached: TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined;\n\n  async connect(options: ISwarmMessagesDatabaseConnectOptions<P, T, DbType, DBO, Exclude<MSI, T>, SMS, MD>): Promise<void> {\n    this._handleOptions(options);\n    await this._openDatabaseInstance();\n    await this._startSwarmMessagesCache();\n    this._setListeners();\n    this._setIsReady();\n    this._updateMessagesCache();\n  }\n\n  close = async (): Promise<void> => {\n    if (!this.isReady) {\n      console.warn('SwarmMessageDatabase instance was already closed');\n      return;\n    }\n    this._unsetIsReady();\n    await this._closeSwarmDatabaseInstance();\n    await this._closeSwarmMessagesCahceInstance();\n    this._emitInstanceClosed();\n    await this._handleDatabaseClosed();\n  };\n\n  drop = async (): Promise<void> => {\n    if (!this.isReady) {\n      console.warn('SwarmMessageDatabase instance was already closed');\n      return;\n    }\n    this._unsetIsReady();\n    await this._dropSwarmDatabaseInstance();\n    this._emitDatabaseDropped();\n    await this._handleDatabaseClosed();\n  };\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  addMessage = ((...args: Parameters<OmitFirstArg<SMS['addMessage']>>): ReturnType<SMS['addMessage']> => {\n    if (!this._checkIsReady()) {\n      throw new Error('The instance is not ready to use');\n    }\n    // TODO - remove cast to any https://github.com/microsoft/TypeScript/issues/28010\n    return (this._swarmMessageStore.addMessage as any)(this._dbName, ...args);\n  }) as OmitFirstArg<SMS['addMessage']>;\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  deleteMessage = ((messageAddressOrKey: ISwarmMessageStoreDeleteMessageArg<P>): ReturnType<SMS['deleteMessage']> => {\n    if (!this._checkIsReady()) {\n      throw new Error('The instance is not ready to use');\n    }\n    return this._swarmMessageStore.deleteMessage(this._dbName, messageAddressOrKey) as ReturnType<SMS['deleteMessage']>;\n  }) as OmitFirstArg<SMS['deleteMessage']>;\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  collect = ((...args: Parameters<OmitFirstArg<SMS['collect']>>): ReturnType<SMS['collect']> => {\n    if (!this._checkIsReady()) {\n      throw new Error('The instance is not ready to use');\n    }\n    // TODO - remove cast to any https://github.com/microsoft/TypeScript/issues/28010\n    return (this._swarmMessageStore.collect as any)(this._dbName, ...args);\n  }) as OmitFirstArg<SMS['collect']>;\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  collectWithMeta = ((\n    ...args: Parameters<OmitFirstArg<SMS['collectWithMeta']>>\n  ): ReturnType<OmitFirstArg<SMS['collectWithMeta']>> => {\n    if (!this._checkIsReady()) {\n      throw new Error('The instance is not ready to use');\n    }\n    // TODO - remove cast to any https://github.com/microsoft/TypeScript/issues/28010\n    return (this._swarmMessageStore.collectWithMeta as any)(this._dbName, ...args);\n  }) as OmitFirstArg<SMS['collectWithMeta']>;\n\n  /**\n   * Checks if the instance is ready to use\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _checkIsReady(): this is ISwarmMessagesDatabaseReady<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    O\n  > {\n    if (!this._isReady) {\n      throw new Error('The instance is not ready to use');\n    }\n    if (!this._swarmMessageStore) {\n      throw new Error('Implementation of the SwarmMessgaeStore interface is not provided');\n    }\n    if (!this._dbName) {\n      throw new Error('Database name is not defined for the instance');\n    }\n    if (!this._currentUserId) {\n      throw new Error('Identity of the current user is not defined');\n    }\n    if (!this._swarmMessagesCache) {\n      throw new Error('Swarm messages cahce is not exists');\n    }\n    return true;\n  }\n\n  protected _validateOptions(options: ISwarmMessagesDatabaseConnectOptions<P, T, DbType, DBO, Exclude<MSI, T>, SMS, MD>): void {\n    assert(!!options, 'An options object must be provided');\n    assert(typeof options === 'object', 'Options must be an object');\n    assert(!!options.dbOptions, 'An options for database must be provided');\n    assert(typeof options.dbOptions === 'object', 'An options for database must be an object');\n    assert(!!options.swarmMessageStore, 'An instance implemented SwarmMessageStore interface must be provided');\n    assert(options.swarmMessageStore.isReady, 'An implementation of the ISwarmMessageStore interface must be ready to use');\n    assert(!!options.user, 'The current user options must be defined');\n    assert(typeof options.user === 'object', 'The current user options should be an object');\n    validateUserIdentifier(options.user.userId);\n  }\n\n  protected _setDbOptions(dbOptions: DBO): void {\n    this._dbOptions = dbOptions;\n    this._dbName = dbOptions.dbName;\n    this._dbType = dbOptions.dbType as DbType;\n  }\n\n  protected _setUserOptions(optionsUser: ISwarmMessagesDatabaseConnectCurrentUserOptions): void {\n    this._currentUserOptons = optionsUser;\n  }\n\n  protected _setOptions(options: ISwarmMessagesDatabaseConnectOptions<P, T, DbType, DBO, Exclude<MSI, T>, SMS, MD>): void {\n    this._setDbOptions(options.dbOptions);\n    this._swarmMessageStore = options.swarmMessageStore;\n    this._setUserOptions(options.user);\n  }\n\n  protected _validateCacheOptions(\n    options?: ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions<P, T, DbType, DBO, MD>\n  ): void {\n    if (!options) {\n      return;\n    }\n    assert(typeof options === 'object', 'Swarm messages cache options must be an object');\n    if (options.cacheConstructor) {\n      assert(isConstructor(options.cacheConstructor), 'cacheConstructor option should be a constructor');\n    }\n  }\n\n  protected _setCacheOptions(\n    options: ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions<P, T, DbType, DBO, MD>\n  ): void {\n    this._cacheOptions = options;\n  }\n\n  /**\n   * Handle options provided for the connect\n   * method.\n   *\n   * @protected\n   * @param {ISwarmMessage_handleDatabaseClosedsDatabaseConnectOptions<P>} options\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _handleOptions(options: ISwarmMessagesDatabaseConnectOptions<P, T, DbType, DBO, Exclude<MSI, T>, SMS, MD>): void {\n    this._validateOptions(options);\n    this._setOptions(options);\n    if (options.cacheOptions) {\n      this._validateCacheOptions(options.cacheOptions);\n      this._setCacheOptions(options.cacheOptions);\n    }\n  }\n\n  protected _checkDatabaseProps(): this is Omit<\n    ISwarmMessagesDatabaseReady<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO, MSI, GAC, MCF, ACO, O>,\n    'isReady'\n  > {\n    const swarmMessageStore = this._swarmMessageStore;\n\n    if (!swarmMessageStore) {\n      throw new Error('A SwarmMessageStore interface implementation is not defined');\n    }\n\n    const { _dbName } = this;\n\n    if (!_dbName) {\n      throw new Error('A database name is not defined');\n    }\n    return true;\n  }\n\n  /**\n   * Set the database is ready to use.\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _setIsReady = (): void => {\n    this._isReady = true;\n  };\n\n  /**\n   * Unset flag that the database is ready to use.\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _unsetIsReady = (): void => {\n    this._isReady = false;\n  };\n\n  protected _setMessagesCached = (messagesCached: TSwarmMessageDatabaseMessagesCached<P, DbType, MD>) => {\n    this._messagesCached = messagesCached;\n  };\n\n  protected _updateMessagesCache(attempt = 0): void {\n    if (!this._isReady) {\n      console.warn(`The database ${this._dbName}:${this._dbType} is not ready`);\n      return;\n    }\n    if (this._checkIsReady()) {\n      this._swarmMessagesCache.update().catch(async (err) => {\n        if (attempt > SWARM_MESSAGES_DATABASE_MESSAGES_MAX_ATTEMPTS_CACHE_UPDATE) {\n          console.error(`Failed to update messages cache ${err.message}`);\n          await delay(SWARM_MESSAGES_DATABASE_MESSAGES_CACHE_UPDATE_RETRY_DELAY_MS);\n          this._updateMessagesCache(attempt++);\n        }\n      });\n    }\n  }\n\n  protected _getSwarmMessageWithMeta(\n    dbName: DBO['dbName'],\n    message: MD,\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ): ISwarmMessageStoreMessageWithMeta<P, MD> {\n    return {\n      dbName,\n      message,\n      messageAddress,\n      key,\n    };\n  }\n\n  /**\n   * Add message to the cache by it's description.\n   *\n   * @protected\n   * @param {string} dbName\n   * @param {MD} message\n   * @param {TSwarmStoreDatabaseEntityAddress<P>} messageAddress\n   * @param {TSwarmStoreDatabaseEntityKey<P>} [key]\n   * @returns {Promise<void>}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _addMessageToCache(\n    dbName: DBO['dbName'],\n    message: MD,\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ): Promise<boolean> {\n    if (this._checkIsReady()) {\n      return this._swarmMessagesCache.addMessage(this._getSwarmMessageWithMeta(dbName, message, messageAddress, key));\n    }\n    throw new Error('Swarm messages cache is not ready');\n  }\n\n  protected _removeMessageFromCache(\n    messageAddress: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n      : TSwarmStoreDatabaseEntityAddress<P>,\n    key: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE ? TSwarmStoreDatabaseEntityKey<P> : undefined\n  ): Promise<void> {\n    if (this._checkIsReady()) {\n      if (!messageAddress && !key) {\n        throw new Error('Messages address or message key requered to remove message from the cache');\n      }\n      return this._swarmMessagesCache.deleteMessage(messageAddress, key);\n    }\n    throw new Error('Swarm messages cache is not ready');\n  }\n\n  protected _handleDatabaseLoadingEvent = (dbName: DBO['dbName'], percentage: number): void => {\n    if (this._dbName !== dbName) return;\n    this._emitter.emit(ESwarmStoreEventNames.DB_LOADING, dbName, percentage);\n  };\n\n  protected _handleDatabaseUpdatedEvent = (dbName: DBO['dbName']): void => {\n    if (this._dbName !== dbName) return;\n\n    this._emitter.emit(ESwarmStoreEventNames.UPDATE, dbName);\n    this._updateMessagesCache();\n  };\n\n  /**\n   * Returns a unique value for the message to set it in\n   * the list of messages received.\n   *\n   * @param {TSwarmStoreDatabaseEntityAddress<P>} messageAddress\n   * @param {TSwarmStoreDatabaseEntityKey<P>} [key]\n   * @param {MD} [message] - optional cause for DELETE messages\n   * a message object by itself may be not exists.\n   * @returns {string}\n   */\n  protected _getMessageUniqueIdForEmittedAsNewList = (\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>,\n    message?: MD\n  ): string => {\n    return message ? message.sig : `${SWARM_MESSAGES_DATABASE_MESSAGES_EMITTED_UNIQ_ID_ADDRESS_PREFIX}::${messageAddress}`;\n  };\n\n  /**\n   * Add message to the list of a messages uniq id's which\n   * were emitted as a new before\n   *\n   * @param {TSwarmStoreDatabaseEntityAddress<P>} messageAddress\n   * @param {TSwarmStoreDatabaseEntityKey<P>} [key]\n   * @param {MD} [message] - optional cause for DELETE messages\n   * a message object by itself may be not exists.\n   */\n  protected _addMessageToListOfEmitted = (\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>,\n    message?: MD\n  ): void => {\n    this._newMessagesEmitted.add(this._getMessageUniqueIdForEmittedAsNewList(messageAddress, key, message));\n  };\n\n  /**\n   * Checks whether the message is already been emitted as a new message\n   *\n   * @param {TSwarmStoreDatabaseEntityAddress<P>} messageAddress\n   * @param {TSwarmStoreDatabaseEntityKey<P>} [key]\n   * @param {MD} [message] - optional cause for DELETE messages\n   * a message object by itself may be not exists.\n   * @returns {boolean}\n   */\n  protected _isMessageAlreadyEmitted = (\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>,\n    message?: MD\n  ): boolean => {\n    return this._newMessagesEmitted.has(this._getMessageUniqueIdForEmittedAsNewList(messageAddress, key, message));\n  };\n\n  protected _handleDatabaseNewMessage = async (\n    dbName: DBO['dbName'],\n    message: MD,\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ) => {\n    if (this._dbName !== dbName) return;\n\n    if (this._isMessageAlreadyEmitted(messageAddress, key, message)) {\n      return;\n    }\n\n    this._emitter.emit(ESwarmMessageStoreEventNames.NEW_MESSAGE, dbName, message, messageAddress, key);\n    this._addMessageToListOfEmitted(messageAddress, key, message);\n    await this._handleCacheUpdateOnNewMessage(message, messageAddress, key);\n  };\n\n  protected _handleDatabaseDeleteMessage = async (\n    dbName: DBO['dbName'],\n    userID: TSwarmMessageUserIdentifierSerialized,\n    // the global unique address (hash) of the DELETE message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // the global unique address (hash) of the DELETED message in the swarm\n    messageDeletedAddress: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n      : TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key for the value,\n    // for feed store it will be hash of the message which deleted by this one.\n    keyOrHash: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE ? TSwarmStoreDatabaseEntityKey<P> : undefined\n  ) => {\n    if (this._dbName !== dbName) return;\n\n    const keyToCheckAlreadyEmitted = this._isKeyValueDatabase ? keyOrHash : undefined;\n\n    if (this._isMessageAlreadyEmitted(messageAddress, keyToCheckAlreadyEmitted)) {\n      return;\n    }\n\n    this._emitter.emit(\n      ESwarmMessageStoreEventNames.DELETE_MESSAGE,\n      dbName,\n      userID,\n      messageAddress,\n      messageDeletedAddress,\n      keyOrHash\n    );\n    this._addMessageToListOfEmitted(messageAddress, keyToCheckAlreadyEmitted);\n    await this._handleCacheUpdateOnDeleteMessage(userID, messageAddress, messageDeletedAddress, keyOrHash);\n  };\n\n  protected _handleDatabaseMessageError = (\n    dbName: DBO['dbName'],\n    // swarm message string failed to deserialize\n    messageSerialized: T,\n    // error occurred while deserializing the message\n    error: Error,\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ) => {\n    if (this._dbName !== dbName) return;\n    this._emitter.emit(ESwarmMessageStoreEventNames.NEW_MESSAGE_ERROR, dbName, messageSerialized, error, messageAddress, key);\n  };\n\n  protected _handleDatabaseReadyEvent = (dbName: DBO['dbName']): void => {\n    if (this._dbName !== dbName) return;\n    this._emitter.emit(ESwarmStoreEventNames.READY, dbName);\n    this._setIsReady();\n  };\n\n  protected _emitInstanceClosed() {\n    if (!this._dbName) {\n      throw new Error('SwarmMessagesDatabase::_emitInstanceClosed: failed cause there is no database name defined');\n    }\n    this._emitter.emit(ESwarmStoreEventNames.CLOSE_DATABASE, this._dbName);\n  }\n\n  protected _handleDatabaseClosedEvent = async (dbName: DBO['dbName']): Promise<void> => {\n    if (this._dbName !== dbName) return;\n    this._emitInstanceClosed();\n    await this._handleDatabaseClosed();\n  };\n\n  protected _emitDatabaseDropped(): void {\n    if (!this._dbName) {\n      throw new Error('SwarmMessagesDatabase::_emitDatabaseDropped: failed cause there is no database name defined');\n    }\n    this._emitter.emit(ESwarmStoreEventNames.DROP_DATABASE, this._dbName);\n  }\n\n  protected _handleDatabaseDroppedEvent = async (dbName: DBO['dbName']): Promise<void> => {\n    if (this._dbName !== dbName) return;\n    this._emitDatabaseDropped();\n    await this._handleDatabaseClosed();\n  };\n\n  /**\n   /**\n   * Set listeners to listen events of the SwarmMessageStore\n   * implementation.\n   *\n   *\n   * @protected\n   * @param {boolean} [isSetListeners=true] - set or remove the listeners\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _setSwarmMessagesStoreListeners(isSetListeners: boolean = true): void {\n    const method = isSetListeners ? 'addListener' : 'removeListener';\n\n    this._swarmMessageStore?.[method](ESwarmStoreEventNames.DB_LOADING, this._handleDatabaseLoadingEvent);\n    this._swarmMessageStore?.[method](ESwarmStoreEventNames.UPDATE, this._handleDatabaseUpdatedEvent);\n    this._swarmMessageStore?.[method](ESwarmMessageStoreEventNames.NEW_MESSAGE, this._handleDatabaseNewMessage);\n    this._swarmMessageStore?.[method](ESwarmMessageStoreEventNames.DELETE_MESSAGE, this._handleDatabaseDeleteMessage);\n    this._swarmMessageStore?.[method](ESwarmStoreEventNames.READY, this._handleDatabaseReadyEvent);\n    this._swarmMessageStore?.[method](ESwarmStoreEventNames.CLOSE_DATABASE, this._handleDatabaseClosedEvent);\n    this._swarmMessageStore?.[method](ESwarmStoreEventNames.DROP_DATABASE, this._handleDatabaseDroppedEvent);\n  }\n\n  protected _handleCacheUpdating = (): void => {\n    this._emitter.emit(ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATING);\n  };\n\n  protected _handleCacheUpdated = (messagesCached: TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined): void => {\n    if (!messagesCached) {\n      console.warn('_handleCacheUpdated::not messages cached to update');\n      return;\n    }\n    this._setMessagesCached(messagesCached);\n    this.emitter.emit(ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATED, messagesCached);\n  };\n\n  /**\n   * Set listeners for swarm messages cache events\n   *\n   * @protected\n   * @param {boolean} [isSetListeners=true]\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _setCacheListeners(isSetListeners: boolean = true): void {\n    if (!this._swarmMessagesCache) {\n      throw new Error('Swarm messages cache is not defined');\n    }\n\n    const { emitter } = this._swarmMessagesCache;\n\n    if (isSetListeners) {\n      emitter.addListener(ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATING, this._handleCacheUpdating);\n      emitter.addListener(ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATED, this._handleCacheUpdated);\n    } else {\n      emitter.removeListener(ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATING, this._handleCacheUpdating);\n      emitter.removeListener(ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATED, this._handleCacheUpdated);\n    }\n  }\n\n  protected _setListeners(isSetListeners: boolean = true): void {\n    this._setSwarmMessagesStoreListeners(isSetListeners);\n    this._setCacheListeners(isSetListeners);\n  }\n\n  protected async _openDatabaseInstance(): Promise<void> {\n    if (!this._swarmMessageStore) {\n      throw new Error('Swarm message store must be provided');\n    }\n    if (!this._dbOptions) {\n      throw new Error('There is no options provided for the database');\n    }\n\n    const result = await this._swarmMessageStore.openDatabase(this._dbOptions);\n\n    if (result instanceof Error) {\n      throw new Error(`Failed top open the database: ${result.message}`);\n    }\n  }\n\n  protected _getSwarmMessagesCacheOptions(): ISwarmMessagesDatabaseCacheOptions<P, T, DbType, MD> {\n    if (!this._dbType) {\n      throw new Error('Failed to defined database type');\n    }\n    if (!this._dbName) {\n      throw new Error('Database name should not be empty');\n    }\n    return {\n      dbInstance: this as ISwarmMessagesDatabaseCacheOptionsDbInstance<P, T, DbType, MD>,\n      dbType: this._dbType,\n      dbName: this._dbName,\n    };\n  }\n\n  protected async _startSwarmMessagesCache(): Promise<void> {\n    const SwarmMessagesCacheConstructor = this._swarmMessagesCacheClassFromOptions;\n    const swarmMessagesCacheOptions = this._getSwarmMessagesCacheOptions();\n    const swarmMessagesCache = new SwarmMessagesCacheConstructor(swarmMessagesCacheOptions);\n\n    await swarmMessagesCache.start();\n    this._swarmMessagesCache = swarmMessagesCache;\n  }\n\n  protected _unsetOptions(): void {\n    this._dbName = undefined;\n    this._dbOptions = undefined;\n    this._dbType = undefined;\n    this._currentUserOptons = undefined;\n  }\n\n  protected _unsetThisInstanceListeners(): void {\n    this._emitter.removeAllListeners();\n  }\n\n  protected _unsetSwarmStoreListeners() {\n    this._setListeners(false);\n  }\n\n  protected _unsetSwarmMessageStoreInstance(): void {\n    this._unsetSwarmStoreListeners();\n    this._swarmMessageStore = undefined;\n  }\n\n  /**\n   * Close the database\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabase\n   */\n  protected async _handleDatabaseClosed() {\n    this._unsetIsReady();\n    this._unsetOptions();\n    this._unsetThisInstanceListeners();\n    this._unsetSwarmMessageStoreInstance();\n  }\n\n  protected async _closeSwarmDatabaseInstance(): Promise<void> {\n    if (!this._checkDatabaseProps()) {\n      throw new Error('Database props are not valid');\n    }\n    const dbName = this._dbName;\n    const result = await this._swarmMessageStore.closeDatabase(dbName);\n\n    if (result instanceof Error) {\n      throw new Error(`Failed to close the database ${dbName}: ${result.message}`);\n    }\n  }\n\n  protected _closeSwarmMessagesCahceInstance(): Promise<void> {\n    if (!this._swarmMessagesCache) {\n      throw new Error('There is no active instance for caching swarm messages');\n    }\n    return this._swarmMessagesCache.close();\n  }\n\n  protected async _dropSwarmDatabaseInstance() {\n    if (!this._checkDatabaseProps()) {\n      throw new Error('Database props are not valid');\n    }\n\n    const dbName = this._dbName;\n    const result = await this._swarmMessageStore?.dropDatabase(dbName);\n\n    if (result instanceof Error) {\n      throw new Error(`Failed to drop the database ${dbName}: ${result.message}`);\n    }\n  }\n\n  /**\n   * Handle what to do with a cache of the messages\n   * if a new message added to the storage.\n   *\n   * @protected\n   * @param {MD} message\n   * @param {TSwarmStoreDatabaseEntityUniqueAddress<P>} messageAddress\n   * @param {string} [key]\n   * @memberof SwarmMessagesDatabase\n   */\n  protected async _handleCacheUpdateOnNewMessage(\n    message: MD,\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ) {\n    if (this._checkIsReady()) {\n      await this._addMessageToCache(this._dbName, message, messageAddress, key);\n    }\n  }\n\n  /**\n   * Performing the swarm messages cache updating\n   * on message removed from the databse.\n   *\n   * @protected\n   * @param {TSwarmMessageUserIdentifierSerialized} userID\n   * @param {TSwarmStoreDatabaseEntityUniqueAddress<P>} messageAddress\n   * @param {string} [keyOrHash]\n   * @memberof SwarmMessagesDatabase\n   */\n  protected async _handleCacheUpdateOnDeleteMessage(\n    userID: TSwarmMessageUserIdentifierSerialized,\n    // the global unique address (hash) of the DELETE message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // deleted message address\n    messageDeletedAddress: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n      : TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key for the value,\n    // for feed store it will be hash of the message which deleted by this one.\n    keyOrHash: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE ? TSwarmStoreDatabaseEntityKey<P> : undefined\n  ) {\n    if (this._checkIsReady()) {\n      await this._removeMessageFromCache(messageDeletedAddress, keyOrHash);\n    }\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database.types.ts",[],"/home/paul/projects/protocol/src/components/message-component/index.ts",[],"/home/paul/projects/protocol/src/components/message-component/message-component.tsx",["3607","3608","3609","3610"],"import React from 'react';\nimport { ISwarmMessageInstanceDecrypted } from '../../classes/swarm-message/swarm-message-constructor.types';\nimport { TSwarmStoreDatabaseEntityKey } from '../../classes/swarm-store-class/swarm-store-class.types';\nimport { ESwarmStoreConnector } from '../../classes/swarm-store-class/swarm-store-class.const';\n\nexport interface IMessageComponentProps<P extends ESwarmStoreConnector> {\n  id: TSwarmStoreDatabaseEntityKey<P>;\n  k?: string;\n  dbName: string;\n  message: ISwarmMessageInstanceDecrypted;\n  deleteMessage?(\n    id: TSwarmStoreDatabaseEntityKey<P>,\n    message: ISwarmMessageInstanceDecrypted,\n    key: string | undefined\n  ): Promise<void>;\n}\n\nexport class MessageComponent<P extends ESwarmStoreConnector> extends React.PureComponent<IMessageComponentProps<P>> {\n  get payload() {\n    return this.props.message.bdy.pld;\n  }\n\n  get senderId() {\n    return this.props.message.uid;\n  }\n\n  delete = () => {\n    const { deleteMessage, id, message, k } = this.props;\n\n    void deleteMessage?.(id, message, k);\n  };\n\n  render() {\n    const { id, k } = this.props;\n    return (\n      <div style={{ border: '1px solid black' }}>\n        <span>\n          {id}; {k && `Key: ${k}`}; From: {this.senderId}\n        </span>\n        <div>{this.payload}</div>\n        <button onClick={this.delete}>Delete</button>\n      </div>\n    );\n  }\n}\n","/home/paul/projects/protocol/src/components/swarm-messages-database-component/index.ts",[],"/home/paul/projects/protocol/src/components/swarm-messages-database-component/swarm-messages-database-component.tsx",["3611","3612","3613","3614","3615","3616","3617","3618","3619","3620","3621","3622","3623","3624","3625","3626","3627","3628","3629","3630"],"import React from 'react';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../../classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY } from '../const/connect-to-swarm.const';\nimport { ESwarmStoreConnectorOrbitDbDatabaseIteratorOption } from '../../classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { MessageComponent } from '../message-component/message-component';\nimport { setMessageListener } from './swarm-messages-database-component.utils';\nimport { ESwarmStoreConnector } from '../../classes/swarm-store-class/swarm-store-class.const';\nimport { TSwarmStoreDatabaseEntityKey, TSwarmStoreDatabaseType } from '../../classes/swarm-store-class/swarm-store-class.types';\nimport {\n  ISwarmMessagesDatabaseMessageDescription,\n  ISwarmMessagesDatabaseDeleteMessageDescription,\n} from './swarm-messages-database-component.types';\nimport {\n  ISwarmMessageInstanceDecrypted,\n  TSwarmMessageSerialized,\n} from '../../classes/swarm-message/swarm-message-constructor.types';\nimport {\n  ISwarmMessageStoreDeleteMessageArg,\n  ISwarmMessageStoreMessagingMethods,\n} from '../../classes/swarm-message-store/swarm-message-store.types';\nimport { setMessageDeleteListener, setCacheUpdateListener } from './swarm-messages-database-component.utils';\nimport {\n  TSwarmMessageDatabaseMessagesCached,\n  ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions,\n} from '../../classes/swarm-messages-database/swarm-messages-database.types';\nimport { isValidSwarmMessageDecryptedFormat } from '../../classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-swarm-message';\nimport { TSwarmMessageUserIdentifierSerialized } from '../../classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { TSwarmStoreDatabaseOptions } from '../../classes/swarm-store-class/swarm-store-class.types';\nimport { IConnectionBridgeUnknown } from '../../classes/connection-bridge/connection-bridge.types';\nimport { ISwarmMessagesDatabaseConnectedFabric } from '../../classes/swarm-messages-database/swarm-messages-database-fabric/swarm-messages-database-fabric.types';\nimport { PromiseResolveType } from '../../types/helper.types';\nimport { TSwarmMessageInstance } from '../../classes/swarm-message/swarm-message-constructor.types';\n\ntype P = ESwarmStoreConnector.OrbitDB;\n\ninterface IProps<\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  CB extends IConnectionBridgeUnknown<P, T, DbType, any, DBO, MSI>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T,\n  MD extends ISwarmMessageInstanceDecrypted\n> {\n  userId: TSwarmMessageUserIdentifierSerialized;\n  databaseOptions: DBO;\n  swarmMessagesDatabaseCacheOptions: ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions<P, T, DbType, DBO, MD>;\n  connectionBridge?: CB;\n  isOpenImmediate?: boolean;\n  swarmMessagesDatabaseConnectedFabric: ISwarmMessagesDatabaseConnectedFabric<P, T, DbType, DBO, MSI, any, MD>;\n}\n\ninterface IState<\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T,\n  MD extends ISwarmMessageInstanceDecrypted\n> {\n  messages: TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined;\n  isOpening: boolean;\n  isClosing: boolean;\n  db?: PromiseResolveType<ReturnType<ISwarmMessagesDatabaseConnectedFabric<P, T, DbType, DBO, MSI, any, MD>>>;\n}\n\nexport class SwarmMessagesDatabaseComponent<\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  CB extends IConnectionBridgeUnknown<P, T, DbType, any, DBO, MSI>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType> = TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T = TSwarmMessageInstance | T,\n  MD extends ISwarmMessageInstanceDecrypted = ISwarmMessageInstanceDecrypted\n> extends React.PureComponent<IProps<T, DbType, CB, DBO, MSI, MD>, IState<T, DbType, DBO, MSI, MD>> {\n  state: IState<T, DbType, DBO, MSI, MD> = {\n    messages: undefined,\n    isOpening: false,\n    isClosing: false,\n    db: undefined,\n  };\n\n  get isOpened(): boolean {\n    const { isOpening, isClosing, db } = this.state;\n\n    return !isOpening && !isClosing && !!db;\n  }\n\n  get isUpdating(): boolean {\n    return !!this.state.db?.whetherMessagesListUpdateInProgress;\n  }\n\n  get messagesCached(): TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined {\n    return this.state.db?.cachedMessages;\n  }\n\n  protected get swarmMessagesDatabaseConnectedFabric(): ISwarmMessagesDatabaseConnectedFabric<P, T, DbType, DBO, MSI, any, MD> {\n    const { swarmMessagesDatabaseConnectedFabric } = this.props;\n    if (!swarmMessagesDatabaseConnectedFabric) {\n      throw new Error('A swarmMessagesDatabaseConnectedFabric not exists in the props');\n    }\n    return swarmMessagesDatabaseConnectedFabric;\n  }\n\n  queryDatabase = async () => {\n    const { db } = this.state;\n\n    if (db) {\n      const result = await db.collect({\n        [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.limit]: -1,\n      });\n      console.log(result);\n    }\n  };\n\n  queryDatabaseMessagesWithMeta = async () => {\n    const { db } = this.state;\n\n    if (db) {\n      const result = await db.collectWithMeta({\n        [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.limit]: -1,\n      } as any);\n      console.log(result);\n    }\n  };\n\n  onNewMessage = (message: ISwarmMessagesDatabaseMessageDescription<P>): void => {\n    console.log('New message', message);\n  };\n\n  onMessageDelete = (deleteMessageDescription: ISwarmMessagesDatabaseDeleteMessageDescription<P>) => {\n    console.log('Message removed', deleteMessageDescription);\n  };\n\n  onMessagesCacheUpdated = (messages: TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined) => {\n    console.log('Cache updated', messages);\n    this.setState({\n      messages,\n    });\n  };\n\n  handleDbClose = async () => {\n    const { connectionBridge } = this.props;\n    const { isClosing, db } = this.state;\n\n    if (connectionBridge && db && this.isOpened && !isClosing) {\n      try {\n        this.setState({ isClosing: true });\n        await db.close();\n        this.setState({ db: undefined });\n      } catch (err) {\n        console.error(err);\n      } finally {\n        this.setState({ isClosing: false });\n      }\n    }\n  };\n\n  handleDbOpen = async () => {\n    const { connectionBridge, databaseOptions, swarmMessagesDatabaseCacheOptions: cacheOptions } = this.props;\n    const { isOpening } = this.state;\n\n    if (connectionBridge && connectionBridge.swarmMessageStore && !this.isOpened && !isOpening) {\n      try {\n        this.setState({ isOpening: true });\n\n        const dbOptions: DBO = {\n          ...databaseOptions,\n          grantAccess: async (...args: any[]) => {\n            console.log(...args);\n            return true;\n          },\n        };\n        const db = await this.swarmMessagesDatabaseConnectedFabric({\n          dbOptions,\n          cacheOptions,\n          swarmMessageStore: connectionBridge.swarmMessageStore,\n          user: {\n            userId: this.props.userId,\n          },\n        });\n\n        setMessageListener<\n          P,\n          T,\n          DbType,\n          DBO,\n          MSI,\n          ISwarmMessageStoreMessagingMethods<P, T, DbType, Exclude<MSI, T>>,\n          MD,\n          Required<IState<T, DbType, DBO, MSI, MD>>['db']\n        >(db, this.onNewMessage);\n        setMessageDeleteListener<\n          P,\n          T,\n          DbType,\n          DBO,\n          MSI,\n          ISwarmMessageStoreMessagingMethods<P, T, DbType, Exclude<MSI, T>>,\n          MD,\n          Required<IState<T, DbType, DBO, MSI, MD>>['db']\n        >(db, this.onMessageDelete);\n        setCacheUpdateListener<\n          P,\n          T,\n          DbType,\n          DBO,\n          MSI,\n          ISwarmMessageStoreMessagingMethods<P, T, DbType, Exclude<MSI, T>>,\n          MD,\n          Required<IState<T, DbType, DBO, MSI, MD>>['db']\n        >(db, this.onMessagesCacheUpdated);\n        this.setState({ db });\n      } catch (err) {\n        console.error(err);\n      } finally {\n        this.setState({ isOpening: false });\n      }\n    }\n  };\n\n  handleDeleteMessage = async (\n    id: TSwarmStoreDatabaseEntityKey<P>,\n    message: MD,\n    key: TSwarmStoreDatabaseEntityKey<P> | undefined\n  ): Promise<void> => {\n    const { db } = this.state;\n    let removeArg: TSwarmStoreDatabaseEntityKey<P> | T | MD | undefined;\n\n    if (this.isOpened && db?.isReady) {\n      const { dbType } = db;\n\n      if (dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE) {\n        if (!key) {\n          throw new Error('For key-value database type a key must be provided to delete a message');\n        }\n        removeArg = key;\n      } else if (db.dbType === ESwarmStoreConnectorOrbitDbDatabaseType.FEED) {\n        removeArg = id;\n      } else {\n        removeArg = message;\n      }\n      return db.deleteMessage(removeArg as ISwarmMessageStoreDeleteMessageArg<P>);\n    }\n  };\n\n  protected sendSwarmMessage = async () => {\n    const { databaseOptions } = this.props;\n    const { db } = this.state;\n\n    try {\n      if (this.isOpened && db) {\n        if (!databaseOptions.isPublic) {\n          alert('It is not a public database');\n          return;\n        }\n\n        let key: TSwarmStoreDatabaseEntityKey<P> | undefined;\n\n        if (databaseOptions.dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE) {\n          key = prompt('Key for the message', '') || undefined;\n          if (!key) {\n            return;\n          }\n        }\n\n        // const message = prompt('Message', String(new Date()));\n        while (true) {\n          await db.addMessage(\n            {\n              ...CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY,\n              pld: String(new Date()) || '',\n            },\n            key\n          );\n          await new Promise((res) => setTimeout(res, 300));\n        }\n      }\n    } catch (err) {\n      console.error(err);\n      alert(err.message);\n    }\n  };\n\n  componentDidMount() {\n    const { isOpenImmediate } = this.props;\n\n    if (isOpenImmediate) {\n      void this.handleDbOpen();\n    }\n  }\n\n  render() {\n    const { isOpening, isClosing } = this.state;\n    const { databaseOptions } = this.props;\n    const { isOpened, isUpdating } = this;\n    const { dbName, isPublic } = databaseOptions;\n    // TODO - this.messagesCached doesn't work\n    const { messages } = this.state;\n\n    return (\n      <div style={{ border: '1px solid black' }}>\n        Database: {dbName}, {isOpened ? 'opened' : 'closed'}, {isPublic ? 'is public' : ''}, {isOpening && 'is opening'},{' '}\n        {isClosing && 'is closing'};\n        <br />\n        {isOpened ? <button onClick={this.handleDbClose}>Close</button> : <button onClick={this.handleDbOpen}>Open</button>}\n        <br />\n        {isOpened && <button onClick={this.sendSwarmMessage}>Send message</button>}\n        {isUpdating && <div>Updating...</div>}\n        <div>\n          Messages:\n          {messages &&\n            Array.from(messages.entries()).map(([key, messageWithMeta]) => {\n              const { messageAddress, dbName: messageDbName, message } = messageWithMeta;\n              let messageId = '';\n\n              if (message instanceof Error) {\n                return <div>Error: {message.message}</div>;\n              }\n              try {\n                if (!isValidSwarmMessageDecryptedFormat(message)) {\n                  return <div>Message has an invalid format</div>;\n                }\n              } catch (err) {\n                return <div>Error message format: {err.message}</div>;\n              }\n              if (messageAddress instanceof Error) {\n                messageId = messageAddress.message;\n              } else if (messageAddress) {\n                messageId = messageAddress;\n              }\n              return (\n                <MessageComponent\n                  key={key}\n                  dbName={messageDbName || dbName}\n                  id={messageId}\n                  k={key}\n                  message={message}\n                  deleteMessage={this.handleDeleteMessage}\n                />\n              );\n            })}\n        </div>\n      </div>\n    );\n  }\n}\n","/home/paul/projects/protocol/src/components/swarm-messages-database-component/swarm-messages-database-component.types.ts",[],"/home/paul/projects/protocol/src/components/swarm-messages-database-component/swarm-messages-database-component.utils.ts",["3631","3632"],"import { ESwarmStoreConnector } from '../../classes/swarm-store-class/swarm-store-class.const';\nimport { TSwarmMessageDatabaseMessagesCached } from '../../classes/swarm-messages-database/swarm-messages-database.types';\nimport {\n  ISwarmMessageInstanceDecrypted,\n  TSwarmMessageSerialized,\n  ISwarmMessageInstanceEncrypted,\n} from '../../classes/swarm-message/swarm-message-constructor.types';\nimport {\n  ISwarmMessagesDatabaseMessageDescription,\n  ISwarmMessagesDatabaseDeleteMessageDescription,\n} from './swarm-messages-database-component.types';\nimport { ESwarmMessageStoreEventNames } from '../../classes/swarm-message-store/swarm-message-store.const';\nimport { ESwarmMessagesDatabaseCacheEventsNames } from '../../classes/swarm-messages-database/swarm-messages-database.const';\nimport { TSwarmStoreDatabaseOptions } from '../../classes/swarm-store-class/swarm-store-class.types';\nimport { ISwarmMessageStoreMessagingMethods } from '../../classes/swarm-message-store/swarm-message-store.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../../classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { ISwarmMessagesDatabaseConnector } from '../../classes/swarm-messages-database/swarm-messages-database.types';\nimport { TSwarmMessageInstance } from '../../classes/swarm-message/swarm-message-constructor.types';\nimport {\n  TSwarmStoreDatabaseType,\n  TSwarmStoreDatabaseEntityKey,\n  TSwarmStoreDatabaseEntityAddress,\n} from '../../classes/swarm-store-class/swarm-store-class.types';\n\nexport const setMessageListener = <\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T,\n  SMS extends ISwarmMessageStoreMessagingMethods<P, T, DbType, Exclude<MSI, T>>,\n  MD extends ISwarmMessageInstanceDecrypted,\n  DB extends ISwarmMessagesDatabaseConnector<P, T, DbType, DBO, MSI, SMS, MD>\n>(\n  db: DB,\n  messagesListener: (message: ISwarmMessagesDatabaseMessageDescription<P>) => void\n): (() => void) => {\n  const listener = (\n    dbName: string,\n    message: ISwarmMessageInstanceDecrypted,\n    // the global unique address of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ) => {\n    messagesListener({\n      message,\n      id: messageAddress,\n      key,\n    });\n  };\n  db.emitter.addListener(ESwarmMessageStoreEventNames.NEW_MESSAGE, listener);\n  return () => {\n    db.emitter.removeListener(ESwarmMessageStoreEventNames.NEW_MESSAGE, listener);\n  };\n};\n\nexport const setMessageDeleteListener = <\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T,\n  SMS extends ISwarmMessageStoreMessagingMethods<P, T, DbType, Exclude<MSI, T>>,\n  MD extends ISwarmMessageInstanceDecrypted,\n  DB extends ISwarmMessagesDatabaseConnector<P, T, DbType, DBO, MSI, SMS, MD>\n>(\n  db: DB,\n  messagesDeleteListener: (message: ISwarmMessagesDatabaseDeleteMessageDescription<P>) => void\n): (() => void) => {\n  const listener = (\n    dbName: DBO['dbName'],\n    // the user who removed the message\n    userId: TSwarmMessageUserIdentifierSerialized,\n    // the global unique address (hash) of the DELETE message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // the global unique address (hash) of the DELETED message in the swarm\n    messageDeletedAddress: TSwarmStoreDatabaseEntityAddress<P> | undefined,\n    // for key-value store it will be the key for the value,\n    // for feed store it will be hash of the message which deleted by this one.\n    key: TSwarmStoreDatabaseEntityKey<P> | undefined\n  ) => {\n    messagesDeleteListener({\n      id: messageAddress,\n      idDeleted: messageDeletedAddress,\n      key,\n      userId,\n    });\n  };\n\n  db.emitter.addListener(ESwarmMessageStoreEventNames.DELETE_MESSAGE, listener);\n  return () => db.emitter.removeListener(ESwarmMessageStoreEventNames.DELETE_MESSAGE, listener);\n};\n\nexport const setCacheUpdateListener = <\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T,\n  SMS extends ISwarmMessageStoreMessagingMethods<P, T, DbType, Exclude<MSI, T>>,\n  MD extends ISwarmMessageInstanceDecrypted,\n  DB extends ISwarmMessagesDatabaseConnector<P, T, DbType, DBO, MSI, SMS, MD>\n>(\n  db: DB,\n  cacheUpdateListener: (messages: TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined) => unknown\n) => {\n  const listener = (messages: TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined) => {\n    cacheUpdateListener(messages);\n  };\n  db.emitter.addListener(ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATED, listener);\n  return () => db.emitter.removeListener(ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATED, listener);\n};\n","/home/paul/projects/protocol/src/components/swarm-store-db-component/index.ts",[],"/home/paul/projects/protocol/src/components/swarm-store-db-component/swarm-store-db-component.tsx",["3633","3634","3635","3636","3637","3638","3639","3640","3641","3642"],"import React from 'react';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../../classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY } from '../const/connect-to-swarm.const';\nimport { MessageComponent } from '../message-component/message-component';\nimport { IMessageDescription } from '../connect-to-swarm/connect-to-swarm';\nimport { IConnectionBridgeUnknown } from '../../classes/connection-bridge/connection-bridge.types';\nimport { ESwarmStoreConnector } from '../../classes/swarm-store-class/swarm-store-class.const';\nimport {\n  TSwarmStoreDatabaseType,\n  TSwarmStoreDatabaseOptions,\n  TSwarmStoreDatabaseEntityKey,\n} from '../../classes/swarm-store-class/swarm-store-class.types';\nimport {\n  TSwarmMessageSerialized,\n  TSwarmMessageInstance,\n  ISwarmMessageBodyDeserialized,\n} from '../../classes/swarm-message/swarm-message-constructor.types';\n\ninterface IProps<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  CD extends boolean = true,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType> = TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T = TSwarmMessageInstance | T\n> {\n  databaseOptions: DBO;\n  isOpened: boolean;\n  connectionBridge?: IConnectionBridgeUnknown<P, T, DbType, CD, DBO, MSI>;\n  messages: IMessageDescription<P>[];\n}\n\nexport class SwarmStoreDbComponent<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType> = TSwarmStoreDatabaseOptions<P, T, DbType>,\n  CD extends boolean = boolean,\n  MSI extends TSwarmMessageInstance | T = TSwarmMessageInstance | T\n> extends React.PureComponent<IProps<P, T, DbType, CD, DBO, MSI>> {\n  state = {\n    isOpening: false as boolean,\n    isClosing: false as boolean,\n  };\n\n  protected get connectionBridgeStorageOrUndefined(): Required<\n    IProps<P, T, DbType, CD, DBO, MSI>\n  >['connectionBridge']['swarmMessageStore'] {\n    return this.props.connectionBridge?.swarmMessageStore;\n  }\n\n  handleDbClose = async () => {\n    const { connectionBridgeStorageOrUndefined } = this;\n    const { databaseOptions, isOpened } = this.props;\n    const { isClosing } = this.state;\n\n    if (connectionBridgeStorageOrUndefined && isOpened && !isClosing) {\n      try {\n        this.setState({ isClosing: true });\n        await connectionBridgeStorageOrUndefined.closeDatabase(databaseOptions.dbName);\n      } catch (err) {\n        console.error(err);\n      } finally {\n        this.setState({ isClosing: false });\n      }\n    }\n  };\n\n  handleDbOpen = async () => {\n    const { connectionBridgeStorageOrUndefined } = this;\n    const { databaseOptions, isOpened } = this.props;\n    const { isOpening } = this.state;\n\n    if (connectionBridgeStorageOrUndefined && !isOpened && !isOpening) {\n      try {\n        this.setState({ isOpening: true });\n        await connectionBridgeStorageOrUndefined?.openDatabase({\n          ...databaseOptions,\n          grantAccess: async (...args: any[]) => {\n            console.log(...args);\n            return true;\n          },\n        });\n      } catch (err) {\n        console.error(err);\n      } finally {\n        this.setState({ isOpening: false });\n      }\n    }\n  };\n\n  protected isKeyValueDatabase(\n    connectionBridge: any\n  ): connectionBridge is IConnectionBridgeUnknown<P, T, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE, CD, any, MSI> {\n    const { databaseOptions } = this.props;\n    return !!connectionBridge && databaseOptions.dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE;\n  }\n\n  protected createSwarmMessageBody(): ISwarmMessageBodyDeserialized {\n    const messagePayload = prompt('Message', '');\n    return {\n      ...CONNECT_TO_SWARM_STORAGE_DEFAULT_MESSAGE_BODY,\n      pld: messagePayload || '',\n    };\n  }\n\n  protected sendSwarmMessage = async () => {\n    const { connectionBridgeStorageOrUndefined } = this;\n    const { connectionBridge, databaseOptions, isOpened } = this.props;\n    try {\n      if (isOpened && connectionBridge && connectionBridgeStorageOrUndefined) {\n        if (!databaseOptions.isPublic) {\n          alert('It is not a public database');\n          return;\n        }\n        let key: TSwarmStoreDatabaseEntityKey<P> | undefined;\n        const { connectionBridge } = this.props;\n\n        if (this.isKeyValueDatabase(connectionBridge)) {\n          key = (prompt('Key for the message', '') || undefined) as TSwarmStoreDatabaseEntityKey<P>;\n          if (!key) {\n            throw new Error('Key should be defined for key value store');\n          }\n        }\n        await connectionBridgeStorageOrUndefined.addMessage(databaseOptions.dbName, this.createSwarmMessageBody(), key);\n      }\n    } catch (err) {\n      console.error(err);\n      alert(err.message);\n    }\n  };\n\n  render() {\n    const { isOpening, isClosing } = this.state;\n    const { databaseOptions, isOpened, messages } = this.props;\n    const { dbName, isPublic } = databaseOptions;\n\n    return (\n      <div style={{ border: '1px solid black' }}>\n        Database: {dbName}, {isOpened ? 'opened' : 'closed'}, {isPublic ? 'is public' : ''}, {isOpening && 'is opening'},{' '}\n        {isClosing && 'is closing'};\n        <br />\n        {isOpened ? <button onClick={this.handleDbClose}>Close</button> : <button onClick={this.handleDbOpen}>Open</button>}\n        <br />\n        {isOpened && <button onClick={this.sendSwarmMessage}>Send message</button>}\n        <div>\n          Messages:\n          {messages.map((message) => {\n            return (\n              <MessageComponent key={message.id} dbName={dbName} id={message.id} k={message.key} message={message.message} />\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/event-emitter-class-base/event-emitter-class-base.types.ts",["3643"],"import EEmitter from 'events';\nimport TypedEmitter from 'strict-event-emitter-types';\n\nexport type TTypedEmitter<IEvents extends Record<string, any>> = TypedEmitter<EEmitter, IEvents>;\n","/home/paul/projects/protocol/src/classes/storage-providers/storage-in-memory-provider/index.ts",[],"/home/paul/projects/protocol/src/classes/storage-providers/storage-in-memory-provider/storage-in-memory-provider.ts",["3644","3645","3646","3647","3648","3649","3650","3651","3652","3653","3654","3655","3656","3657","3658","3659","3660"],"import assert from 'assert';\n\nimport { isTypedArrayNative } from 'utils/typed-array-utils';\n\nimport { StorageProvider, IStorageProviderOptions } from '../storage-providers.types';\nimport { TStorageInMemory } from './storage-in-memory-provider.types';\n\nexport class StorageProviderInMemory<V = any> extends StorageProvider<V> {\n  public static isBufferSupported = true;\n\n  private _isConnected: boolean = false;\n\n  private _options?: IStorageProviderOptions;\n\n  private _storage?: TStorageInMemory<V>;\n\n  public async connect(options?: IStorageProviderOptions): Promise<true | Error> {\n    try {\n      if (!this._isConnected) {\n        this._storage = new Map();\n        this._setOptions(options);\n        this._setIsConnected();\n      }\n      return true;\n    } catch (err) {\n      console.error('SecretStorageProviderLevelJS', err);\n      return err;\n    }\n  }\n\n  public async disconnect(): Promise<true | Error> {\n    try {\n      if (this._isConnected) {\n        this._unsetOptions();\n        this._unsetDb();\n        this._unsetIsConnected();\n      }\n      return true;\n    } catch (err) {\n      console.error(err);\n      return err;\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public async set(key: string, value?: V | Uint8Array): Promise<Error | true> {\n    if (!value) {\n      return this.unset(key);\n    }\n    try {\n      this._checkIsReady();\n      this._storage?.set(key, value as V);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async unset(key: string): Promise<Error | true> {\n    try {\n      this._checkIsReady();\n      this._storage?.delete(key);\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async clearDb(): Promise<Error | boolean> {\n    try {\n      this._checkIsReady();\n      this._storage?.clear();\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * WARNING! If the value is empty\n   * it will be removed with the leveljs.del\n   *\n   * @param {string} key\n   * @param {string} [value]\n   * @returns {(Promise<Error | true>)}\n   * @memberof SecretStorageProviderLevelJS\n   */\n  public setUInt8Array(key: string, value?: Uint8Array): Promise<Error | true> {\n    return this.set(key, value);\n  }\n\n  public async get(key: string): Promise<V | Error | undefined> {\n    try {\n      this._checkIsReady();\n      return this._storage?.get(key);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  public async getUInt8Array(key: string): Promise<Error | Uint8Array | undefined> {\n    try {\n      this._checkIsReady();\n\n      const item = await this.get(key);\n\n      if (item instanceof Error) {\n        throw item;\n      }\n      if (Array.isArray(item) || isTypedArrayNative(item)) {\n        return new Uint8Array(item);\n      }\n      if (item) {\n        throw new Error('The entiry is not related to Uint8Array');\n      }\n      return undefined;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected _setOptions(options?: IStorageProviderOptions): void {\n    if (options) {\n      assert(options && typeof options !== 'object', 'Options must be an object');\n      this._options = options;\n    }\n  }\n\n  protected _setIsConnected() {\n    this._isConnected = true;\n  }\n\n  protected _unsetIsConnected() {\n    this._isConnected = false;\n  }\n\n  protected _unsetOptions() {\n    this._options = undefined;\n  }\n\n  protected _unsetDb() {\n    this._storage = undefined;\n  }\n\n  protected _checkIsReady(): this is { _storage: TStorageInMemory<V> } {\n    assert(this._isConnected, 'The instance is disconnected');\n    assert(this._storage instanceof Map, 'Storage is not initialized');\n    return true;\n  }\n}\n","/home/paul/projects/protocol/src/classes/storage-providers/storage-in-memory-provider/storage-in-memory-provider.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.ts",["3661","3662"],"import { StorageProvider } from '../../../storage-providers/storage-providers.types';\nimport { ISwarmMessageDecrypted } from '../../../swarm-message/swarm-message-constructor.types';\nimport {\n  SWARM_MESSAGE_STORE_UTILS_MESSAGES_CACHE_KEY_DB_KEY_VALUE_KEY_PREFIX,\n  SWARM_MESSAGE_STORE_UTILS_MESSAGES_CACHE_KEY_PARTS_DELIMETER,\n} from './swarm-message-store-utils-messages-cache.const';\nimport {\n  ISwarmMessageStoreUtilsMessagesCache,\n  ISwarmMessageStoreUtilsMessagesCacheOptions,\n  ISwarmMessageStoreUtilsMessageCacheReady,\n} from './swarm-message-store-utils-messages-cache.types';\nimport assert from 'assert';\nimport {\n  TSwarmStoreDatabaseEntityAddress,\n  TSwarmStoreDatabaseEntityKey,\n} from '../../../swarm-store-class/swarm-store-class.types';\nimport { ESwarmStoreConnector } from '../../../swarm-store-class/swarm-store-class.const';\n\nexport class SwarmMessageStoreUtilsMessagesCache<P extends ESwarmStoreConnector, MD extends ISwarmMessageDecrypted>\n  implements ISwarmMessageStoreUtilsMessagesCache<P, MD> {\n  /**\n   * Falag means the instance is opened and ready to use.\n   *\n   * @protected\n   * @type {boolean}\n   * @memberof SwarmMessageStoreUtilsMessagesCache\n   */\n  protected _isReady: boolean = false;\n  protected _cache?: StorageProvider<MD | TSwarmStoreDatabaseEntityKey<P> | TSwarmStoreDatabaseEntityAddress<P>>;\n\n  protected _dbName?: string;\n\n  /**\n   * Open connection with the instance.\n   *\n   * @param {ISwarmMessageStoreUtilsMessagesCacheOptions} options - options for the instance.\n   * @returns {Promise<void>}\n   * @memberof ISwarmMessageStoreUtilsMessagesCache\n   */\n  async connect(options: ISwarmMessageStoreUtilsMessagesCacheOptions<P, MD>): Promise<void> {\n    if (this._isReady) {\n      return;\n    }\n    this._validateAndSetOptions(options);\n    this._isReady = true;\n  }\n\n  /**\n   * Return a swarm message by it's unique address\n   *\n   * @param {string} messageAddress - message unique address\n   * @memberof ISwarmMessageStoreUtilsMessagesCache\n   * @returns {(Promise<TSwarmMessageInstance | undefined>)} - undefined if not exist or swarm message instance\n   */\n  getMessageByAddress = async (messageAddress: TSwarmStoreDatabaseEntityAddress<P>): Promise<MD | undefined> => {\n    if (this._checkIsReady()) {\n      const cacheKey = this.getCacheKeyForMessageAddressAndDbName(messageAddress);\n      const value = await this._cache.get(cacheKey);\n\n      if (value instanceof Error) {\n        throw value;\n      }\n      if (typeof value === 'string') {\n        throw new Error('A swarm message instance must not be a string');\n      }\n      return value;\n    }\n  };\n\n  /**\n   * Set a swarm message for the messages's unique address.\n   *\n   * @param {string} messageAddress - message's unique address\n   * @param {TSwarmMessageInstance} message - message instance\n   * @returns {Promise<void>}\n   * @memberof ISwarmMessageStoreUtilsMessagesCache\n   * @throws\n   */\n  setMessageByAddress = async (messageAddress: TSwarmStoreDatabaseEntityAddress<P>, message: MD): Promise<void> => {\n    if (this._checkIsReady()) {\n      const cacheKey = this.getCacheKeyForMessageAddressAndDbName(messageAddress);\n      const value = await this._cache.set(cacheKey, message);\n\n      if (value instanceof Error) {\n        throw value;\n      }\n    }\n  };\n\n  /**\n   * Unset message in cache by it's address\n   *\n   * @param {string} messageAddress - message's address.\n   * @returns {Promise<void>}\n   * @memberof ISwarmMessageStoreUtilsMessagesCache\n   * @throws\n   */\n  unsetMessageByAddress = async (messageAddress: TSwarmStoreDatabaseEntityAddress<P>): Promise<void> => {\n    if (this._checkIsReady()) {\n      const cacheKey = this.getCacheKeyForMessageAddressAndDbName(messageAddress);\n      const value = await this._cache.unset(cacheKey);\n\n      if (value instanceof Error) {\n        throw value;\n      }\n    }\n  };\n\n  /**\n   * Returns a swarm message's address for a key\n   * of a key-value database.\n   *\n   * @param {string} dbKey - database key for a key-value database\n   * @returns {(Promise<string | undefined>)} - message address or undefined if not exists for the key\n   * @memberof ISwarmMessageStoreUtilsMessagesCache\n   */\n  getMessageAddressByKey = async (\n    dbKey: TSwarmStoreDatabaseEntityKey<P>\n  ): Promise<TSwarmStoreDatabaseEntityAddress<P> | undefined> => {\n    if (this._checkIsReady()) {\n      const cacheKey = this.getCacheKeyForDbKeyAndDbName(dbKey);\n      const value = await this._cache.get(cacheKey);\n\n      if (value instanceof Error) {\n        throw value;\n      }\n      if (typeof value !== 'string') {\n        throw new Error('A swarm message address must be a string');\n      }\n      return value;\n    }\n  };\n\n  /**\n   * Set message's address in cache for a key of a key-value database.\n   *\n   * @param {string} dbKey - database key for a key-value database\n   * @param {string} messageAddress - swarm message instance\n   * @returns {Promise<void>}\n   * @memberof ISwarmMessageStoreUtilsMessagesCache\n   * @throws\n   */\n  setMessageAddressForKey = async (\n    dbKey: TSwarmStoreDatabaseEntityKey<P>,\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>\n  ): Promise<void> => {\n    if (this._checkIsReady()) {\n      const cacheKey = this.getCacheKeyForDbKeyAndDbName(dbKey);\n      const value = await this._cache.set(cacheKey, messageAddress);\n\n      if (value instanceof Error) {\n        throw value;\n      }\n    }\n  };\n\n  /**\n   * Unset message's address for a key of a database.\n   *\n   * @param {string} dbKey\n   * @returns {Promise<void>}\n   * @memberof ISwarmMessageStoreUtilsMessagesCache\n   * @throws\n   */\n  unsetMessageAddressForKey = async (dbKey: TSwarmStoreDatabaseEntityKey<P>): Promise<void> => {\n    if (this._checkIsReady()) {\n      const cacheKey = this.getCacheKeyForDbKeyAndDbName(dbKey);\n      const value = await this._cache.unset(cacheKey);\n\n      if (value instanceof Error) {\n        throw value;\n      }\n    }\n  };\n\n  /**\n   * Returns a message by key of a key-value database.\n   *\n   * @param {string} dbKey\n   * @returns {(Promise<TSwarmMessageInstance | undefined>)}\n   * @memberof ISwarmMessageStoreUtilsMessagesCache\n   * @throws\n   */\n  getMessageByKey = async (dbKey: TSwarmStoreDatabaseEntityKey<P>): Promise<MD | undefined> => {\n    const messageAddress = await this.getMessageAddressByKey(dbKey);\n\n    if (!messageAddress) {\n      return;\n    }\n    return this.getMessageByAddress(messageAddress);\n  };\n\n  /**\n   * Clear all database's values.\n   *\n   * @returns {Promise<void>}\n   * @memberof ISwarmMessageStoreUtilsMessagesCache\n   * @throws\n   */\n  clear = async (): Promise<void> => {\n    if (this._checkIsReady()) {\n      await this._cache.clearDb();\n    }\n  };\n\n  /**\n   * Validate options\n   *\n   * @protected\n   * @param {ISwarmMessageStoreUtilsMessagesCacheOptions} options\n   * @memberof SwarmMessageStoreUtilsMessagesCache\n   * @throws\n   */\n  protected _validateOptions(options: ISwarmMessageStoreUtilsMessagesCacheOptions<P, MD>): void {\n    assert(!!options, 'Options should not be empty');\n    assert(typeof options === 'object', 'Options should be an object');\n    assert(typeof options.dbName === 'string', 'A database name should be a string');\n    assert(!!options.cache, 'A cache storage implementation should be defined');\n    assert(typeof options.cache === 'object', 'Cache implementation should be an object');\n    assert(\n      typeof options.cache.get === 'function',\n      'Cache implementation is not related to the interface - should have the \"get\" method'\n    );\n    assert(\n      typeof options.cache.set === 'function',\n      'Cache implementation is not related to the interface - should have the \"set\" method'\n    );\n  }\n\n  /**\n   * Validate and set options\n   *\n   * @protected\n   * @param {ISwarmMessageStoreUtilsMessagesCacheOptions} options\n   * @memberof SwarmMessageStoreUtilsMessagesCache\n   */\n  protected _validateAndSetOptions(options: ISwarmMessageStoreUtilsMessagesCacheOptions<P, MD>): void {\n    this._validateOptions(options);\n    this._cache = options.cache;\n    this._dbName = options.dbName;\n  }\n\n  /**\n   * Checks the instance is ready to use\n   *\n   * @protected\n   * @returns {this is ISwarmMessageStoreUtilsMessageCacheReady}\n   * @memberof SwarmMessageStoreUtilsMessagesCache\n   * @throws\n   */\n  protected _checkIsReady(): this is ISwarmMessageStoreUtilsMessageCacheReady<P, MD> {\n    assert(this._isReady, 'The instance is not ready');\n    assert(this._cache, 'Cache is not defined for the instance');\n    assert(this._dbName, 'Database name should be defined');\n    return true;\n  }\n\n  /**\n   * Get key in cache for Key value storage\n   *\n   * @protected\n   * @param {string} messageAddress\n   * @param {string} dbName\n   * @returns {string}\n   * @memberof SwarmMessageStore\n   */\n  protected getCacheKeyForMessageAddressAndDbName(messageAddress: TSwarmStoreDatabaseEntityAddress<P>): string {\n    return `${this._dbName}${SWARM_MESSAGE_STORE_UTILS_MESSAGES_CACHE_KEY_PARTS_DELIMETER}${messageAddress}`;\n  }\n\n  protected getCacheKeyForDbKeyAndDbName(messageKey: TSwarmStoreDatabaseEntityKey<P>): string {\n    return `${SWARM_MESSAGE_STORE_UTILS_MESSAGES_CACHE_KEY_DB_KEY_VALUE_KEY_PREFIX}${this._dbName}${SWARM_MESSAGE_STORE_UTILS_MESSAGES_CACHE_KEY_PARTS_DELIMETER}${messageKey}`;\n  }\n\n  protected async clearCache() {\n    await this._cache?.clearDb();\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-utils-messages-cache/swarm-message-store-utils-messages-cache.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database.const.ts",[],"/home/paul/projects/protocol/src/utils/throttling-utils/index.ts",[],"/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/index.ts",[],"/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/throttling-utils-idle-callback.const.ts",[],"/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/throttling-utils-idle-callback.ts",["3663","3664","3665","3666","3667","3668"],"import { THROTTLING_UTILS_IDLE_CALLBACK_TIMEOUT_DEFAULT_MS } from './throttling-utils-idle-callback.const';\nimport {\n  RequestIdleCallback,\n  CancelRequestIdleCallback,\n  RequestIdleCallbackArgument,\n} from './throttling-utils-idle-callback.types';\n\nexport const getRequestIdleCallback = (): RequestIdleCallback =>\n  (window as any).requestIdleCallback ||\n  function (cb) {\n    return setTimeout(function () {\n      const start = Date.now();\n      cb({\n        didTimeout: false,\n        timeRemaining: function () {\n          return Math.max(0, 50 - (Date.now() - start));\n        },\n      });\n    }, 1);\n  };\n\nexport const getCancelRequestIdleCallback = (): CancelRequestIdleCallback =>\n  (window as any).cancelIdleCallback ||\n  function (id: number) {\n    clearTimeout(id);\n  };\n\nexport const resolveOnIdleCallback = (\n  timeoutMs: number = THROTTLING_UTILS_IDLE_CALLBACK_TIMEOUT_DEFAULT_MS\n): Promise<{\n  timeRemaining: number;\n  didTimeout: boolean;\n}> =>\n  new Promise((res) => {\n    const requestIdleCallback = getRequestIdleCallback();\n    const idleCallback = requestIdleCallback(\n      (e: RequestIdleCallbackArgument) => {\n        const timeRemaining = Number(e.timeRemaining && e.timeRemaining());\n        res({\n          timeRemaining,\n          didTimeout: !!e.didTimeout,\n        });\n        getCancelRequestIdleCallback()(idleCallback);\n      },\n      { timeout: timeoutMs }\n    );\n  });\n","/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-idle-callback/throttling-utils-idle-callback.types.ts",["3669"],"export interface RequestIdleCallbackArgument {\n  didTimeout?: boolean;\n  timeRemaining?(): number;\n}\n\nexport interface RequestIdleCallbackOptions {\n  timeout?: number;\n}\n\nexport type RequestIdleCallbackId = number;\n\nexport interface RequestIdleCallback {\n  (cb: (deadline: RequestIdleCallbackArgument) => any, options?: RequestIdleCallbackOptions): RequestIdleCallbackId;\n}\n\nexport interface CancelRequestIdleCallback {\n  (id: RequestIdleCallbackId): void;\n}\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.ts",["3670","3671","3672","3673","3674","3675","3676","3677","3678","3679","3680","3681","3682","3683","3684","3685","3686","3687","3688","3689","3690","3691","3692","3693","3694","3695","3696","3697","3698","3699","3700","3701","3702"],"import { ESwarmStoreConnector } from '../../../swarm-store-class/swarm-store-class.const';\nimport {\n  TSwarmStoreDatabaseEntityAddress,\n  TSwarmStoreDatabaseEntityKey,\n  TSwarmStoreDatabaseEntityUniqueIndex,\n  TSwarmStoreDatabaseIteratorMethodArgument,\n  TSwarmStoreDatabaseType,\n} from '../../../swarm-store-class/swarm-store-class.types';\nimport {\n  ISwarmMessageDatabaseEvents,\n  ISwarmMessagesDatabaseCache,\n  TSwarmMessageDatabaseMessagesCached,\n} from '../../swarm-messages-database.types';\nimport { ISwarmMessageStoreMessagingRequestWithMetaResult } from '../../../swarm-message-store';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database';\nimport {\n  ESwarmMessagesDatabaseCacheEventsNames,\n  SWARM_MESSAGES_DATABASE_MESSAGES_CACHE_ITEMS_COUNT_LIMIT_DEFAULT,\n  SWARM_MESSAGES_DATABASE_MESSAGES_CACHE_ITEMS_COUNT_PER_IDLE_PERIOD_OF_50_MS,\n  SWARM_MESSAGES_DATABASE_MESSAGES_CACHE_ITEMS_MAX_PAGE_QUERY_ATTEMPTS_DEFAULT,\n} from '../../swarm-messages-database.const';\nimport {\n  resolveOnIdleCallback,\n  THROTTLING_UTILS_IDLE_CALLBACK_TIME_REMAINING_MAX_MS,\n} from '../../../../utils/throttling-utils/throttling-utils-idle-callback';\nimport { getItemsCount, round } from '../../../../utils/common-utils';\nimport { TTypedEmitter } from '../../../basic-classes/event-emitter-class-base/event-emitter-class-base.types';\nimport { getEventEmitterInstance } from '../../../basic-classes/event-emitter-class-base/event-emitter-class-base';\nimport { ISwarmMessageStoreMessageWithMeta } from '../../../swarm-message-store/swarm-message-store.types';\nimport {\n  ISwarmMessagesDatabaseCacheOptions,\n  ISwarmMessagesDatabaseCacheOptionsDbInstance,\n} from '../../swarm-messages-database.types';\nimport {\n  SWARM_MESSAGES_DATABASE_CACHE_PLANNED_CACHE_UPDATE_FAILED_RETRY_DELAY_MS,\n  SWARM_MESSAGES_DATABASE_CACHE_PLANNED_CACHE_UPDATE_BATCH_TIMEOUT_MS,\n} from './swarm-messages-database-cache.const';\nimport { delay } from 'utils/common-utils/common-utils-timer';\nimport { timeout } from '../../../../utils/common-utils/common-utils-timer';\nimport { debounce } from 'utils/throttling-utils';\nimport { SWARM_MESSAGES_DATABASE_CACHE_ADD_TO_CACHE_MESSAGES_PENDING_DEBOUNCE_MS } from './swarm-messages-database-cache.const';\nimport {\n  ISwarmMessagesDatabaseMessagesCacheStoreNonTemp,\n  ISwarmMessagesDatabaseMessagesCacheStoreTemp,\n} from './swarm-messages-database-cache.types';\nimport { ESwarmStoreConnectorOrbitDbDatabaseIteratorOption } from '../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { constructCacheStoreFabric } from '../swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store';\nimport {\n  getMessageDescriptionForMessageWithMeta,\n  createMessagesMetaByAddressAndKey,\n} from './swarm-messages-database-cache.utils';\nimport { ISwarmMessagesDatabaseMesssageMeta } from '../../swarm-messages-database.types';\nimport { getMessagesUniqIndexesByMeta } from './swarm-messages-database-cache.utils';\nimport { TSwarmMessagesDatabaseMessagesCacheStore } from './swarm-messages-database-cache.types';\nimport { TSwarmMessageSerialized } from '../../../swarm-message/swarm-message-constructor.types';\nimport { TSwarmStoreDatabaseOptions } from '../../../swarm-store-class/swarm-store-class.types';\nimport { ISwarmMessageInstanceDecrypted } from '../../../swarm-message/swarm-message-constructor.types';\n\nexport class SwarmMessagesDatabaseCache<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MD extends ISwarmMessageInstanceDecrypted\n> implements ISwarmMessagesDatabaseCache<P, T, DbType, DBO, MD> {\n  get isReady(): boolean {\n    return this._isReady;\n  }\n\n  get cache(): TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined {\n    return this._messagesCached;\n  }\n\n  get isUpdating(): boolean {\n    return !!this._pendingMessagesUpdatePromise;\n  }\n\n  get emitter(): TTypedEmitter<ISwarmMessageDatabaseEvents<P, T, DbType, DBO, MD>> {\n    return this._emitter;\n  }\n\n  get whetherMessagesListContainsAllMessages(): boolean {\n    return this._whetherMessagesListContainsAllMessages;\n  }\n\n  protected _isReady: boolean = false;\n\n  protected _dbType?: DbType;\n\n  protected _dbName?: string;\n\n  protected _dbInstance?: ISwarmMessagesDatabaseCacheOptionsDbInstance<P, T, DbType, MD>;\n\n  protected _emitter = getEventEmitterInstance<ISwarmMessageDatabaseEvents<P, T, DbType, DBO, MD>>();\n\n  /**\n   * Storage which handling operations of cahe update.\n   *\n   * @protected\n   * @type {ISwarmMessagesDatabaseMessagesCacheStoreNonTemp<P, DbType>}\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected _messagesCachedStore?: ISwarmMessagesDatabaseMessagesCacheStoreNonTemp<P, DbType, MD>;\n\n  /**\n   * Whether the cache contains all messages from the databse\n   *\n   * @protected\n   * @type {boolean}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _whetherMessagesListContainsAllMessages: boolean = false;\n\n  /**\n   * Flag means that when the cureent cache update will be ended\n   * it's necessary to update it from the start to the end once\n   * again.\n   * That may be caused by replication process ended or adding/removing\n   * of a message to the database.\n   *\n   * @protected\n   * @type {boolean}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _isSwarmMessagesCacheUpdateRequested: boolean = false;\n\n  /**\n   * An active promise updating messages cache.\n   *\n   * @protected\n   * @type {(Promise<TSwarmMessageDatabaseMessagesCached<P, DbType>> | undefined)}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _pendingMessagesUpdatePromise: Promise<void> | undefined;\n\n  /**\n   * Promise with partial cache update of a messages meta\n   * which are marked as a necessary to be updated in cache.\n   *\n   * @protected\n   * @type {(Promise<void>\n   *     | undefined)}\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected _defferedPartialCacheUpdatePromise:\n    | ReturnType<SwarmMessagesDatabaseCache<P, T, DbType, DBO, MD>['_runDefferedMessagesUpdateInCache']>\n    | undefined;\n\n  /**\n   * Promise which will be resolved on next batch\n   * of messages cache update will be overed.\n   *\n   * @protected\n   * @type {(Promise<void> | undefined)}\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected _messagesCacheUpdatingBatch: Promise<void> | undefined = undefined;\n\n  protected get _isKeyValueDatabase(): boolean {\n    return this._dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE;\n  }\n\n  protected get _messagesCached(): TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined {\n    return this._messagesCachedStore?.entries;\n  }\n\n  /**\n   * Is a cache update process is active\n   *\n   * @readonly\n   * @protected\n   * @type {boolean}\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected get _isCacheUpdateActive(): boolean {\n    return !!this._pendingMessagesUpdatePromise;\n  }\n\n  /**\n   * Is a deffered messages update is active\n   *\n   * @readonly\n   * @protected\n   * @type {boolean}\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected get _isDefferedMessagesUpdateActive(): boolean {\n    return !!this._defferedPartialCacheUpdatePromise;\n  }\n\n  constructor(options: ISwarmMessagesDatabaseCacheOptions<P, T, DbType, MD>) {\n    this._setOptions(options);\n  }\n\n  public start = async (): Promise<void> => {\n    if (this._isReady) {\n      return;\n    }\n    this._resetTheInstance();\n    this._initializeCacheStore();\n    this._isReady = true;\n  };\n\n  public close = async () => {\n    this._isReady = false;\n    this._clearEventEmitter();\n    this._resetTheInstance();\n    this._unsetCacheStore();\n    this._unsetDbInstance();\n  };\n\n  public update = async () => {\n    // wait when the cache update process will be overed\n    await this._updateMessagesCache();\n    return this._messagesCached;\n  };\n\n  public addMessage = async (swarmMessageWithMeta: ISwarmMessageStoreMessageWithMeta<P, MD>): Promise<boolean> => {\n    if (!this._checkIsReady()) {\n      return false;\n    }\n    // wait till the cache updating is in progress\n    // because the message may be already in the cache\n    await this._waitTillMessagesCacheUpateBatchOver();\n    return this._addMessageToCachedStore(swarmMessageWithMeta);\n  };\n\n  public deleteMessage = async (\n    messageUniqAddress: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n      : TSwarmStoreDatabaseEntityAddress<P>,\n    key: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE ? TSwarmStoreDatabaseEntityKey<P> : undefined\n  ): Promise<void> => {\n    // TODO - doesnt work in the key-value store\n    // if remove value from a key and then add\n    // add a new value by the same key. The new value is still absent\n    // it's necessary to remove a message only by it's address (not by key)\n    // or request cache updated (moreconsistent)\n    if (!this._checkIsReady()) {\n      return;\n    }\n    await this._waitTillMessagesCacheUpateBatchOver();\n    return this._removeMessageFromCachedStore(messageUniqAddress, key);\n  };\n\n  protected _checkIsReady(): this is {\n    _isReady: true;\n    _dbType: DbType;\n    _dbInstance: ISwarmMessagesDatabaseCacheOptionsDbInstance<P, T, DbType, MD>;\n    _messagesCachedStore: ISwarmMessagesDatabaseMessagesCacheStoreNonTemp<P, DbType, MD>;\n  } {\n    if (!this._isReady) {\n      throw new Error('The instance is not ready to use');\n    }\n    if (!this._dbInstance) {\n      throw new Error('A database instance is not set');\n    }\n    if (!this._messagesCachedStore) {\n      throw new Error('A messages cached instance is not exists');\n    }\n    if (!this._dbType) {\n      throw new Error('A database type should not be empty');\n    }\n    return true;\n  }\n\n  protected _setOptions(options: ISwarmMessagesDatabaseCacheOptions<P, T, DbType, MD>): void {\n    this._dbType = options.dbType;\n    this._dbInstance = options.dbInstance;\n    this._dbName = options.dbName;\n  }\n\n  protected _createMessagesCachedStorage<IsTemp extends boolean>(\n    isTemp: IsTemp\n  ): TSwarmMessagesDatabaseMessagesCacheStore<P, DbType, MD, IsTemp> {\n    if (!this._dbType) {\n      throw new Error('Database type should be defined');\n    }\n    if (!this._dbName) {\n      throw new Error('Database name should be defined');\n    }\n    return constructCacheStoreFabric(this._dbType, this._dbName, isTemp) as TSwarmMessagesDatabaseMessagesCacheStore<\n      P,\n      DbType,\n      MD,\n      IsTemp\n    >;\n  }\n\n  protected _initializeCacheStore(): void {\n    this._messagesCachedStore = this._createMessagesCachedStorage(false);\n  }\n\n  protected _resetTheInstance() {\n    this._pendingMessagesUpdatePromise = undefined;\n    this._isSwarmMessagesCacheUpdateRequested = false;\n    this._whetherMessagesListContainsAllMessages = false;\n  }\n\n  protected _unsetCacheStore() {\n    this._messagesCachedStore = undefined;\n  }\n\n  protected _unsetDbInstance() {\n    this._dbInstance = undefined;\n  }\n\n  protected _clearEventEmitter() {\n    this._emitter.removeAllListeners();\n  }\n\n  protected _checkMessagesEqual<MI extends MD>(messageFirst?: MI, messageSecond?: MI) {\n    return messageFirst?.sig === messageSecond?.sig;\n  }\n\n  protected _checkWhetherMessgeWithMetaInstancesEqual(\n    messageWithMetaMetaInstanceFirst: ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>['message'] | undefined,\n    messageWithMetaMetaInstanceSecond: ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>['message'] | undefined\n  ) {\n    if (messageWithMetaMetaInstanceFirst === messageWithMetaMetaInstanceSecond) {\n      return true;\n    }\n    if (!messageWithMetaMetaInstanceSecond) {\n      return false;\n    }\n    if (messageWithMetaMetaInstanceSecond instanceof Error) {\n      return false;\n    }\n    if (messageWithMetaMetaInstanceFirst instanceof Error) {\n      return false;\n    }\n    return this._checkMessagesEqual(messageWithMetaMetaInstanceSecond, messageWithMetaMetaInstanceFirst);\n  }\n\n  protected async _waitTillMessagesCacheUpateBatchOver() {\n    const { _messagesCacheUpdatingBatch } = this;\n\n    if (_messagesCacheUpdatingBatch) {\n      await Promise.race([\n        _messagesCacheUpdatingBatch,\n        timeout(SWARM_MESSAGES_DATABASE_CACHE_PLANNED_CACHE_UPDATE_BATCH_TIMEOUT_MS),\n      ]).catch((err) => {\n        console.log(err);\n      });\n    }\n  }\n\n  protected _addMessageInKeyValueStoreCache = (\n    messageWithMeta: ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>,\n    // for key-value store it will be the key\n    key: TSwarmStoreDatabaseEntityKey<P>,\n    messagesCachedStore: TSwarmMessageDatabaseMessagesCached<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE, MD>\n  ): void => {\n    messagesCachedStore?.set(key, messageWithMeta);\n  };\n\n  protected _checkMessageInKeyValueStoreCache = (\n    messageWithMeta: ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>,\n    messagesCachedStore: TSwarmMessageDatabaseMessagesCached<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE, MD>\n  ): boolean => {\n    const messageKey = messageWithMeta.key;\n\n    if (!messageKey) {\n      return false;\n    }\n    if (messageKey instanceof Error) {\n      return false;\n    }\n\n    const messageWithMetaCached = messagesCachedStore?.get(messageKey);\n\n    return this._checkWhetherMessgeWithMetaInstancesEqual(messageWithMeta.message, messageWithMetaCached?.message);\n  };\n\n  protected _addMessageInFeedStoreCache = (\n    messageWithMeta: ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>,\n    // for key-value store it will be the key\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    messagesCachedStore: TSwarmMessageDatabaseMessagesCached<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED, MD>\n  ) => {\n    messagesCachedStore?.set(messageAddress, messageWithMeta);\n  };\n\n  protected _checkMessageInFeedStoreCache = (\n    messageWithMeta: ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>,\n    messagesCachedStore: TSwarmMessageDatabaseMessagesCached<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED, MD>\n  ): boolean => {\n    const { messageAddress } = messageWithMeta;\n\n    if (!messageAddress) {\n      return false;\n    }\n    if (messageAddress instanceof Error) {\n      return false;\n    }\n\n    const messageWithMetaCached = messagesCachedStore.get(messageAddress);\n\n    return this._checkWhetherMessgeWithMetaInstancesEqual(messageWithMeta.message, messageWithMetaCached?.message);\n  };\n\n  protected _removeKeyValueFromKVStoreCache = (\n    messagesCache: TSwarmMessageDatabaseMessagesCached<P, DbType, MD>,\n    key: TSwarmStoreDatabaseEntityKey<P>\n  ) => {\n    messagesCache?.delete(key);\n  };\n\n  protected _emitCacheUpdatingIsInProgress() {\n    this._emitter.emit(ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATING);\n  }\n\n  protected _emitCacheUpdated(messages: TSwarmMessageDatabaseMessagesCached<P, DbType, MD>) {\n    this._emitter.emit(ESwarmMessagesDatabaseCacheEventsNames.CACHE_UPDATED, messages);\n  }\n\n  protected _emitDbMessagesWithAddedMessagesCaheUpdated() {\n    if (this._messagesCached) {\n      this._emitCacheUpdated(this._messagesCached);\n    }\n  }\n\n  protected _setMessagesCacheUpdateInProgress = (promisePending: Promise<void>) => {\n    this._pendingMessagesUpdatePromise = promisePending;\n    this._emitCacheUpdatingIsInProgress();\n  };\n\n  protected _unsetCacheUpdateInProgress = () => {\n    this._pendingMessagesUpdatePromise = undefined;\n  };\n\n  protected _setNewCacheUpdatePlanned = () => {\n    this._isSwarmMessagesCacheUpdateRequested = true;\n  };\n\n  protected _unsetNewCacheUpdatePlanned = () => {\n    this._isSwarmMessagesCacheUpdateRequested = false;\n  };\n\n  /**\n   * Whether the limit of failed attempts reached\n   *\n   * @param {number} queryAttemtNumber\n   * @returns {boolean}\n   */\n  protected _whetherMaxDatabaseQueriesAttemptsFailed = (queryAttemtNumber: number): boolean => {\n    return queryAttemtNumber >= SWARM_MESSAGES_DATABASE_MESSAGES_CACHE_ITEMS_MAX_PAGE_QUERY_ATTEMPTS_DEFAULT;\n  };\n\n  /**\n   * Get options for query for a batch of messages\n   *\n   * @param {number} messagesCountToQuery\n   * @param {Array<TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>>} messagesReadAddressesOrKeysToExclude - messages identifiers to exclude from the result\n   * @returns {TSwarmStoreDatabaseIteratorMethodArgument<P>}\n   */\n  protected _getDatabaseMessagesToReadQueryOptionsWithMessagesToExclude = (\n    messagesCountToQuery: number,\n    messagesReadAddressesOrKeysToExclude: Array<TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>>\n  ): TSwarmStoreDatabaseIteratorMethodArgument<P, DbType> => {\n    return {\n      [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.limit]: messagesCountToQuery,\n      [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.neq]: messagesReadAddressesOrKeysToExclude as string[],\n    } as TSwarmStoreDatabaseIteratorMethodArgument<P, DbType>;\n  };\n\n  /**\n   * Returns options to query database and to include only messages with\n   * identity passed in argument.\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected _getDatabaseMessagesToReadQueryOptionsWithMessagesToInclude = (\n    messagesReadAddressesOrKeysToInclude: Array<TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>>\n  ): TSwarmStoreDatabaseIteratorMethodArgument<P, DbType> => {\n    return {\n      [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.eq]: messagesReadAddressesOrKeysToInclude as string[],\n    } as TSwarmStoreDatabaseIteratorMethodArgument<P, DbType>;\n  };\n\n  /**\n   * Request idle callback and resolves\n   * with a time browser will be do nothing\n   *\n   * @returns {Promise<number>} - time browser decide it will be in idle state.\n   */\n  protected _requestTimeBrowserIdle = async (): Promise<number> => {\n    const { timeRemaining, didTimeout } = await resolveOnIdleCallback();\n\n    if (didTimeout) {\n      return 0;\n    }\n    // time browser decide it will be idle.\n    return timeRemaining;\n  };\n  /**\n   * how many items can be read during\n   * the current idle time of the browser\n   *\n   * @param {number} timeAvailToRun\n   * @returns {number}\n   */\n  protected _getItemsCountToReadForIdlePeriod = (timeAvailToRun: number): number => {\n    // the maximum messages to read for max time remaining THROTTLING_UTILS_IDLE_CALLBACK_TIME_REMAINING_MAX_MS\n    // is equal to SWARM_MESSAGES_DATABASE_MESSAGES_CACHE_ITEMS_COUNT_PER_PAGE_DEFAULT. We need to calculate\n    // messages to read for timeAvailToRun.\n    const percentAcordingToFreeTime = round(timeAvailToRun / THROTTLING_UTILS_IDLE_CALLBACK_TIME_REMAINING_MAX_MS, 2);\n\n    return round(SWARM_MESSAGES_DATABASE_MESSAGES_CACHE_ITEMS_COUNT_PER_IDLE_PERIOD_OF_50_MS * percentAcordingToFreeTime, 0);\n  };\n  /**\n   * Returns a uniqiue global address for the message\n   * by it's description\n   *\n   * @param {ISwarmMessageStoreMessagingRequestWithMetaResult<P>} message\n   * @returns {(TSwarmStoreDatabaseEntityUniqueAddress<P> | undefined)}\n   */\n  protected _getMessageAddressByDescription = (\n    message: ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>\n  ): TSwarmStoreDatabaseEntityAddress<P> | undefined => {\n    const { messageAddress } = message;\n\n    if (!messageAddress || messageAddress instanceof Error) {\n      return undefined;\n    }\n    return messageAddress;\n  };\n  /**\n   * Returns message's key in Key-Value databse\n   *\n   * @param {ISwarmMessageStoreMessagingRequestWithMetaResult<P>} message\n   * @returns {(string | undefined)}\n   */\n  protected _getMessageKeyByDescription = (\n    message: ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>\n  ): TSwarmStoreDatabaseEntityKey<P> | undefined => {\n    const { key } = message;\n\n    if (!key || key instanceof Error) {\n      return undefined;\n    }\n    return key;\n  };\n\n  /**\n   * Map messages with meta to a structure related to the current\n   * store type.\n   *\n   * @param {ISwarmMessageStoreMessagingRequestWithMetaResult<P>[]} messagesWithMeta\n   * @returns {TSwarmMessageDatabaseMessagesCached<P, DbType>}\n   */\n  protected _mapMessagesWithMetaToStorageRelatedStructure = (\n    messagesWithMeta: Array<ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined>\n  ): TSwarmMessageDatabaseMessagesCached<P, DbType, MD> => {\n    if (this._isKeyValueDatabase) {\n      return this._mapMessagesDescriptionsToKVStoreMap(messagesWithMeta) as TSwarmMessageDatabaseMessagesCached<P, DbType, MD>;\n    }\n    return this._mapMessagesDescriptionsToFeedStore(messagesWithMeta) as TSwarmMessageDatabaseMessagesCached<P, DbType, MD>;\n  };\n\n  /**\n   * Checks whether the count is more than the limit\n   * of messages read.\n   *\n   * @param {number} messagesCount\n   * @returns {boolean}\n   */\n  protected _whetherMessagesLimitReached = (messagesCount: number): boolean => {\n    return messagesCount > SWARM_MESSAGES_DATABASE_MESSAGES_CACHE_ITEMS_COUNT_LIMIT_DEFAULT;\n  };\n\n  protected _getMessageWithMeta(\n    dbName: string,\n    message: MD,\n    // the global unique address (hash) of the message in the swarm\n    messageAddress: TSwarmStoreDatabaseEntityAddress<P>,\n    // for key-value store it will be the key\n    key?: TSwarmStoreDatabaseEntityKey<P>\n  ): ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> {\n    return {\n      message,\n      dbName,\n      messageAddress,\n      key,\n    };\n  }\n\n  protected _unsetKeyInCacheKVStore(key: TSwarmStoreDatabaseEntityKey<P>): void {\n    if (!this._messagesCached) {\n      throw new Error('There is no messages in cache to unset the key');\n    }\n    this._messagesCached.delete(key);\n  }\n\n  protected _getOptionsToReadKeyFromKVDatabase = (\n    key: TSwarmStoreDatabaseEntityKey<P>\n  ): TSwarmStoreDatabaseIteratorMethodArgument<P, DbType> => {\n    return {\n      [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.limit]: 1,\n      [ESwarmStoreConnectorOrbitDbDatabaseIteratorOption.eq]: String(key),\n    } as TSwarmStoreDatabaseIteratorMethodArgument<P, DbType>;\n  };\n\n  protected _setFullMessagesReadFromDatabaseToCache() {\n    this._whetherMessagesListContainsAllMessages = true;\n  }\n\n  protected _unsetFullMessagesReadFromDatabaseToCache() {\n    this._whetherMessagesListContainsAllMessages = false;\n  }\n\n  /**\n   * Perform query to collect messages from the database.\n   *\n   * @protected\n   * @param {TSwarmStoreDatabaseIteratorMethodArgument<P, DbType>} queryOptions - options for querying the\n   * @memberof SwarmMessagesDatabase\n   * @returns {Promise<Array<ISwarmMessageStoreMessagingRequestWithMetaResult<P>>>}\n   * @throws\n   */\n  protected async _performMessagesCacheCollectPageRequest(\n    queryOptions: TSwarmStoreDatabaseIteratorMethodArgument<P, DbType>\n  ): Promise<Array<ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined>> {\n    if (!this._checkIsReady()) {\n      throw new Error('The instance is not ready');\n    }\n    let queryAttempt = 0;\n    let messages: Array<ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined> | undefined;\n    while (!messages && !this._whetherMaxDatabaseQueriesAttemptsFailed(queryAttempt)) {\n      try {\n        messages = (await this._dbInstance.collectWithMeta(queryOptions)) as Array<\n          ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined\n        >;\n      } catch (err) {\n        console.error(new Error(`_performMessagesCachePageRequest::failed::attempt::${queryAttempt}`), err);\n        await this._requestTimeBrowserIdle();\n      } finally {\n        queryAttempt++;\n      }\n    }\n    if (!messages) {\n      throw new Error('Failed to read a batch of messages from the database cause of unknown reason');\n    }\n    return messages;\n  }\n\n  /**\n   * Map messages with meta to the data structure related\n   * to the KeyValue store.\n   *\n   * @protected\n   * @param {ISwarmMessageStoreMessagingRequestWithMetaResult<P>[]} messagesWithMeta\n   * @returns {Map<string, ISwarmMessageStoreMessagingRequestWithMetaResult<P>>}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _mapMessagesDescriptionsToKVStoreMap<MWM extends ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>>(\n    messagesWithMeta: Array<MWM | undefined>\n  ): TSwarmMessageDatabaseMessagesCached<ESwarmStoreConnector.OrbitDB, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE, MD> {\n    const messagesMap = new Map<TSwarmStoreDatabaseEntityKey<P>, MWM>();\n\n    messagesWithMeta.forEach((messageDescription) => {\n      if (!messageDescription) {\n        return messageDescription;\n      }\n      const key = this._getMessageKeyByDescription(messageDescription);\n\n      if (key) {\n        messagesMap.set(key, messageDescription);\n      }\n    });\n    return messagesMap;\n  }\n\n  /**\n   * Map messages with descriptions to a data structure related\n   * to a Feed store.\n   *\n   * @protected\n   * @param {ISwarmMessageStoreMessagingRequestWithMetaResult<P>[]} messagesWithMeta\n   * @returns {Set<ISwarmMessageStoreMessagingRequestWithMetaResult<P>>}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected _mapMessagesDescriptionsToFeedStore<MWM extends ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>>(\n    messagesWithMeta: Array<MWM | undefined>\n  ): TSwarmMessageDatabaseMessagesCached<ESwarmStoreConnector.OrbitDB, ESwarmStoreConnectorOrbitDbDatabaseType.FEED, MD> {\n    const messagesMap = new Map<TSwarmStoreDatabaseEntityAddress<P>, MWM>();\n\n    messagesWithMeta.forEach((messageDescription) => {\n      if (!messageDescription) {\n        console.warn('Swarm message description is absent');\n        return;\n      }\n      const messageAddress = this._getMessageAddressByDescription(messageDescription);\n\n      if (messageAddress) {\n        messagesMap.set(messageAddress, messageDescription);\n      }\n    });\n    return messagesMap;\n  }\n\n  protected _getMessagesReadKeys(\n    messagesCache: TSwarmMessageDatabaseMessagesCached<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE, MD>\n  ): Array<TSwarmStoreDatabaseEntityKey<P>> {\n    return Array.from(messagesCache.keys());\n  }\n\n  protected _getMessagesReadAddresses(\n    messagesCache: TSwarmMessageDatabaseMessagesCached<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED, MD>\n  ): Array<TSwarmStoreDatabaseEntityKey<P>> {\n    return Array.from(messagesCache.keys());\n  }\n\n  protected _getMessagesReadKeysOrAddresses(\n    messagesCache: TSwarmMessageDatabaseMessagesCached<P, DbType, MD>\n  ): Array<TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>> {\n    if (this._dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE) {\n      return this._getMessagesReadKeys(messagesCache) as Array<TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>>;\n    } else if (this._dbType === ESwarmStoreConnectorOrbitDbDatabaseType.FEED) {\n      return this._getMessagesReadAddresses(messagesCache) as Array<TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>>;\n    }\n    return [];\n  }\n\n  protected _createMessagesCacheUpdatingBatchPromise = () => {\n    let resolve: () => void;\n    this._messagesCacheUpdatingBatch = new Promise((res, rej) => {\n      resolve = res;\n      setTimeout(rej, SWARM_MESSAGES_DATABASE_CACHE_PLANNED_CACHE_UPDATE_BATCH_TIMEOUT_MS);\n    });\n    return () => {\n      resolve();\n      this._messagesCacheUpdatingBatch = undefined;\n    };\n  };\n\n  /**\n   * Returns a count of items can be read from the store\n   * during the current browser's idle period.\n   *\n   * @protected\n   * @returns\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected async _getItemsCountCanBeReadForCurrentIdlePeriod(): Promise<number> {\n    const timeAvailToRun = await this._requestTimeBrowserIdle();\n\n    if (!timeAvailToRun) {\n      // if there is no free time to run\n      // waiting for the time\n      return 0;\n    }\n    // the maximum messages to read for max time remaining THROTTLING_UTILS_IDLE_CALLBACK_TIME_REMAINING_MAX_MS\n    // is equal to SWARM_MESSAGES_DATABASE_MESSAGES_CACHE_ITEMS_COUNT_PER_PAGE_DEFAULT. We need to calculate\n    // messages to read for timeAvailToRun.\n    return this._getItemsCountToReadForIdlePeriod(timeAvailToRun);\n  }\n\n  /**\n   * Checks whether all items read from the database.\n   * Because in OrbitDB's store there is no\n   * way at now to know how many keys with non-empty\n   * data are exist, than the only way is to read items\n   * and check some conditions to understand whether all\n   * items were read. Also when no items were returned, that\n   * doesn't mean that there is no more messages in storage,\n   * because an empty data returns also for \"delete\" messages.\n   *\n   * @param {number} expectedMessagesOverallToReadAtTheBatchCount -\n   * @param {number} expectedNewMessagesCountToReadAtTheBatchCount -\n   * @param {number} resultedNewMessagesCountReadAtTheBatchCount -\n   * @returns {boolean}\n   */\n  protected _whetherMessagesReadLessThanRequested = (\n    expectedMessagesOverallToReadAtTheBatchCount: number,\n    expectedNewMessagesToReadAtTheBatchCount: number,\n    resultedNewMessagesReadAtTheBatchCount: number\n  ): boolean => {\n    return (\n      expectedMessagesOverallToReadAtTheBatchCount > 50 &&\n      expectedNewMessagesToReadAtTheBatchCount > 6 &&\n      !resultedNewMessagesReadAtTheBatchCount\n    );\n  };\n\n  protected getMessagesIdentitiesToExcludeAtCacheUpdateBatch(\n    messagesCachedStoreTemp: ISwarmMessagesDatabaseMessagesCacheStoreTemp<P, DbType, MD, true>\n  ): TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>[] {\n    const entriesExists = (messagesCachedStoreTemp.entries || []) as TSwarmMessageDatabaseMessagesCached<P, DbType, MD>;\n    return this._getMessagesReadKeysOrAddresses(entriesExists);\n  }\n\n  /**\n   * Performs swarm messages cache update by\n   * quering database.\n   * Query performed only when the brawser is\n   * not busy per page.\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabase\n   * @returns {Promise<Array<ISwarmMessageStoreMessagingRequestWithMetaResult<P>>>}\n   * @throws\n   * @memberof SwarmMessagesDatabase\n   */\n  protected async _performMessagesReadingToUpdateCache(\n    messagesCachedStoreTemp: ISwarmMessagesDatabaseMessagesCacheStoreTemp<P, DbType, MD, true>\n  ): Promise<void> {\n    // current page\n    let pageToQueryIndex = 0;\n    // overall messages read count\n    let messagesReadCount = 0;\n    // count messages to read from the database.\n    let messagesCountToReadAtTheBatch = 0;\n    // limit of messages count in the cached was reached\n    let whetherMessagesLimitToReadReached = false;\n    // whether all messages were read from the databse\n    let whetherFullMessagesRead = false;\n    const allMessagesRead = new Map();\n\n    while (!whetherMessagesLimitToReadReached && !whetherFullMessagesRead) {\n      this._checkIsReady();\n\n      const resolveMessagesUpatingBatchPromise = this._createMessagesCacheUpdatingBatchPromise();\n      const currentPageItemsToReadCount = await this._getItemsCountCanBeReadForCurrentIdlePeriod();\n\n      if (!currentPageItemsToReadCount) {\n        // nothing to read at this iteration\n        continue;\n      }\n      pageToQueryIndex = pageToQueryIndex + 1;\n      messagesCountToReadAtTheBatch = messagesReadCount + currentPageItemsToReadCount;\n      whetherMessagesLimitToReadReached = this._whetherMessagesLimitReached(messagesCountToReadAtTheBatch);\n\n      if (whetherMessagesLimitToReadReached) {\n        // add one more to define if the database\n        // contains some more data\n        messagesCountToReadAtTheBatch = messagesCountToReadAtTheBatch + 1;\n      }\n\n      const messagesIdentitiesToExclude = this.getMessagesIdentitiesToExcludeAtCacheUpdateBatch(messagesCachedStoreTemp);\n      const queryOptions = this._getDatabaseMessagesToReadQueryOptionsWithMessagesToExclude(\n        messagesCountToReadAtTheBatch,\n        messagesIdentitiesToExclude\n      );\n      const messagesReadAtBatch = await this._performMessagesCacheCollectPageRequest(queryOptions);\n      const messagesReadAtBatchMapped = this._mapMessagesWithMetaToStorageRelatedStructure(messagesReadAtBatch);\n      // if read less than requested it means that\n      // all messages were read\n      whetherFullMessagesRead = this._whetherMessagesReadLessThanRequested(\n        messagesCountToReadAtTheBatch,\n        currentPageItemsToReadCount,\n        getItemsCount(messagesReadAtBatchMapped)\n      );\n      // TODO - ORBIT DB counts also removed items, so we can request more than\n      // it will return\n      // getItemsCount(messagesReadAtBatch) < currentPageItemsToRead;\n      messagesCachedStoreTemp.update(messagesReadAtBatchMapped);\n      // DEBUG--\n      messagesReadAtBatchMapped.forEach((value, key) => {\n        allMessagesRead.set(key, value);\n      });\n      if (allMessagesRead.size > Number(messagesCachedStoreTemp?.entries?.size)) {\n        console.error(new Error('Read count is not equal'));\n        debugger;\n      }\n      if (whetherFullMessagesRead) {\n        debugger;\n      }\n      // --DEBUG\n      console.log(messagesCachedStoreTemp);\n      resolveMessagesUpatingBatchPromise();\n      messagesReadCount = messagesCountToReadAtTheBatch;\n    }\n    if (whetherFullMessagesRead) {\n      this._setFullMessagesReadFromDatabaseToCache();\n    } else {\n      this._unsetFullMessagesReadFromDatabaseToCache();\n    }\n  }\n\n  /**\n   * Wait till the current messages update process\n   * will be ended.\n   *\n   * @protected\n   * @returns\n   * @memberof SwarmMessagesDatabase\n   */\n  protected async _waitForCurrentMessagesUpdate() {\n    if (this._pendingMessagesUpdatePromise) {\n      return this._pendingMessagesUpdatePromise;\n    }\n  }\n\n  /**\n   * Plan a cache update which will be run after the current iteration\n   * will be ended.\n   *\n   * @protected\n   * @returns {(Promise<TSwarmMessageDatabaseMessagesCached<P, DbType> | undefined>)}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected async _planNewCacheUpdate(): Promise<void> {\n    this._setNewCacheUpdatePlanned();\n    // await when the current iteration will be over\n    await this._waitForCurrentMessagesUpdate();\n    this._checkIsReady();\n    if (!this._pendingMessagesUpdatePromise) {\n      // start a new interaction if there is no one active\n      this._unsetNewCacheUpdatePlanned();\n      try {\n        return await this._runNewCacheUpdate();\n      } catch (err) {\n        console.error(`Failed to plan a new cache update: ${err.message}`, err);\n        await delay(SWARM_MESSAGES_DATABASE_CACHE_PLANNED_CACHE_UPDATE_FAILED_RETRY_DELAY_MS);\n        return await this._planNewCacheUpdate();\n      }\n    }\n    // if another iteration was started just waiting for results\n    return this._waitForCurrentMessagesUpdate();\n  }\n\n  /**\n   * Check whether a next messages cache update\n   * is planned and runs it.\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabase\n   */\n  protected async _runNextCacheUpdateIterationIfNecessary() {\n    if (this._isSwarmMessagesCacheUpdateRequested) {\n      // uset that a cache update required\n      this._unsetNewCacheUpdatePlanned();\n      // and run the next cache update\n      await this._runNewCacheUpdate();\n    }\n  }\n\n  /**\n   * Link a temporary cached messages store to the current\n   * cached messages store.\n   *\n   * @protected\n   * @param {ISwarmMessagesDatabaseMessagesCacheStoreTemp<P, DbType, true>} messagesTempStore\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected _linkTempStoreToMessagesCachedStore(\n    messagesTempStore: ISwarmMessagesDatabaseMessagesCacheStoreTemp<P, DbType, MD, true>\n  ): void {\n    if (this._checkIsReady()) {\n      this._messagesCachedStore.linkWithTempStore(messagesTempStore);\n    }\n  }\n\n  /**\n   * Update messages in messages cached store with messages in\n   * the linked temp store.\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected _updateMessagesCachedStoreByLinkedTempStoreMessages(): boolean {\n    if (this._checkIsReady()) {\n      const hasMessagesUpdated = this._messagesCachedStore.updateByTempStore();\n\n      this._messagesCachedStore.unlinkWithTempStore();\n      return hasMessagesUpdated;\n    }\n    return false;\n  }\n\n  /**\n   * Runs swarm messages cache update and the next iteration\n   * if it's planned.\n   *\n   * @protected\n   * @returns {(Promise<TSwarmMessageDatabaseMessagesCached<P, DbType> | undefined>)}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected async _runNewCacheUpdate(): Promise<void> {\n    try {\n      const messagesCachedTempStore = this._createMessagesCachedStorage(true);\n\n      this._linkTempStoreToMessagesCachedStore(messagesCachedTempStore);\n\n      const promiseMessagesUpdating = this._performMessagesReadingToUpdateCache(messagesCachedTempStore);\n\n      this._setMessagesCacheUpdateInProgress(promiseMessagesUpdating);\n      await promiseMessagesUpdating;\n\n      let hasMessagesUpdated = this._updateMessagesCachedStoreByLinkedTempStoreMessages();\n\n      hasMessagesUpdated = hasMessagesUpdated || (await this._runDefferedPartialCacheUpdateAfterCacheUpdate());\n      if (hasMessagesUpdated) {\n        // emit only if any message was updated in the cache store\n        this._emitDbMessagesWithAddedMessagesCaheUpdated();\n      }\n    } catch (err) {\n      console.error(`Failed to update messages cache: ${err.message}`, err);\n      throw err;\n    } finally {\n      this._unsetCacheUpdateInProgress();\n      void this._runNextCacheUpdateIterationIfNecessary();\n    }\n  }\n\n  /**\n   * Request database for all messages.\n   *\n   * @protected\n   * @returns {Promise<TSwarmMessageDatabaseMessagesCached<P, DbType> | undefined>}\n   * @memberof SwarmMessagesDatabase\n   */\n  protected async _updateMessagesCache(): Promise<void> {\n    this._checkIsReady();\n    if (this._pendingMessagesUpdatePromise) {\n      return this._planNewCacheUpdate();\n    }\n    this._unsetNewCacheUpdatePlanned();\n    return this._runNewCacheUpdate();\n  }\n\n  protected _addSwarmMessageWithMetaToCachedStore(swarmMessageWithMeta: ISwarmMessageStoreMessageWithMeta<P, MD>): boolean {\n    if (!this._checkIsReady()) {\n      return false;\n    }\n    return this._messagesCachedStore.add(\n      getMessageDescriptionForMessageWithMeta<P, DbType, MD>(swarmMessageWithMeta, this._dbType)\n    );\n  }\n\n  protected _addMessageToCachedStore(swarmMessageWithMeta: ISwarmMessageStoreMessageWithMeta<P, MD>): boolean {\n    const result = this._addSwarmMessageWithMetaToCachedStore(swarmMessageWithMeta);\n\n    this._runDefferedPartialCacheUpdateDebounced();\n    return result;\n  }\n\n  protected _removeMessageFromCachedStore = async (\n    messageUniqAddress: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n      : TSwarmStoreDatabaseEntityAddress<P>,\n    key: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE ? TSwarmStoreDatabaseEntityKey<P> : undefined\n  ): Promise<void> => {\n    if (!this._checkIsReady()) {\n      return;\n    }\n\n    const result = this._messagesCachedStore.remove(\n      createMessagesMetaByAddressAndKey<P, DbType>(messageUniqAddress, key, this._dbType)\n    );\n\n    this._runDefferedPartialCacheUpdateDebounced();\n    return result;\n  };\n\n  protected _getMessagesDefferedUpdateWithinCacheUpdateBatch() {\n    return this._messagesCachedStore?.getDefferedReadAfterCurrentCacheUpdateBatch();\n  }\n\n  protected _getDefferedUpdateAfterCacheUpdateProcess() {\n    return this._messagesCachedStore?.getDefferedRead();\n  }\n\n  protected _resetMessagesDeffered() {\n    this._messagesCachedStore?.resetDeffered();\n  }\n\n  protected _resetMessagesDefferedWithinBatch() {\n    this._messagesCachedStore?.resetDefferedAfterCurrentCacheUpdateBatch();\n  }\n\n  protected _getAndResetMessagesDefferedUpdateWithinCaheUpdateBatch():\n    | Set<ISwarmMessagesDatabaseMesssageMeta<P, DbType>>\n    | undefined {\n    const messagesMetaToUpdate = this._getMessagesDefferedUpdateWithinCacheUpdateBatch();\n\n    this._resetMessagesDefferedWithinBatch();\n    return messagesMetaToUpdate;\n  }\n\n  protected _getAndResetDefferedUpdateAfterCacheUpdateProcess(): Set<ISwarmMessagesDatabaseMesssageMeta<P, DbType>> | undefined {\n    const messagesMetaToUpdate:\n      | Set<ISwarmMessagesDatabaseMesssageMeta<P, DbType>>\n      | undefined = this._getDefferedUpdateAfterCacheUpdateProcess();\n\n    this._resetMessagesDeffered();\n    this._resetMessagesDefferedWithinBatch();\n    return messagesMetaToUpdate;\n  }\n\n  /**\n   * Run messages update in the cache batch read.\n   *\n   * @protected\n   * @param {TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>[]} messagesMetaToRead\n   * @returns {Promise<TSwarmMessageDatabaseMessagesCached<P, DbType>>}\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected async _runDefferedMessageReadBatch(\n    messagesMetaToRead: TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>[]\n  ): Promise<TSwarmMessageDatabaseMessagesCached<P, DbType, MD>> {\n    const options = this._getDatabaseMessagesToReadQueryOptionsWithMessagesToInclude(messagesMetaToRead);\n    const messagesReadAtBatch = await this._performMessagesCacheCollectPageRequest(options);\n    return this._mapMessagesWithMetaToStorageRelatedStructure(messagesReadAtBatch);\n  }\n\n  /**\n   * Return a part of messages which must be updated at the\n   * next batch.\n   *\n   * @protected\n   * @param {TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>[]} messagesMetaToRead\n   * @param {number} messagesCountReadAtPreviousBatches\n   * @param {number} messagesCountToReadAtBatch\n   * @returns {TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>[]}\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected _getMessagesMetaToReadAtBatch(\n    messagesMetaToRead: TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>[],\n    messagesCountReadAtPreviousBatches: number,\n    messagesCountToReadAtBatch: number\n  ): TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>[] {\n    return messagesMetaToRead.slice(messagesCountReadAtPreviousBatches, messagesCountToReadAtBatch);\n  }\n\n  /**\n   * Read messages deffered by a metadata of them.\n   *\n   * @protected\n   * @param {Set<ISwarmMessagesDatabaseMesssageMeta<P, DbType>>} messagesForUpdateMeta\n   * @param {ISwarmMessagesDatabaseMessagesCacheStoreNonTemp<P, DbType>} cacheStore\n   * @param {DbType} dbType\n   * @returns {Promise<boolean>}\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected async _runDefferedMessagesUpdateInCache<DT extends DbType>(\n    messagesForUpdateMeta: Set<ISwarmMessagesDatabaseMesssageMeta<P, DT>>,\n    cacheStore: ISwarmMessagesDatabaseMessagesCacheStoreNonTemp<P, DT, MD>,\n    dbType: DT\n  ): Promise<boolean> {\n    let messagesCountAlreadyRead = 0;\n    let hasMessagesUpdated = false;\n    const messagesMetaToRead = getMessagesUniqIndexesByMeta(messagesForUpdateMeta, dbType);\n\n    while (messagesCountAlreadyRead < messagesMetaToRead.length) {\n      const messagesCountToReadAtBatch = await this._getItemsCountCanBeReadForCurrentIdlePeriod();\n\n      if (!messagesCountToReadAtBatch) {\n        continue;\n      }\n\n      const messagesMetaToReadAtBatch = this._getMessagesMetaToReadAtBatch(\n        messagesMetaToRead,\n        messagesCountAlreadyRead,\n        messagesCountToReadAtBatch\n      );\n      const messagesReadAtBatch = await this._runDefferedMessageReadBatch(messagesMetaToReadAtBatch);\n      const hasMessagesUpdatedAtBatch = cacheStore.update(messagesReadAtBatch);\n      hasMessagesUpdated = hasMessagesUpdated || hasMessagesUpdatedAtBatch;\n      messagesCountAlreadyRead += messagesCountToReadAtBatch;\n      console.log('swarmMessagesDatabaseCache::messagesCountAlreadyRead', messagesCountAlreadyRead);\n    }\n    return hasMessagesUpdated;\n  }\n\n  protected _setActiveDefferedPartialCacheUpdate<ItemType extends T>(\n    activeUpdate: ReturnType<SwarmMessagesDatabaseCache<P, ItemType, DbType, DBO, MD>['_runDefferedMessagesUpdateInCache']>\n  ): void {\n    this._defferedPartialCacheUpdatePromise = activeUpdate;\n  }\n\n  protected _unsetActiveDefferedPartialCacheUpdate(): void {\n    this._defferedPartialCacheUpdatePromise = undefined;\n  }\n\n  protected async _runDefferedPartialCacheUpdateForCachedMessagesStore(\n    messagesMetaToUpdate: Set<ISwarmMessagesDatabaseMesssageMeta<P, DbType>>,\n    messagesCachedStore: ISwarmMessagesDatabaseMessagesCacheStoreNonTemp<P, DbType, MD>,\n    dbType: DbType\n  ) {\n    const activeCachePartialUpdate = this._runDefferedMessagesUpdateInCache(messagesMetaToUpdate, messagesCachedStore, dbType);\n\n    this._setActiveDefferedPartialCacheUpdate(activeCachePartialUpdate);\n\n    const hasMessagesUpdated = await activeCachePartialUpdate;\n    this._unsetActiveDefferedPartialCacheUpdate();\n    return hasMessagesUpdated;\n  }\n\n  /**\n   * Runs adding of messages to addedMessages store\n   * from the queue of a pending for adding messages.\n   * Plans a clearing of a messages added store.\n   * Emits the cahce update event if any message was added\n   * to the store.\n   *\n   * @protected\n   * @memberof SwarmMessagesDatabaseCache\n   */\n  protected _runDefferedPartialCacheUpdate = async (\n    messagesMetaToUpdate: Set<ISwarmMessagesDatabaseMesssageMeta<P, DbType>>\n  ): Promise<boolean> => {\n    if (!this._checkIsReady()) {\n      return false;\n    }\n    return this._runDefferedPartialCacheUpdateForCachedMessagesStore(\n      messagesMetaToUpdate,\n      this._messagesCachedStore,\n      this._dbType\n    );\n  };\n\n  protected async _runDefferedPartialCacheUpdateAfterCacheUpdate(): Promise<boolean> {\n    if (this._isDefferedMessagesUpdateActive) {\n      // if it's already in progress\n      await this._defferedPartialCacheUpdatePromise;\n    }\n    const messagesUpdate = this._getAndResetDefferedUpdateAfterCacheUpdateProcess();\n\n    if (messagesUpdate?.size) {\n      return this._runDefferedPartialCacheUpdate(messagesUpdate);\n    }\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  protected _runDefferedPartialCacheUpdateDebounced = debounce(async (): Promise<void> => {\n    if (this._isDefferedMessagesUpdateActive) {\n      // if it's already in progress\n      return;\n    }\n    const messagesToUpdate = this._getAndResetMessagesDefferedUpdateWithinCaheUpdateBatch();\n\n    if (messagesToUpdate?.size) {\n      if (await this._runDefferedPartialCacheUpdate(messagesToUpdate)) {\n        // if has any updated messages emit the event that the cache have updated\n        this._emitDbMessagesWithAddedMessagesCaheUpdated();\n      }\n      this._runDefferedPartialCacheUpdateDebounced();\n    }\n  }, SWARM_MESSAGES_DATABASE_CACHE_ADD_TO_CACHE_MESSAGES_PENDING_DEBOUNCE_MS);\n}\n","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-message-with-meta.ts",["3703","3704","3705","3706","3707","3708","3709","3710","3711"],"import assert from 'assert';\nimport { ISwarmMessageStoreMessageWithMeta } from '../../swarm-message-store.types';\nimport { ESwarmStoreConnector } from '../../../swarm-store-class/swarm-store-class.const';\nimport { isValidSwarmMessageDecryptedFormat } from './swarm-message-store-validator-swarm-message';\nimport { TSwarmMessageSerialized, ISwarmMessageInstanceDecrypted } from '../../../swarm-message/swarm-message-constructor.types';\n\n/**\n * Validates swarm message with meta format\n *\n * @export\n * @template P\n * @param {ISwarmMessageStoreMessageWithMeta<P>} swarmMessageWithMeta\n * @returns {true}\n * @throws - is format is not valid\n */\nexport function validateSwarmMessageWithMeta<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  MD extends ISwarmMessageInstanceDecrypted\n>(swarmMessageWithMeta: any): swarmMessageWithMeta is ISwarmMessageStoreMessageWithMeta<P, MD> {\n  if (!swarmMessageWithMeta) {\n    alert('No swarm message with meta');\n  }\n  assert(!!swarmMessageWithMeta, 'Swarm message with meta is not defined');\n  assert(typeof swarmMessageWithMeta === 'object', 'Swarm message with meta should be an object');\n  assert(!!swarmMessageWithMeta.dbName, 'A databse name should not be empty');\n  assert(typeof swarmMessageWithMeta.dbName === 'string', 'A database name should be a string');\n  assert(!!swarmMessageWithMeta.messageAddress, 'A message address should not be empty');\n  assert(typeof swarmMessageWithMeta.messageAddress === 'string', 'A message address should not be empty');\n  if (swarmMessageWithMeta.key) {\n    assert(typeof swarmMessageWithMeta.key === 'string', 'Swarm message key should be a string');\n  }\n  isValidSwarmMessageDecryptedFormat(swarmMessageWithMeta.message);\n  return true;\n}\n","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-swarm-message.ts",["3712","3713","3714","3715","3716","3717","3718","3719","3720"],"import assert from 'assert';\nimport {\n  ISwarmMessageInstanceDecrypted,\n  ISwarmMessageEncrypted,\n  TSwarmMessageInstance,\n} from '../../../swarm-message/swarm-message-constructor.types';\nimport SwarmMessageSubclassFieldsValidator from '../../../swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator';\n\nconst swarmMessageFieldsValidator = new SwarmMessageSubclassFieldsValidator();\n\n/**\n * Validates swarm message decrypted instance format\n *\n * @export\n * @param {ISwarmMessageInstanceDecrypted} message\n * @returns {true}\n * @throws - throw error if format is not valid\n */\nexport function isValidSwarmMessageDecryptedFormat(message: any): message is ISwarmMessageInstanceDecrypted {\n  assert(!!message, 'Swarm message should be defined');\n  assert(typeof message.bdy === 'object', 'Body of a decrypted message should be an object');\n  swarmMessageFieldsValidator.validateMessage(message);\n  return true;\n}\n\n/**\n * Validates swarm message encrypted instance format\n *\n * @export\n * @param {ISwarmMessageInstanceDecrypted} message\n * @returns {true}\n * @throws - throw an error if format is not valid\n */\nexport function isValidSwarmMessageEncryptedFormat(message: any): message is ISwarmMessageEncrypted {\n  assert(!!message, 'Swarm message should be defined');\n  assert(typeof message.bdy === 'string', 'Body of an encrypted message should be a string');\n  swarmMessageFieldsValidator.validateMessage(message);\n  return true;\n}\n\n/**\n * Validate is swarm message encrypted or decrypted has a valid format\n *\n * @export\n * @param {*} message\n * @returns {true}\n * @throws - if a message hasn't a valid format\n */\nexport function isValidSwarmMessageEncryptedOrDescryptedFormat(message: any): message is TSwarmMessageInstance {\n  assert(!!message, 'Swarm message should be defined');\n  assert(typeof message.bdy === 'string', 'Body of an encrypted message should be a string');\n  swarmMessageFieldsValidator.validateMessage(message);\n  return true;\n}\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-classes.ts",["3721","3722","3723","3724"],"import { ConstructorType } from 'types/helper.types';\n\nexport const isConstructor = (v: any): v is ConstructorType<any> => {\n  return typeof v === 'function' && typeof v.prototype?.constructor?.name === 'string';\n};\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-maps.ts",["3725","3726","3727","3728","3729"],"export function filterMapKeys<M extends Map<any, any>, F extends Array<any>>(map: M, filterKeys: F): M {\n  if (!filterKeys.length) {\n    return map;\n  }\n\n  const filteredMap = new Map() as M;\n\n  for (const [key, value] of map) {\n    if (!filterKeys.includes(key)) {\n      filteredMap.set(key, value);\n    }\n  }\n  return filteredMap;\n}\n\n/**\n * Merge all maps into the target\n *\n * @export\n * @template M\n * @param {M} mapTarget\n * @param {...M[]} maps\n * @returns {M}\n */\nexport function concatMaps<M extends Map<any, any>>(mapTarget: M, ...maps: M[]): M {\n  const mergedMap = mapTarget;\n\n  for (let idx = 0, len = maps.length; idx < len; idx += 1) {\n    const map = maps[idx];\n    let entry;\n    for (entry of map) {\n      mergedMap.set(entry[0], entry[1]);\n    }\n  }\n  return mergedMap;\n}\n","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-memoization.ts",["3730","3731","3732","3733","3734","3735","3736","3737","3738","3739","3740"],"import { FirstPrameter } from '../../types';\nimport { commonUtilsAreAllArraysEqual } from '../common-utils';\nimport { mapValuesForFurtherComparision } from './data-cache-utils-main';\n\nexport const memoize = <F extends (arg: any) => any, A extends FirstPrameter<F>, R extends ReturnType<F>>(\n  functionToMemoize: F\n): ((arg: A) => R) => {\n  const cachedResults = new Map<A, R>();\n  const memoized = (a: A): R => {\n    const cachedResult = cachedResults.get(a);\n\n    if (cachedResult) {\n      return cachedResult;\n    }\n\n    const result = functionToMemoize(a);\n\n    cachedResults.set(a, result);\n    return result;\n  };\n\n  memoized.clean = () => cachedResults.clear();\n  return memoized;\n};\n\n/**\n * Returns a function which will return the same result\n * as the last one if the arguments are equals to the\n * arguments for the last result memoized.\n *\n * @template R\n * @template A\n * @template F\n * @param {F} func\n * @returns {(...arg: A) => R} - returns a function which only the last result will be memoized\n */\nexport const memoizeLastReturnedValue = <F extends (...arg: any[]) => any>(func: F) => {\n  let lastArgs: any[];\n  let lastReturnValue: ReturnType<F>;\n\n  return (...args: Parameters<F>): ReturnType<F> => {\n    const argsMappedForComparision = mapValuesForFurtherComparision(args);\n\n    if (!lastArgs || !commonUtilsAreAllArraysEqual(lastArgs, argsMappedForComparision)) {\n      lastArgs = argsMappedForComparision;\n      lastReturnValue = func(...args);\n    }\n    return lastReturnValue;\n  };\n};\n","/home/paul/projects/protocol/src/components/connect-to-swarm-immediate/connect-to-swarm-immediate.tsx",["3741","3742","3743"],"import React from 'react';\n\nimport { ConnectToSwarm } from '../connect-to-swarm/connect-to-swarm';\nimport { TSwarmStoreDatabaseType, TSwarmStoreDatabaseOptions } from '../../classes/swarm-store-class/swarm-store-class.types';\nimport { ESwarmStoreConnector } from '../../classes/swarm-store-class/swarm-store-class.const';\nimport {\n  TSwarmMessageSerialized,\n  TSwarmMessageInstance,\n  ISwarmMessageInstanceDecrypted,\n} from '../../classes/swarm-message/swarm-message-constructor.types';\nimport { IConnectionBridgeOptionsDefault } from '../../classes/connection-bridge/connection-bridge.types';\nimport { IUserCredentialsCommon } from '../../types/credentials.types';\nimport { TSwarmMessageUserIdentifierSerialized } from '../../classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-fields-validator/swarm-message-subclass-validator-fields-validator-validators/swarm-message-subclass-validator-fields-validator-validator-user-identifier/swarm-message-subclass-validator-fields-validator-validator-user-identifier.types';\nimport { ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions } from '../../classes/swarm-messages-database/swarm-messages-database.types';\n\ntype P = ESwarmStoreConnector.OrbitDB;\n\ntype TConnectToSwarmImmediateProps<\n  DbType extends TSwarmStoreDatabaseType<P>,\n  T extends TSwarmMessageSerialized,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  CBO extends IConnectionBridgeOptionsDefault<P, T, DbType, any>,\n  MD extends ISwarmMessageInstanceDecrypted\n> = {\n  dbOptions: DBO;\n  connectionBridgeOptions: CBO;\n  userCredentials: IUserCredentialsCommon;\n  userIdReceiverSwarmMessages: TSwarmMessageUserIdentifierSerialized;\n  swarmMessagesDatabaseCacheOptions: ISwarmMessagesDatabaseConnectOptionsSwarmMessagesCacheOptions<P, T, DbType, DBO, MD>;\n};\n\nconst CREDENTIALS: IUserCredentialsCommon[] = [];\n\nexport class ConnectToSwarmImmediate<\n  DbType extends TSwarmStoreDatabaseType<P>,\n  T extends TSwarmMessageSerialized,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  CBO extends IConnectionBridgeOptionsDefault<P, T, DbType, any>,\n  MI extends TSwarmMessageInstance,\n  MD extends ISwarmMessageInstanceDecrypted\n> extends React.Component<TConnectToSwarmImmediateProps<DbType, T, DBO, CBO, MD>> {\n  render() {\n    const {\n      dbOptions,\n      connectionBridgeOptions,\n      userCredentials,\n      userIdReceiverSwarmMessages,\n      swarmMessagesDatabaseCacheOptions,\n    } = this.props;\n    return (\n      <ConnectToSwarm<DbType, T, DBO, CBO, MI, MD>\n        connectionBridgeOptions={connectionBridgeOptions}\n        userCredentialsList={CREDENTIALS}\n        userCredentialsToConnectImmediate={userCredentials}\n        dbo={dbOptions}\n        userIdReceiverSwarmMessages={userIdReceiverSwarmMessages}\n        swarmMessagesDatabaseCacheOptions={swarmMessagesDatabaseCacheOptions}\n      />\n    );\n  }\n}\n","/home/paul/projects/protocol/src/components/connect-to-swarm-immediate/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.const.ts",[],"/home/paul/projects/protocol/src/utils/throttling-utils/throttling-utils-main.ts",["3744"],"export const debounce = <F extends (...args: unknown[]) => unknown>(fn: F, timeoutMs: number) => {\n  let latestArgs: Parameters<F>;\n  let isTimeoutExists: boolean;\n\n  return (...args: Parameters<F>): void => {\n    latestArgs = args;\n    if (!isTimeoutExists) {\n      setTimeout(() => {\n        try {\n          fn(...latestArgs);\n        } catch (err) {\n          console.error(err);\n        } finally {\n          isTimeoutExists = false;\n        }\n      }, timeoutMs);\n      isTimeoutExists = true;\n    }\n  };\n};\n","/home/paul/projects/protocol/src/const/const-helpers.ts",["3745"],"export const SIMPLE_OBJECT_PROTOTYPE = Object.getPrototypeOf({});\n","/home/paul/projects/protocol/src/utils/data-cache-utils/data-cache-utils-main.ts",["3746","3747","3748","3749","3750","3751"],"import { TSimpleTypes } from 'types/common.types';\nimport { SIMPLE_OBJECT_PROTOTYPE } from '../../const/const-helpers';\n\n/**\n * Returns a primitive value which can be used\n * as a simple measurement of the value\n * to decide where it's changed or not\n * from the previous state.\n *\n * @template T\n * @param {T} value\n * @returns {(TSimpleTypes | T)}\n */\nconst getValueStateMeasurement = <T = unknown>(value: T): TSimpleTypes | T => {\n  if (typeof value === 'symbol') {\n    return value;\n  }\n  if (typeof value !== 'object') {\n    // if a primitive\n    return value;\n  }\n  if (!value) {\n    return value;\n  }\n  if (value instanceof Array) {\n    return value.length;\n  }\n  if (value instanceof ArrayBuffer) {\n    return value.byteLength;\n  }\n  if (value instanceof Map) {\n    return value.size;\n  }\n  if (value instanceof Set) {\n    return value.size;\n  }\n  if (Object.getPrototypeOf(value) === SIMPLE_OBJECT_PROTOTYPE) {\n    // if a simple object\n    return Object.keys(value).length;\n  }\n  return value;\n};\n\n/**\n * Map array passed to a map which includes a\n * values by itself and some primitive values\n * which are determine that the value has\n * changed.\n * E.g. it may be a number of keys in an object,\n * or number of items into an array or entries in\n * a SET\n *\n * @param {...any[]} args\n * @returns {any[]}\n */\nexport const mapValuesForFurtherComparision = (values: any[]): any[] => {\n  return values.reduce((acc, argument) => acc.concat([argument, getValueStateMeasurement(argument)]), []);\n};\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-common/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-utils/swarm-message-utils-common/swarm-message-utils-common-decrypted.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.ts",["3752"],"import { ESwarmStoreConnector } from '../../../swarm-store-class/swarm-store-class.const';\nimport { TSwarmStoreDatabaseType } from '../../../swarm-store-class/swarm-store-class.types';\nimport { SwarmMessagesDatabaseMessagesCachedStoreTemp } from './abstractions/swarm-messages-database-messages-cached-store-temp/swarm-messages-database-messages-cached-store-temp';\nimport { SwarmMessagesDatabaseMessagesCachedStore } from './abstractions/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store';\nimport { ISwarmMessagesDatabaseMessagesCacheStoreFabric } from '../swarm-messages-database-cache/swarm-messages-database-cache.types';\nimport { ISwarmMessageEncrypted } from '../../../swarm-message/swarm-message-constructor.types';\n\nexport function constructCacheStore<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  IsTemp extends boolean\n>(dbType: DbType, dbName: string, isTemp: IsTemp) {\n  if (isTemp) {\n    return new SwarmMessagesDatabaseMessagesCachedStoreTemp(dbType, dbName, true);\n  }\n  return new SwarmMessagesDatabaseMessagesCachedStore(dbType, dbName);\n}\n\nexport const constructCacheStoreFabric = (function <\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  MD extends ISwarmMessageEncrypted,\n  IsTemp extends boolean\n>(): ISwarmMessagesDatabaseMessagesCacheStoreFabric<P, DbType, MD, IsTemp> {\n  return (constructCacheStore as unknown) as ISwarmMessagesDatabaseMessagesCacheStoreFabric<P, DbType, MD, IsTemp>;\n})();\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.types.ts",["3753"],"import { ESwarmStoreConnector } from '../../../swarm-store-class/swarm-store-class.const';\nimport { TSwarmStoreDatabaseType } from '../../../swarm-store-class/swarm-store-class.types';\nimport { ISwarmMessageStoreMessagingRequestWithMetaResult } from '../../../swarm-message-store/swarm-message-store.types';\nimport { ISwarmMessagesDatabaseMessagesCacheStoreTemp } from '../swarm-messages-database-cache/swarm-messages-database-cache.types';\nimport { ISwarmMessagesDatabaseMesssageMeta, TSwarmMessageDatabaseMessagesCached } from '../../swarm-messages-database.types';\nimport { ISwarmMessageInstanceDecrypted } from '../../../swarm-message/swarm-message-constructor.types';\nimport {\n  ISwarmMessagesDatabaseMessagesCacheStoreNonTemp,\n  ISwarmMessagesDatabaseMessagesCacheMessageDescription,\n} from '../swarm-messages-database-cache/swarm-messages-database-cache.types';\n\nexport interface ISwarmMessagesDatabaseMessagesCachedStoreCore<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  MD extends ISwarmMessageInstanceDecrypted,\n  IsTemp extends boolean = false\n> {\n  /**\n   * Version of the store.\n   *\n   * @type {number}\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStoreCore\n   */\n  readonly storeVersion: number;\n\n  /**\n   * List with entries cached.\n   *\n   * @type {TSwarmMessageDatabaseMessagesCached<P, DbType>}\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStoreCore\n   */\n  readonly entriesCached: TSwarmMessageDatabaseMessagesCached<P, DbType, MD>;\n\n  /**\n   * Is it a temporary cache store.\n   *\n   * @type {IsTemp}\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStoreCore\n   */\n  readonly isTemp: IsTemp;\n\n  /**\n   * Return message from the cache\n   *\n   * @param {ISwarmMessagesDatabaseMesssageMeta<P, DbType>} meta\n   * @returns {(ISwarmMessagesDatabaseMessagesCacheMessageDescription<P,DbType> | undefined)}\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStoreCore\n   */\n  get(\n    meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>\n  ): ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined | undefined;\n\n  /**\n   * Set the entry in the cache right at this moment\n   *\n   * @param {ISwarmMessagesDatabaseMessagesCacheMessageDescription<P,DbType>} entry\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStoreCore\n   */\n  set: (entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType>) => void;\n\n  /**\n   * Add a new entry to the store, can be a deffered operation.\n   *\n   * @param {ISwarmMessagesDatabaseMessagesCacheMessageDescription<P,DbType>} entry\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStoreCore\n   */\n  add: IsTemp extends false ? (entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType>) => void : undefined;\n\n  /**\n   * Remove a message with the characteristics from the cache right in this moment.\n   *\n   * @param {ISwarmMessagesDatabaseMesssageMeta<P, DbType>} meta\n   * @returns {void}\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStoreCore\n   */\n  unset(meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void;\n  /**\n   * Update the cache with the entries.\n   *\n   * @param {TSwarmMessageDatabaseMessagesCached<P, DbType>} entries\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStoreCore\n   * @returns {boolean} - whether any messages were updated\n   */\n  updateWithEntries(entries: TSwarmMessageDatabaseMessagesCached<P, DbType, MD>): boolean;\n  /**\n   * Remove an existing message from the store. Can be a deffered operation.\n   *\n   * @param {ISwarmMessagesDatabaseMesssageMeta<P, DbType>} meta\n   * @returns {void}\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStoreCore\n   */\n  remove: IsTemp extends false ? (meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>) => void : undefined;\n\n  /**\n   * Unset all items in the cache\n   *\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStoreCore\n   */\n  clear(): void;\n}\n\nexport type TSwarmMessagesDatabaseMessagesCachedStoreMessagesMetaHash = string;\n\nexport interface ISwarmMessagesDatabaseMessagesCacheStoreExtendedDefferedMethods<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  MD extends ISwarmMessageInstanceDecrypted\n> extends ISwarmMessagesDatabaseMessagesCacheStoreNonTemp<P, DbType, MD> {\n  /**\n   * Add the entry for reading it directly from the store after the current\n   * batch update will be done.\n   *\n   * @param {ISwarmMessagesDatabaseMesssageMeta<P, DbType>} meta\n   * @memberof ISwarmMessagesDatabaseMessagesCacheStoreExtendedDefferedMethods\n   */\n  _addToDefferedReadAfterCurrentCacheUpdateBatch(meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void;\n  /**\n   * Add the entry for reading it directly from the store after overall\n   * provess of cache update will be ended.\n   *\n   * @param {ISwarmMessagesDatabaseMesssageMeta<P, DbType>} meta\n   * @memberof ISwarmMessagesDatabaseMessagesCacheStoreExtendedDefferedMethods\n   */\n  _addToDefferedUpdate(meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void;\n}\n\nexport interface ISwarmMessagesDatabaseMessagesCachedStoreCoreConstructor<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  MD extends ISwarmMessageInstanceDecrypted,\n  IsTemp extends boolean = false\n> {\n  constructor(\n    cachedStore: IsTemp extends true\n      ? ISwarmMessagesDatabaseMessagesCacheStoreTemp<P, DbType, MD, IsTemp>\n      : ISwarmMessagesDatabaseMessagesCacheStoreExtendedDefferedMethods<P, DbType, MD>,\n    isTemp: IsTemp,\n    dbType: DbType,\n    dbName: string\n  ): ISwarmMessagesDatabaseMessagesCachedStoreCore<P, DbType, MD, IsTemp>;\n}\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-cache/swarm-messages-database-cache.utils.ts",["3754","3755","3756","3757"],"import {\n  TSwarmStoreDatabaseEntityAddress,\n  TSwarmStoreDatabaseEntityKey,\n  TSwarmStoreDatabaseType,\n} from '../../../swarm-store-class/swarm-store-class.types';\nimport { ESwarmStoreConnector } from '../../../swarm-store-class/swarm-store-class.const';\nimport { ISwarmMessagesDatabaseMesssageMeta } from '../../swarm-messages-database.types';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { ISwarmMessagesDatabaseMessagesCacheMessageDescription } from './swarm-messages-database-cache.types';\nimport {\n  ISwarmMessageStoreMessageWithMeta,\n  ISwarmMessageStoreMessagingRequestWithMetaResult,\n} from '../../../swarm-message-store/swarm-message-store.types';\nimport { TSwarmStoreDatabaseEntityUniqueIndex } from '../../../swarm-store-class/swarm-store-class.types';\nimport { isValidSwarmMessageDecryptedFormat } from '../../../swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-swarm-message';\nimport { whetherSwarmMessagesDecryptedAreEqual } from '../../../swarm-message/swarm-message-utils/swarm-message-utils-common/swarm-message-utils-common-decrypted';\nimport { ISwarmMessageInstanceDecrypted, ISwarmMessageDecrypted } from '../../../swarm-message/swarm-message-constructor.types';\n\nexport const checkMessageAddress = <P extends ESwarmStoreConnector, DbType extends TSwarmStoreDatabaseType<P>>(\n  messageUniqAddress: any,\n  dbType: DbType\n): messageUniqAddress is DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n  ? undefined\n  : TSwarmStoreDatabaseEntityAddress<P> => {\n  const isFeedStore = dbType === ESwarmStoreConnectorOrbitDbDatabaseType.FEED;\n\n  if (isFeedStore) {\n    if (!messageUniqAddress) {\n      throw new Error('The message should have an address for a feed store');\n    }\n  }\n  return true;\n};\n\nexport const checkMessageKey = <P extends ESwarmStoreConnector, DbType extends TSwarmStoreDatabaseType<P>>(\n  key: any,\n  dbType: DbType\n): key is DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE ? TSwarmStoreDatabaseEntityKey<P> : undefined => {\n  const isFeedStore = dbType === ESwarmStoreConnectorOrbitDbDatabaseType.FEED;\n  const isKeyValueStore = dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE;\n\n  if (isFeedStore) {\n    if (key) {\n      throw new Error('The message should not have a key for a feed store');\n    }\n  }\n  if (isKeyValueStore) {\n    if (!key) {\n      throw new Error('The message should have a key for a key-value store');\n    }\n  }\n  return true;\n};\n\nexport const getMessagesMetaByAddressAndKey = <P extends ESwarmStoreConnector, DbType extends TSwarmStoreDatabaseType<P>>(\n  messageUniqAddress: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n    ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n    : TSwarmStoreDatabaseEntityAddress<P>,\n  key: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE ? TSwarmStoreDatabaseEntityKey<P> : undefined,\n  dbType: DbType\n): ISwarmMessagesDatabaseMesssageMeta<P, DbType> => {\n  if (checkMessageAddress(messageUniqAddress, dbType) && checkMessageKey(key, dbType)) {\n    return {\n      messageUniqAddress,\n      key,\n    };\n  }\n  throw new Error('Meta information is not valid for this database type');\n};\n\nexport const createMessagesMetaByAddressAndKey = <P extends ESwarmStoreConnector, DbType extends TSwarmStoreDatabaseType<P>>(\n  messageUniqAddress: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n    ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n    : TSwarmStoreDatabaseEntityAddress<P>,\n  key: DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE ? TSwarmStoreDatabaseEntityKey<P> : undefined,\n  dbType: DbType\n): ISwarmMessagesDatabaseMesssageMeta<P, DbType> => {\n  const isFeedStore = dbType === ESwarmStoreConnectorOrbitDbDatabaseType.FEED;\n\n  checkMessageAddress(messageUniqAddress, dbType);\n  checkMessageKey(key, dbType);\n  return getMessagesMetaByAddressAndKey<P, DbType>(\n    messageUniqAddress,\n    (isFeedStore ? undefined : key) as DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityKey<P>\n      : undefined,\n    dbType\n  );\n};\n\nexport const getMessageMetaForMessageWithMeta = <\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  MD extends ISwarmMessageInstanceDecrypted\n>(\n  swarmMessageWithMeta: ISwarmMessageStoreMessageWithMeta<P, MD>,\n  dbType: DbType\n): ISwarmMessagesDatabaseMesssageMeta<P, DbType> => {\n  const { key, messageAddress } = swarmMessageWithMeta;\n  return createMessagesMetaByAddressAndKey<P, DbType>(\n    (messageAddress as unknown) as DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityAddress<P> | undefined\n      : TSwarmStoreDatabaseEntityAddress<P>,\n    (key as unknown) as DbType extends ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE\n      ? TSwarmStoreDatabaseEntityKey<P>\n      : undefined,\n    dbType\n  );\n};\n\nexport const getMessageUniqIndexByMeta = <P extends ESwarmStoreConnector, DbType extends TSwarmStoreDatabaseType<P>>(\n  messageMeta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>,\n  dbType: DbType\n): TSwarmStoreDatabaseEntityUniqueIndex<P, DbType> => {\n  if (dbType === ESwarmStoreConnectorOrbitDbDatabaseType.FEED) {\n    const { messageUniqAddress } = messageMeta;\n\n    if (!messageUniqAddress) {\n      throw new Error('Message unique address should be defined for a feed store');\n    }\n    return (messageUniqAddress as unknown) as TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>;\n  } else {\n    const { key } = messageMeta;\n\n    if (!key) {\n      throw new Error('Message key should be defined for a key-value store');\n    }\n    return (key as unknown) as TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>;\n  }\n};\n\nexport const getMessagesUniqIndexesByMeta = <P extends ESwarmStoreConnector, DbType extends TSwarmStoreDatabaseType<P>>(\n  messagesMeta: Set<ISwarmMessagesDatabaseMesssageMeta<P, DbType>>,\n  dbType: DbType\n): Array<TSwarmStoreDatabaseEntityUniqueIndex<P, DbType>> => {\n  const resultedArray = [];\n\n  for (const messageMeta of messagesMeta) {\n    resultedArray.push(getMessageUniqIndexByMeta(messageMeta, dbType));\n  }\n  return resultedArray;\n};\n\nexport const getMessageDescriptionForMessageWithMeta = <\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  MD extends ISwarmMessageInstanceDecrypted\n>(\n  swarmMessageWithMeta: ISwarmMessageStoreMessageWithMeta<P, MD>,\n  dbType: DbType\n): ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType> => {\n  const messageMeta = getMessageMetaForMessageWithMeta(swarmMessageWithMeta, dbType);\n  return {\n    messageMeta,\n    messageEntry: swarmMessageWithMeta.message,\n  };\n};\n/**\n * Check whether the arguments are a values have the valid SwarmMessageDecrypted format\n * and the same.\n *\n * @param {ISwarmMessageStoreMessagingRequestWithMetaResult<ESwarmStoreConnector>} first\n * @param {ISwarmMessageStoreMessagingRequestWithMetaResult<ESwarmStoreConnector>} second\n * @returns {boolean}\n */\nexport const _checkWhetherSameSwarmMessagesDecrypted = (\n  first: ISwarmMessageStoreMessagingRequestWithMetaResult<ESwarmStoreConnector, ISwarmMessageDecrypted> | undefined,\n  second: ISwarmMessageStoreMessagingRequestWithMetaResult<ESwarmStoreConnector, ISwarmMessageDecrypted> | undefined\n): boolean => {\n  if (!first || !second || first instanceof Error || second instanceof Error) {\n    return false;\n  }\n  return (\n    isValidSwarmMessageDecryptedFormat(first) &&\n    isValidSwarmMessageDecryptedFormat(second) &&\n    whetherSwarmMessagesDecryptedAreEqual(first, second)\n  );\n};\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/abstractions/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.ts",["3758","3759","3760"],"import assert from 'assert';\n\nimport { ISwarmMessagesDatabaseMessagesCachedStoreCore } from '../../swarm-messages-database-messages-cached-store.types';\nimport { ESwarmStoreConnector } from '../../../../../swarm-store-class/swarm-store-class.const';\nimport { TSwarmStoreDatabaseType } from '../../../../../swarm-store-class/swarm-store-class.types';\nimport { ISwarmMessagesDatabaseMessagesCacheStoreExtendedDefferedMethods } from '../../swarm-messages-database-messages-cached-store.types';\nimport { SwarmMessagesDatabaseMessagesCachedStoreTemp } from '../swarm-messages-database-messages-cached-store-temp/swarm-messages-database-messages-cached-store-temp';\nimport {\n  ISwarmMessagesDatabaseMesssageMeta,\n  TSwarmMessageDatabaseMessagesCached,\n} from '../../../../swarm-messages-database.types';\nimport {\n  ISwarmMessagesDatabaseMessagesCacheMessageDescription,\n  ISwarmMessagesDatabaseMessagesCacheStoreTemp,\n} from '../../../swarm-messages-database-cache/swarm-messages-database-cache.types';\nimport { whetherSwarmMessagesDecryptedAreEqual } from '../../../../../swarm-message/swarm-message-utils/swarm-message-utils-common/swarm-message-utils-common-decrypted';\nimport { ISwarmMessageStoreMessagingRequestWithMetaResult } from '../../../../../swarm-message-store/swarm-message-store.types';\nimport { isValidSwarmMessageDecryptedFormat } from '../../../../../swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-swarm-message';\nimport { ISwarmMessageInstanceDecrypted } from '../../../../../swarm-message/swarm-message-constructor.types';\nimport { commonUtilsIsTwoArraysHaveSameItems } from '../../../../../../utils/common-utils/common-utils-array';\n\nexport class SwarmMessagesDatabaseMessagesCachedStore<\n    P extends ESwarmStoreConnector,\n    DbType extends TSwarmStoreDatabaseType<P>,\n    MD extends ISwarmMessageInstanceDecrypted\n  >\n  extends SwarmMessagesDatabaseMessagesCachedStoreTemp<P, DbType, MD, false>\n  implements ISwarmMessagesDatabaseMessagesCacheStoreExtendedDefferedMethods<P, DbType, MD> {\n  protected _listDefferedReadAfterCurrentCacheUpdateBatch = new Set<ISwarmMessagesDatabaseMesssageMeta<P, DbType>>();\n\n  protected _listDefferedRead = new Set<ISwarmMessagesDatabaseMesssageMeta<P, DbType>>();\n\n  protected _tempMessagesCachedStoreLinked?: ISwarmMessagesDatabaseMessagesCacheStoreTemp<P, DbType, MD, false>;\n\n  constructor(protected _dbType: DbType, protected _dbName: string) {\n    super(_dbType, _dbName, false);\n  }\n\n  public add(description: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType>): boolean {\n    if (this._checkIfMessageInTempStore(description)) {\n      return true;\n    }\n    this._cachedStoreImplementation.add(description);\n    return true;\n  }\n\n  public remove = (messageCharacteristic: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void => {\n    return this._cachedStoreImplementation.remove(messageCharacteristic);\n  };\n\n  public linkWithTempStore<isTemp extends boolean>(\n    tempCacheStore: ISwarmMessagesDatabaseMessagesCacheStoreTemp<P, DbType, MD, isTemp>\n  ) {}\n\n  public updateByTempStore = (): boolean => {\n    const { _tempMessagesCachedStoreLinked } = this;\n\n    if (!_tempMessagesCachedStoreLinked || !_tempMessagesCachedStoreLinked.entries) {\n      return false;\n    }\n\n    const whetherSameKeysInTempAndMainStorage = this._whetherSameKeysBetweenTempStorageLinkedEntriesAndMain();\n\n    if (!whetherSameKeysInTempAndMainStorage) {\n      this._cachedStoreImplementation.clear();\n    }\n    return this._cachedStoreImplementation.updateWithEntries(_tempMessagesCachedStoreLinked.entries);\n  };\n\n  public unlinkWithTempStore() {\n    this._tempMessagesCachedStoreLinked = undefined;\n  }\n\n  public getDefferedReadAfterCurrentCacheUpdateBatch(): Set<ISwarmMessagesDatabaseMesssageMeta<P, DbType>> {\n    return this._listDefferedReadAfterCurrentCacheUpdateBatch;\n  }\n  /**\n   * Reset messages to read after the current batch of update will be performed.\n   *\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStore\n   */\n  public resetDefferedAfterCurrentCacheUpdateBatch(): void {\n    this._listDefferedReadAfterCurrentCacheUpdateBatch.clear();\n  }\n\n  /**\n   * Get messages to read after the current cache update proces will be ended.\n   *\n   * @returns {Set<ISwarmMessagesDatabaseMesssageMeta<P, DbType>>}\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStore\n   */\n  public getDefferedRead(): Set<ISwarmMessagesDatabaseMesssageMeta<P, DbType>> {\n    return this._listDefferedRead;\n  }\n  /**\n   * Reset messages to read after the current cache update proces will be ended.\n   *\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStore\n   */\n  public resetDeffered(): void {\n    this._listDefferedRead.clear();\n  }\n\n  public _addToDefferedUpdate = (meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void => {\n    this._listDefferedRead.add(meta);\n  };\n\n  public _addToDefferedReadAfterCurrentCacheUpdateBatch = (meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void => {\n    this._listDefferedReadAfterCurrentCacheUpdateBatch.add(meta);\n  };\n\n  protected _checkIsReady(): this is {\n    _cachedStoreImplementation: ISwarmMessagesDatabaseMessagesCachedStoreCore<P, DbType, MD, false>;\n  } {\n    return this._isReady;\n  }\n\n  protected _throwIfNotReady(): this is {\n    _cachedStoreImplementation: ISwarmMessagesDatabaseMessagesCachedStoreCore<P, DbType, MD, false>;\n  } {\n    assert(this._checkIsReady(), 'The instance is not ready');\n    return true;\n  }\n\n  protected _mapCachedStoreItemsToMessagesWithMeta(): TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined {\n    if (!this._checkIsReady()) {\n      return undefined;\n    }\n    return this._cachedStoreImplementation.entriesCached;\n  }\n\n  protected _getEntryFromTempStoreLinked(\n    messageCharacteristic: ISwarmMessagesDatabaseMesssageMeta<P, DbType>\n  ): ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined {\n    const { _cachedStoreImplementation } = this;\n\n    if (!_cachedStoreImplementation) {\n      return;\n    }\n    return _cachedStoreImplementation.get(messageCharacteristic);\n  }\n\n  protected _getMessageDecryptedFromTempStoreLinked(\n    messageCharacteristic: ISwarmMessagesDatabaseMesssageMeta<P, DbType>\n  ): ISwarmMessageInstanceDecrypted | undefined {\n    const entry = this._getEntryFromTempStoreLinked(messageCharacteristic);\n\n    if (!entry || entry instanceof Error) {\n      return undefined;\n    }\n\n    const { message } = entry;\n\n    if (!isValidSwarmMessageDecryptedFormat(message)) {\n      return undefined;\n    }\n    return message;\n  }\n\n  protected _checkIfMessageInTempStore(description: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType>): boolean {\n    const messageInTempStore = this._getMessageDecryptedFromTempStoreLinked(description.messageMeta);\n\n    if (!messageInTempStore) {\n      return false;\n    }\n    return !!messageInTempStore && whetherSwarmMessagesDecryptedAreEqual(messageInTempStore, description.messageEntry);\n  }\n\n  protected _whetherSameKeysBetweenTempStorageLinkedEntriesAndMain(): boolean {\n    const linkedStorageKeys = this._tempMessagesCachedStoreLinked?.entries?.keys();\n    const mainStorageKeys = this._cachedStoreImplementation.entriesCached.keys();\n\n    if (!mainStorageKeys !== !linkedStorageKeys) {\n      return false;\n    }\n    if (!linkedStorageKeys) {\n      return false;\n    }\n    return commonUtilsIsTwoArraysHaveSameItems(Array.from(mainStorageKeys), Array.from(linkedStorageKeys));\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/abstractions/swarm-messages-database-messages-cached-store-temp/swarm-messages-database-messages-cached-store-temp.ts",["3761","3762","3763"],"import assert from 'assert';\n\nimport { ISwarmMessagesDatabaseMessagesCachedStoreCore } from '../../swarm-messages-database-messages-cached-store.types';\nimport { ESwarmStoreConnector } from '../../../../../swarm-store-class/swarm-store-class.const';\nimport { TSwarmStoreDatabaseType } from '../../../../../swarm-store-class/swarm-store-class.types';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../../../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { SwarmMessagesDatabaseMessagesCachedStoreKeyValue } from '../../implementations/swarm-messages-database-messages-cached-store-keyvalue/swarm-messages-database-messages-cached-store-keyvalue';\nimport { SwarmMessagesDatabaseMessagesCachedStoreFeed } from '../../implementations/swarm-messages-database-messages-cached-store-feed/index';\nimport { ISwarmMessageStoreMessagingRequestWithMetaResult } from '../../../../../swarm-message-store/swarm-message-store.types';\nimport { ISwarmMessageDecrypted } from '../../../../../swarm-message/swarm-message-constructor.types';\nimport {\n  ISwarmMessagesDatabaseMesssageMeta,\n  TSwarmMessageDatabaseMessagesCached,\n} from '../../../../swarm-messages-database.types';\nimport {\n  ISwarmMessagesDatabaseMessagesCacheMessageDescription,\n  ISwarmMessagesDatabaseMessagesCacheStoreTemp,\n} from '../../../swarm-messages-database-cache/swarm-messages-database-cache.types';\n\nexport class SwarmMessagesDatabaseMessagesCachedStoreTemp<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  MD extends ISwarmMessageDecrypted,\n  IsTemp extends boolean\n> implements ISwarmMessagesDatabaseMessagesCacheStoreTemp<P, DbType, MD, IsTemp> {\n  public get isTemp() {\n    return this._isTemp;\n  }\n\n  public get entries(): TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined {\n    return this._mapCachedStoreItemsToMessagesWithMeta();\n  }\n\n  protected _cachedStoreImplementation: ISwarmMessagesDatabaseMessagesCachedStoreCore<P, DbType, MD, IsTemp>;\n\n  protected get _isReady(): boolean {\n    return !!this._cachedStoreImplementation;\n  }\n\n  constructor(protected _dbType: DbType, protected _dbName: string, protected _isTemp: IsTemp) {\n    this._cachedStoreImplementation = this._createCachedStoreImplementation();\n  }\n\n  /**\n   * Read message from the cache\n   *\n   * @param {ISwarmMessagesDatabaseMesssageMeta<P, DbType>} messageCharacteristic\n   * @returns {(ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType> | undefined)}\n   * @memberof ISwarmMessagesDatabaseMessagesCachedStore\n   */\n  get(\n    messageCharacteristic: ISwarmMessagesDatabaseMesssageMeta<P, DbType>\n  ): ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined {\n    return this._cachedStoreImplementation.get(messageCharacteristic);\n  }\n\n  set(description: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType>): void {\n    return this._cachedStoreImplementation.set(description);\n  }\n\n  unset(messageCharacteristic: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void {\n    return this._cachedStoreImplementation.unset(messageCharacteristic);\n  }\n\n  update(entries: TSwarmMessageDatabaseMessagesCached<P, DbType, MD>): boolean {\n    return this._cachedStoreImplementation.updateWithEntries(entries);\n  }\n\n  protected _createCachedStoreImplementationFeed(): ISwarmMessagesDatabaseMessagesCachedStoreCore<\n    P,\n    ESwarmStoreConnectorOrbitDbDatabaseType.FEED,\n    MD,\n    IsTemp\n  > {\n    return new SwarmMessagesDatabaseMessagesCachedStoreFeed(\n      (this as unknown) as any,\n      this._isTemp,\n      ESwarmStoreConnectorOrbitDbDatabaseType.FEED,\n      this._dbName\n    );\n  }\n\n  protected _createCachedStoreImplementationKeyValue(): ISwarmMessagesDatabaseMessagesCachedStoreCore<\n    P,\n    ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE,\n    MD,\n    IsTemp\n  > {\n    return new SwarmMessagesDatabaseMessagesCachedStoreKeyValue(\n      (this as unknown) as any,\n      this._isTemp,\n      ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE,\n      this._dbName\n    );\n  }\n\n  protected _createCachedStoreImplementation(): ISwarmMessagesDatabaseMessagesCachedStoreCore<P, DbType, MD, IsTemp> {\n    if (this._dbType === ESwarmStoreConnectorOrbitDbDatabaseType.FEED) {\n      return this._createCachedStoreImplementationFeed() as ISwarmMessagesDatabaseMessagesCachedStoreCore<P, DbType, MD, IsTemp>;\n    }\n    if (this._dbType === ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE) {\n      return this._createCachedStoreImplementationKeyValue() as ISwarmMessagesDatabaseMessagesCachedStoreCore<\n        P,\n        DbType,\n        MD,\n        IsTemp\n      >;\n    }\n    throw new Error('Failed to create cache store implementation for a given store type');\n  }\n\n  protected _checkIsReady(): this is {\n    _cachedStoreImplementation: ISwarmMessagesDatabaseMessagesCachedStoreCore<P, DbType, MD, IsTemp>;\n  } {\n    return this._isReady;\n  }\n\n  protected _throwIfNotReady(): this is {\n    _cachedStoreImplementation: ISwarmMessagesDatabaseMessagesCachedStoreCore<P, DbType, MD, IsTemp>;\n  } {\n    assert(this._checkIsReady(), 'The instance is not ready');\n    return true;\n  }\n\n  protected _mapCachedStoreItemsToMessagesWithMeta(): TSwarmMessageDatabaseMessagesCached<P, DbType, MD> | undefined {\n    if (!this._checkIsReady()) {\n      return undefined;\n    }\n    return this._cachedStoreImplementation.entriesCached;\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/implementations/swarm-messages-database-messages-cached-store-core/swarm-messages-database-messages-cached-store-core.ts",["3764","3765","3766","3767","3768","3769","3770","3771","3772","3773"],"import assert from 'assert';\nimport { ESwarmStoreConnector } from '../../../../../swarm-store-class/swarm-store-class.const';\nimport {\n  ISwarmMessagesDatabaseMessagesCachedStoreCore,\n  TSwarmMessagesDatabaseMessagesCachedStoreMessagesMetaHash,\n} from '../../swarm-messages-database-messages-cached-store.types';\nimport { ISwarmMessagesDatabaseMessagesCacheMessageDescription } from '../../../swarm-messages-database-cache/swarm-messages-database-cache.types';\nimport {\n  ISwarmMessagesDatabaseMesssageMeta,\n  TSwarmMessageDatabaseMessagesCached,\n} from '../../../../swarm-messages-database.types';\nimport {\n  TSwarmStoreDatabaseType,\n  TSwarmStoreDatabaseEntityKey,\n  TSwarmStoreDatabaseEntityAddress,\n} from '../../../../../swarm-store-class/swarm-store-class.types';\nimport { isValidSwarmMessageDecryptedFormat } from '../../../../../swarm-message-store/swarm-message-store-utils/swarm-message-store-validators/swarm-message-store-validator-swarm-message';\nimport {\n  ISwarmMessageInstanceDecrypted,\n  ISwarmMessageDecrypted,\n} from '../../../../../swarm-message/swarm-message-constructor.types';\nimport { SWARM_MESSGES_DATABASE_SWARM_MESSAGES_CACHED_SWARM_MESSAGES_META_HASH_DELIMETER } from 'classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/swarm-messages-database-messages-cached-store.const';\nimport { whetherSwarmMessagesDecryptedAreEqual } from '../../../../../swarm-message/swarm-message-utils/swarm-message-utils-common/swarm-message-utils-common-decrypted';\nimport { TSwarmMessagesDatabaseMessagesCacheStore } from '../../../swarm-messages-database-cache/swarm-messages-database-cache.types';\nimport { ISwarmMessagesDatabaseMessagesCacheStoreExtendedDefferedMethods } from '../../swarm-messages-database-messages-cached-store.types';\nimport { ISwarmMessageStoreMessagingRequestWithMetaResult } from '../../../../../swarm-message-store/swarm-message-store.types';\nimport { _checkWhetherSameSwarmMessagesDecrypted } from '../../../swarm-messages-database-cache/swarm-messages-database-cache.utils';\n\nexport abstract class SwarmMessagesDatabaseMessagesCachedStoreCore<\n  P extends ESwarmStoreConnector,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  MD extends ISwarmMessageDecrypted,\n  IsTemp extends boolean,\n  MetaHash extends TSwarmMessagesDatabaseMessagesCachedStoreMessagesMetaHash\n> implements\n    Omit<\n      ISwarmMessagesDatabaseMessagesCachedStoreCore<P, DbType, MD, IsTemp>,\n      'entriesCached' | 'get' | 'set' | 'unset' | 'updateWithEntries' | 'clear'\n    > {\n  public get isTemp(): IsTemp {\n    return this._isTemp;\n  }\n\n  public get storeVersion() {\n    return this._messagesCachedVersion;\n  }\n\n  protected _messagesCachedVersion: number = 0;\n\n  protected get _isInitialized(): boolean {\n    return !!this._cachedStore;\n  }\n\n  constructor(\n    protected _cachedStore: TSwarmMessagesDatabaseMessagesCacheStore<P, DbType, MD, IsTemp>,\n    protected _isTemp: IsTemp,\n    protected _dbType: DbType,\n    protected _dbName: string\n  ) {}\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  add = (this._isTemp === true\n    ? undefined\n    : (entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType>): void => {\n        this._checkIsInitialized();\n        this._checkEntryWithMeta(entry);\n        if (this._whetherEntryIsExists(entry)) {\n          return;\n        }\n        this._addDefferedReadEntryAfterCurrentBatchOfCacheUpdate(entry.messageMeta);\n        this._addDefferedReadEntryAfterOverallCaheUpdate(entry.messageMeta);\n      }) as ISwarmMessagesDatabaseMessagesCachedStoreCore<P, DbType, MD, IsTemp>['add'];\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  remove = (this._isTemp === true\n    ? undefined\n    : (meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void => {\n        this._checkIsInitialized();\n        this._checkMeta(meta);\n        this._addDefferedReadEntryAfterCurrentBatchOfCacheUpdate(meta);\n        this._addDefferedReadEntryAfterOverallCaheUpdate(meta);\n      }) as ISwarmMessagesDatabaseMessagesCachedStoreCore<P, DbType, MD, IsTemp>['remove'];\n\n  protected _beforeGet = (meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void => {\n    this._checkIsInitialized();\n    this._checkMeta(meta);\n  };\n\n  protected _beforeSet = (entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType>): void => {\n    this._checkIsInitialized();\n    this._checkEntryWithMeta(entry);\n  };\n\n  protected _beforeUnset = (meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void => {\n    this._checkIsInitialized();\n    this._checkMeta(meta);\n  };\n\n  protected _checkIsInitialized(): this is {\n    _cachedStore: ISwarmMessagesDatabaseMessagesCacheStoreExtendedDefferedMethods<P, DbType, MD>;\n  } {\n    assert(this._cachedStore, 'The isnstance is not initialized');\n    assert(\n      typeof ((this._cachedStore as unknown) as any)?._addToDefferedReadAfterCurrentCacheUpdateBatch === 'function',\n      'The cached store should have the \"_addToDefferedReadAfterCurrentCacheUpdateBatch\" method'\n    );\n    assert(\n      typeof ((this._cachedStore as unknown) as any)?._addToDefferedUpdate === 'function',\n      'The cached store should have the \"_addToDefferedUpdate\" method'\n    );\n    return true;\n  }\n\n  protected _getMessageAddressFromMeta(\n    meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>\n  ): TSwarmStoreDatabaseEntityAddress<P> | undefined {\n    return meta.messageUniqAddress;\n  }\n\n  protected _getMessageKeyFromMeta(\n    meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>\n  ): TSwarmStoreDatabaseEntityKey<P> | undefined {\n    return meta.key;\n  }\n\n  protected _checkMeta(meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void {\n    assert(meta, 'The meta information must be defined');\n    assert(typeof meta === 'object', 'The meta must be an object');\n    assert(meta.messageUniqAddress, 'The meta information must includes message address');\n  }\n\n  protected _checkMessageEntry(message: ISwarmMessageInstanceDecrypted): void {\n    isValidSwarmMessageDecryptedFormat(message);\n  }\n\n  protected _checkEntryWithMeta(entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType>): void {\n    assert(entry, 'The enty must be defined');\n    assert(typeof entry === 'object', 'The enty must be an object');\n    assert(entry.messageMeta, 'A meta information must be defined');\n    assert(entry.messageEntry, 'A message must be defined');\n    this._checkMeta(entry.messageMeta);\n    this._checkMessageEntry(entry.messageEntry);\n  }\n\n  protected _getMetaHash(meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): MetaHash {\n    return `${meta.messageUniqAddress}${SWARM_MESSGES_DATABASE_SWARM_MESSAGES_CACHED_SWARM_MESSAGES_META_HASH_DELIMETER}${meta.key}` as MetaHash;\n  }\n\n  protected _incMessagesInCacheVersion() {\n    this._messagesCachedVersion += 1;\n  }\n\n  protected _incMessagesInCacheVersionIfMessagesNotEquals(\n    entryFirst: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType> | undefined,\n    entrySecond: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType> | undefined\n  ) {\n    if (entryFirst === entrySecond) {\n      return;\n    }\n    if (\n      (entryFirst && this._getMetaHash(entryFirst.messageMeta)) !== (entrySecond && this._getMetaHash(entrySecond.messageMeta))\n    ) {\n      this._incMessagesInCacheVersion();\n    }\n    if (whetherSwarmMessagesDecryptedAreEqual(entryFirst?.messageEntry, entrySecond?.messageEntry)) {\n      this._incMessagesInCacheVersion();\n    }\n  }\n\n  protected _addDefferedReadEntryAfterCurrentBatchOfCacheUpdate(meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void {\n    if (this._checkIsInitialized()) {\n      this._cachedStore._addToDefferedReadAfterCurrentCacheUpdateBatch(meta);\n    }\n  }\n\n  protected _addDefferedReadEntryAfterOverallCaheUpdate(meta: ISwarmMessagesDatabaseMesssageMeta<P, DbType>): void {\n    if (this._checkIsInitialized()) {\n      this._cachedStore._addToDefferedUpdate(meta);\n    }\n  }\n\n  protected _canUpdateWithEmptyValue() {\n    return false;\n  }\n\n  protected _checkWhetherUpdatValue(\n    source: ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined,\n    target: ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined\n  ): boolean {\n    if (!target && !this._canUpdateWithEmptyValue()) {\n      return false;\n    }\n    if (!source && !target) {\n      return false;\n    }\n    if (!source && target) {\n      return true;\n    }\n    if (source === target) {\n      return false;\n    }\n    return !source || !_checkWhetherSameSwarmMessagesDecrypted(source, target);\n  }\n\n  protected _checkWhetherUpdateKey(\n    key: TSwarmStoreDatabaseEntityKey<P>,\n    value: ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>,\n    entriesCached: TSwarmMessageDatabaseMessagesCached<P, DbType, MD>\n  ) {\n    return this._checkWhetherUpdatValue(entriesCached.get(key), value);\n  }\n\n  protected _clearEntriesCached(entriesCached: TSwarmMessageDatabaseMessagesCached<P, DbType, MD>) {\n    entriesCached.clear();\n  }\n\n  protected _updateCacheWithEntries(\n    entries: TSwarmMessageDatabaseMessagesCached<P, DbType, MD>,\n    entriesCached: TSwarmMessageDatabaseMessagesCached<P, DbType, MD>\n  ): boolean {\n    let hasMessagesUpdated = false;\n    // if there is no entries cached for now, it is not neccesary to check\n    // whether to need update it, because it is always neccessary.\n    const wetherToCheckUpdateNeccessary = !!entriesCached.size;\n\n    entries.forEach((value, key) => {\n      if (wetherToCheckUpdateNeccessary || this._checkWhetherUpdateKey(key, value, entriesCached)) {\n        entriesCached.set(key, value);\n        hasMessagesUpdated = true;\n      } else {\n        console.error(new Error('_updateCacheWithEntries'));\n      }\n    });\n    return hasMessagesUpdated;\n  }\n\n  protected abstract _whetherEntryIsExists(entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, DbType>): boolean;\n}\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/implementations/swarm-messages-database-messages-cached-store-feed/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/implementations/swarm-messages-database-messages-cached-store-feed/swarm-messages-database-messages-cached-store-feed.ts",["3774"],"import { SwarmMessagesDatabaseMessagesCachedStoreCore } from '../swarm-messages-database-messages-cached-store-core/swarm-messages-database-messages-cached-store-core';\nimport { ESwarmStoreConnector } from '../../../../../swarm-store-class/swarm-store-class.const';\nimport {\n  TSwarmMessagesDatabaseMessagesCachedStoreMessagesMetaHash,\n  ISwarmMessagesDatabaseMessagesCachedStoreCore,\n} from '../../swarm-messages-database-messages-cached-store.types';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../../../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport { ISwarmMessagesDatabaseMessagesCacheMessageDescription } from '../../../swarm-messages-database-cache/swarm-messages-database-cache.types';\nimport {\n  ISwarmMessagesDatabaseMesssageMeta,\n  TSwarmMessageDatabaseMessagesCached,\n} from '../../../../swarm-messages-database.types';\nimport { ISwarmMessageStoreMessagingRequestWithMetaResult } from '../../../../../swarm-message-store/swarm-message-store.types';\nimport { ISwarmMessageInstanceDecrypted } from '../../../../../swarm-message/swarm-message-constructor.types';\n\nexport class SwarmMessagesDatabaseMessagesCachedStoreFeed<\n    P extends ESwarmStoreConnector,\n    MD extends ISwarmMessageInstanceDecrypted,\n    IsTemp extends boolean\n  >\n  extends SwarmMessagesDatabaseMessagesCachedStoreCore<\n    P,\n    ESwarmStoreConnectorOrbitDbDatabaseType.FEED,\n    MD,\n    IsTemp,\n    TSwarmMessagesDatabaseMessagesCachedStoreMessagesMetaHash\n  >\n  implements ISwarmMessagesDatabaseMessagesCachedStoreCore<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED, MD, IsTemp> {\n  get entriesCached(): TSwarmMessageDatabaseMessagesCached<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED, MD> {\n    return this._entriesCached;\n  }\n  protected _entriesCached = new Map() as TSwarmMessageDatabaseMessagesCached<\n    P,\n    ESwarmStoreConnectorOrbitDbDatabaseType.FEED,\n    MD\n  >;\n\n  get = (\n    meta: ISwarmMessagesDatabaseMesssageMeta<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED>\n  ): ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined => {\n    this._beforeGet(meta);\n    return this._getMessageCachedByMeta(meta);\n  };\n\n  set = (entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED>): void => {\n    this._beforeSet(entry);\n    this._setMessageInEntriesCached(entry);\n  };\n\n  unset = (meta: ISwarmMessagesDatabaseMesssageMeta<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED>): void => {\n    this._beforeUnset(meta);\n    this._unsetMessageInEntriesCached(meta);\n  };\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  updateWithEntries(entries: TSwarmMessageDatabaseMessagesCached<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED, MD>): boolean {\n    const hasUpdatedMessages = this._updateCacheWithEntries(entries, this._entriesCached);\n\n    this._incMessagesInCacheVersion();\n    return hasUpdatedMessages;\n  }\n\n  clear() {\n    this._entriesCached.clear();\n  }\n\n  protected _whetherEntryIsExists(\n    entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED>\n  ): boolean {\n    return !!this._getMessageCachedByMeta(entry.messageMeta);\n  }\n\n  protected _getMessageCachedByMeta = (\n    meta: ISwarmMessagesDatabaseMesssageMeta<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED>\n  ): ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined => {\n    const messageAddress = this._getMessageAddressFromMeta(meta);\n\n    if (!messageAddress) {\n      console.warn('Failed to get message address by meta');\n      return;\n    }\n    return this._entriesCached.get(messageAddress);\n  };\n\n  protected _getMessageInfo(\n    entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED>\n  ): Omit<ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>, 'key'> {\n    const { messageMeta: meta, messageEntry: message } = entry;\n    const address = this._getMessageAddressFromMeta(meta);\n\n    if (!address) {\n      throw new Error('A message add must be defined');\n    }\n    const messageDecrypted = message as MD;\n    return {\n      dbName: this._dbName,\n      message: messageDecrypted,\n      messageAddress: address,\n    };\n  }\n\n  protected _unsetMessageInEntriesCached(\n    meta: ISwarmMessagesDatabaseMesssageMeta<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED>\n  ): void {\n    const address = this._getMessageAddressFromMeta(meta);\n\n    if (!address) {\n      throw new Error('A message add must be defined');\n    }\n    this.entriesCached.delete(address);\n  }\n\n  protected _setMessageInEntriesCached(\n    entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, ESwarmStoreConnectorOrbitDbDatabaseType.FEED>\n  ): void {\n    const { messageMeta } = entry;\n    const address = this._getMessageAddressFromMeta(messageMeta);\n\n    if (!address) {\n      throw new Error('An address must not be empty');\n    }\n    this._entriesCached.set(address, this._getMessageInfo(entry));\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/implementations/swarm-messages-database-messages-cached-store-keyvalue/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-subclasses/swarm-messages-database-messages-cached-store/implementations/swarm-messages-database-messages-cached-store-keyvalue/swarm-messages-database-messages-cached-store-keyvalue.ts",["3775","3776"],"import assert from 'assert';\nimport { SwarmMessagesDatabaseMessagesCachedStoreCore } from '../swarm-messages-database-messages-cached-store-core/swarm-messages-database-messages-cached-store-core';\nimport { ESwarmStoreConnector } from '../../../../../swarm-store-class/swarm-store-class.const';\nimport {\n  TSwarmMessagesDatabaseMessagesCachedStoreMessagesMetaHash,\n  ISwarmMessagesDatabaseMessagesCachedStoreCore,\n} from '../../swarm-messages-database-messages-cached-store.types';\nimport { ESwarmStoreConnectorOrbitDbDatabaseType } from '../../../../../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.const';\nimport {\n  ISwarmMessagesDatabaseMesssageMeta,\n  TSwarmMessageDatabaseMessagesCached,\n} from '../../../../swarm-messages-database.types';\nimport { ISwarmMessagesDatabaseMessagesCacheMessageDescription } from '../../../swarm-messages-database-cache/swarm-messages-database-cache.types';\nimport { ISwarmMessageStoreMessagingRequestWithMetaResult } from '../../../../../swarm-message-store/swarm-message-store.types';\nimport { ISwarmMessageInstanceDecrypted } from '../../../../../swarm-message/swarm-message-constructor.types';\nimport { TSwarmStoreDatabaseEntityKey } from '../../../../../swarm-store-class/swarm-store-class.types';\n\nexport class SwarmMessagesDatabaseMessagesCachedStoreKeyValue<\n    P extends ESwarmStoreConnector,\n    MD extends ISwarmMessageInstanceDecrypted,\n    IsTemp extends boolean\n  >\n  extends SwarmMessagesDatabaseMessagesCachedStoreCore<\n    P,\n    ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE,\n    MD,\n    IsTemp,\n    TSwarmMessagesDatabaseMessagesCachedStoreMessagesMetaHash\n  >\n  implements ISwarmMessagesDatabaseMessagesCachedStoreCore<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE, MD, IsTemp> {\n  get entriesCached(): TSwarmMessageDatabaseMessagesCached<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE, MD> {\n    return this._entriesCached;\n  }\n  protected _entriesCached = new Map() as TSwarmMessageDatabaseMessagesCached<\n    P,\n    ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE,\n    MD\n  >;\n\n  get = (\n    meta: ISwarmMessagesDatabaseMesssageMeta<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE>\n  ): ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined => {\n    this._beforeGet(meta);\n    return this._getMessageCachedByMeta(meta);\n  };\n\n  set = (\n    entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE>\n  ): void => {\n    this._beforeSet(entry);\n    this._setMessageInEntriesCached(entry);\n    this._incMessagesInCacheVersion();\n  };\n\n  unset = (meta: ISwarmMessagesDatabaseMesssageMeta<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE>): void => {\n    this._beforeUnset(meta);\n    this._unsetMessageInEntriesCached(meta);\n    this._incMessagesInCacheVersion();\n  };\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  updateWithEntries(\n    entries: TSwarmMessageDatabaseMessagesCached<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE, MD>\n  ): boolean {\n    const hasUpdatedMessages = this._updateCacheWithEntries(entries, this._entriesCached);\n\n    this._incMessagesInCacheVersion();\n    return hasUpdatedMessages;\n  }\n\n  clear() {\n    this._entriesCached.clear();\n  }\n\n  protected _whetherEntryIsExists(\n    entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE>\n  ): boolean {\n    return !!this._getMessageCachedByMeta(entry.messageMeta);\n  }\n\n  protected _checkMeta(meta: ISwarmMessagesDatabaseMesssageMeta<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE>): void {\n    super._checkMeta(meta);\n    assert(meta.key, 'Key must be defined in meta information');\n  }\n\n  protected _getMessageCachedByMeta(\n    meta: ISwarmMessagesDatabaseMesssageMeta<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE>\n  ): ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD> | undefined {\n    this._checkMeta(meta);\n\n    const messageKey = this._getMessageKeyFromMeta(meta);\n\n    if (!messageKey) {\n      console.warn('Message key is absent in meta information');\n      return;\n    }\n    return this._entriesCached.get(messageKey);\n  }\n\n  protected _getMessageInfo(\n    entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE>\n  ): Required<ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>> {\n    const { messageMeta: meta, messageEntry: message } = entry;\n    const key = this._getMessageKeyFromMeta(meta);\n    const address = this._getMessageAddressFromMeta(meta);\n\n    if (!key) {\n      throw new Error('A key must be defined');\n    }\n    if (!address) {\n      throw new Error('A message add must be defined');\n    }\n    const messageDecrypted = message as MD;\n    return {\n      dbName: this._dbName,\n      message: messageDecrypted,\n      key,\n      messageAddress: address,\n    };\n  }\n\n  protected _unsetMessageInEntriesCached(\n    meta: ISwarmMessagesDatabaseMesssageMeta<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE>\n  ): void {\n    const key = this._getMessageAddressFromMeta(meta);\n    if (!key) {\n      throw new Error('A key is not defined');\n    }\n    this.entriesCached.delete(key);\n  }\n\n  protected _setMessageInEntriesCached(\n    entry: ISwarmMessagesDatabaseMessagesCacheMessageDescription<P, ESwarmStoreConnectorOrbitDbDatabaseType.KEY_VALUE>\n  ): void {\n    const { messageMeta } = entry;\n    const key = this._getMessageKeyFromMeta(messageMeta);\n\n    if (!key) {\n      throw new Error('A key is not defined');\n    }\n    this.entriesCached.set(key, this._getMessageInfo(entry));\n  }\n\n  protected _checkWhetherUpdateKey(\n    key: TSwarmStoreDatabaseEntityKey<P>,\n    value: ISwarmMessageStoreMessagingRequestWithMetaResult<P, MD>\n  ) {\n    return this._checkWhetherUpdatValue(this._entriesCached.get(key), value);\n  }\n}\n","/home/paul/projects/protocol/src/utils/common-utils/common-utils-sets.ts",[],"/home/paul/projects/protocol/src/utils/common-utils/commom-utils.promies.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter.ts",["3777","3778","3779","3780","3781","3782","3783","3784","3785","3786","3787","3788","3789"],"import { TCallbackError, TCallbackErrorValue } from 'orbit-db-cache';\nimport { OpenStorage } from '../../../../../../open-storage/open-storage';\nimport { IStorageCommon } from '../../../../../../../types/storage.types';\nimport { SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_STORAGE_ADAPTER_DEFAULT_OPTIONS_STORAGE } from '../swarm-store-connector-orbit-db-subclasses-cache.const';\nimport { ISwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapterConstructorOptions } from './swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter.types';\nimport { SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_OPEN_STORAGE_ADAPTER_STATUS } from '../swarm-store-connector-orbit-db-subclasses-cache.const';\nimport {\n  ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbKeystoreStore,\n  ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore,\n} from '../swarm-store-connector-orbit-db-subclasses-cache.types';\n\nexport class SwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapter\n  implements\n    ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbKeystoreStore,\n    ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore {\n  public get status(): SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_OPEN_STORAGE_ADAPTER_STATUS {\n    const { isClose } = this;\n\n    if (isClose) {\n      return SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_OPEN_STORAGE_ADAPTER_STATUS.CLOSE;\n    }\n    return SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_OPEN_STORAGE_ADAPTER_STATUS.OPEN;\n  }\n\n  /**\n   * this is used in the Cache(orbit-db-cache) in status\n   * ` get status () { return this._store.db.status } `\n   *\n   * @readonly\n   * @type {{ status: SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_OPEN_STORAGE_ADAPTER_STATUS }}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStoreToStorageAdapter\n   */\n  public get db() {\n    return {\n      status: this.status,\n    };\n  }\n\n  protected options?: ISwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapterConstructorOptions;\n\n  protected storage?: IStorageCommon;\n\n  protected isOpen: boolean = false;\n\n  protected isClose: boolean = false;\n\n  /**\n   * close() method will not close the instance. It's\n   * necessary when restart the database, it's cache\n   * is closed by the OrbitDB API, so to prevent\n   * a cache from closing and it can be resused.\n   *\n   * @protected\n   * @type {boolean}\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapter\n   */\n  protected isPreventedClose: boolean = false;\n\n  constructor(options: ISwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapterConstructorOptions) {\n    this.setOptions(options);\n  }\n\n  public async open(cb?: TCallbackError): Promise<void> {\n    const { isClose, isOpen } = this;\n\n    if (!isClose && isOpen) {\n      return;\n    }\n\n    const result = await this.startStorage();\n\n    if (result instanceof Error) {\n      throw result;\n    }\n    this.setIsOpen();\n    this.unsetIsClose();\n    if (typeof cb === 'function') {\n      cb(undefined);\n    }\n  }\n\n  public close = async (cb?: TCallbackError): Promise<void> => {\n    this.throwIfClosed();\n    if (this.isPreventedClose) {\n      return;\n    }\n    this.setIsClose();\n    this.unsetIsOpen();\n    const result = await this.disconnectStorage();\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw result;\n    }\n    if (typeof cb === 'function') {\n      cb(undefined);\n    }\n  };\n\n  public async get(k: string, cb?: TCallbackErrorValue): Promise<string | undefined> {\n    this.throwIfClosed();\n    // open connection to the secret storage\n    // before any operations\n    await this.openIfNecessary();\n\n    const storage = this.getStorage();\n\n    if (storage instanceof Error) {\n      console.error(Storage);\n      throw storage;\n    }\n\n    const result = await storage.get(k);\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw result;\n    }\n    const resulted = result ? result : undefined;\n    if (typeof cb === 'function') {\n      cb(undefined, resulted);\n    }\n    return resulted;\n  }\n\n  public async put(k: string, v: string | Buffer, cb?: TCallbackError): Promise<void> {\n    this.throwIfClosed();\n    await this.openIfNecessary();\n\n    const storage = this.getStorage();\n\n    if (storage instanceof Error) {\n      console.error(Storage);\n      throw storage;\n    }\n\n    const value = v instanceof Buffer ? v.toString() : v;\n    const result = await storage.set(k, value);\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw result;\n    }\n    if (typeof cb === 'function') {\n      cb(undefined);\n    }\n  }\n\n  public del = async (key: string, cb?: TCallbackError) => {\n    this.throwIfClosed();\n    await this.openIfNecessary();\n\n    const storage = this.getStorage();\n\n    if (storage instanceof Error) {\n      console.error(Storage);\n      throw storage;\n    }\n\n    const result = await storage.set(key, undefined);\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw result;\n    }\n    if (typeof cb === 'function') {\n      cb(undefined);\n    }\n  };\n\n  public setPreventClose = (isPrevented: boolean): void => {\n    this.throwIfClosed();\n    this.isPreventedClose = Boolean(isPrevented);\n  };\n\n  public dropDb = async () => {\n    await this.openIfNecessary();\n\n    const storage = this.getStorage();\n\n    if (Storage instanceof Error) {\n      console.error(Storage);\n      throw storage;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const result = await (storage as OpenStorage).clearDb?.();\n\n    if (result instanceof Error) {\n      console.error(result);\n      throw new Error('Failed to drop the database');\n    }\n  };\n\n  // TODO - not implemented in ocrbit-db-cache\n  public async load() {}\n\n  // TODO - not implemented in ocrbit-db-cache\n  public async destroy() {\n    await this.dropDb();\n    await this.close();\n    this.unsetStorage();\n  }\n\n  protected setIsOpen() {\n    this.isOpen = true;\n  }\n\n  protected unsetIsOpen() {\n    this.isOpen = false;\n  }\n\n  protected setIsClose() {\n    this.isClose = true;\n  }\n\n  protected unsetIsClose() {\n    this.isClose = false;\n  }\n\n  protected throwIfClosed() {\n    if (this.isClose) {\n      throw new Error('The instance is closed');\n    }\n  }\n\n  protected getStorage(): Error | IStorageCommon {\n    const { storage } = this;\n\n    if (storage) {\n      return storage;\n    }\n    return new Error('There is no connection to the OpenStorage');\n  }\n\n  protected setStorageImplementationToUse(storageImplementation: IStorageCommon) {\n    this.storage = storageImplementation;\n  }\n\n  protected setOptions(options: ISwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapterConstructorOptions): void {\n    if (!options) {\n      throw new Error('Options must be provided');\n    }\n    if (typeof options !== 'object') {\n      throw new Error('Options must be an object');\n    }\n\n    const { dbName, storageImplementation } = options;\n\n    if (!dbName) {\n      throw new Error('A database name must be specified in the options');\n    }\n    if (typeof dbName !== 'string') {\n      throw new Error('A database name must be a string');\n    }\n    if (storageImplementation) {\n      this.setStorageImplementationToUse(storageImplementation);\n    }\n    this.options = options;\n  }\n\n  private unsetStorage() {\n    this.storage = undefined;\n  }\n\n  private async createDefaultStorageImplementation(): Promise<IStorageCommon> {\n    const storageImplementation = new OpenStorage();\n    const storageImplementationConnectionResult = await storageImplementation.connect({\n      ...SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_STORAGE_ADAPTER_DEFAULT_OPTIONS_STORAGE,\n      options: this.options,\n    });\n\n    if (storageImplementationConnectionResult instanceof Error) {\n      console.error(storageImplementationConnectionResult);\n      throw new Error(storageImplementationConnectionResult.message);\n    }\n    return storageImplementation;\n  }\n\n  protected async startStorage(): Promise<Error | boolean> {\n    if (this.storage) {\n      return true;\n    }\n\n    const storageImplementation = await this.createDefaultStorageImplementation();\n\n    this.setStorageImplementationToUse(storageImplementation);\n    return true;\n  }\n\n  private async disconnectStorage(): Promise<Error | void> {\n    const { storage } = this;\n\n    if (!Storage) {\n      return new Error('There is no instance of the storage connected to');\n    }\n    try {\n      const result = await (storage as OpenStorage).disconnect?.();\n\n      if (result instanceof Error) {\n        return result;\n      }\n    } catch (err) {\n      return err;\n    }\n  }\n\n  protected async openIfNecessary(): Promise<void> {\n    const { isOpen } = this;\n\n    if (isOpen) {\n      return;\n    }\n    await this.open();\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.ts",["3790","3791"],"import { validateCryptoKeyCredentials } from '../../../../../../secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-main/secret-storage-class-utils-main';\nimport {\n  ISecretStoreCredentials,\n  ISecretStoreCredentialsCryptoKey,\n} from 'classes/secret-storage-class/secret-storage-class.types';\nimport { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';\nimport { SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_STORAGE_ADAPTER_DEFAULT_OPTIONS_STORAGE } from '../swarm-store-connector-orbit-db-subclasses-cache.const';\nimport {\n  ISecretStorage,\n  TSecretStorageAuthorizazionOptions,\n} from '../../../../../../secret-storage-class/secret-storage-class.types';\nimport { ISwarmStoreConnectorOrbitDbSubclassStoreToSecretStorageAdapterConstructorOptions } from './swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.types';\nimport {\n  ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbKeystoreStore,\n  ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore,\n} from '../swarm-store-connector-orbit-db-subclasses-cache.types';\nimport { SwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapter } from '../swarm-store-connector-orbit-db-subclass-store-to-open-storage-adapter';\n\nexport class SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter\n  extends SwarmStoreConnectorOrbitDBSubclassStoreToOpenStorageAdapter\n  implements\n    ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbKeystoreStore,\n    ISwarmStoreConnectorOrbitDbSubclassesCacheOrbitDbCacheStore {\n  protected storage?: ISecretStorage;\n\n  private credentials?: ISecretStoreCredentials;\n\n  private credentialsCryptoKey?: ISecretStoreCredentialsCryptoKey;\n\n  constructor(\n    options: ISwarmStoreConnectorOrbitDbSubclassStoreToSecretStorageAdapterConstructorOptions,\n    credentials: TSecretStorageAuthorizazionOptions\n  ) {\n    super(options);\n    this.setCredentials(credentials);\n    this.createSecretStorage();\n  }\n\n  /**\n   * validate and set credentials with password or crypto key\n   *\n   * @protected\n   * @param {(ISecretStoreCredentials | ISecretStoreCredentialsCryptoKey)} credentials\n   * @memberof SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter\n   * @throws\n   */\n  protected setCredentials(credentials: TSecretStorageAuthorizazionOptions) {\n    if (!credentials) {\n      throw new Error('Credentials must be specified');\n    }\n    if (typeof credentials !== 'object') {\n      throw new Error('Credentials must be an object');\n    }\n\n    if ((credentials as ISecretStoreCredentialsCryptoKey).key) {\n      const credentialsValidationResult = validateCryptoKeyCredentials(credentials as ISecretStoreCredentialsCryptoKey);\n\n      if (credentialsValidationResult instanceof Error) {\n        console.error(credentialsValidationResult);\n        throw new Error('setCredentials::crypto credentials not valid');\n      }\n      this.credentialsCryptoKey = credentials as ISecretStoreCredentialsCryptoKey;\n    }\n    this.credentials = credentials as ISecretStoreCredentials;\n  }\n\n  protected unsetCredentials() {\n    this.credentials = undefined;\n  }\n\n  private createSecretStorage() {\n    const secretStorage = new SecretStorage(\n      SWARM_STORE_CONNECTOR_ORBITDB_SUBCASS_STORE_TO_STORAGE_ADAPTER_DEFAULT_OPTIONS_STORAGE\n    );\n\n    this.storage = secretStorage;\n  }\n\n  protected async startStorage(): Promise<Error | boolean> {\n    const { options, credentials, storage: secretStorage, credentialsCryptoKey } = this;\n\n    if (secretStorage) {\n      if (credentialsCryptoKey) {\n        return secretStorage.authorizeByKey(credentialsCryptoKey, options);\n      } else if (credentials) {\n        return secretStorage.authorize(credentials, options);\n      }\n      return new Error('Credentials was not provided');\n    }\n    return new Error('Secret storage is not defined');\n  }\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclasses-cache.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclasses-cache/swarm-store-connector-orbit-db-subclasses-cache.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-utils/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-utils/swarm-store-connector-orbit-db-utils-address/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-utils/swarm-store-connector-orbit-db-utils-address/swarm-store-connector-orbit-db-utils-address.const.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-utils/swarm-store-connector-orbit-db-utils-address/swarm-store-connector-orbit-db-utils-address.ts",["3792","3793","3794","3795","3796","3797"],"import { relative } from 'path';\nimport OrbitDbAddress from 'orbit-db/src/orbit-db-address';\nimport assert from 'assert';\n\nimport { calculateHash } from 'utils/hash-calculation-utils/hash-calculation-utils';\n\nimport { ISwarmStoreConnectorOrbitDbUtilsAddressCreateRootPathOptions } from './swarm-store-connector-orbit-db-utils-address.types';\n\nimport { HASH_CALCULATION_UTILS_HASH_ALHORITHM } from 'utils';\nimport { SWARM_STORE_CONNECTOR_ORITDB_UTILS_ADDRESS_FULL_PSATH_HASH_CALC_METHOD } from './swarm-store-connector-orbit-db-utils-address.const';\nimport {\n  SWARM_STORE_CONNECTOR_ORITDB_UTILS_ADDRESS_DIRECTORY_HASH_CALC_METHOD,\n  SWARM_STORE_CONNECTOR_ORITDB_UTILS_ADDRESS_USER_ID_HASH_CALC_METHOD,\n  SWARM_STORE_CONNECTOR_ORITDB_UTILS_ADDRESS_DBNAME_HASH_CALC_METHOD,\n  SWARM_STORE_CONNECTOR_ORITDB_UTILS_ADDRESS_ORBITDB_PATH_PREFIX,\n} from './swarm-store-connector-orbit-db-utils-address.const';\n\nexport function checkIfPathStartedWithSlash(path: string): boolean {\n  return path.startsWith('/') || path.startsWith('\\\\');\n}\n\nexport function addStartSlash(path: string): string {\n  if (checkIfPathStartedWithSlash(path)) {\n    return path;\n  }\n  if (path.includes('\\\\') && !path.includes('/')) {\n    return `\\\\${path}`;\n  }\n  return `/${path}`;\n}\n\nexport function removeDuplicateOrbitDBPrefixInPath(path: string): string {\n  if (\n    path.indexOf(SWARM_STORE_CONNECTOR_ORITDB_UTILS_ADDRESS_ORBITDB_PATH_PREFIX) !==\n    path.lastIndexOf(SWARM_STORE_CONNECTOR_ORITDB_UTILS_ADDRESS_ORBITDB_PATH_PREFIX)\n  ) {\n    const pathWithoutPrefixDuplication = relative(SWARM_STORE_CONNECTOR_ORITDB_UTILS_ADDRESS_ORBITDB_PATH_PREFIX, path);\n    return checkIfPathStartedWithSlash(path) ? addStartSlash(pathWithoutPrefixDuplication) : pathWithoutPrefixDuplication;\n  }\n  return path;\n}\n\nexport function swarmStoreConnectorOrbitDbUtilsAddressJoinPathParts(...parts: string[]): string {\n  return removeDuplicateOrbitDBPrefixInPath(OrbitDbAddress.join(...parts));\n}\n\nexport async function swarmStoreConnectorOrbitDbUtilsAddresGetAddressPartForPathPart(\n  pathPart: string,\n  alg: HASH_CALCULATION_UTILS_HASH_ALHORITHM\n): Promise<string> {\n  const result = await calculateHash(pathPart, alg);\n\n  if (result instanceof Error) {\n    console.error(result);\n    throw new Error(result.message);\n  }\n  return result;\n}\n\nexport async function swarmStoreConnectorOrbitDbUtilsAddresGetHashPathFull(fullPath: string): Promise<string> {\n  assert(typeof fullPath === 'string', 'Full path shoult be a string');\n  return swarmStoreConnectorOrbitDbUtilsAddresGetAddressPartForPathPart(\n    fullPath,\n    SWARM_STORE_CONNECTOR_ORITDB_UTILS_ADDRESS_FULL_PSATH_HASH_CALC_METHOD\n  );\n}\n\nexport async function swarmStoreConnectorOrbitDbUtilsAddresGetAddressPartForUserId(userId: string): Promise<string> {\n  assert(typeof userId === 'string', 'User id should be a string');\n  return swarmStoreConnectorOrbitDbUtilsAddresGetAddressPartForPathPart(\n    userId,\n    SWARM_STORE_CONNECTOR_ORITDB_UTILS_ADDRESS_USER_ID_HASH_CALC_METHOD\n  );\n}\n\nexport async function swarmStoreConnectorOrbitDbUtilsAddresGetAddressPartForDirectory(directory: string): Promise<string> {\n  assert(typeof directory === 'string', 'Directory shoult be a string');\n  return swarmStoreConnectorOrbitDbUtilsAddresGetAddressPartForPathPart(\n    directory,\n    SWARM_STORE_CONNECTOR_ORITDB_UTILS_ADDRESS_DIRECTORY_HASH_CALC_METHOD\n  );\n}\n\nexport async function swarmStoreConnectorOrbitDbUtilsAddresGetAddressPartForDb(dbName: string): Promise<string> {\n  assert(typeof dbName === 'string', 'Database name shoult be a string');\n  return swarmStoreConnectorOrbitDbUtilsAddresGetAddressPartForPathPart(\n    dbName,\n    SWARM_STORE_CONNECTOR_ORITDB_UTILS_ADDRESS_DBNAME_HASH_CALC_METHOD\n  );\n}\n\nexport async function swarmStoreConnectorOrbitDbUtilsAddressCreateRootPath(\n  options: ISwarmStoreConnectorOrbitDbUtilsAddressCreateRootPathOptions\n): Promise<string> {\n  const { directory, userId } = options;\n  const directoryHash = await swarmStoreConnectorOrbitDbUtilsAddresGetAddressPartForDirectory(directory);\n  const userIdHash = await swarmStoreConnectorOrbitDbUtilsAddresGetAddressPartForUserId(userId);\n\n  return swarmStoreConnectorOrbitDbUtilsAddressJoinPathParts(directoryHash, userIdHash);\n}\n\nexport function swarmStoreConnectorOrbitDbUtilsAddressGetValidPath(path: string): string {\n  // return path.startsWith('/') ? path : `/${path}`;\n  return swarmStoreConnectorOrbitDbUtilsAddressJoinPathParts(path);\n}\n\nexport function swarmStoreConnectorOrbitDbUtilsAddressGetDBNameByAddress(path: string): undefined | string {\n  try {\n    return OrbitDbAddress.parseAddress(swarmStoreConnectorOrbitDbUtilsAddressGetValidPath(path)).path;\n  } catch (err) {\n    console.error('Cant parse the path', err);\n  }\n}\n\nexport async function swarmStoreConnectorOrbitDbUtilsAddressCreateOrbitDbAddressByDatabaseName(\n  rootPath: string,\n  dbName: string\n): Promise<string> {\n  const dbNamePathPart = await swarmStoreConnectorOrbitDbUtilsAddresGetAddressPartForDb(dbName);\n  return swarmStoreConnectorOrbitDbUtilsAddressJoinPathParts(rootPath, dbNamePathPart);\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-utils/swarm-store-connector-orbit-db-utils-address/swarm-store-connector-orbit-db-utils-address.types.ts",[],"/home/paul/projects/protocol/src/types/orbit-db-address.d.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/async-queue-concurent/async-queue-concurent.ts",["3798","3799","3800","3801","3802","3803","3804"],"import { MaybeError } from 'types/common.types';\nimport { IPromisePendingRejectableCreator } from 'types/promise.types';\n\nimport { IAsyncQueueConcurent, IJobPromise, IJobResolver, IJobResolveCallback } from './async-queue-concurent.types';\nimport { createJobPromise } from './async-queue-concurent.utils';\n\nexport class ConcurentAsyncQueue<T = void, E extends MaybeError = void> implements IAsyncQueueConcurent<T, E> {\n  private queue: Array<IJobPromise<T, E>> = [];\n\n  private _isDestroying: boolean = false;\n\n  constructor(protected _promisePendingRejectableCreator: IPromisePendingRejectableCreator<T, E>) {}\n\n  public wait = (): Promise<IJobResolver<T>> => {\n    this.failIfDestroying();\n\n    const { queue } = this;\n    const lastWorkPromise = !!queue.length && queue[queue.length - 1];\n    const jobPromise = createJobPromise<T, E>(this._promisePendingRejectableCreator);\n    const promiseToWaitBeforeRunJob = (lastWorkPromise || Promise.resolve()) as IJobPromise<T, E>;\n\n    this._addInQueue(jobPromise);\n    return promiseToWaitBeforeRunJob.then(\n      this._createResolverStep(this._createWorkPromiseResolver(jobPromise.resolve, jobPromise))\n    );\n  };\n\n  public destroy = async (err: E): Promise<void> => {\n    this.failIfDestroying();\n    try {\n      this.setIsDestroying();\n      await this._rejectAllPendingJobs(err);\n      this.clearQueue();\n    } finally {\n      this.unsetIsDestroying();\n    }\n  };\n\n  protected _addInQueue = (jobPromise: IJobPromise<T, E>) => {\n    this.queue = [...this.queue, jobPromise];\n  };\n\n  protected _createResolverStep = (resolver: IJobResolveCallback<T>): (() => IJobResolver<T>) => {\n    return () => ({\n      done: resolver,\n    });\n  };\n\n  protected _createWorkPromiseResolver = (\n    workPromiseResolve: IJobResolveCallback<T>,\n    workPromise: IJobPromise<T, E>\n  ): ((v: T) => void) => {\n    return (v: T): void => {\n      this.failIfDestroying();\n      this._removePromiseFromQueue(workPromise);\n      workPromiseResolve(v);\n    };\n  };\n\n  protected _removePromiseFromQueue = (workPromise: IJobPromise<T, E>) => {\n    this.queue = this.queue.filter((item) => item !== workPromise);\n  };\n\n  protected _rejectAllPendingJobs = (err: E) => {\n    return Promise.all(this.queue.map((job) => job.reject(err)));\n  };\n\n  protected clearQueue = () => {\n    this.queue = [];\n  };\n\n  protected setIsDestroying() {\n    this._isDestroying = true;\n  }\n\n  protected unsetIsDestroying() {\n    this._isDestroying = false;\n  }\n\n  protected failIfDestroying() {\n    if (this._isDestroying) {\n      throw new Error('The instance is destroying');\n    }\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-concurent/async-queue-concurent.types.ts",["3805"],"import { IPromisePendingRejectable } from 'types/promise.types';\nimport { MaybeError } from 'types/common.types';\n\nexport interface IJobResolveCallback<T> {\n  (v: T): unknown;\n}\n\nexport interface IJobResolver<T> {\n  done: IJobResolveCallback<T>;\n}\n\nexport interface IJobPromise<T, E extends MaybeError> extends IPromisePendingRejectable<T, E> {}\n\nexport interface IAsyncQueueConcurent<T, E extends MaybeError> {\n  /**\n   * Wait till all previous jobs will be done\n   *\n   * @returns {Promise<IJobResolver>}\n   * @memberof IAsyncQueueConcurent\n   */\n  wait(): Promise<IJobResolver<T>>;\n  /**\n   * Destroy and fail all pending promise\n   *\n   * @param {E} err\n   * @returns {Promise<void>}\n   * @memberof IAsyncQueueConcurent\n   */\n  destroy(err: E): Promise<void>;\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-concurent/async-queue-concurent.utils.ts",["3806","3807","3808","3809","3810","3811","3812","3813"],"import { MaybeError } from 'types/common.types';\nimport { IPromisePendingRejectableCreator } from 'types/promise.types';\n\nimport { IJobPromise, IAsyncQueueConcurent } from './async-queue-concurent.types';\n\nexport const createJobPromise = <T, E extends MaybeError = void>(\n  promisePendingRejectableCreator: IPromisePendingRejectableCreator<T, E>\n): IJobPromise<T, E> => promisePendingRejectableCreator();\n\nexport const wrapAllMethodsWithAsyncQueue = <F extends Function, E extends MaybeError = void>(\n  target: F,\n  asyncQueueCreator: (object: any) => IAsyncQueueConcurent<void, E>,\n  methodsNamesList?: string[]\n): F => {\n  const prototype = { ...target.prototype };\n  for (const propertyName of Object.keys(prototype)) {\n    if (methodsNamesList && methodsNamesList.includes(propertyName)) {\n      continue;\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(prototype, propertyName);\n    if (!descriptor) {\n      continue;\n    }\n\n    const isMethod = descriptor.value instanceof Function;\n    if (!isMethod) continue;\n\n    const originalMethod = descriptor.value;\n    descriptor.value = async function (...args: any[]) {\n      const job = await asyncQueueCreator(this).wait();\n      try {\n        return originalMethod.apply(this, args);\n      } finally {\n        job.done();\n      }\n    };\n\n    Object.defineProperty(prototype, propertyName, descriptor);\n  }\n  Object.setPrototypeOf(target, prototype);\n  return target;\n};\n","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-concurent/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database-classes-extended/swarm-store-connector-orbit-db-subclass-database-queued/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database-classes-extended/swarm-store-connector-orbit-db-subclass-database-queued/swarm-store-connector-orbit-db-subclass-database-queued.ts",["3814","3815","3816"],"import { SwarmStoreConnectorOrbitDBDatabase } from '../../swarm-store-connector-orbit-db-subclass-database';\nimport { ConcurentAsyncQueue } from 'classes/basic-classes/async-queue-concurent/async-queue-concurent';\nimport { createPromisePendingRejectable } from 'utils/common-utils/commom-utils.promies';\n\nimport {\n  TSwarmStoreValueTypes,\n  TSwarmStoreDatabaseType,\n  TSwarmStoreDatabaseOptions,\n} from '../../../../../../swarm-store-class.types';\nimport { ESwarmStoreConnector } from '../../../../../../swarm-store-class.const';\nimport {\n  IJobResolver,\n  IAsyncQueueConcurent,\n} from '../../../../../../../basic-classes/async-queue-concurent/async-queue-concurent.types';\nimport { ArgumentTypes } from 'types/helper.types';\nimport { ISwarmStoreConnectorBasic } from '../../../../../../swarm-store-class.types';\n\nexport class SwarmStoreConnectorOrbitDBDatabaseQueued<\n    ItemType extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>,\n    DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>,\n    DBO extends TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, ItemType, DbType>\n  >\n  extends SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>\n  implements ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO> {\n  /**\n   * All async operations with the database, excluding datbase\n   * close and open, should use this queue.\n   *\n   * @protected\n   * @memberof SwarmStoreConnectorOrbitDBDatabase\n   */\n  private _asyncOperationsQueue: IAsyncQueueConcurent<void, Error> | undefined;\n\n  public connect = async (\n    ...args: ArgumentTypes<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['connect']>\n  ): ReturnType<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['close']> => {\n    await this._rejectAllPendingOperationsOnDbOpen();\n    return super.connect(...args);\n  };\n\n  public close = async (\n    ...args: ArgumentTypes<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['close']>\n  ): ReturnType<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['close']> => {\n    await this._rejectAllPendingOperationsOnDbClose();\n    return super.close(...args);\n  };\n\n  public drop = async (\n    ...args: ArgumentTypes<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['drop']>\n  ): ReturnType<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['drop']> => {\n    await this._rejectAllPendingOperationsOnDbDrop();\n    return super.drop(...args);\n  };\n\n  public load = async (\n    ...args: ArgumentTypes<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['load']>\n  ): ReturnType<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['load']> => {\n    return this._runAsJob(() => super.load(...args));\n  };\n\n  public add = async (\n    ...args: ArgumentTypes<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['add']>\n  ): ReturnType<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['add']> => {\n    return this._runAsJob(() => super.add(...args));\n  };\n\n  public get = async (\n    ...args: ArgumentTypes<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['get']>\n  ): ReturnType<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['get']> => {\n    return this._runAsJob(() => super.get(...args));\n  };\n\n  public remove = async (\n    ...args: ArgumentTypes<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['remove']>\n  ): ReturnType<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['remove']> => {\n    return this._runAsJob(() => super.remove(...args));\n  };\n\n  public iterator = async (\n    ...args: ArgumentTypes<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['iterator']>\n  ): ReturnType<SwarmStoreConnectorOrbitDBDatabase<ItemType, DbType, DBO>['iterator']> => {\n    return this._runAsJob(() => super.iterator(...args));\n  };\n\n  protected _initializeAsyncQueue() {\n    this._asyncOperationsQueue = new ConcurentAsyncQueue<void, Error>(createPromisePendingRejectable);\n  }\n\n  protected _getAsyncOperationsQueue(): IAsyncQueueConcurent<void, Error> {\n    if (!this._asyncOperationsQueue) {\n      this._initializeAsyncQueue();\n    }\n    if (!this._asyncOperationsQueue) {\n      throw new Error('Failed to initialize the async queue instance');\n    }\n    return this._asyncOperationsQueue;\n  }\n\n  protected _waitOperationsQueue(): Promise<IJobResolver<void>> {\n    return this._getAsyncOperationsQueue().wait();\n  }\n\n  protected _rejectAllPendingOperations(err: Error): Promise<void> {\n    return this._getAsyncOperationsQueue().destroy(err);\n  }\n\n  protected _rejectAllPendingOperationsOnDbClose(): Promise<void> {\n    return this._rejectAllPendingOperations(new Error('Datatabase closed'));\n  }\n\n  protected _rejectAllPendingOperationsOnDbOpen(): Promise<void> {\n    return this._rejectAllPendingOperations(new Error('Datatabase opened again'));\n  }\n\n  protected _rejectAllPendingOperationsOnDbDrop(): Promise<void> {\n    return this._rejectAllPendingOperations(new Error('Datatabase dropped'));\n  }\n\n  protected _runAsJob = async <F extends () => any>(func: F): Promise<ReturnType<F>> => {\n    const currentJob = await this._waitOperationsQueue();\n    try {\n      return func();\n    } finally {\n      currentJob.done();\n    }\n  };\n}\n","/home/paul/projects/protocol/src/types/promise.types.ts",[],"/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge.utils.ts",["3817"],"import {\n  TSwarmStoreConnectorBasicFabric,\n  TSwarmStoreConnectorConnectionOptions,\n  TSwarmStoreDatabaseType,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { ESwarmStoreConnector } from '../swarm-store-class/swarm-store-class.const';\nimport { TSwarmMessageSerialized } from '../swarm-message/swarm-message-constructor.types';\nimport { IConnectionBridgeSwarmConnection, TNativeConnectionType, TNativeConnectionOptions } from './connection-bridge.types';\nimport { IPFS } from 'types/ipfs.types';\nimport { ISwarmStoreConnectorOrbitDbConnecectionBasicFabric } from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db.types';\nimport OrbitDB from 'orbit-db';\nimport { ISwarmStoreConnectorOrbitDbDatabaseOptions } from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\nimport { SwarmStoreConnectorOrbitDbSubclassDatabaseQueuedItemsCounted } from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database-classes-extended/swarm-store-connector-orbit-db-subclass-database-queued-items-counted/swarm-store-connector-orbit-db-subclass-database-queued-items-counted';\nimport {\n  ISwarmStoreConnectorBasic,\n  ISwarmStoreProviderOptions,\n  TSwarmStoreDatabaseOptions,\n  ISwarmStoreOptionsConnectorFabric,\n  TSwarmStoreConnectorConstructorOptions,\n} from '../swarm-store-class/swarm-store-class.types';\nimport { ipfsUtilsConnectBasic } from '../../utils/ipfs-utils/ipfs-utils';\nimport {\n  ISwarmStoreConnectorWithEntriesCount,\n  ISwarmStoreConnectorBasicWithEntriesCount,\n} from '../swarm-store-class/swarm-store-class-extended/swarm-store-class-with-entries-count/swarm-store-class-with-entries-count.types';\nimport { SwarmStoreConnectorOrbitDBWithEntriesCount } from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-extended/swarm-store-connector-orbit-db-with-entries-count/swarm-store-connector-orbit-db-with-entries-count';\nimport { ISwarmStoreConnector } from '../swarm-store-class/swarm-store-class.types';\nimport { SwarmStoreConnectorOrbitDB } from '../swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db';\n\nexport const connectorBasicFabricOrbitDBDefault = <\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>,\n  DBO extends TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, T, DbType>\n>(\n  dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<T, DbType>,\n  orbitDb: OrbitDB\n): ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, T, DbType, DBO> => {\n  return new SwarmStoreConnectorOrbitDbSubclassDatabaseQueuedItemsCounted(dbOptions, orbitDb);\n};\n\nexport const connectorBasicFabricOrbitDBWithEntriesCount = <\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>,\n  DBO extends TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, T, DbType>\n>(\n  dbOptions: ISwarmStoreConnectorOrbitDbDatabaseOptions<T, DbType>,\n  orbitDb: OrbitDB\n): ISwarmStoreConnectorBasicWithEntriesCount<ESwarmStoreConnector.OrbitDB, T, DbType, DBO> => {\n  return new SwarmStoreConnectorOrbitDbSubclassDatabaseQueuedItemsCounted(dbOptions, orbitDb);\n};\n\nexport const getSwarmStoreConnectionProviderOptionsForOrbitDb = <\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>,\n  DBO extends TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<ESwarmStoreConnector.OrbitDB, T, DbType, DBO>,\n  NC extends IPFS,\n  SC extends IConnectionBridgeSwarmConnection<ESwarmStoreConnector.OrbitDB, NC>\n>(\n  swarmConnection: SC,\n  connectorBasicFabric: ISwarmStoreConnectorOrbitDbConnecectionBasicFabric<T, DbType, DBO, ConnectorBasic>\n): TSwarmStoreConnectorConnectionOptions<ESwarmStoreConnector.OrbitDB, T, DbType, DBO, ConnectorBasic> => {\n  return {\n    ipfs: swarmConnection.getNativeConnection(),\n    connectorBasicFabric,\n  };\n};\n\nexport const getSwarmStoreConnectionProviderOptionsForSwarmStoreConnector = <\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  NC extends TNativeConnectionType<P>,\n  SC extends IConnectionBridgeSwarmConnection<P, NC>\n>(\n  swarmStoreConnectorType: P,\n  swarmConnection: SC,\n  connectorBasicFabric: TSwarmStoreConnectorBasicFabric<P, T, DbType, DBO, ConnectorBasic>\n): TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic> => {\n  if (swarmStoreConnectorType === ESwarmStoreConnector.OrbitDB) {\n    const orbitDbOptions = getSwarmStoreConnectionProviderOptionsForOrbitDb<T, DbType, DBO, ConnectorBasic, NC, SC>(\n      swarmConnection,\n      connectorBasicFabric\n    );\n    return orbitDbOptions as TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic>;\n  }\n  throw new Error('This swarm store connector type is not supported');\n};\n\nexport const createNativeConnectionForOrbitDB = (\n  nativeConnectionOptions: TNativeConnectionOptions<ESwarmStoreConnector.OrbitDB>\n): Promise<TNativeConnectionType<ESwarmStoreConnector.OrbitDB>> => {\n  return ipfsUtilsConnectBasic(nativeConnectionOptions);\n};\n\nexport const createNativeConnection = async <P extends ESwarmStoreConnector>(\n  swarmStoreConnectorType: P,\n  nativeConnectionOptions: TNativeConnectionOptions<P>\n): Promise<TNativeConnectionType<P>> => {\n  switch (swarmStoreConnectorType) {\n    case ESwarmStoreConnector.OrbitDB:\n      return createNativeConnectionForOrbitDB(nativeConnectionOptions) as Promise<TNativeConnectionType<P>>;\n    default:\n      throw new Error('Unsupported swarm connector type');\n  }\n};\n\nconst getMainConnectorFabricForOrbitDBWithEntriesCount = <\n  P extends ESwarmStoreConnector.OrbitDB,\n  ItemType extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasicWithEntriesCount<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>\n>(\n  swarmStoreConnectorOrbitDBConstructorOptions: TSwarmStoreConnectorConstructorOptions<P, ItemType, DbType>,\n  options: CO\n): ISwarmStoreConnectorWithEntriesCount<P, ItemType, DbType, DBO, ConnectorBasic, PO> => {\n  const swarmMessageStoreWithEntriesCount = new SwarmStoreConnectorOrbitDBWithEntriesCount(\n    swarmStoreConnectorOrbitDBConstructorOptions\n  );\n  return swarmMessageStoreWithEntriesCount as ISwarmStoreConnectorWithEntriesCount<P, ItemType, DbType, DBO, ConnectorBasic, PO>;\n};\n\nconst getMainConnectorFabricForOrbitDB = <\n  P extends ESwarmStoreConnector.OrbitDB,\n  ItemType extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>\n>(\n  swarmStoreConnectorOrbitDBConstructorOptions: TSwarmStoreConnectorConstructorOptions<P, ItemType, DbType>,\n  options: CO\n): ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO> => {\n  const swarmMessageStoreWithEntriesCount = new SwarmStoreConnectorOrbitDB(swarmStoreConnectorOrbitDBConstructorOptions);\n  return swarmMessageStoreWithEntriesCount as ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO>;\n};\n\nexport const getMainConnectorFabricDefault = <\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnector<P, ItemType, DbType, DBO, ConnectorBasic, PO>\n>(\n  swarmStoreConnectorConstructorOptions: TSwarmStoreConnectorConstructorOptions<P, ItemType, DbType>\n): ISwarmStoreOptionsConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> => {\n  return (storeProviderOptions: CO): ConnectorMain => {\n    const { provider: swarmStoreConnectorType } = storeProviderOptions;\n    switch (swarmStoreConnectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        return getMainConnectorFabricForOrbitDB<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO>(\n          swarmStoreConnectorConstructorOptions,\n          storeProviderOptions\n        ) as ConnectorMain;\n      default:\n        throw new Error('Unsupported swarm connector type');\n    }\n  };\n};\n\nexport const getMainConnectorFabricWithEntriesCountDefault = <\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasicWithEntriesCount<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnectorWithEntriesCount<P, ItemType, DbType, DBO, ConnectorBasic, PO>\n>(\n  swarmStoreConnectorConstructorOptions: TSwarmStoreConnectorConstructorOptions<P, ItemType, DbType>\n): ISwarmStoreOptionsConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> => {\n  return (storeProviderOptions: CO): ConnectorMain => {\n    const { provider: swarmStoreConnectorType } = storeProviderOptions;\n    switch (swarmStoreConnectorType) {\n      case ESwarmStoreConnector.OrbitDB:\n        return getMainConnectorFabricForOrbitDBWithEntriesCount<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO>(\n          swarmStoreConnectorConstructorOptions,\n          storeProviderOptions\n        ) as ConnectorMain;\n      default:\n        throw new Error('Unsupported swarm connector type');\n    }\n  };\n};\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database-classes-extended/swarm-store-connector-orbit-db-subclass-database-queued-items-counted/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database-classes-extended/swarm-store-connector-orbit-db-subclass-database-queued-items-counted/swarm-store-connector-orbit-db-subclass-database-queued-items-counted.ts",[],"/home/paul/projects/protocol/src/types/swarm-store-connector.types.ts",["3818"],"import { ESwarmStoreConnector } from '../classes/swarm-store-class/swarm-store-class.const';\nimport { TSwarmStoreValueTypes, TSwarmStoreDatabaseType } from '../classes/swarm-store-class/swarm-store-class.types';\nimport {\n  ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions,\n  ISwarmStoreConnectorOrbitDbDatabaseValue,\n  TSwarmStoreConnectorOrbitDbDatabaseEntityIndex,\n  TSwarmStoreConnectorOrbitDbDatabaseAddMethodArgument,\n} from '../classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-subclasses/swarm-store-connector-orbit-db-subclass-database/swarm-store-connector-orbit-db-subclass-database.types';\n\nexport interface ISwarmStoreConnectorBasic<\n  TSwarmStoreConnectorType extends ESwarmStoreConnector,\n  TStoreValue extends TSwarmStoreValueTypes<TSwarmStoreConnectorType>,\n  DbType extends TSwarmStoreDatabaseType<TSwarmStoreConnectorType>\n> {\n  /**\n   * Connect to the database\n   *\n   * @returns {(Promise<Error | void>)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  connect(): Promise<Error | void>;\n  /**\n   * Close the insatnce\n   *\n   * @param {*} [opt]\n   * @returns {(Promise<Error | void>)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  close(opt?: any): Promise<Error | void>;\n  /**\n   * Add the new entry to the database\n   *\n   * @param {TSwarmStoreConnectorOrbitDbDatabaseAddMethodArgument<TStoreValue>} addArg\n   * @returns {(Promise<string | Error>)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  add(addArg: TSwarmStoreConnectorOrbitDbDatabaseAddMethodArgument<TStoreValue>): Promise<string | Error>;\n\n  /**\n   * Read entry from the database by the given argument.\n   * for the key value store a key must be used.\n   * for the feed store a hash of the value\n   * must be used.\n   *\n   * @param {TSwarmStoreConnectorOrbitDbDatabaseEntityIndex} keyOrHash\n   * @returns {(Promise<\n   *     Error | ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValue> | undefined\n   *   >)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  get(\n    keyOrHash: TSwarmStoreConnectorOrbitDbDatabaseEntityIndex\n  ): Promise<Error | ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValue> | undefined>;\n\n  /**\n   * Remove a value located in the key provided if it is a key value\n   * database.\n   * Remove an entry by it's address for a non key-value database.\n   *\n   * @param {TSwarmStoreConnectorOrbitDbDatabaseEntityIndex} keyOrEntryAddress\n   * @returns {(Promise<Error | void>)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  remove(keyOrEntryAddress: TSwarmStoreConnectorOrbitDbDatabaseEntityIndex): Promise<Error | void>;\n\n  /**\n   * Iterate over the database values which are follows conditions\n   * from the options.\n   *\n   * @param {ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<DbType>} [options]\n   * @returns {(Promise<\n   *     | Error\n   *     | Array<\n   *         | ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValue>\n   *         | Error\n   *         | undefined\n   *       >\n   *   >)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  iterator(\n    options?: ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<DbType>\n  ): Promise<Error | Array<ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValue> | Error | undefined>>;\n\n  /**\n   * Drop the database and clear all local stored entries.\n   *\n   * @returns {(Promise<Error | void>)}\n   * @memberof ISwarmStoreConnectorOrbitDBDatabase\n   */\n  drop(): Promise<Error | void>;\n}\n","/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-extended/swarm-message-store-with-entries-count/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-message-store/swarm-message-store-extended/swarm-message-store-with-entries-count/swarm-message-store-with-entries-count.ts",["3819"],"import { ESwarmStoreConnector } from '../../../swarm-store-class/swarm-store-class.const';\nimport { TSwarmMessageSerialized, TSwarmMessageInstance } from '../../../swarm-message/swarm-message-constructor.types';\nimport {\n  TSwarmStoreDatabaseType,\n  TSwarmStoreConnectorConnectionOptions,\n  TSwarmStoreDatabaseOptions,\n  ISwarmStoreProviderOptions,\n  ISwarmStoreOptionsConnectorFabric,\n  TSwarmStoreOptionsOfDatabasesKnownList,\n} from '../../../swarm-store-class/swarm-store-class.types';\nimport {\n  TSwarmMessagesStoreGrantAccessCallback,\n  ISwarmMessageStoreAccessControlOptions,\n  ISwarmMessageStoreOptionsWithConnectorFabric,\n  ISwarmMessageStoreEvents,\n} from '../../swarm-message-store.types';\nimport { ISwarmMessageConstructorWithEncryptedCacheFabric } from '../../../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport { SwarmMessageStore } from '../../swarm-message-store';\nimport { extendClassSwarmStoreWithEntriesCount } from '../../../swarm-store-class/swarm-store-class-extended/swarm-store-class-with-entries-count';\nimport {\n  ISwarmStoreConnectorBasicWithEntriesCount,\n  ISwarmStoreConnectorWithEntriesCount,\n} from '../../../swarm-store-class/swarm-store-class-extended/swarm-store-class-with-entries-count/swarm-store-class-with-entries-count.types';\n\nexport function getClassSwarmMessageStoreWithEntriesCount<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasicWithEntriesCount<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnectorWithEntriesCount<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>,\n  MSI extends TSwarmMessageInstance | ItemType,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, ItemType, MSI, GAC> | undefined,\n  O extends ISwarmMessageStoreOptionsWithConnectorFabric<\n    P,\n    ItemType,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO\n  >,\n  E extends ISwarmMessageStoreEvents<P, ItemType, DbType, DBO>,\n  DBL extends TSwarmStoreOptionsOfDatabasesKnownList<P, ItemType, DbType, DBO>\n>() {\n  return extendClassSwarmStoreWithEntriesCount<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO, O>(\n    class B extends SwarmMessageStore<\n      P,\n      ItemType,\n      DbType,\n      DBO,\n      ConnectorBasic,\n      PO,\n      CO,\n      ConnectorMain,\n      CFO,\n      MSI,\n      GAC,\n      MCF,\n      ACO,\n      O,\n      E,\n      DBL\n    > {}\n  );\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class-extended/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class-extended/swarm-store-class-with-entries-count/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class-extended/swarm-store-class-with-entries-count/swarm-store-class-with-entries-count.ts",["3820"],"import { ESwarmStoreConnector } from '../../swarm-store-class.const';\nimport {\n  ISwarmStoreEvents,\n  ISwarmStoreOptionsConnectorFabric,\n  ISwarmStoreOptionsWithConnectorFabric,\n  ISwarmStoreProviderOptions,\n  TSwarmStoreConnectorConnectionOptions,\n  TSwarmStoreDatabaseOptions,\n  TSwarmStoreDatabaseType,\n  TSwarmStoreOptionsOfDatabasesKnownList,\n  TSwarmStoreValueTypes,\n} from '../../swarm-store-class.types';\nimport {\n  ISwarmStoreConnectorBasicWithEntriesCount,\n  ISwarmStoreConnectorWithEntriesCount,\n} from './swarm-store-class-with-entries-count.types';\nimport { SwarmStore } from '../../swarm-store-class';\nimport { extendClassSwarmStoreWithEntriesCount } from './swarm-store-class-with-entries-count-mixin';\n\nexport function getClassSwarmStoreWithEntriesCount<\n  P extends ESwarmStoreConnector,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>,\n  ConnectorBasic extends ISwarmStoreConnectorBasicWithEntriesCount<P, ItemType, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, ItemType, DbType, DBO, ConnectorBasic>,\n  CO extends ISwarmStoreProviderOptions<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  ConnectorMain extends ISwarmStoreConnectorWithEntriesCount<P, ItemType, DbType, DBO, ConnectorBasic, PO>,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>,\n  O extends ISwarmStoreOptionsWithConnectorFabric<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n  E extends ISwarmStoreEvents<P, ItemType, DbType, DBO>,\n  DBL extends TSwarmStoreOptionsOfDatabasesKnownList<P, ItemType, DbType, DBO>\n>() {\n  return extendClassSwarmStoreWithEntriesCount<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO, O>(\n    class BC extends SwarmStore<P, ItemType, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO, O, E, DBL> {}\n  );\n}\n","/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-extended/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-extended/swarm-store-connector-orbit-db-with-entries-count/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-connectors/swarm-store-connector-orbit-db/swarm-store-connector-orbit-db-extended/swarm-store-connector-orbit-db-with-entries-count/swarm-store-connector-orbit-db-with-entries-count.ts",["3821","3822"],"import { SwarmStoreConnectorOrbitDB } from '../../swarm-store-connector-orbit-db';\nimport { ESwarmStoreConnector } from '../../../../swarm-store-class.const';\nimport { TSwarmStoreConnectorConnectionOptions } from '../../../../swarm-store-class.types';\nimport { TSwarmStoreValueTypes, TSwarmStoreDatabaseType, TSwarmStoreDatabaseOptions } from '../../../../swarm-store-class.types';\nimport {\n  ISwarmStoreConnectorBasicWithEntriesCount,\n  ISwarmStoreConnectorWithEntriesCount,\n} from '../../../../swarm-store-class-extended/swarm-store-class-with-entries-count/swarm-store-class-with-entries-count.types';\n\nexport class SwarmStoreConnectorOrbitDBWithEntriesCount<\n    ItemType extends TSwarmStoreValueTypes<ESwarmStoreConnector.OrbitDB>,\n    DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>,\n    DBO extends TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, ItemType, DbType>,\n    ConnectorBasic extends ISwarmStoreConnectorBasicWithEntriesCount<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO>,\n    PO extends TSwarmStoreConnectorConnectionOptions<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO, ConnectorBasic>\n  >\n  extends SwarmStoreConnectorOrbitDB<ItemType, DbType, DBO, ConnectorBasic, PO>\n  implements ISwarmStoreConnectorWithEntriesCount<ESwarmStoreConnector.OrbitDB, ItemType, DbType, DBO, ConnectorBasic, PO> {\n  async getCountEntriesLoaded(\n    dbName: TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, ItemType, DbType>['dbName']\n  ): Promise<number | Error> {\n    const connector = this.getDbConnectionExists(dbName);\n\n    if (!connector) {\n      return new Error('Basic connector is not exists');\n    }\n    return connector.countEntriesLoaded;\n  }\n\n  async getCountEntriesAllExists(\n    dbName: TSwarmStoreDatabaseOptions<ESwarmStoreConnector.OrbitDB, ItemType, DbType>['dbName']\n  ): Promise<number | Error> {\n    const connector = this.getDbConnectionExists(dbName);\n\n    if (!connector) {\n      return new Error('Basic connector is not exists');\n    }\n    return connector.countEntriesAllExists;\n  }\n}\n","/home/paul/projects/protocol/src/classes/basic-classes/async-queue-class-base/async-queue-class-base.test.ts",[],"/home/paul/projects/protocol/src/classes/basic-classes/queued-encryption-class-base/queued-encryption-class-base.test.ts",["3823","3824","3825","3826","3827","3828"],"/home/paul/projects/protocol/src/classes/swarm-message/swarm-message-subclasses/swarm-message-subclass-validators/swarm-message-subclass-validator-signature-validator/swarm-message-subclass-validator-signature-validator.test.ts",["3829","3830"],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class-extended/swarm-store-class-with-entries-count/swarm-store-class-with-entries-count-mixin.ts",[],"/home/paul/projects/protocol/src/classes/swarm-store-class/swarm-store-class-extended/swarm-store-class-with-entries-count/swarm-store-class-with-entries-count.types.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-credentials/index.ts",[],"/home/paul/projects/protocol/src/classes/secret-storage-class/secret-storage-class-utils/secret-storage-class-utils-credentials/secret-storage-class-utils-credentials.ts",[],"/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge-fabric/connection-bridge-fabric.ts",["3831"],"import { IConnectionBridgeOptions, TConnectionBridgeCFODefault } from '../connection-bridge.types';\nimport { ESwarmStoreConnector } from '../../swarm-store-class/swarm-store-class.const';\nimport { TSwarmMessageInstance } from '../../swarm-message/swarm-message-constructor.types';\nimport {\n  TSwarmMessagesStoreGrantAccessCallback,\n  ISwarmMessageStoreAccessControlOptions,\n} from '../../swarm-message-store/swarm-message-store.types';\nimport { ISwarmMessageConstructorWithEncryptedCacheFabric } from '../../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport { TSwarmStoreDatabaseType, TSwarmStoreConnectorConnectionOptions } from '../../swarm-store-class/swarm-store-class.types';\nimport { TSwarmMessageSerialized } from '../../swarm-message/swarm-message-constructor.types';\nimport {\n  ISwarmStoreConnectorBasic,\n  ISwarmStoreConnector,\n  TSwarmStoreConnectorBasicFabric,\n} from '../../swarm-store-class/swarm-store-class.types';\nimport { ISwarmMessageStoreOptionsWithConnectorFabric } from '../../swarm-message-store/swarm-message-store.types';\nimport { ConnectionBridge } from '../connection-bridge';\nimport {\n  TSwarmStoreDatabaseOptions,\n  ISwarmStoreProviderOptions,\n  ISwarmStoreOptionsConnectorFabric,\n} from '../../swarm-store-class/swarm-store-class.types';\n\nexport const createConnectrionBridgeConnection = async <\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  CD extends boolean = true,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType> = TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T = TSwarmMessageInstance | T,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined = undefined,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI> = TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, T, MSI, GAC> | undefined = undefined,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO> = ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  CBFO extends TSwarmStoreConnectorBasicFabric<P, T, DbType, DBO, ConnectorBasic> | undefined = undefined,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic> = TSwarmStoreConnectorConnectionOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic\n  >,\n  CO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, PO> = ISwarmStoreProviderOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO\n  >,\n  ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, PO> = ISwarmStoreConnector<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO\n  >,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> | undefined = undefined,\n  O extends ISwarmMessageStoreOptionsWithConnectorFabric<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n    MSI,\n    GAC,\n    MCF,\n    ACO\n  > = ISwarmMessageStoreOptionsWithConnectorFabric<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    TConnectionBridgeCFODefault<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO>,\n    MSI,\n    GAC,\n    MCF,\n    ACO\n  >,\n  CBO extends IConnectionBridgeOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    CFO,\n    CBFO,\n    CD\n  > = IConnectionBridgeOptions<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, MSI, GAC, MCF, ACO, CFO, CBFO, CD>\n>(\n  options: CBO,\n  useSessionIfExists: boolean = false\n) => {\n  const connectionBridge = new ConnectionBridge<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    CBFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    O,\n    CD,\n    CBO\n  >();\n  let useSessionAuth: boolean = false;\n  const optionsWithoutCredentials = {\n    ...options,\n    auth: {\n      ...options.auth,\n      credentials: undefined,\n    },\n  };\n\n  if (useSessionIfExists) {\n    useSessionAuth = await connectionBridge.checkSessionAvailable(optionsWithoutCredentials);\n  }\n\n  await connectionBridge.connect(useSessionAuth ? optionsWithoutCredentials : options);\n  return connectionBridge;\n};\n","/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge-fabric/index.ts",[],"/home/paul/projects/protocol/src/classes/connection-bridge/connection-bridge-fabric/connection-bridge-fabric.types.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-fabric/swarm-messages-database-fabric.ts",["3832"],"import { ISwarmMessagesDatabaseConnectOptions, ISwarmMessagesDatabaseConnector } from '../swarm-messages-database.types';\nimport {\n  ISwarmMessageStore,\n  TSwarmMessagesStoreGrantAccessCallback,\n  ISwarmMessageStoreAccessControlOptions,\n  ISwarmMessageStoreOptionsWithConnectorFabric,\n} from '../../swarm-message-store/swarm-message-store.types';\nimport { TSwarmMessageSerialized, TSwarmMessageInstance } from '../../swarm-message/swarm-message-constructor.types';\nimport { TSwarmStoreDatabaseOptions, TSwarmStoreDatabaseType } from '../../swarm-store-class/swarm-store-class.types';\nimport {\n  ISwarmStoreConnectorBasic,\n  ISwarmStoreConnector,\n  TSwarmStoreConnectorConnectionOptions,\n  ISwarmStoreProviderOptions,\n  ISwarmStoreOptionsConnectorFabric,\n} from '../../swarm-store-class/swarm-store-class.types';\nimport { ISwarmMessageConstructorWithEncryptedCacheFabric } from '../../swarm-messgae-encrypted-cache/swarm-messgae-encrypted-cache.types';\nimport { ISwarmMessageInstanceEncrypted } from '../../swarm-message/swarm-message-constructor.types';\nimport { SwarmMessagesDatabase } from '../swarm-messages-database';\nimport { ESwarmStoreConnector } from 'classes/swarm-store-class/swarm-store-class.const';\nimport { TConnectToSwarmMessagesDatabaseReturnType } from './swarm-messages-database-fabric.types';\n\nexport const swarmMessagesDatabaseConnectedFabric = async <\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType> = TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T = TSwarmMessageInstance | T,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined = undefined,\n  MD extends Exclude<MSI, T | ISwarmMessageInstanceEncrypted> &\n    Exclude<Exclude<MSI, T>, ISwarmMessageInstanceEncrypted> = Exclude<MSI, T | ISwarmMessageInstanceEncrypted> &\n    Exclude<Exclude<MSI, T>, ISwarmMessageInstanceEncrypted>,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI> = TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, T, MSI, GAC> | undefined = undefined,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO> = ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic> = TSwarmStoreConnectorConnectionOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic\n  >,\n  CO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, PO> = ISwarmStoreProviderOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO\n  >,\n  ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, PO> = ISwarmStoreConnector<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO\n  >,\n  CFO extends ISwarmStoreOptionsConnectorFabric<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain\n  > = ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain>,\n  O extends ISwarmMessageStoreOptionsWithConnectorFabric<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO\n  > = ISwarmMessageStoreOptionsWithConnectorFabric<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO\n  >,\n  SMS extends ISwarmMessageStore<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    O\n  > = ISwarmMessageStore<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, CFO, MSI, GAC, MCF, ACO, O>\n>(\n  options: ISwarmMessagesDatabaseConnectOptions<P, T, DbType, DBO, Exclude<MSI, T>, SMS, MD>\n): Promise<\n  TConnectToSwarmMessagesDatabaseReturnType<\n    P,\n    T,\n    DbType,\n    DBO,\n    MSI,\n    MCF,\n    MD,\n    GAC,\n    ACO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    O,\n    SMS\n  >\n> => {\n  const db = new SwarmMessagesDatabase<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO,\n    CO,\n    ConnectorMain,\n    CFO,\n    MSI,\n    GAC,\n    MCF,\n    ACO,\n    O,\n    SMS,\n    MD\n  >();\n\n  await db.connect(options);\n  return db;\n};\n","/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-fabric/index.ts",[],"/home/paul/projects/protocol/src/classes/swarm-messages-database/swarm-messages-database-fabric/swarm-messages-database-fabric.types.ts",[],"/home/paul/projects/protocol/src/types/credentials.types.ts",[],"/home/paul/projects/protocol/src/components/const/connect-to-swarm-immediate.const.ts",[],"/home/paul/projects/protocol/src/components/const/connect-to-swarm.const.ts",[],"/home/paul/projects/protocol/src/utils/ipfs-utils/ipfs-utils-libp2p/index.ts",[],{"ruleId":null,"fatal":true,"severity":2,"message":"3833"},{"ruleId":null,"fatal":true,"severity":2,"message":"3834"},{"ruleId":null,"fatal":true,"severity":2,"message":"3835"},{"ruleId":null,"fatal":true,"severity":2,"message":"3836"},{"ruleId":"3837","severity":1,"message":"3838","line":10,"column":56,"nodeType":"3839","messageId":"3840","endLine":10,"endColumn":59,"suggestions":"3841"},{"ruleId":"3837","severity":1,"message":"3838","line":12,"column":28,"nodeType":"3839","messageId":"3840","endLine":12,"endColumn":31,"suggestions":"3842"},{"ruleId":"3837","severity":1,"message":"3838","line":23,"column":37,"nodeType":"3839","messageId":"3840","endLine":23,"endColumn":40,"suggestions":"3843"},{"ruleId":"3837","severity":1,"message":"3838","line":32,"column":42,"nodeType":"3839","messageId":"3840","endLine":32,"endColumn":45,"suggestions":"3844"},{"ruleId":"3845","severity":1,"message":"3846","line":44,"column":7,"nodeType":"3847","messageId":"3848","endLine":44,"endColumn":54},{"ruleId":"3849","severity":1,"message":"3850","line":48,"column":21,"nodeType":"3851","messageId":"3852","endLine":48,"endColumn":32},{"ruleId":"3849","severity":1,"message":"3853","line":70,"column":24,"nodeType":"3854","messageId":"3855","endLine":70,"endColumn":44},{"ruleId":"3837","severity":1,"message":"3838","line":70,"column":41,"nodeType":"3839","messageId":"3840","endLine":70,"endColumn":44,"suggestions":"3856"},{"ruleId":"3849","severity":1,"message":"3853","line":73,"column":30,"nodeType":"3854","messageId":"3855","endLine":73,"endColumn":50},{"ruleId":"3837","severity":1,"message":"3838","line":73,"column":47,"nodeType":"3839","messageId":"3840","endLine":73,"endColumn":50,"suggestions":"3857"},{"ruleId":"3837","severity":1,"message":"3838","line":74,"column":47,"nodeType":"3839","messageId":"3840","endLine":74,"endColumn":50,"suggestions":"3858"},{"ruleId":"3837","severity":1,"message":"3838","line":55,"column":65,"nodeType":"3839","messageId":"3840","endLine":55,"endColumn":68,"suggestions":"3859"},{"ruleId":"3837","severity":1,"message":"3838","line":65,"column":37,"nodeType":"3839","messageId":"3840","endLine":65,"endColumn":40,"suggestions":"3860"},{"ruleId":"3837","severity":1,"message":"3838","line":4,"column":27,"nodeType":"3839","messageId":"3840","endLine":4,"endColumn":30,"suggestions":"3861"},{"ruleId":"3845","severity":1,"message":"3862","line":12,"column":5,"nodeType":"3863","messageId":"3864","endLine":12,"endColumn":33},{"ruleId":"3849","severity":1,"message":"3850","line":7,"column":36,"nodeType":"3851","messageId":"3852","endLine":7,"endColumn":63},{"ruleId":"3837","severity":1,"message":"3838","line":4,"column":58,"nodeType":"3839","messageId":"3840","endLine":4,"endColumn":61,"suggestions":"3865"},{"ruleId":"3837","severity":1,"message":"3838","line":6,"column":72,"nodeType":"3839","messageId":"3840","endLine":6,"endColumn":75,"suggestions":"3866"},{"ruleId":"3849","severity":1,"message":"3850","line":11,"column":3,"nodeType":"3867","messageId":"3852","endLine":11,"endColumn":69},{"ruleId":"3849","severity":1,"message":"3850","line":30,"column":3,"nodeType":"3867","messageId":"3852","endLine":30,"endColumn":37},{"ruleId":"3849","severity":1,"message":"3850","line":43,"column":3,"nodeType":"3867","messageId":"3852","endLine":43,"endColumn":38},{"ruleId":"3868","severity":1,"message":"3869","line":78,"column":15,"nodeType":"3870","messageId":"3871","endLine":78,"endColumn":27},{"ruleId":"3849","severity":1,"message":"3850","line":17,"column":3,"nodeType":"3867","messageId":"3852","endLine":17,"endColumn":20},{"ruleId":"3849","severity":1,"message":"3850","line":24,"column":3,"nodeType":"3867","messageId":"3852","endLine":24,"endColumn":25},{"ruleId":"3849","severity":1,"message":"3850","line":30,"column":3,"nodeType":"3867","messageId":"3852","endLine":30,"endColumn":23},{"ruleId":"3845","severity":1,"message":"3872","line":49,"column":7,"nodeType":"3863","messageId":"3848","endLine":49,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":64,"column":3,"nodeType":"3867","messageId":"3852","endLine":64,"endColumn":26},{"ruleId":"3849","severity":1,"message":"3850","line":11,"column":3,"nodeType":"3867","messageId":"3852","endLine":11,"endColumn":36},{"ruleId":"3849","severity":1,"message":"3850","line":15,"column":3,"nodeType":"3867","messageId":"3852","endLine":15,"endColumn":61},{"ruleId":"3873","severity":1,"message":"3874","line":53,"column":9,"nodeType":"3854","endLine":53,"endColumn":15},{"ruleId":"3875","severity":1,"message":"3876","line":67,"column":52,"nodeType":"3877","messageId":"3878","endLine":67,"endColumn":58},{"ruleId":"3875","severity":1,"message":"3876","line":79,"column":103,"nodeType":"3877","messageId":"3878","endLine":79,"endColumn":109},{"ruleId":"3875","severity":1,"message":"3876","line":96,"column":52,"nodeType":"3877","messageId":"3878","endLine":96,"endColumn":58},{"ruleId":"3879","severity":1,"message":"3880","line":100,"column":13,"nodeType":"3881","messageId":"3882","endLine":100,"endColumn":43},{"ruleId":"3845","severity":1,"message":"3872","line":103,"column":9,"nodeType":"3863","messageId":"3848","endLine":103,"endColumn":23},{"ruleId":"3883","severity":1,"message":"3884","line":70,"column":14,"nodeType":"3885","messageId":"3886","endLine":70,"endColumn":37},{"ruleId":"3837","severity":1,"message":"3838","line":70,"column":27,"nodeType":"3839","messageId":"3840","endLine":70,"endColumn":30,"suggestions":"3887"},{"ruleId":"3879","severity":1,"message":"3880","line":71,"column":11,"nodeType":"3881","messageId":"3882","endLine":71,"endColumn":51},{"ruleId":"3883","severity":1,"message":"3884","line":71,"column":26,"nodeType":"3885","messageId":"3886","endLine":71,"endColumn":49},{"ruleId":"3888","severity":1,"message":"3889","line":71,"column":26,"nodeType":"3885","messageId":"3890","endLine":71,"endColumn":49},{"ruleId":"3837","severity":1,"message":"3838","line":71,"column":39,"nodeType":"3839","messageId":"3840","endLine":71,"endColumn":42,"suggestions":"3891"},{"ruleId":"3845","severity":1,"message":"3872","line":73,"column":5,"nodeType":"3863","messageId":"3848","endLine":73,"endColumn":25},{"ruleId":"3883","severity":1,"message":"3892","line":37,"column":10,"nodeType":"3885","messageId":"3886","endLine":37,"endColumn":25},{"ruleId":"3888","severity":1,"message":"3889","line":37,"column":10,"nodeType":"3885","messageId":"3890","endLine":37,"endColumn":25},{"ruleId":"3875","severity":1,"message":"3876","line":89,"column":44,"nodeType":"3877","messageId":"3878","endLine":89,"endColumn":50},{"ruleId":"3868","severity":1,"message":"3869","line":96,"column":36,"nodeType":"3870","messageId":"3871","endLine":96,"endColumn":40},{"ruleId":"3845","severity":1,"message":"3872","line":108,"column":7,"nodeType":"3863","messageId":"3848","endLine":108,"endColumn":18},{"ruleId":"3883","severity":1,"message":"3893","line":125,"column":14,"nodeType":"3885","messageId":"3886","endLine":125,"endColumn":53},{"ruleId":"3837","severity":1,"message":"3838","line":125,"column":38,"nodeType":"3839","messageId":"3840","endLine":125,"endColumn":41,"suggestions":"3894"},{"ruleId":"3849","severity":1,"message":"3850","line":205,"column":3,"nodeType":"3867","messageId":"3852","endLine":205,"endColumn":53},{"ruleId":"3883","severity":1,"message":"3892","line":222,"column":12,"nodeType":"3885","messageId":"3886","endLine":222,"endColumn":27},{"ruleId":"3888","severity":1,"message":"3889","line":222,"column":12,"nodeType":"3885","messageId":"3890","endLine":222,"endColumn":27},{"ruleId":"3883","severity":1,"message":"3892","line":226,"column":17,"nodeType":"3885","messageId":"3886","endLine":226,"endColumn":32},{"ruleId":"3888","severity":1,"message":"3889","line":226,"column":17,"nodeType":"3885","messageId":"3890","endLine":226,"endColumn":32},{"ruleId":"3875","severity":1,"message":"3876","line":37,"column":33,"nodeType":"3877","messageId":"3878","endLine":37,"endColumn":39},{"ruleId":"3875","severity":1,"message":"3876","line":43,"column":19,"nodeType":"3877","messageId":"3878","endLine":43,"endColumn":25},{"ruleId":"3875","severity":1,"message":"3876","line":54,"column":47,"nodeType":"3877","messageId":"3878","endLine":54,"endColumn":53},{"ruleId":"3875","severity":1,"message":"3876","line":5,"column":42,"nodeType":"3877","messageId":"3878","endLine":5,"endColumn":48},{"ruleId":"3875","severity":1,"message":"3876","line":33,"column":47,"nodeType":"3877","messageId":"3878","endLine":33,"endColumn":53},{"ruleId":"3873","severity":1,"message":"3895","line":38,"column":7,"nodeType":"3854","endLine":38,"endColumn":17},{"ruleId":"3849","severity":1,"message":"3850","line":59,"column":3,"nodeType":"3867","messageId":"3852","endLine":59,"endColumn":23},{"ruleId":"3849","severity":1,"message":"3850","line":65,"column":3,"nodeType":"3867","messageId":"3852","endLine":65,"endColumn":20},{"ruleId":"3849","severity":1,"message":"3850","line":18,"column":28,"nodeType":"3851","messageId":"3852","endLine":18,"endColumn":65},{"ruleId":"3849","severity":1,"message":"3850","line":33,"column":3,"nodeType":"3867","messageId":"3852","endLine":33,"endColumn":37},{"ruleId":"3849","severity":1,"message":"3850","line":40,"column":3,"nodeType":"3867","messageId":"3852","endLine":40,"endColumn":17},{"ruleId":"3849","severity":1,"message":"3850","line":58,"column":3,"nodeType":"3867","messageId":"3852","endLine":58,"endColumn":87},{"ruleId":"3849","severity":1,"message":"3850","line":77,"column":20,"nodeType":"3851","messageId":"3852","endLine":77,"endColumn":25},{"ruleId":"3849","severity":1,"message":"3850","line":81,"column":3,"nodeType":"3867","messageId":"3852","endLine":81,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":85,"column":3,"nodeType":"3867","messageId":"3852","endLine":85,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":92,"column":3,"nodeType":"3867","messageId":"3852","endLine":92,"endColumn":10},{"ruleId":"3849","severity":1,"message":"3850","line":97,"column":3,"nodeType":"3867","messageId":"3852","endLine":97,"endColumn":9},{"ruleId":"3849","severity":1,"message":"3850","line":75,"column":3,"nodeType":"3867","messageId":"3852","endLine":75,"endColumn":67},{"ruleId":"3849","severity":1,"message":"3850","line":86,"column":3,"nodeType":"3867","messageId":"3852","endLine":86,"endColumn":68},{"ruleId":"3849","severity":1,"message":"3850","line":116,"column":3,"nodeType":"3867","messageId":"3852","endLine":116,"endColumn":48},{"ruleId":"3849","severity":1,"message":"3850","line":8,"column":31,"nodeType":"3851","messageId":"3852","endLine":12,"endColumn":40},{"ruleId":"3875","severity":1,"message":"3876","line":8,"column":48,"nodeType":"3877","messageId":"3878","endLine":8,"endColumn":54},{"ruleId":"3875","severity":1,"message":"3876","line":3,"column":53,"nodeType":"3877","messageId":"3878","endLine":3,"endColumn":59},{"ruleId":"3896","severity":1,"message":"3897","line":65,"column":3,"nodeType":"3898","endLine":65,"endColumn":19},{"ruleId":"3899","severity":1,"message":"3900","line":65,"column":17,"nodeType":"3867","messageId":"3901"},{"ruleId":"3873","severity":1,"message":"3902","line":3,"column":3,"nodeType":"3854","endLine":3,"endColumn":41},{"ruleId":"3873","severity":1,"message":"3903","line":1,"column":10,"nodeType":"3854","endLine":1,"endColumn":39},{"ruleId":"3849","severity":1,"message":"3904","line":13,"column":3,"nodeType":"3854","messageId":"3855","endLine":13,"endColumn":9},{"ruleId":"3879","severity":1,"message":"3880","line":16,"column":11,"nodeType":"3881","messageId":"3882","endLine":20,"endColumn":10},{"ruleId":"3849","severity":1,"message":"3904","line":13,"column":3,"nodeType":"3854","messageId":"3855","endLine":13,"endColumn":9},{"ruleId":"3879","severity":1,"message":"3880","line":16,"column":11,"nodeType":"3881","messageId":"3882","endLine":20,"endColumn":10},{"ruleId":"3837","severity":1,"message":"3838","line":2,"column":7,"nodeType":"3839","messageId":"3840","endLine":2,"endColumn":10,"suggestions":"3905"},{"ruleId":"3849","severity":1,"message":"3906","line":12,"column":52,"nodeType":"3854","messageId":"3855","endLine":12,"endColumn":64},{"ruleId":"3837","severity":1,"message":"3838","line":12,"column":61,"nodeType":"3839","messageId":"3840","endLine":12,"endColumn":64,"suggestions":"3907"},{"ruleId":"3849","severity":1,"message":"3908","line":39,"column":3,"nodeType":"3854","messageId":"3855","endLine":39,"endColumn":31},{"ruleId":"3837","severity":1,"message":"3838","line":39,"column":28,"nodeType":"3839","messageId":"3840","endLine":39,"endColumn":31,"suggestions":"3909"},{"ruleId":"3849","severity":1,"message":"3910","line":56,"column":49,"nodeType":"3854","messageId":"3855","endLine":56,"endColumn":77},{"ruleId":"3837","severity":1,"message":"3838","line":56,"column":74,"nodeType":"3839","messageId":"3840","endLine":56,"endColumn":77,"suggestions":"3911"},{"ruleId":"3879","severity":1,"message":"3880","line":58,"column":11,"nodeType":"3881","messageId":"3882","endLine":58,"endColumn":86},{"ruleId":"3879","severity":1,"message":"3880","line":38,"column":13,"nodeType":"3881","messageId":"3882","endLine":38,"endColumn":107},{"ruleId":"3883","severity":1,"message":"3912","line":38,"column":27,"nodeType":"3885","messageId":"3886","endLine":38,"endColumn":107},{"ruleId":"3837","severity":1,"message":"3838","line":38,"column":58,"nodeType":"3839","messageId":"3840","endLine":38,"endColumn":61,"suggestions":"3913"},{"ruleId":"3849","severity":1,"message":"3850","line":192,"column":3,"nodeType":"3867","messageId":"3852","endLine":192,"endColumn":106},{"ruleId":"3849","severity":1,"message":"3850","line":109,"column":3,"nodeType":"3867","messageId":"3852","endLine":109,"endColumn":34},{"ruleId":"3849","severity":1,"message":"3850","line":370,"column":3,"nodeType":"3867","messageId":"3852","endLine":370,"endColumn":27},{"ruleId":"3849","severity":1,"message":"3850","line":375,"column":3,"nodeType":"3867","messageId":"3852","endLine":375,"endColumn":27},{"ruleId":"3849","severity":1,"message":"3850","line":379,"column":3,"nodeType":"3867","messageId":"3852","endLine":379,"endColumn":29},{"ruleId":"3849","severity":1,"message":"3850","line":445,"column":3,"nodeType":"3867","messageId":"3852","endLine":445,"endColumn":32},{"ruleId":"3849","severity":1,"message":"3850","line":507,"column":3,"nodeType":"3867","messageId":"3852","endLine":507,"endColumn":95},{"ruleId":"3849","severity":1,"message":"3850","line":513,"column":3,"nodeType":"3867","messageId":"3852","endLine":513,"endColumn":36},{"ruleId":"3849","severity":1,"message":"3850","line":518,"column":3,"nodeType":"3867","messageId":"3852","endLine":518,"endColumn":85},{"ruleId":"3849","severity":1,"message":"3850","line":522,"column":3,"nodeType":"3867","messageId":"3852","endLine":522,"endColumn":49},{"ruleId":"3849","severity":1,"message":"3850","line":596,"column":3,"nodeType":"3867","messageId":"3852","endLine":596,"endColumn":116},{"ruleId":"3849","severity":1,"message":"3850","line":600,"column":3,"nodeType":"3867","messageId":"3852","endLine":600,"endColumn":61},{"ruleId":"3849","severity":1,"message":"3850","line":634,"column":3,"nodeType":"3867","messageId":"3852","endLine":634,"endColumn":44},{"ruleId":"3849","severity":1,"message":"3850","line":792,"column":3,"nodeType":"3867","messageId":"3852","endLine":792,"endColumn":92},{"ruleId":"3849","severity":1,"message":"3850","line":796,"column":3,"nodeType":"3867","messageId":"3852","endLine":796,"endColumn":55},{"ruleId":"3914","severity":1,"message":"3915","line":176,"column":3,"nodeType":"3867","messageId":"3916","endLine":176,"endColumn":23},{"ruleId":"3914","severity":1,"message":"3917","line":194,"column":106,"nodeType":"3851","messageId":"3916","endLine":194,"endColumn":108},{"ruleId":"3849","severity":1,"message":"3850","line":295,"column":3,"nodeType":"3867","messageId":"3852","endLine":295,"endColumn":70},{"ruleId":"3849","severity":1,"message":"3850","line":299,"column":3,"nodeType":"3867","messageId":"3852","endLine":299,"endColumn":55},{"ruleId":"3849","severity":1,"message":"3850","line":339,"column":3,"nodeType":"3867","messageId":"3852","endLine":339,"endColumn":129},{"ruleId":"3849","severity":1,"message":"3850","line":381,"column":3,"nodeType":"3867","messageId":"3852","endLine":381,"endColumn":33},{"ruleId":"3849","severity":1,"message":"3850","line":444,"column":3,"nodeType":"3867","messageId":"3852","endLine":444,"endColumn":42},{"ruleId":"3914","severity":1,"message":"3918","line":454,"column":3,"nodeType":"3867","messageId":"3916","endLine":454,"endColumn":37},{"ruleId":"3875","severity":1,"message":"3876","line":867,"column":86,"nodeType":"3877","messageId":"3878","endLine":867,"endColumn":92},{"ruleId":"3845","severity":1,"message":"3872","line":873,"column":7,"nodeType":"3863","messageId":"3848","endLine":873,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":894,"column":7,"nodeType":"3863","messageId":"3848","endLine":894,"endColumn":18},{"ruleId":"3879","severity":1,"message":"3880","line":902,"column":13,"nodeType":"3881","messageId":"3882","endLine":902,"endColumn":104},{"ruleId":"3845","severity":1,"message":"3872","line":906,"column":9,"nodeType":"3863","messageId":"3848","endLine":906,"endColumn":28},{"ruleId":"3845","severity":1,"message":"3872","line":909,"column":7,"nodeType":"3863","messageId":"3848","endLine":909,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":934,"column":9,"nodeType":"3863","messageId":"3848","endLine":934,"endColumn":20},{"ruleId":"3849","severity":1,"message":"3850","line":973,"column":3,"nodeType":"3867","messageId":"3852","endLine":973,"endColumn":47},{"ruleId":"3845","severity":1,"message":"3872","line":990,"column":7,"nodeType":"3863","messageId":"3848","endLine":990,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3919","line":996,"column":7,"nodeType":"3863","messageId":"3864","endLine":996,"endColumn":48},{"ruleId":"3849","severity":1,"message":"3850","line":53,"column":3,"nodeType":"3867","messageId":"3852","endLine":53,"endColumn":31},{"ruleId":"3868","severity":1,"message":"3869","line":179,"column":14,"nodeType":"3870","messageId":"3871","endLine":179,"endColumn":47,"suggestions":"3920"},{"ruleId":"3868","severity":1,"message":"3869","line":205,"column":26,"nodeType":"3870","messageId":"3871","endLine":205,"endColumn":75},{"ruleId":"3849","severity":1,"message":"3850","line":331,"column":3,"nodeType":"3867","messageId":"3852","endLine":331,"endColumn":28},{"ruleId":"3883","severity":1,"message":"3921","line":336,"column":9,"nodeType":"3885","messageId":"3886","endLine":336,"endColumn":32},{"ruleId":"3837","severity":1,"message":"3838","line":336,"column":17,"nodeType":"3839","messageId":"3840","endLine":336,"endColumn":20,"suggestions":"3922"},{"ruleId":"3849","severity":1,"message":"3850","line":405,"column":3,"nodeType":"3867","messageId":"3852","endLine":405,"endColumn":32},{"ruleId":"3849","severity":1,"message":"3850","line":416,"column":3,"nodeType":"3867","messageId":"3852","endLine":416,"endColumn":34},{"ruleId":"3849","severity":1,"message":"3850","line":420,"column":3,"nodeType":"3867","messageId":"3852","endLine":420,"endColumn":106},{"ruleId":"3849","severity":1,"message":"3850","line":424,"column":3,"nodeType":"3867","messageId":"3852","endLine":424,"endColumn":63},{"ruleId":"3849","severity":1,"message":"3850","line":455,"column":3,"nodeType":"3867","messageId":"3852","endLine":455,"endColumn":40},{"ruleId":"3868","severity":1,"message":"3869","line":46,"column":14,"nodeType":"3870","messageId":"3871","endLine":46,"endColumn":18,"suggestions":"3923"},{"ruleId":"3849","severity":1,"message":"3850","line":129,"column":3,"nodeType":"3867","messageId":"3852","endLine":129,"endColumn":73},{"ruleId":"3849","severity":1,"message":"3924","line":150,"column":5,"nodeType":"3854","messageId":"3855","endLine":150,"endColumn":32},{"ruleId":"3837","severity":1,"message":"3838","line":150,"column":29,"nodeType":"3839","messageId":"3840","endLine":150,"endColumn":32,"suggestions":"3925"},{"ruleId":"3879","severity":1,"message":"3880","line":157,"column":13,"nodeType":"3881","messageId":"3882","endLine":160,"endColumn":33},{"ruleId":"3849","severity":1,"message":"3924","line":176,"column":5,"nodeType":"3854","messageId":"3855","endLine":176,"endColumn":32},{"ruleId":"3837","severity":1,"message":"3838","line":176,"column":29,"nodeType":"3839","messageId":"3840","endLine":176,"endColumn":32,"suggestions":"3926"},{"ruleId":"3837","severity":1,"message":"3838","line":212,"column":33,"nodeType":"3839","messageId":"3840","endLine":212,"endColumn":36,"suggestions":"3927"},{"ruleId":"3879","severity":1,"message":"3880","line":240,"column":7,"nodeType":"3928","messageId":"3882","endLine":240,"endColumn":53},{"ruleId":"3879","severity":1,"message":"3880","line":283,"column":15,"nodeType":"3881","messageId":"3882","endLine":283,"endColumn":43},{"ruleId":"3849","severity":1,"message":"3850","line":20,"column":3,"nodeType":"3867","messageId":"3852","endLine":20,"endColumn":56},{"ruleId":"3849","severity":1,"message":"3850","line":24,"column":3,"nodeType":"3867","messageId":"3852","endLine":24,"endColumn":64},{"ruleId":"3849","severity":1,"message":"3929","line":37,"column":27,"nodeType":"3854","messageId":"3855","endLine":37,"endColumn":35},{"ruleId":"3837","severity":1,"message":"3838","line":37,"column":32,"nodeType":"3839","messageId":"3840","endLine":37,"endColumn":35,"suggestions":"3930"},{"ruleId":"3868","severity":1,"message":"3869","line":103,"column":13,"nodeType":"3870","messageId":"3871","endLine":103,"endColumn":22,"suggestions":"3931"},{"ruleId":"3868","severity":1,"message":"3869","line":134,"column":13,"nodeType":"3870","messageId":"3871","endLine":134,"endColumn":22,"suggestions":"3932"},{"ruleId":"3868","severity":1,"message":"3869","line":152,"column":30,"nodeType":"3870","messageId":"3871","endLine":152,"endColumn":39,"suggestions":"3933"},{"ruleId":"3849","severity":1,"message":"3934","line":7,"column":3,"nodeType":"3854","messageId":"3855","endLine":7,"endColumn":21},{"ruleId":"3837","severity":1,"message":"3838","line":7,"column":18,"nodeType":"3839","messageId":"3840","endLine":7,"endColumn":21,"suggestions":"3935"},{"ruleId":"3845","severity":1,"message":"3872","line":12,"column":3,"nodeType":"3863","messageId":"3848","endLine":12,"endColumn":53},{"ruleId":"3883","severity":1,"message":"3892","line":12,"column":10,"nodeType":"3885","messageId":"3886","endLine":12,"endColumn":25},{"ruleId":"3888","severity":1,"message":"3889","line":12,"column":10,"nodeType":"3885","messageId":"3890","endLine":12,"endColumn":25},{"ruleId":"3883","severity":1,"message":"3936","line":12,"column":26,"nodeType":"3885","messageId":"3886","endLine":12,"endColumn":51},{"ruleId":"3849","severity":1,"message":"3850","line":98,"column":3,"nodeType":"3867","messageId":"3852","endLine":98,"endColumn":62},{"ruleId":"3937","severity":1,"message":"3938","line":278,"column":21,"nodeType":"3851","messageId":"3939","endLine":285,"endColumn":16},{"ruleId":"3937","severity":1,"message":"3938","line":286,"column":22,"nodeType":"3851","messageId":"3939","endLine":289,"endColumn":16},{"ruleId":"3849","severity":1,"message":"3850","line":335,"column":29,"nodeType":"3851","messageId":"3852","endLine":335,"endColumn":40},{"ruleId":"3849","severity":1,"message":"3850","line":383,"column":3,"nodeType":"3867","messageId":"3852","endLine":383,"endColumn":30},{"ruleId":"3849","severity":1,"message":"3850","line":484,"column":3,"nodeType":"3867","messageId":"3852","endLine":488,"endColumn":4},{"ruleId":"3849","severity":1,"message":"3850","line":522,"column":3,"nodeType":"3867","messageId":"3852","endLine":522,"endColumn":111},{"ruleId":"3849","severity":1,"message":"3940","line":9,"column":54,"nodeType":"3854","messageId":"3855","endLine":9,"endColumn":73},{"ruleId":"3837","severity":1,"message":"3838","line":9,"column":70,"nodeType":"3839","messageId":"3840","endLine":9,"endColumn":73,"suggestions":"3941"},{"ruleId":"3845","severity":1,"message":"3872","line":14,"column":5,"nodeType":"3863","messageId":"3848","endLine":14,"endColumn":47},{"ruleId":"3883","severity":1,"message":"3892","line":14,"column":12,"nodeType":"3885","messageId":"3886","endLine":14,"endColumn":27},{"ruleId":"3888","severity":1,"message":"3889","line":14,"column":12,"nodeType":"3885","messageId":"3890","endLine":14,"endColumn":27},{"ruleId":"3849","severity":1,"message":"3942","line":22,"column":3,"nodeType":"3854","messageId":"3855","endLine":22,"endColumn":22},{"ruleId":"3837","severity":1,"message":"3838","line":22,"column":19,"nodeType":"3839","messageId":"3840","endLine":22,"endColumn":22,"suggestions":"3943"},{"ruleId":"3849","severity":1,"message":"3944","line":273,"column":5,"nodeType":"3854","messageId":"3855","endLine":273,"endColumn":22},{"ruleId":"3849","severity":1,"message":"3945","line":399,"column":5,"nodeType":"3854","messageId":"3855","endLine":399,"endColumn":27},{"ruleId":"3879","severity":1,"message":"3880","line":415,"column":13,"nodeType":"3881","messageId":"3882","endLine":415,"endColumn":81},{"ruleId":"3879","severity":1,"message":"3880","line":443,"column":13,"nodeType":"3881","messageId":"3882","endLine":443,"endColumn":87},{"ruleId":"3845","severity":1,"message":"3872","line":449,"column":7,"nodeType":"3863","messageId":"3848","endLine":449,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":457,"column":7,"nodeType":"3863","messageId":"3848","endLine":457,"endColumn":18},{"ruleId":"3879","severity":1,"message":"3880","line":134,"column":13,"nodeType":"3881","messageId":"3882","endLine":134,"endColumn":42},{"ruleId":"3849","severity":1,"message":"3850","line":145,"column":3,"nodeType":"3867","messageId":"3852","endLine":145,"endColumn":94},{"ruleId":"3849","severity":1,"message":"3850","line":184,"column":3,"nodeType":"3867","messageId":"3852","endLine":184,"endColumn":49},{"ruleId":"3849","severity":1,"message":"3850","line":188,"column":3,"nodeType":"3867","messageId":"3852","endLine":188,"endColumn":32},{"ruleId":"3845","severity":1,"message":"3872","line":215,"column":7,"nodeType":"3863","messageId":"3848","endLine":215,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":180,"column":3,"nodeType":"3867","messageId":"3852","endLine":180,"endColumn":29},{"ruleId":"3849","severity":1,"message":"3850","line":190,"column":3,"nodeType":"3867","messageId":"3852","endLine":190,"endColumn":31},{"ruleId":"3849","severity":1,"message":"3850","line":215,"column":3,"nodeType":"3867","messageId":"3852","endLine":215,"endColumn":35},{"ruleId":"3914","severity":1,"message":"3946","line":307,"column":3,"nodeType":"3867","messageId":"3916","endLine":307,"endColumn":53},{"ruleId":"3849","severity":1,"message":"3850","line":426,"column":3,"nodeType":"3867","messageId":"3852","endLine":426,"endColumn":117},{"ruleId":"3849","severity":1,"message":"3904","line":15,"column":55,"nodeType":"3854","messageId":"3855","endLine":15,"endColumn":61},{"ruleId":"3837","severity":1,"message":"3838","line":15,"column":58,"nodeType":"3839","messageId":"3840","endLine":15,"endColumn":61,"suggestions":"3947"},{"ruleId":"3849","severity":1,"message":"3948","line":26,"column":39,"nodeType":"3854","messageId":"3855","endLine":26,"endColumn":52},{"ruleId":"3837","severity":1,"message":"3838","line":26,"column":49,"nodeType":"3839","messageId":"3840","endLine":26,"endColumn":52,"suggestions":"3949"},{"ruleId":"3879","severity":1,"message":"3880","line":28,"column":11,"nodeType":"3881","messageId":"3882","endLine":31,"endColumn":17},{"ruleId":"3849","severity":1,"message":"3948","line":54,"column":47,"nodeType":"3854","messageId":"3855","endLine":54,"endColumn":60},{"ruleId":"3837","severity":1,"message":"3838","line":54,"column":57,"nodeType":"3839","messageId":"3840","endLine":54,"endColumn":60,"suggestions":"3950"},{"ruleId":"3879","severity":1,"message":"3880","line":56,"column":11,"nodeType":"3881","messageId":"3882","endLine":59,"endColumn":17},{"ruleId":"3849","severity":1,"message":"3951","line":75,"column":35,"nodeType":"3854","messageId":"3855","endLine":75,"endColumn":50},{"ruleId":"3837","severity":1,"message":"3838","line":75,"column":47,"nodeType":"3839","messageId":"3840","endLine":75,"endColumn":50,"suggestions":"3952"},{"ruleId":"3883","severity":1,"message":"3953","line":77,"column":22,"nodeType":"3885","messageId":"3886","endLine":77,"endColumn":80},{"ruleId":"3883","severity":1,"message":"3954","line":81,"column":22,"nodeType":"3885","messageId":"3886","endLine":81,"endColumn":74},{"ruleId":"3873","severity":1,"message":"3955","line":9,"column":29,"nodeType":"3854","endLine":9,"endColumn":49},{"ruleId":"3845","severity":1,"message":"3872","line":58,"column":5,"nodeType":"3863","messageId":"3848","endLine":58,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":98,"column":5,"nodeType":"3863","messageId":"3848","endLine":98,"endColumn":16},{"ruleId":"3883","severity":1,"message":"3956","line":114,"column":56,"nodeType":"3885","messageId":"3886","endLine":114,"endColumn":72},{"ruleId":"3888","severity":1,"message":"3889","line":114,"column":56,"nodeType":"3885","messageId":"3890","endLine":114,"endColumn":72},{"ruleId":"3879","severity":1,"message":"3880","line":46,"column":5,"nodeType":"3928","messageId":"3882","endLine":46,"endColumn":57},{"ruleId":"3845","severity":1,"message":"3872","line":48,"column":5,"nodeType":"3863","messageId":"3848","endLine":48,"endColumn":16},{"ruleId":"3879","severity":1,"message":"3880","line":54,"column":9,"nodeType":"3881","messageId":"3882","endLine":57,"endColumn":27},{"ruleId":"3879","severity":1,"message":"3880","line":84,"column":5,"nodeType":"3928","messageId":"3882","endLine":84,"endColumn":60},{"ruleId":"3845","severity":1,"message":"3872","line":86,"column":5,"nodeType":"3863","messageId":"3848","endLine":86,"endColumn":16},{"ruleId":"3879","severity":1,"message":"3880","line":89,"column":9,"nodeType":"3881","messageId":"3882","endLine":92,"endColumn":27},{"ruleId":"3849","severity":1,"message":"3957","line":177,"column":3,"nodeType":"3854","messageId":"3855","endLine":177,"endColumn":33},{"ruleId":"3837","severity":1,"message":"3838","line":177,"column":30,"nodeType":"3839","messageId":"3840","endLine":177,"endColumn":33,"suggestions":"3958"},{"ruleId":"3849","severity":1,"message":"3959","line":207,"column":3,"nodeType":"3854","messageId":"3855","endLine":207,"endColumn":31},{"ruleId":"3837","severity":1,"message":"3838","line":207,"column":28,"nodeType":"3839","messageId":"3840","endLine":207,"endColumn":31,"suggestions":"3960"},{"ruleId":"3879","severity":1,"message":"3880","line":222,"column":5,"nodeType":"3928","messageId":"3882","endLine":222,"endColumn":68},{"ruleId":"3849","severity":1,"message":"3904","line":21,"column":42,"nodeType":"3854","messageId":"3855","endLine":21,"endColumn":48},{"ruleId":"3849","severity":1,"message":"3904","line":23,"column":45,"nodeType":"3854","messageId":"3855","endLine":23,"endColumn":51},{"ruleId":"3849","severity":1,"message":"3904","line":26,"column":38,"nodeType":"3854","messageId":"3855","endLine":26,"endColumn":44},{"ruleId":"3883","severity":1,"message":"3961","line":33,"column":7,"nodeType":"3885","messageId":"3886","endLine":33,"endColumn":15},{"ruleId":"3883","severity":1,"message":"3961","line":39,"column":7,"nodeType":"3885","messageId":"3886","endLine":39,"endColumn":15},{"ruleId":"3849","severity":1,"message":"3904","line":48,"column":44,"nodeType":"3854","messageId":"3855","endLine":48,"endColumn":50},{"ruleId":"3849","severity":1,"message":"3904","line":50,"column":34,"nodeType":"3854","messageId":"3855","endLine":50,"endColumn":40},{"ruleId":"3883","severity":1,"message":"3961","line":51,"column":48,"nodeType":"3885","messageId":"3886","endLine":51,"endColumn":56},{"ruleId":"3849","severity":1,"message":"3904","line":54,"column":31,"nodeType":"3854","messageId":"3855","endLine":54,"endColumn":37},{"ruleId":"3849","severity":1,"message":"3962","line":58,"column":41,"nodeType":"3854","messageId":"3855","endLine":58,"endColumn":61},{"ruleId":"3879","severity":1,"message":"3880","line":66,"column":9,"nodeType":"3881","messageId":"3882","endLine":66,"endColumn":46},{"ruleId":"3849","severity":1,"message":"3963","line":16,"column":55,"nodeType":"3854","messageId":"3855","endLine":16,"endColumn":65},{"ruleId":"3837","severity":1,"message":"3838","line":16,"column":62,"nodeType":"3839","messageId":"3840","endLine":16,"endColumn":65,"suggestions":"3964"},{"ruleId":"3849","severity":1,"message":"3945","line":27,"column":3,"nodeType":"3854","messageId":"3855","endLine":27,"endColumn":25},{"ruleId":"3837","severity":1,"message":"3838","line":27,"column":22,"nodeType":"3839","messageId":"3840","endLine":27,"endColumn":25,"suggestions":"3965"},{"ruleId":"3879","severity":1,"message":"3880","line":34,"column":9,"nodeType":"3881","messageId":"3882","endLine":37,"endColumn":24},{"ruleId":"3849","severity":1,"message":"3945","line":65,"column":3,"nodeType":"3854","messageId":"3855","endLine":65,"endColumn":25},{"ruleId":"3837","severity":1,"message":"3838","line":65,"column":22,"nodeType":"3839","messageId":"3840","endLine":65,"endColumn":25,"suggestions":"3966"},{"ruleId":"3837","severity":1,"message":"3838","line":66,"column":38,"nodeType":"3839","messageId":"3840","endLine":66,"endColumn":41,"suggestions":"3967"},{"ruleId":"3879","severity":1,"message":"3880","line":72,"column":9,"nodeType":"3881","messageId":"3882","endLine":75,"endColumn":24},{"ruleId":"3849","severity":1,"message":"3945","line":106,"column":3,"nodeType":"3854","messageId":"3855","endLine":106,"endColumn":25},{"ruleId":"3837","severity":1,"message":"3838","line":106,"column":22,"nodeType":"3839","messageId":"3840","endLine":106,"endColumn":25,"suggestions":"3968"},{"ruleId":"3849","severity":1,"message":"3969","line":114,"column":63,"nodeType":"3854","messageId":"3855","endLine":114,"endColumn":101},{"ruleId":"3837","severity":1,"message":"3838","line":114,"column":98,"nodeType":"3839","messageId":"3840","endLine":114,"endColumn":101,"suggestions":"3970"},{"ruleId":"3849","severity":1,"message":"3971","line":5,"column":41,"nodeType":"3854","messageId":"3855","endLine":5,"endColumn":57},{"ruleId":"3837","severity":1,"message":"3838","line":5,"column":54,"nodeType":"3839","messageId":"3840","endLine":5,"endColumn":57,"suggestions":"3972"},{"ruleId":"3849","severity":1,"message":"3850","line":189,"column":3,"nodeType":"3867","messageId":"3852","endLine":189,"endColumn":29},{"ruleId":"3849","severity":1,"message":"3850","line":257,"column":3,"nodeType":"3867","messageId":"3852","endLine":257,"endColumn":90},{"ruleId":"3849","severity":1,"message":"3850","line":328,"column":3,"nodeType":"3867","messageId":"3852","endLine":328,"endColumn":42},{"ruleId":"3849","severity":1,"message":"3850","line":356,"column":3,"nodeType":"3867","messageId":"3852","endLine":356,"endColumn":90},{"ruleId":"3849","severity":1,"message":"3850","line":644,"column":3,"nodeType":"3867","messageId":"3852","endLine":644,"endColumn":112},{"ruleId":"3849","severity":1,"message":"3850","line":654,"column":3,"nodeType":"3867","messageId":"3852","endLine":654,"endColumn":95},{"ruleId":"3837","severity":1,"message":"3838","line":737,"column":7,"nodeType":"3839","messageId":"3840","endLine":737,"endColumn":10,"suggestions":"3973"},{"ruleId":"3849","severity":1,"message":"3850","line":920,"column":3,"nodeType":"3867","messageId":"3852","endLine":920,"endColumn":86},{"ruleId":"3849","severity":1,"message":"3850","line":1037,"column":3,"nodeType":"3867","messageId":"3852","endLine":1037,"endColumn":48},{"ruleId":"3849","severity":1,"message":"3850","line":1067,"column":3,"nodeType":"3867","messageId":"3852","endLine":1067,"endColumn":75},{"ruleId":"3914","severity":1,"message":"3974","line":1239,"column":3,"nodeType":"3867","messageId":"3916","endLine":1239,"endColumn":42},{"ruleId":"3849","severity":1,"message":"3850","line":1274,"column":3,"nodeType":"3867","messageId":"3852","endLine":1274,"endColumn":58},{"ruleId":"3914","severity":1,"message":"3975","line":1274,"column":3,"nodeType":"3867","messageId":"3916","endLine":1274,"endColumn":56},{"ruleId":"3849","severity":1,"message":"3850","line":1284,"column":3,"nodeType":"3867","messageId":"3852","endLine":1284,"endColumn":55},{"ruleId":"3914","severity":1,"message":"3976","line":1284,"column":3,"nodeType":"3867","messageId":"3916","endLine":1284,"endColumn":53},{"ruleId":"3849","severity":1,"message":"3850","line":1323,"column":3,"nodeType":"3867","messageId":"3852","endLine":1323,"endColumn":60},{"ruleId":"3849","severity":1,"message":"3850","line":1423,"column":3,"nodeType":"3867","messageId":"3852","endLine":1423,"endColumn":63},{"ruleId":"3875","severity":1,"message":"3977","line":35,"column":113,"nodeType":"3978","messageId":"3878","endLine":35,"endColumn":115},{"ruleId":"3979","severity":1,"message":"3980","line":341,"column":18,"nodeType":"3854","messageId":"3981","endLine":341,"endColumn":49,"fix":"3982"},{"ruleId":"3979","severity":1,"message":"3980","line":388,"column":18,"nodeType":"3854","messageId":"3981","endLine":388,"endColumn":56,"fix":"3983"},{"ruleId":"3979","severity":1,"message":"3980","line":397,"column":18,"nodeType":"3854","messageId":"3981","endLine":397,"endColumn":42,"fix":"3984"},{"ruleId":"3837","severity":1,"message":"3838","line":406,"column":48,"nodeType":"3839","messageId":"3840","endLine":406,"endColumn":51,"suggestions":"3985"},{"ruleId":"3837","severity":1,"message":"3838","line":406,"column":53,"nodeType":"3839","messageId":"3840","endLine":406,"endColumn":56,"suggestions":"3986"},{"ruleId":"3837","severity":1,"message":"3838","line":406,"column":58,"nodeType":"3839","messageId":"3840","endLine":406,"endColumn":61,"suggestions":"3987"},{"ruleId":"3837","severity":1,"message":"3838","line":406,"column":63,"nodeType":"3839","messageId":"3840","endLine":406,"endColumn":66,"suggestions":"3988"},{"ruleId":"3837","severity":1,"message":"3838","line":406,"column":68,"nodeType":"3839","messageId":"3840","endLine":406,"endColumn":71,"suggestions":"3989"},{"ruleId":"3837","severity":1,"message":"3838","line":406,"column":73,"nodeType":"3839","messageId":"3840","endLine":406,"endColumn":76,"suggestions":"3990"},{"ruleId":"3837","severity":1,"message":"3838","line":406,"column":93,"nodeType":"3839","messageId":"3840","endLine":406,"endColumn":96,"suggestions":"3991"},{"ruleId":"3837","severity":1,"message":"3838","line":406,"column":98,"nodeType":"3839","messageId":"3840","endLine":406,"endColumn":101,"suggestions":"3992"},{"ruleId":"3837","severity":1,"message":"3838","line":406,"column":107,"nodeType":"3839","messageId":"3840","endLine":406,"endColumn":110,"suggestions":"3993"},{"ruleId":"3849","severity":1,"message":"3850","line":21,"column":3,"nodeType":"3867","messageId":"3852","endLine":21,"endColumn":22},{"ruleId":"3849","severity":1,"message":"3850","line":29,"column":3,"nodeType":"3867","messageId":"3852","endLine":29,"endColumn":36},{"ruleId":"3914","severity":1,"message":"3915","line":29,"column":3,"nodeType":"3867","messageId":"3916","endLine":29,"endColumn":23},{"ruleId":"3875","severity":1,"message":"3977","line":29,"column":33,"nodeType":"3978","messageId":"3878","endLine":29,"endColumn":35},{"ruleId":"3849","severity":1,"message":"3850","line":33,"column":3,"nodeType":"3867","messageId":"3852","endLine":33,"endColumn":23},{"ruleId":"3899","severity":1,"message":"3994","line":33,"column":24,"nodeType":"3867","messageId":"3901"},{"ruleId":"3875","severity":1,"message":"3977","line":35,"column":75,"nodeType":"3978","messageId":"3878","endLine":35,"endColumn":77},{"ruleId":"3914","severity":1,"message":"3917","line":35,"column":113,"nodeType":"3851","messageId":"3916","endLine":35,"endColumn":115},{"ruleId":"3849","severity":1,"message":"3850","line":55,"column":21,"nodeType":"3851","messageId":"3852","endLine":55,"endColumn":116},{"ruleId":"3914","severity":1,"message":"3917","line":55,"column":114,"nodeType":"3851","messageId":"3916","endLine":55,"endColumn":116},{"ruleId":"3979","severity":1,"message":"3995","line":3,"column":18,"nodeType":"3854","messageId":"3996","endLine":3,"endColumn":54},{"ruleId":"3979","severity":1,"message":"3980","line":5,"column":18,"nodeType":"3854","messageId":"3981","endLine":5,"endColumn":61,"fix":"3997"},{"ruleId":"3979","severity":1,"message":"3995","line":7,"column":18,"nodeType":"3854","messageId":"3996","endLine":7,"endColumn":61},{"ruleId":"3979","severity":1,"message":"3995","line":9,"column":18,"nodeType":"3854","messageId":"3996","endLine":9,"endColumn":66},{"ruleId":"3849","severity":1,"message":"3850","line":32,"column":3,"nodeType":"3867","messageId":"3852","endLine":32,"endColumn":22},{"ruleId":"3849","severity":1,"message":"3850","line":62,"column":3,"nodeType":"3867","messageId":"3852","endLine":62,"endColumn":70},{"ruleId":"3849","severity":1,"message":"3850","line":73,"column":3,"nodeType":"3867","messageId":"3852","endLine":73,"endColumn":23},{"ruleId":"3914","severity":1,"message":"3998","line":73,"column":3,"nodeType":"3867","messageId":"3916","endLine":73,"endColumn":21},{"ruleId":"3875","severity":1,"message":"3999","line":89,"column":30,"nodeType":"3854","messageId":"3878","endLine":89,"endColumn":38},{"ruleId":"3868","severity":1,"message":"3869","line":99,"column":36,"nodeType":"3870","messageId":"3871","endLine":99,"endColumn":45},{"ruleId":"3868","severity":1,"message":"3869","line":138,"column":33,"nodeType":"3870","messageId":"3871","endLine":138,"endColumn":38,"suggestions":"4000"},{"ruleId":"3849","severity":1,"message":"3850","line":176,"column":21,"nodeType":"3851","messageId":"3852","endLine":176,"endColumn":121},{"ruleId":"3849","severity":1,"message":"3850","line":182,"column":3,"nodeType":"3867","messageId":"3852","endLine":182,"endColumn":70},{"ruleId":"3849","severity":1,"message":"3850","line":202,"column":3,"nodeType":"3867","messageId":"3852","endLine":202,"endColumn":62},{"ruleId":"3873","severity":1,"message":"4001","line":203,"column":12,"nodeType":"3854","endLine":203,"endColumn":19},{"ruleId":"3873","severity":1,"message":"4002","line":203,"column":21,"nodeType":"3854","endLine":203,"endColumn":27},{"ruleId":"3979","severity":1,"message":"3995","line":50,"column":18,"nodeType":"3854","messageId":"3996","endLine":50,"endColumn":61},{"ruleId":"3979","severity":1,"message":"3980","line":52,"column":18,"nodeType":"3854","messageId":"3981","endLine":52,"endColumn":66,"fix":"4003"},{"ruleId":"3873","severity":1,"message":"4004","line":1,"column":10,"nodeType":"3854","endLine":1,"endColumn":29},{"ruleId":"3837","severity":1,"message":"3838","line":47,"column":17,"nodeType":"3839","messageId":"3840","endLine":47,"endColumn":20,"suggestions":"4005"},{"ruleId":"3849","severity":1,"message":"3850","line":15,"column":20,"nodeType":"3851","messageId":"3852","endLine":15,"endColumn":85},{"ruleId":"3849","severity":1,"message":"3850","line":19,"column":18,"nodeType":"3851","messageId":"3852","endLine":19,"endColumn":61},{"ruleId":"3914","severity":1,"message":"3917","line":19,"column":59,"nodeType":"3851","messageId":"3916","endLine":19,"endColumn":61},{"ruleId":"3849","severity":1,"message":"3850","line":28,"column":16,"nodeType":"3851","messageId":"3852","endLine":33,"endColumn":7},{"ruleId":"3849","severity":1,"message":"3850","line":42,"column":16,"nodeType":"3851","messageId":"3852","endLine":42,"endColumn":101},{"ruleId":"3849","severity":1,"message":"3850","line":52,"column":3,"nodeType":"3867","messageId":"3852","endLine":52,"endColumn":105},{"ruleId":"3849","severity":1,"message":"3850","line":76,"column":3,"nodeType":"3867","messageId":"3852","endLine":76,"endColumn":69},{"ruleId":"3849","severity":1,"message":"3850","line":80,"column":3,"nodeType":"3867","messageId":"3852","endLine":80,"endColumn":45},{"ruleId":"3849","severity":1,"message":"3850","line":84,"column":3,"nodeType":"3867","messageId":"3852","endLine":84,"endColumn":71},{"ruleId":"3849","severity":1,"message":"3850","line":88,"column":3,"nodeType":"3867","messageId":"3852","endLine":88,"endColumn":73},{"ruleId":"3849","severity":1,"message":"3850","line":93,"column":3,"nodeType":"3867","messageId":"3852","endLine":93,"endColumn":64},{"ruleId":"3849","severity":1,"message":"3850","line":101,"column":3,"nodeType":"3867","messageId":"3852","endLine":101,"endColumn":81},{"ruleId":"3849","severity":1,"message":"3850","line":106,"column":3,"nodeType":"3867","messageId":"3852","endLine":106,"endColumn":59},{"ruleId":"3879","severity":1,"message":"3880","line":121,"column":11,"nodeType":"3881","messageId":"3882","endLine":121,"endColumn":89},{"ruleId":"3879","severity":1,"message":"3880","line":122,"column":11,"nodeType":"3881","messageId":"3882","endLine":122,"endColumn":75},{"ruleId":"3888","severity":1,"message":"4006","line":122,"column":21,"nodeType":"4007","messageId":"4008","endLine":122,"endColumn":75},{"ruleId":"3883","severity":1,"message":"4009","line":122,"column":26,"nodeType":"3885","messageId":"3886","endLine":122,"endColumn":51},{"ruleId":"3883","severity":1,"message":"4010","line":124,"column":11,"nodeType":"3885","messageId":"3886","endLine":124,"endColumn":26},{"ruleId":"3888","severity":1,"message":"3889","line":124,"column":11,"nodeType":"3885","messageId":"3890","endLine":124,"endColumn":26},{"ruleId":"3883","severity":1,"message":"4011","line":126,"column":12,"nodeType":"3885","messageId":"3886","endLine":126,"endColumn":30},{"ruleId":"3837","severity":1,"message":"3838","line":40,"column":36,"nodeType":"3839","messageId":"3840","endLine":40,"endColumn":39,"suggestions":"4012"},{"ruleId":"3849","severity":1,"message":"3850","line":19,"column":3,"nodeType":"3867","messageId":"3852","endLine":19,"endColumn":33},{"ruleId":"3883","severity":1,"message":"4013","line":24,"column":9,"nodeType":"3885","messageId":"3886","endLine":24,"endColumn":50},{"ruleId":"3849","severity":1,"message":"3850","line":28,"column":3,"nodeType":"3867","messageId":"3852","endLine":28,"endColumn":36},{"ruleId":"3883","severity":1,"message":"4013","line":33,"column":9,"nodeType":"3885","messageId":"3886","endLine":33,"endColumn":50},{"ruleId":"3845","severity":1,"message":"3872","line":54,"column":7,"nodeType":"3863","messageId":"3848","endLine":54,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":156,"column":3,"nodeType":"3867","messageId":"3852","endLine":156,"endColumn":58},{"ruleId":"3849","severity":1,"message":"3850","line":160,"column":3,"nodeType":"3867","messageId":"3852","endLine":160,"endColumn":27},{"ruleId":"3849","severity":1,"message":"3850","line":164,"column":3,"nodeType":"3867","messageId":"3852","endLine":164,"endColumn":85},{"ruleId":"3849","severity":1,"message":"3850","line":168,"column":3,"nodeType":"3867","messageId":"3852","endLine":168,"endColumn":45},{"ruleId":"3849","severity":1,"message":"3850","line":96,"column":3,"nodeType":"3867","messageId":"3852","endLine":96,"endColumn":17},{"ruleId":"3849","severity":1,"message":"3850","line":106,"column":3,"nodeType":"3867","messageId":"3852","endLine":106,"endColumn":16},{"ruleId":"3849","severity":1,"message":"3850","line":117,"column":19,"nodeType":"3851","messageId":"3852","endLine":117,"endColumn":47},{"ruleId":"3849","severity":1,"message":"4014","line":136,"column":32,"nodeType":"3854","messageId":"3855","endLine":136,"endColumn":44},{"ruleId":"3837","severity":1,"message":"3838","line":136,"column":41,"nodeType":"3839","messageId":"3840","endLine":136,"endColumn":44,"suggestions":"4015"},{"ruleId":"3883","severity":1,"message":"4016","line":137,"column":63,"nodeType":"3885","messageId":"3886","endLine":137,"endColumn":77},{"ruleId":"3883","severity":1,"message":"4016","line":137,"column":96,"nodeType":"3885","messageId":"3886","endLine":137,"endColumn":110},{"ruleId":"3849","severity":1,"message":"3850","line":150,"column":3,"nodeType":"3867","messageId":"3852","endLine":150,"endColumn":56},{"ruleId":"3868","severity":1,"message":"3869","line":174,"column":31,"nodeType":"3870","messageId":"3871","endLine":174,"endColumn":43,"suggestions":"4017"},{"ruleId":"3868","severity":1,"message":"3869","line":199,"column":35,"nodeType":"3870","messageId":"3871","endLine":199,"endColumn":56},{"ruleId":"3868","severity":1,"message":"3869","line":212,"column":34,"nodeType":"3870","messageId":"3871","endLine":212,"endColumn":46,"suggestions":"4018"},{"ruleId":"3849","severity":1,"message":"3850","line":230,"column":3,"nodeType":"3867","messageId":"3852","endLine":230,"endColumn":44},{"ruleId":"3849","severity":1,"message":"3850","line":243,"column":3,"nodeType":"3867","messageId":"3852","endLine":243,"endColumn":39},{"ruleId":"3849","severity":1,"message":"3850","line":301,"column":3,"nodeType":"3867","messageId":"3852","endLine":301,"endColumn":27},{"ruleId":"3849","severity":1,"message":"3850","line":314,"column":3,"nodeType":"3867","messageId":"3852","endLine":314,"endColumn":40},{"ruleId":"3879","severity":1,"message":"3880","line":345,"column":13,"nodeType":"3881","messageId":"3882","endLine":345,"endColumn":54},{"ruleId":"3883","severity":1,"message":"4019","line":345,"column":26,"nodeType":"3885","messageId":"3886","endLine":345,"endColumn":54},{"ruleId":"3837","severity":1,"message":"3838","line":345,"column":39,"nodeType":"3839","messageId":"3840","endLine":345,"endColumn":42,"suggestions":"4020"},{"ruleId":"3845","severity":1,"message":"3872","line":358,"column":9,"nodeType":"3863","messageId":"3848","endLine":358,"endColumn":20},{"ruleId":"3849","severity":1,"message":"3850","line":392,"column":3,"nodeType":"3867","messageId":"3852","endLine":392,"endColumn":74},{"ruleId":"3914","severity":1,"message":"3917","line":439,"column":126,"nodeType":"3851","messageId":"3916","endLine":439,"endColumn":128},{"ruleId":"3879","severity":1,"message":"4021","line":440,"column":13,"nodeType":"3854","messageId":"4022","endLine":440,"endColumn":24},{"ruleId":"3868","severity":1,"message":"3869","line":470,"column":10,"nodeType":"3870","messageId":"3871","endLine":470,"endColumn":38},{"ruleId":"3845","severity":1,"message":"3872","line":482,"column":7,"nodeType":"3863","messageId":"3848","endLine":482,"endColumn":18},{"ruleId":"3837","severity":1,"message":"3838","line":3,"column":42,"nodeType":"3839","messageId":"3840","endLine":3,"endColumn":45,"suggestions":"4023"},{"ruleId":"3837","severity":1,"message":"3838","line":34,"column":71,"nodeType":"3839","messageId":"3840","endLine":34,"endColumn":74,"suggestions":"4024"},{"ruleId":"3849","severity":1,"message":"3850","line":3,"column":36,"nodeType":"3851","messageId":"3852","endLine":3,"endColumn":41},{"ruleId":"3849","severity":1,"message":"3850","line":35,"column":3,"nodeType":"3867","messageId":"3852","endLine":35,"endColumn":50},{"ruleId":"3849","severity":1,"message":"3850","line":41,"column":3,"nodeType":"3867","messageId":"3852","endLine":41,"endColumn":45},{"ruleId":"3849","severity":1,"message":"3850","line":112,"column":3,"nodeType":"3867","messageId":"3852","endLine":112,"endColumn":29},{"ruleId":"3873","severity":1,"message":"4025","line":460,"column":38,"nodeType":"3854","endLine":460,"endColumn":44},{"ruleId":"3914","severity":1,"message":"4026","line":497,"column":3,"nodeType":"3867","messageId":"3916","endLine":497,"endColumn":32},{"ruleId":"3849","severity":1,"message":"3850","line":595,"column":3,"nodeType":"3867","messageId":"3852","endLine":595,"endColumn":61},{"ruleId":"3873","severity":1,"message":"4025","line":733,"column":38,"nodeType":"3854","endLine":733,"endColumn":44},{"ruleId":"3849","severity":1,"message":"3850","line":764,"column":3,"nodeType":"3867","messageId":"3852","endLine":764,"endColumn":41},{"ruleId":"3849","severity":1,"message":"4027","line":824,"column":28,"nodeType":"3854","messageId":"3855","endLine":824,"endColumn":37},{"ruleId":"3837","severity":1,"message":"3838","line":824,"column":34,"nodeType":"3839","messageId":"3840","endLine":824,"endColumn":37,"suggestions":"4028"},{"ruleId":"3845","severity":1,"message":"3872","line":829,"column":7,"nodeType":"3863","messageId":"3848","endLine":829,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":841,"column":5,"nodeType":"3863","messageId":"3848","endLine":841,"endColumn":72},{"ruleId":"3914","severity":1,"message":"4029","line":844,"column":3,"nodeType":"3867","messageId":"3916","endLine":844,"endColumn":34},{"ruleId":"3914","severity":1,"message":"4030","line":878,"column":3,"nodeType":"3867","messageId":"3916","endLine":878,"endColumn":33},{"ruleId":"3849","severity":1,"message":"3850","line":935,"column":3,"nodeType":"3867","messageId":"3852","endLine":935,"endColumn":41},{"ruleId":"3875","severity":1,"message":"3876","line":10,"column":45,"nodeType":"3877","messageId":"3878","endLine":10,"endColumn":51},{"ruleId":"3875","severity":1,"message":"3876","line":30,"column":60,"nodeType":"3877","messageId":"3878","endLine":30,"endColumn":66},{"ruleId":"3849","severity":1,"message":"3850","line":10,"column":29,"nodeType":"3851","messageId":"3852","endLine":10,"endColumn":47},{"ruleId":"3849","severity":1,"message":"4031","line":3,"column":48,"nodeType":"3854","messageId":"3855","endLine":3,"endColumn":76},{"ruleId":"3879","severity":1,"message":"3880","line":8,"column":9,"nodeType":"3881","messageId":"3882","endLine":8,"endColumn":68},{"ruleId":"3849","severity":1,"message":"3850","line":83,"column":3,"nodeType":"3867","messageId":"3852","endLine":83,"endColumn":48},{"ruleId":"3849","severity":1,"message":"4032","line":83,"column":34,"nodeType":"3854","messageId":"3855","endLine":83,"endColumn":47},{"ruleId":"3837","severity":1,"message":"3838","line":83,"column":44,"nodeType":"3839","messageId":"3840","endLine":83,"endColumn":47,"suggestions":"4033"},{"ruleId":"3849","severity":1,"message":"3850","line":97,"column":3,"nodeType":"3867","messageId":"3852","endLine":97,"endColumn":42},{"ruleId":"3849","severity":1,"message":"4034","line":97,"column":31,"nodeType":"3854","messageId":"3855","endLine":97,"endColumn":41},{"ruleId":"3837","severity":1,"message":"3838","line":97,"column":38,"nodeType":"3839","messageId":"3840","endLine":97,"endColumn":41,"suggestions":"4035"},{"ruleId":"3849","severity":1,"message":"3850","line":181,"column":3,"nodeType":"3867","messageId":"3852","endLine":181,"endColumn":28},{"ruleId":"3849","severity":1,"message":"3850","line":187,"column":3,"nodeType":"3867","messageId":"3852","endLine":187,"endColumn":24},{"ruleId":"3849","severity":1,"message":"3850","line":459,"column":3,"nodeType":"3867","messageId":"3852","endLine":459,"endColumn":25},{"ruleId":"3845","severity":1,"message":"3872","line":492,"column":7,"nodeType":"3863","messageId":"3848","endLine":492,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":578,"column":3,"nodeType":"3867","messageId":"3852","endLine":578,"endColumn":36},{"ruleId":"3849","severity":1,"message":"3963","line":629,"column":28,"nodeType":"3854","messageId":"3855","endLine":629,"endColumn":38},{"ruleId":"3837","severity":1,"message":"3838","line":629,"column":35,"nodeType":"3839","messageId":"3840","endLine":629,"endColumn":38,"suggestions":"4036"},{"ruleId":"3849","severity":1,"message":"3850","line":633,"column":3,"nodeType":"3867","messageId":"3852","endLine":633,"endColumn":20},{"ruleId":"3879","severity":1,"message":"3880","line":889,"column":13,"nodeType":"3881","messageId":"3882","endLine":889,"endColumn":121},{"ruleId":"3845","severity":1,"message":"3872","line":904,"column":7,"nodeType":"3863","messageId":"3848","endLine":904,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":928,"column":7,"nodeType":"3863","messageId":"3848","endLine":928,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":932,"column":31,"nodeType":"3851","messageId":"3852","endLine":932,"endColumn":53},{"ruleId":"3849","severity":1,"message":"4037","line":943,"column":28,"nodeType":"3854","messageId":"3855","endLine":943,"endColumn":47},{"ruleId":"3837","severity":1,"message":"3838","line":943,"column":44,"nodeType":"3839","messageId":"3840","endLine":943,"endColumn":47,"suggestions":"4038"},{"ruleId":"3979","severity":1,"message":"3980","line":10,"column":18,"nodeType":"3854","messageId":"3981","endLine":10,"endColumn":40,"fix":"4039"},{"ruleId":"3979","severity":1,"message":"3980","line":33,"column":18,"nodeType":"3854","messageId":"3981","endLine":33,"endColumn":41,"fix":"4040"},{"ruleId":"3837","severity":1,"message":"3838","line":15,"column":35,"nodeType":"3839","messageId":"3840","endLine":15,"endColumn":38,"suggestions":"4041"},{"ruleId":"3849","severity":1,"message":"3850","line":31,"column":3,"nodeType":"3867","messageId":"3852","endLine":31,"endColumn":70},{"ruleId":"3849","severity":1,"message":"3850","line":48,"column":20,"nodeType":"3851","messageId":"3852","endLine":48,"endColumn":42},{"ruleId":"3914","severity":1,"message":"3917","line":48,"column":40,"nodeType":"3851","messageId":"3916","endLine":48,"endColumn":42},{"ruleId":"3845","severity":1,"message":"3872","line":50,"column":5,"nodeType":"3863","messageId":"3848","endLine":50,"endColumn":28},{"ruleId":"3849","severity":1,"message":"3850","line":53,"column":20,"nodeType":"3851","messageId":"3852","endLine":53,"endColumn":50},{"ruleId":"3849","severity":1,"message":"3904","line":53,"column":40,"nodeType":"3854","messageId":"3855","endLine":53,"endColumn":46},{"ruleId":"3837","severity":1,"message":"3838","line":53,"column":43,"nodeType":"3839","messageId":"3840","endLine":53,"endColumn":46,"suggestions":"4042"},{"ruleId":"3879","severity":1,"message":"3880","line":58,"column":7,"nodeType":"3928","messageId":"3882","endLine":58,"endColumn":26},{"ruleId":"3879","severity":1,"message":"3880","line":70,"column":9,"nodeType":"3928","messageId":"3882","endLine":70,"endColumn":65},{"ruleId":"3879","severity":1,"message":"3880","line":72,"column":9,"nodeType":"3928","messageId":"3882","endLine":72,"endColumn":20},{"ruleId":"3849","severity":1,"message":"3850","line":117,"column":3,"nodeType":"3867","messageId":"3852","endLine":117,"endColumn":20},{"ruleId":"3845","severity":1,"message":"3872","line":142,"column":5,"nodeType":"3863","messageId":"3848","endLine":142,"endColumn":34},{"ruleId":"3849","severity":1,"message":"3850","line":145,"column":3,"nodeType":"3867","messageId":"3852","endLine":145,"endColumn":31},{"ruleId":"3849","severity":1,"message":"3850","line":149,"column":3,"nodeType":"3867","messageId":"3852","endLine":149,"endColumn":32},{"ruleId":"3849","severity":1,"message":"3850","line":153,"column":3,"nodeType":"3867","messageId":"3852","endLine":153,"endColumn":20},{"ruleId":"3837","severity":1,"message":"3838","line":44,"column":31,"nodeType":"3839","messageId":"3840","endLine":44,"endColumn":34,"suggestions":"4043"},{"ruleId":"3837","severity":1,"message":"3838","line":45,"column":33,"nodeType":"3839","messageId":"3840","endLine":45,"endColumn":36,"suggestions":"4044"},{"ruleId":"3845","severity":1,"message":"3872","line":36,"column":7,"nodeType":"3863","messageId":"3848","endLine":36,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":53,"column":7,"nodeType":"3863","messageId":"3848","endLine":53,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":87,"column":7,"nodeType":"3863","messageId":"3848","endLine":87,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":107,"column":7,"nodeType":"3863","messageId":"3848","endLine":107,"endColumn":18},{"ruleId":"3883","severity":1,"message":"4045","line":125,"column":12,"nodeType":"3885","messageId":"3886","endLine":125,"endColumn":39},{"ruleId":"3837","severity":1,"message":"3838","line":125,"column":29,"nodeType":"3839","messageId":"3840","endLine":125,"endColumn":32,"suggestions":"4046"},{"ruleId":"3883","severity":1,"message":"4045","line":128,"column":13,"nodeType":"3885","messageId":"3886","endLine":128,"endColumn":40},{"ruleId":"3888","severity":1,"message":"3889","line":128,"column":13,"nodeType":"3885","messageId":"3890","endLine":128,"endColumn":40},{"ruleId":"3837","severity":1,"message":"3838","line":128,"column":30,"nodeType":"3839","messageId":"3840","endLine":128,"endColumn":33,"suggestions":"4047"},{"ruleId":"3845","severity":1,"message":"3872","line":131,"column":7,"nodeType":"3863","messageId":"3848","endLine":131,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":163,"column":7,"nodeType":"3863","messageId":"3848","endLine":163,"endColumn":18},{"ruleId":"3879","severity":1,"message":"3880","line":176,"column":13,"nodeType":"3881","messageId":"3882","endLine":176,"endColumn":69},{"ruleId":"3868","severity":1,"message":"3869","line":176,"column":26,"nodeType":"3870","messageId":"3871","endLine":176,"endColumn":39,"suggestions":"4048"},{"ruleId":"3845","severity":1,"message":"3872","line":183,"column":7,"nodeType":"3863","messageId":"3848","endLine":183,"endColumn":18},{"ruleId":"3879","severity":1,"message":"3880","line":198,"column":13,"nodeType":"3881","messageId":"3882","endLine":198,"endColumn":68},{"ruleId":"3868","severity":1,"message":"3869","line":198,"column":26,"nodeType":"3870","messageId":"3871","endLine":198,"endColumn":39,"suggestions":"4049"},{"ruleId":"3845","severity":1,"message":"3872","line":202,"column":7,"nodeType":"3863","messageId":"3848","endLine":202,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":218,"column":3,"nodeType":"3867","messageId":"3852","endLine":218,"endColumn":32},{"ruleId":"3845","severity":1,"message":"3872","line":240,"column":7,"nodeType":"3863","messageId":"3848","endLine":240,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":49,"column":7,"nodeType":"3863","messageId":"3848","endLine":49,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":67,"column":7,"nodeType":"3863","messageId":"3848","endLine":67,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":101,"column":7,"nodeType":"3863","messageId":"3848","endLine":101,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":133,"column":7,"nodeType":"3863","messageId":"3848","endLine":133,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":156,"column":7,"nodeType":"3863","messageId":"3848","endLine":156,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":175,"column":7,"nodeType":"3863","messageId":"3848","endLine":175,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":196,"column":7,"nodeType":"3863","messageId":"3848","endLine":196,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":221,"column":7,"nodeType":"3863","messageId":"3848","endLine":221,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":238,"column":3,"nodeType":"3867","messageId":"3852","endLine":238,"endColumn":32},{"ruleId":"3845","severity":1,"message":"3872","line":265,"column":7,"nodeType":"3863","messageId":"3848","endLine":265,"endColumn":18},{"ruleId":"3914","severity":1,"message":"3915","line":11,"column":3,"nodeType":"3867","messageId":"3916","endLine":11,"endColumn":23},{"ruleId":"3845","severity":1,"message":"3872","line":21,"column":7,"nodeType":"3863","messageId":"3848","endLine":21,"endColumn":18},{"ruleId":"3914","severity":1,"message":"4050","line":25,"column":3,"nodeType":"3867","messageId":"3916","endLine":25,"endColumn":26},{"ruleId":"3849","severity":1,"message":"3850","line":30,"column":3,"nodeType":"3867","messageId":"3852","endLine":30,"endColumn":25},{"ruleId":"3914","severity":1,"message":"4051","line":30,"column":3,"nodeType":"3867","messageId":"3916","endLine":30,"endColumn":23},{"ruleId":"3845","severity":1,"message":"3872","line":48,"column":7,"nodeType":"3863","messageId":"3848","endLine":48,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":65,"column":7,"nodeType":"3863","messageId":"3848","endLine":65,"endColumn":18},{"ruleId":"3914","severity":1,"message":"4052","line":69,"column":3,"nodeType":"3867","messageId":"3916","endLine":69,"endColumn":21},{"ruleId":"3845","severity":1,"message":"3872","line":79,"column":7,"nodeType":"3863","messageId":"3848","endLine":79,"endColumn":18},{"ruleId":"3914","severity":1,"message":"4053","line":83,"column":3,"nodeType":"3867","messageId":"3916","endLine":83,"endColumn":19},{"ruleId":"3845","severity":1,"message":"3872","line":98,"column":7,"nodeType":"3863","messageId":"3848","endLine":98,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":102,"column":3,"nodeType":"3867","messageId":"3852","endLine":102,"endColumn":58},{"ruleId":"3849","severity":1,"message":"3850","line":115,"column":3,"nodeType":"3867","messageId":"3852","endLine":115,"endColumn":36},{"ruleId":"3914","severity":1,"message":"3915","line":10,"column":3,"nodeType":"3867","messageId":"3916","endLine":10,"endColumn":23},{"ruleId":"3845","severity":1,"message":"3872","line":20,"column":7,"nodeType":"3863","messageId":"3848","endLine":20,"endColumn":18},{"ruleId":"3914","severity":1,"message":"4050","line":24,"column":3,"nodeType":"3867","messageId":"3916","endLine":24,"endColumn":26},{"ruleId":"3849","severity":1,"message":"3850","line":29,"column":3,"nodeType":"3867","messageId":"3852","endLine":29,"endColumn":25},{"ruleId":"3914","severity":1,"message":"4051","line":29,"column":3,"nodeType":"3867","messageId":"3916","endLine":29,"endColumn":23},{"ruleId":"3845","severity":1,"message":"3872","line":47,"column":7,"nodeType":"3863","messageId":"3848","endLine":47,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":64,"column":7,"nodeType":"3863","messageId":"3848","endLine":64,"endColumn":18},{"ruleId":"3914","severity":1,"message":"4052","line":68,"column":3,"nodeType":"3867","messageId":"3916","endLine":68,"endColumn":21},{"ruleId":"3845","severity":1,"message":"3872","line":78,"column":7,"nodeType":"3863","messageId":"3848","endLine":78,"endColumn":18},{"ruleId":"3914","severity":1,"message":"4053","line":82,"column":3,"nodeType":"3867","messageId":"3916","endLine":82,"endColumn":19},{"ruleId":"3845","severity":1,"message":"3872","line":97,"column":7,"nodeType":"3863","messageId":"3848","endLine":97,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":101,"column":3,"nodeType":"3867","messageId":"3852","endLine":101,"endColumn":58},{"ruleId":"3849","severity":1,"message":"3850","line":114,"column":3,"nodeType":"3867","messageId":"3852","endLine":114,"endColumn":36},{"ruleId":"3849","severity":1,"message":"3850","line":151,"column":3,"nodeType":"3867","messageId":"3852","endLine":151,"endColumn":70},{"ruleId":"3849","severity":1,"message":"3850","line":236,"column":3,"nodeType":"3867","messageId":"3852","endLine":236,"endColumn":39},{"ruleId":"3849","severity":1,"message":"3850","line":253,"column":3,"nodeType":"3867","messageId":"3852","endLine":253,"endColumn":42},{"ruleId":"3914","severity":1,"message":"4054","line":253,"column":3,"nodeType":"3867","messageId":"3916","endLine":253,"endColumn":40},{"ruleId":"3849","severity":1,"message":"3850","line":281,"column":3,"nodeType":"3867","messageId":"3852","endLine":281,"endColumn":40},{"ruleId":"3849","severity":1,"message":"3850","line":298,"column":3,"nodeType":"3867","messageId":"3852","endLine":298,"endColumn":65},{"ruleId":"3849","severity":1,"message":"3850","line":317,"column":3,"nodeType":"3867","messageId":"3852","endLine":317,"endColumn":71},{"ruleId":"3849","severity":1,"message":"3850","line":99,"column":3,"nodeType":"3867","messageId":"3852","endLine":99,"endColumn":39},{"ruleId":"3849","severity":1,"message":"3850","line":197,"column":3,"nodeType":"3867","messageId":"3852","endLine":197,"endColumn":55},{"ruleId":"3873","severity":1,"message":"4055","line":6,"column":10,"nodeType":"3854","endLine":6,"endColumn":47},{"ruleId":"3849","severity":1,"message":"3850","line":125,"column":3,"nodeType":"3867","messageId":"3852","endLine":125,"endColumn":26},{"ruleId":"3849","severity":1,"message":"3850","line":164,"column":3,"nodeType":"3867","messageId":"3852","endLine":164,"endColumn":40},{"ruleId":"3849","severity":1,"message":"3850","line":175,"column":3,"nodeType":"3867","messageId":"3852","endLine":175,"endColumn":86},{"ruleId":"3849","severity":1,"message":"3850","line":190,"column":3,"nodeType":"3867","messageId":"3852","endLine":190,"endColumn":72},{"ruleId":"3873","severity":1,"message":"4056","line":1,"column":10,"nodeType":"3854","endLine":1,"endColumn":46},{"ruleId":"3849","severity":1,"message":"3850","line":7,"column":8,"nodeType":"4057","messageId":"3852","endLine":7,"endColumn":62},{"ruleId":"3849","severity":1,"message":"3850","line":7,"column":8,"nodeType":"4057","messageId":"3852","endLine":7,"endColumn":66},{"ruleId":"3849","severity":1,"message":"3850","line":57,"column":88,"nodeType":"3851","messageId":"3852","endLine":57,"endColumn":128},{"ruleId":"3849","severity":1,"message":"3850","line":10,"column":15,"nodeType":"3867","messageId":"3852","endLine":10,"endColumn":17},{"ruleId":"3849","severity":1,"message":"3850","line":40,"column":95,"nodeType":"3851","messageId":"3852","endLine":42,"endColumn":5},{"ruleId":"3849","severity":1,"message":"3850","line":203,"column":3,"nodeType":"3867","messageId":"3852","endLine":203,"endColumn":57},{"ruleId":"3849","severity":1,"message":"4058","line":203,"column":36,"nodeType":"3854","messageId":"3855","endLine":203,"endColumn":56},{"ruleId":"3837","severity":1,"message":"3838","line":203,"column":53,"nodeType":"3839","messageId":"3840","endLine":203,"endColumn":56,"suggestions":"4059"},{"ruleId":"3849","severity":1,"message":"3850","line":291,"column":3,"nodeType":"3867","messageId":"3852","endLine":291,"endColumn":65},{"ruleId":"4060","severity":1,"message":"4061","line":312,"column":98,"nodeType":"3851","messageId":"4062"},{"ruleId":"3849","severity":1,"message":"3850","line":50,"column":3,"nodeType":"3867","messageId":"3852","endLine":50,"endColumn":72},{"ruleId":"3849","severity":1,"message":"3850","line":73,"column":3,"nodeType":"3867","messageId":"3852","endLine":73,"endColumn":67},{"ruleId":"3849","severity":1,"message":"3850","line":85,"column":3,"nodeType":"3867","messageId":"3852","endLine":85,"endColumn":46},{"ruleId":"3849","severity":1,"message":"3850","line":107,"column":3,"nodeType":"3867","messageId":"3852","endLine":107,"endColumn":76},{"ruleId":"3849","severity":1,"message":"3850","line":120,"column":3,"nodeType":"3867","messageId":"3852","endLine":120,"endColumn":72},{"ruleId":"3849","severity":1,"message":"3850","line":69,"column":3,"nodeType":"3867","messageId":"3852","endLine":69,"endColumn":30},{"ruleId":"3873","severity":1,"message":"4063","line":1,"column":28,"nodeType":"3854","endLine":1,"endColumn":59},{"ruleId":"3849","severity":1,"message":"3850","line":19,"column":49,"nodeType":"3851","messageId":"3852","endLine":22,"endColumn":5},{"ruleId":"3873","severity":1,"message":"4064","line":3,"column":10,"nodeType":"3854","endLine":3,"endColumn":35},{"ruleId":"3873","severity":1,"message":"4065","line":10,"column":10,"nodeType":"3854","endLine":10,"endColumn":52},{"ruleId":"3873","severity":1,"message":"4066","line":17,"column":3,"nodeType":"3854","endLine":17,"endColumn":30},{"ruleId":"3873","severity":1,"message":"4067","line":18,"column":3,"nodeType":"3854","endLine":18,"endColumn":39},{"ruleId":"3879","severity":1,"message":"3880","line":225,"column":9,"nodeType":"3881","messageId":"3882","endLine":228,"endColumn":38},{"ruleId":"3879","severity":1,"message":"3880","line":235,"column":7,"nodeType":"4068","messageId":"3882","endLine":235,"endColumn":27},{"ruleId":"3873","severity":1,"message":"4069","line":9,"column":3,"nodeType":"3854","endLine":9,"endColumn":33},{"ruleId":"3883","severity":1,"message":"4070","line":260,"column":96,"nodeType":"3885","messageId":"3886","endLine":260,"endColumn":107},{"ruleId":"3845","severity":1,"message":"3872","line":288,"column":7,"nodeType":"3863","messageId":"3848","endLine":288,"endColumn":18},{"ruleId":"3837","severity":1,"message":"3838","line":406,"column":45,"nodeType":"3839","messageId":"3840","endLine":406,"endColumn":48,"suggestions":"4071"},{"ruleId":"3883","severity":1,"message":"4072","line":408,"column":21,"nodeType":"3885","messageId":"3886","endLine":408,"endColumn":33},{"ruleId":"3879","severity":1,"message":"3880","line":509,"column":13,"nodeType":"3881","messageId":"3882","endLine":509,"endColumn":44},{"ruleId":"3849","severity":1,"message":"3850","line":531,"column":44,"nodeType":"3851","messageId":"3852","endLine":537,"endColumn":7},{"ruleId":"3849","severity":1,"message":"3850","line":547,"column":30,"nodeType":"3851","messageId":"3852","endLine":552,"endColumn":7},{"ruleId":"3849","severity":1,"message":"3850","line":568,"column":33,"nodeType":"3851","messageId":"3852","endLine":574,"endColumn":7},{"ruleId":"3883","severity":1,"message":"4070","line":686,"column":84,"nodeType":"3885","messageId":"3886","endLine":686,"endColumn":95},{"ruleId":"3849","severity":1,"message":"3850","line":749,"column":3,"nodeType":"3867","messageId":"3852","endLine":749,"endColumn":27},{"ruleId":"3845","severity":1,"message":"3872","line":886,"column":9,"nodeType":"3863","messageId":"3848","endLine":886,"endColumn":20},{"ruleId":"3845","severity":1,"message":"4073","line":889,"column":5,"nodeType":"3863","messageId":"3864","endLine":889,"endColumn":34},{"ruleId":"3849","severity":1,"message":"3850","line":1174,"column":3,"nodeType":"3867","messageId":"3852","endLine":1177,"endColumn":4},{"ruleId":"3849","severity":1,"message":"3850","line":23,"column":3,"nodeType":"3867","messageId":"3852","endLine":23,"endColumn":31},{"ruleId":"3849","severity":1,"message":"3850","line":27,"column":3,"nodeType":"3867","messageId":"3852","endLine":27,"endColumn":25},{"ruleId":"3849","severity":1,"message":"3850","line":34,"column":3,"nodeType":"3867","messageId":"3852","endLine":34,"endColumn":68},{"ruleId":"3849","severity":1,"message":"3850","line":45,"column":16,"nodeType":"3851","messageId":"3852","endLine":45,"endColumn":69},{"ruleId":"3868","severity":1,"message":"3869","line":49,"column":26,"nodeType":"3870","messageId":"3871","endLine":49,"endColumn":47,"suggestions":"4074"},{"ruleId":"3849","severity":1,"message":"3850","line":56,"column":16,"nodeType":"3851","messageId":"3852","endLine":56,"endColumn":38},{"ruleId":"3849","severity":1,"message":"3850","line":65,"column":18,"nodeType":"3851","messageId":"3852","endLine":65,"endColumn":40},{"ruleId":"3868","severity":1,"message":"3869","line":68,"column":26,"nodeType":"3870","messageId":"3871","endLine":68,"endColumn":47,"suggestions":"4075"},{"ruleId":"3849","severity":1,"message":"3850","line":75,"column":3,"nodeType":"3867","messageId":"3852","endLine":75,"endColumn":25},{"ruleId":"3849","severity":1,"message":"3850","line":91,"column":16,"nodeType":"3851","messageId":"3852","endLine":91,"endColumn":69},{"ruleId":"3868","severity":1,"message":"3869","line":95,"column":26,"nodeType":"3870","messageId":"3871","endLine":95,"endColumn":47,"suggestions":"4076"},{"ruleId":"3849","severity":1,"message":"3850","line":102,"column":3,"nodeType":"3867","messageId":"3852","endLine":102,"endColumn":68},{"ruleId":"3849","severity":1,"message":"3850","line":128,"column":3,"nodeType":"3867","messageId":"3852","endLine":128,"endColumn":57},{"ruleId":"3849","severity":1,"message":"3850","line":132,"column":3,"nodeType":"3867","messageId":"3852","endLine":132,"endColumn":41},{"ruleId":"3849","severity":1,"message":"3850","line":163,"column":3,"nodeType":"3867","messageId":"3852","endLine":163,"endColumn":27},{"ruleId":"3849","severity":1,"message":"3850","line":167,"column":3,"nodeType":"3867","messageId":"3852","endLine":167,"endColumn":28},{"ruleId":"3868","severity":1,"message":"3869","line":180,"column":26,"nodeType":"3870","messageId":"3871","endLine":180,"endColumn":47,"suggestions":"4077"},{"ruleId":"3845","severity":1,"message":"3872","line":169,"column":7,"nodeType":"3863","messageId":"3848","endLine":169,"endColumn":18},{"ruleId":"3879","severity":1,"message":"3880","line":186,"column":7,"nodeType":"3928","messageId":"3882","endLine":186,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":360,"column":3,"nodeType":"3867","messageId":"3852","endLine":360,"endColumn":69},{"ruleId":"3845","severity":1,"message":"3872","line":440,"column":5,"nodeType":"3863","messageId":"3848","endLine":440,"endColumn":50},{"ruleId":"3849","severity":1,"message":"3850","line":469,"column":3,"nodeType":"3867","messageId":"3852","endLine":469,"endColumn":39},{"ruleId":"3914","severity":1,"message":"4078","line":498,"column":3,"nodeType":"3867","messageId":"3916","endLine":498,"endColumn":39},{"ruleId":"3849","severity":1,"message":"3850","line":534,"column":3,"nodeType":"3867","messageId":"3852","endLine":534,"endColumn":65},{"ruleId":"3849","severity":1,"message":"3850","line":548,"column":3,"nodeType":"3867","messageId":"3852","endLine":548,"endColumn":68},{"ruleId":"3849","severity":1,"message":"3850","line":560,"column":3,"nodeType":"3867","messageId":"3852","endLine":560,"endColumn":51},{"ruleId":"3849","severity":1,"message":"3850","line":617,"column":35,"nodeType":"3851","messageId":"3852","endLine":617,"endColumn":54},{"ruleId":"3849","severity":1,"message":"3850","line":625,"column":36,"nodeType":"3851","messageId":"3852","endLine":625,"endColumn":55},{"ruleId":"3849","severity":1,"message":"3850","line":637,"column":3,"nodeType":"3867","messageId":"3852","endLine":637,"endColumn":42},{"ruleId":"3849","severity":1,"message":"3850","line":645,"column":31,"nodeType":"3851","messageId":"3852","endLine":645,"endColumn":50},{"ruleId":"3849","severity":1,"message":"3850","line":649,"column":32,"nodeType":"3851","messageId":"3852","endLine":649,"endColumn":51},{"ruleId":"3849","severity":1,"message":"3850","line":651,"column":31,"nodeType":"3851","messageId":"3852","endLine":651,"endColumn":50},{"ruleId":"3849","severity":1,"message":"3850","line":653,"column":33,"nodeType":"3851","messageId":"3852","endLine":653,"endColumn":73},{"ruleId":"3849","severity":1,"message":"3850","line":684,"column":3,"nodeType":"3867","messageId":"3852","endLine":684,"endColumn":62},{"ruleId":"3849","severity":1,"message":"3850","line":695,"column":3,"nodeType":"3867","messageId":"3852","endLine":695,"endColumn":66},{"ruleId":"3849","severity":1,"message":"3850","line":709,"column":3,"nodeType":"3867","messageId":"3852","endLine":709,"endColumn":68},{"ruleId":"3849","severity":1,"message":"3850","line":725,"column":3,"nodeType":"3867","messageId":"3852","endLine":725,"endColumn":59},{"ruleId":"3849","severity":1,"message":"3850","line":736,"column":3,"nodeType":"3867","messageId":"3852","endLine":736,"endColumn":63},{"ruleId":"3837","severity":1,"message":"3838","line":57,"column":64,"nodeType":"3839","messageId":"3840","endLine":57,"endColumn":67,"suggestions":"4079"},{"ruleId":"3979","severity":1,"message":"3980","line":67,"column":18,"nodeType":"3854","messageId":"3981","endLine":67,"endColumn":46,"fix":"4080"},{"ruleId":"3837","severity":1,"message":"3838","line":410,"column":64,"nodeType":"3839","messageId":"3840","endLine":410,"endColumn":67,"suggestions":"4081"},{"ruleId":"3914","severity":1,"message":"4082","line":35,"column":3,"nodeType":"3867","messageId":"3916","endLine":35,"endColumn":92},{"ruleId":"3914","severity":1,"message":"4083","line":105,"column":3,"nodeType":"3867","messageId":"3916","endLine":105,"endColumn":20},{"ruleId":"3845","severity":1,"message":"3872","line":144,"column":5,"nodeType":"3863","messageId":"3848","endLine":144,"endColumn":63},{"ruleId":"3883","severity":1,"message":"4084","line":144,"column":12,"nodeType":"3885","messageId":"3886","endLine":144,"endColumn":52},{"ruleId":"3888","severity":1,"message":"3889","line":144,"column":12,"nodeType":"3885","messageId":"3890","endLine":144,"endColumn":52},{"ruleId":"3837","severity":1,"message":"3838","line":144,"column":33,"nodeType":"3839","messageId":"3840","endLine":144,"endColumn":36,"suggestions":"4085"},{"ruleId":"3849","severity":1,"message":"3850","line":202,"column":3,"nodeType":"3867","messageId":"3852","endLine":202,"endColumn":95},{"ruleId":"3837","severity":1,"message":"3838","line":91,"column":61,"nodeType":"3839","messageId":"3840","endLine":91,"endColumn":64,"suggestions":"4086"},{"ruleId":"3849","severity":1,"message":"3850","line":121,"column":3,"nodeType":"3867","messageId":"3852","endLine":121,"endColumn":39},{"ruleId":"3849","severity":1,"message":"3850","line":125,"column":3,"nodeType":"3867","messageId":"3852","endLine":125,"endColumn":36},{"ruleId":"3849","severity":1,"message":"3850","line":133,"column":3,"nodeType":"3867","messageId":"3852","endLine":133,"endColumn":28},{"ruleId":"3849","severity":1,"message":"4087","line":159,"column":22,"nodeType":"3854","messageId":"3855","endLine":159,"endColumn":31},{"ruleId":"3837","severity":1,"message":"3838","line":159,"column":28,"nodeType":"3839","messageId":"3840","endLine":159,"endColumn":31,"suggestions":"4088"},{"ruleId":"3845","severity":1,"message":"3872","line":209,"column":7,"nodeType":"3863","messageId":"3848","endLine":209,"endColumn":18},{"ruleId":"3914","severity":1,"message":"3917","line":259,"column":86,"nodeType":"3851","messageId":"3916","endLine":259,"endColumn":88},{"ruleId":"3845","severity":1,"message":"3872","line":275,"column":7,"nodeType":"3863","messageId":"3848","endLine":275,"endColumn":18},{"ruleId":"3849","severity":1,"message":"4087","line":279,"column":26,"nodeType":"3854","messageId":"3855","endLine":279,"endColumn":35},{"ruleId":"3837","severity":1,"message":"3838","line":279,"column":32,"nodeType":"3839","messageId":"3840","endLine":279,"endColumn":35,"suggestions":"4089"},{"ruleId":"3879","severity":1,"message":"3880","line":297,"column":7,"nodeType":"3928","messageId":"3882","endLine":297,"endColumn":19},{"ruleId":"3845","severity":1,"message":"3872","line":335,"column":7,"nodeType":"3863","messageId":"3848","endLine":335,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":343,"column":7,"nodeType":"3863","messageId":"3848","endLine":343,"endColumn":18},{"ruleId":"3879","severity":1,"message":"3880","line":371,"column":7,"nodeType":"3928","messageId":"3882","endLine":371,"endColumn":25},{"ruleId":"3845","severity":1,"message":"3872","line":372,"column":7,"nodeType":"3863","messageId":"3848","endLine":372,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":380,"column":3,"nodeType":"3867","messageId":"3852","endLine":380,"endColumn":48},{"ruleId":"3849","severity":1,"message":"3850","line":395,"column":3,"nodeType":"3867","messageId":"3852","endLine":395,"endColumn":40},{"ruleId":"3849","severity":1,"message":"3850","line":399,"column":3,"nodeType":"3867","messageId":"3852","endLine":399,"endColumn":32},{"ruleId":"3883","severity":1,"message":"4070","line":484,"column":72,"nodeType":"3885","messageId":"3886","endLine":484,"endColumn":83},{"ruleId":"3883","severity":1,"message":"4090","line":498,"column":13,"nodeType":"3885","messageId":"3886","endLine":498,"endColumn":31},{"ruleId":"3837","severity":1,"message":"3838","line":498,"column":20,"nodeType":"3839","messageId":"3840","endLine":498,"endColumn":23,"suggestions":"4091"},{"ruleId":"3845","severity":1,"message":"3872","line":649,"column":5,"nodeType":"4092","messageId":"3848","endLine":649,"endColumn":52},{"ruleId":"3837","severity":1,"message":"3838","line":649,"column":49,"nodeType":"3839","messageId":"3840","endLine":649,"endColumn":52,"suggestions":"4093"},{"ruleId":"3849","severity":1,"message":"3850","line":680,"column":42,"nodeType":"3851","messageId":"3852","endLine":680,"endColumn":47},{"ruleId":"3849","severity":1,"message":"3850","line":695,"column":3,"nodeType":"3867","messageId":"3852","endLine":695,"endColumn":74},{"ruleId":"3849","severity":1,"message":"3850","line":707,"column":3,"nodeType":"3867","messageId":"3852","endLine":707,"endColumn":68},{"ruleId":"3837","severity":1,"message":"3838","line":707,"column":62,"nodeType":"3839","messageId":"3840","endLine":707,"endColumn":65,"suggestions":"4094"},{"ruleId":"3883","severity":1,"message":"4070","line":754,"column":72,"nodeType":"3885","messageId":"3886","endLine":754,"endColumn":83},{"ruleId":"3883","severity":1,"message":"4070","line":776,"column":85,"nodeType":"3885","messageId":"3886","endLine":776,"endColumn":96},{"ruleId":"3849","severity":1,"message":"3850","line":780,"column":24,"nodeType":"3851","messageId":"3852","endLine":780,"endColumn":29},{"ruleId":"3837","severity":1,"message":"3838","line":793,"column":78,"nodeType":"3839","messageId":"3840","endLine":793,"endColumn":81,"suggestions":"4095"},{"ruleId":"3879","severity":1,"message":"3880","line":797,"column":7,"nodeType":"4068","messageId":"3882","endLine":797,"endColumn":12},{"ruleId":"3837","severity":1,"message":"3838","line":834,"column":86,"nodeType":"3839","messageId":"3840","endLine":834,"endColumn":89,"suggestions":"4096"},{"ruleId":"3837","severity":1,"message":"3838","line":838,"column":80,"nodeType":"3839","messageId":"3840","endLine":838,"endColumn":83,"suggestions":"4097"},{"ruleId":"3849","severity":1,"message":"3850","line":864,"column":49,"nodeType":"3851","messageId":"3852","endLine":870,"endColumn":7},{"ruleId":"3883","severity":1,"message":"4098","line":951,"column":12,"nodeType":"4099","messageId":"3886","endLine":951,"endColumn":42},{"ruleId":"3837","severity":1,"message":"3838","line":951,"column":30,"nodeType":"3839","messageId":"3840","endLine":951,"endColumn":33,"suggestions":"4100"},{"ruleId":"3879","severity":1,"message":"3880","line":983,"column":7,"nodeType":"3928","messageId":"3882","endLine":983,"endColumn":19},{"ruleId":"3837","severity":1,"message":"3838","line":1007,"column":77,"nodeType":"3839","messageId":"3840","endLine":1007,"endColumn":80,"suggestions":"4101"},{"ruleId":"3849","severity":1,"message":"3850","line":1078,"column":3,"nodeType":"3867","messageId":"3852","endLine":1078,"endColumn":56},{"ruleId":"3849","severity":1,"message":"3850","line":1082,"column":3,"nodeType":"3867","messageId":"3852","endLine":1082,"endColumn":118},{"ruleId":"3837","severity":1,"message":"3838","line":56,"column":5,"nodeType":"3839","messageId":"3840","endLine":56,"endColumn":8,"suggestions":"4102"},{"ruleId":"3837","severity":1,"message":"3838","line":58,"column":5,"nodeType":"3839","messageId":"3840","endLine":58,"endColumn":8,"suggestions":"4103"},{"ruleId":"3979","severity":1,"message":"3980","line":66,"column":18,"nodeType":"3854","messageId":"3981","endLine":66,"endColumn":58,"fix":"4104"},{"ruleId":"3979","severity":1,"message":"3980","line":133,"column":18,"nodeType":"3854","messageId":"3981","endLine":133,"endColumn":68,"fix":"4105"},{"ruleId":"3879","severity":1,"message":"3880","line":29,"column":11,"nodeType":"3881","messageId":"3882","endLine":33,"endColumn":6},{"ruleId":"3845","severity":1,"message":"3872","line":35,"column":5,"nodeType":"3863","messageId":"3848","endLine":35,"endColumn":25},{"ruleId":"3914","severity":1,"message":"4106","line":59,"column":3,"nodeType":"3867","messageId":"3916","endLine":59,"endColumn":14},{"ruleId":"3849","severity":1,"message":"4027","line":77,"column":22,"nodeType":"3854","messageId":"3855","endLine":77,"endColumn":31},{"ruleId":"3837","severity":1,"message":"3838","line":77,"column":28,"nodeType":"3839","messageId":"3840","endLine":77,"endColumn":31,"suggestions":"4107"},{"ruleId":"3868","severity":1,"message":"3869","line":85,"column":23,"nodeType":"3870","messageId":"3871","endLine":85,"endColumn":32,"suggestions":"4108"},{"ruleId":"3879","severity":1,"message":"3880","line":91,"column":11,"nodeType":"3881","messageId":"3882","endLine":91,"endColumn":60},{"ruleId":"3883","severity":1,"message":"4109","line":91,"column":26,"nodeType":"3885","messageId":"3886","endLine":91,"endColumn":49},{"ruleId":"3888","severity":1,"message":"3889","line":91,"column":26,"nodeType":"3885","messageId":"3890","endLine":91,"endColumn":49},{"ruleId":"3868","severity":1,"message":"3869","line":91,"column":27,"nodeType":"3870","messageId":"3871","endLine":91,"endColumn":36},{"ruleId":"3837","severity":1,"message":"3838","line":91,"column":40,"nodeType":"3839","messageId":"3840","endLine":91,"endColumn":43,"suggestions":"4110"},{"ruleId":"3845","severity":1,"message":"3872","line":93,"column":5,"nodeType":"3863","messageId":"3848","endLine":93,"endColumn":19},{"ruleId":"3873","severity":1,"message":"4111","line":2,"column":10,"nodeType":"3854","endLine":2,"endColumn":16},{"ruleId":"3873","severity":1,"message":"4112","line":4,"column":10,"nodeType":"3854","endLine":4,"endColumn":33},{"ruleId":"3837","severity":1,"message":"3838","line":43,"column":22,"nodeType":"3839","messageId":"3840","endLine":43,"endColumn":25,"suggestions":"4113"},{"ruleId":"3879","severity":1,"message":"3880","line":109,"column":5,"nodeType":"3928","messageId":"3882","endLine":109,"endColumn":29},{"ruleId":"3888","severity":1,"message":"3889","line":109,"column":20,"nodeType":"3854","messageId":"3890","endLine":109,"endColumn":27},{"ruleId":"3837","severity":1,"message":"3838","line":92,"column":24,"nodeType":"3839","messageId":"3840","endLine":92,"endColumn":27,"suggestions":"4114"},{"ruleId":"3837","severity":1,"message":"3838","line":110,"column":40,"nodeType":"3839","messageId":"3840","endLine":110,"endColumn":43,"suggestions":"4115"},{"ruleId":"3837","severity":1,"message":"3838","line":110,"column":50,"nodeType":"3839","messageId":"3840","endLine":110,"endColumn":53,"suggestions":"4116"},{"ruleId":"3849","severity":1,"message":"3850","line":261,"column":3,"nodeType":"3867","messageId":"3852","endLine":261,"endColumn":44},{"ruleId":"3845","severity":1,"message":"3872","line":273,"column":7,"nodeType":"3863","messageId":"3848","endLine":273,"endColumn":18},{"ruleId":"3837","severity":1,"message":"3838","line":295,"column":22,"nodeType":"3839","messageId":"3840","endLine":295,"endColumn":25,"suggestions":"4117"},{"ruleId":"3849","severity":1,"message":"3850","line":339,"column":27,"nodeType":"3851","messageId":"3852","endLine":339,"endColumn":32},{"ruleId":"3849","severity":1,"message":"3850","line":463,"column":42,"nodeType":"3851","messageId":"3852","endLine":463,"endColumn":47},{"ruleId":"3849","severity":1,"message":"3850","line":467,"column":3,"nodeType":"3867","messageId":"3852","endLine":467,"endColumn":120},{"ruleId":"3849","severity":1,"message":"3850","line":496,"column":3,"nodeType":"3867","messageId":"3852","endLine":496,"endColumn":23},{"ruleId":"3849","severity":1,"message":"3850","line":500,"column":3,"nodeType":"3867","messageId":"3852","endLine":500,"endColumn":26},{"ruleId":"3849","severity":1,"message":"3850","line":511,"column":3,"nodeType":"3867","messageId":"3852","endLine":511,"endColumn":125},{"ruleId":"3845","severity":1,"message":"3872","line":684,"column":7,"nodeType":"3863","messageId":"3848","endLine":684,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":711,"column":3,"nodeType":"3867","messageId":"3852","endLine":711,"endColumn":52},{"ruleId":"3914","severity":1,"message":"4118","line":835,"column":3,"nodeType":"3867","messageId":"3916","endLine":835,"endColumn":36},{"ruleId":"3879","severity":1,"message":"4021","line":870,"column":19,"nodeType":"3854","messageId":"4022","endLine":870,"endColumn":27},{"ruleId":"3879","severity":1,"message":"3880","line":884,"column":9,"nodeType":"4068","messageId":"3882","endLine":884,"endColumn":17},{"ruleId":"3837","severity":1,"message":"3838","line":886,"column":12,"nodeType":"3839","messageId":"3840","endLine":886,"endColumn":15,"suggestions":"4119"},{"ruleId":"3849","severity":1,"message":"3850","line":949,"column":3,"nodeType":"3867","messageId":"3852","endLine":949,"endColumn":119},{"ruleId":"3837","severity":1,"message":"3838","line":1013,"column":5,"nodeType":"3839","messageId":"3840","endLine":1013,"endColumn":8,"suggestions":"4120"},{"ruleId":"3879","severity":1,"message":"3880","line":1024,"column":7,"nodeType":"4068","messageId":"3882","endLine":1024,"endColumn":12},{"ruleId":"3914","severity":1,"message":"4121","line":1029,"column":3,"nodeType":"3867","messageId":"3916","endLine":1029,"endColumn":43},{"ruleId":"3845","severity":1,"message":"3872","line":1085,"column":7,"nodeType":"3863","messageId":"3848","endLine":1085,"endColumn":18},{"ruleId":"3914","severity":1,"message":"3917","line":1105,"column":37,"nodeType":"3851","messageId":"3916","endLine":1105,"endColumn":39},{"ruleId":"3979","severity":1,"message":"3980","line":17,"column":18,"nodeType":"3854","messageId":"3981","endLine":17,"endColumn":51,"fix":"4122"},{"ruleId":"3873","severity":1,"message":"4123","line":2,"column":10,"nodeType":"3854","endLine":2,"endColumn":26},{"ruleId":"3873","severity":1,"message":"4124","line":3,"column":10,"nodeType":"3854","endLine":3,"endColumn":24},{"ruleId":"3873","severity":1,"message":"4125","line":4,"column":10,"nodeType":"3854","endLine":4,"endColumn":30},{"ruleId":"3849","severity":1,"message":"3850","line":21,"column":3,"nodeType":"3867","messageId":"3852","endLine":21,"endColumn":11},{"ruleId":"3837","severity":1,"message":"3838","line":48,"column":61,"nodeType":"3839","messageId":"3840","endLine":48,"endColumn":64,"suggestions":"4126"},{"ruleId":"3837","severity":1,"message":"3838","line":63,"column":61,"nodeType":"3839","messageId":"3840","endLine":63,"endColumn":64,"suggestions":"4127"},{"ruleId":"3837","severity":1,"message":"3838","line":71,"column":75,"nodeType":"3839","messageId":"3840","endLine":71,"endColumn":78,"suggestions":"4128"},{"ruleId":"3837","severity":1,"message":"3838","line":76,"column":21,"nodeType":"3839","messageId":"3840","endLine":76,"endColumn":24,"suggestions":"4129"},{"ruleId":"3837","severity":1,"message":"3838","line":95,"column":86,"nodeType":"3839","messageId":"3840","endLine":95,"endColumn":89,"suggestions":"4130"},{"ruleId":"3849","severity":1,"message":"3850","line":121,"column":32,"nodeType":"3851","messageId":"3852","endLine":121,"endColumn":43},{"ruleId":"3914","severity":1,"message":"3917","line":121,"column":41,"nodeType":"3851","messageId":"3916","endLine":121,"endColumn":43},{"ruleId":"3849","severity":1,"message":"3850","line":137,"column":39,"nodeType":"3851","messageId":"3852","endLine":137,"endColumn":50},{"ruleId":"3849","severity":1,"message":"3850","line":148,"column":37,"nodeType":"3851","messageId":"3852","endLine":148,"endColumn":68},{"ruleId":"3837","severity":1,"message":"3838","line":149,"column":27,"nodeType":"3839","messageId":"3840","endLine":149,"endColumn":30,"suggestions":"4131"},{"ruleId":"3883","severity":1,"message":"4132","line":150,"column":11,"nodeType":"3885","messageId":"3886","endLine":150,"endColumn":33},{"ruleId":"3883","severity":1,"message":"4132","line":151,"column":23,"nodeType":"3885","messageId":"3886","endLine":151,"endColumn":45},{"ruleId":"3849","severity":1,"message":"3850","line":166,"column":33,"nodeType":"3851","messageId":"3852","endLine":166,"endColumn":44},{"ruleId":"3849","severity":1,"message":"3850","line":181,"column":3,"nodeType":"3867","messageId":"3852","endLine":181,"endColumn":38},{"ruleId":"3849","severity":1,"message":"3850","line":190,"column":24,"nodeType":"3851","messageId":"3852","endLine":190,"endColumn":35},{"ruleId":"3849","severity":1,"message":"3850","line":201,"column":29,"nodeType":"3851","messageId":"3852","endLine":201,"endColumn":40},{"ruleId":"3849","severity":1,"message":"3850","line":214,"column":3,"nodeType":"3867","messageId":"3852","endLine":214,"endColumn":30},{"ruleId":"3849","severity":1,"message":"3850","line":221,"column":3,"nodeType":"3867","messageId":"3852","endLine":221,"endColumn":32},{"ruleId":"3849","severity":1,"message":"3850","line":246,"column":3,"nodeType":"3867","messageId":"3852","endLine":246,"endColumn":29},{"ruleId":"3849","severity":1,"message":"3850","line":253,"column":3,"nodeType":"3867","messageId":"3852","endLine":253,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":276,"column":41,"nodeType":"3851","messageId":"3852","endLine":278,"endColumn":7},{"ruleId":"3849","severity":1,"message":"3850","line":284,"column":29,"nodeType":"3851","messageId":"3852","endLine":284,"endColumn":93},{"ruleId":"3849","severity":1,"message":"3850","line":304,"column":3,"nodeType":"3867","messageId":"3852","endLine":304,"endColumn":119},{"ruleId":"3849","severity":1,"message":"3850","line":314,"column":30,"nodeType":"3851","messageId":"3852","endLine":314,"endColumn":76},{"ruleId":"3879","severity":1,"message":"3880","line":350,"column":9,"nodeType":"4068","messageId":"3882","endLine":350,"endColumn":14},{"ruleId":"3849","severity":1,"message":"3850","line":355,"column":31,"nodeType":"3851","messageId":"3852","endLine":355,"endColumn":57},{"ruleId":"3849","severity":1,"message":"3850","line":373,"column":57,"nodeType":"3851","messageId":"3852","endLine":373,"endColumn":68},{"ruleId":"3849","severity":1,"message":"3850","line":377,"column":34,"nodeType":"3851","messageId":"3852","endLine":377,"endColumn":45},{"ruleId":"3849","severity":1,"message":"3850","line":385,"column":55,"nodeType":"3851","messageId":"3852","endLine":385,"endColumn":108},{"ruleId":"3914","severity":1,"message":"3917","line":385,"column":106,"nodeType":"3851","messageId":"3916","endLine":385,"endColumn":108},{"ruleId":"3837","severity":1,"message":"3838","line":395,"column":59,"nodeType":"3839","messageId":"3840","endLine":395,"endColumn":62,"suggestions":"4133"},{"ruleId":"3879","severity":1,"message":"4134","line":396,"column":43,"nodeType":"4135","messageId":"4136","endLine":396,"endColumn":77},{"ruleId":"3849","severity":1,"message":"3850","line":401,"column":3,"nodeType":"3867","messageId":"3852","endLine":401,"endColumn":32},{"ruleId":"3849","severity":1,"message":"3850","line":406,"column":3,"nodeType":"3867","messageId":"3852","endLine":406,"endColumn":34},{"ruleId":"3837","severity":1,"message":"3838","line":443,"column":121,"nodeType":"3839","messageId":"3840","endLine":443,"endColumn":124,"suggestions":"4137"},{"ruleId":"3837","severity":1,"message":"3838","line":444,"column":117,"nodeType":"3839","messageId":"3840","endLine":444,"endColumn":120,"suggestions":"4138"},{"ruleId":"3849","severity":1,"message":"3850","line":447,"column":3,"nodeType":"3867","messageId":"3852","endLine":447,"endColumn":47},{"ruleId":"3837","severity":1,"message":"3838","line":467,"column":56,"nodeType":"3839","messageId":"3840","endLine":467,"endColumn":59,"suggestions":"4139"},{"ruleId":"3849","severity":1,"message":"3850","line":10,"column":8,"nodeType":"4057","messageId":"3852","endLine":15,"endColumn":116},{"ruleId":"3849","severity":1,"message":"3850","line":20,"column":3,"nodeType":"3867","messageId":"3852","endLine":20,"endColumn":29},{"ruleId":"3849","severity":1,"message":"3850","line":24,"column":3,"nodeType":"3867","messageId":"3852","endLine":24,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":38,"column":3,"nodeType":"3867","messageId":"3852","endLine":38,"endColumn":44},{"ruleId":"3849","severity":1,"message":"3850","line":43,"column":32,"nodeType":"3851","messageId":"3852","endLine":43,"endColumn":82},{"ruleId":"3849","severity":1,"message":"3850","line":88,"column":39,"nodeType":"3851","messageId":"3852","endLine":88,"endColumn":50},{"ruleId":"3849","severity":1,"message":"3850","line":106,"column":3,"nodeType":"3867","messageId":"3852","endLine":106,"endColumn":36},{"ruleId":"4140","severity":1,"message":"4141","line":112,"column":9,"nodeType":"4142","endLine":112,"endColumn":90},{"ruleId":"3849","severity":1,"message":"3850","line":119,"column":3,"nodeType":"3867","messageId":"3852","endLine":119,"endColumn":31},{"ruleId":"3849","severity":1,"message":"3850","line":132,"column":3,"nodeType":"3867","messageId":"3852","endLine":132,"endColumn":33},{"ruleId":"3873","severity":1,"message":"4143","line":1,"column":10,"nodeType":"3854","endLine":1,"endColumn":38},{"ruleId":"3873","severity":1,"message":"4004","line":3,"column":10,"nodeType":"3854","endLine":3,"endColumn":29},{"ruleId":"3873","severity":1,"message":"4144","line":4,"column":10,"nodeType":"3854","endLine":4,"endColumn":38},{"ruleId":"3849","severity":1,"message":"3850","line":7,"column":37,"nodeType":"3851","messageId":"3852","endLine":7,"endColumn":48},{"ruleId":"3879","severity":1,"message":"3880","line":8,"column":9,"nodeType":"3881","messageId":"3882","endLine":8,"endColumn":45},{"ruleId":"3879","severity":1,"message":"3880","line":10,"column":5,"nodeType":"4068","messageId":"3882","endLine":10,"endColumn":9},{"ruleId":"3849","severity":1,"message":"3850","line":15,"column":26,"nodeType":"3851","messageId":"3852","endLine":15,"endColumn":70},{"ruleId":"3849","severity":1,"message":"3850","line":24,"column":22,"nodeType":"3851","messageId":"3852","endLine":24,"endColumn":33},{"ruleId":"3849","severity":1,"message":"3850","line":28,"column":22,"nodeType":"3851","messageId":"3852","endLine":28,"endColumn":33},{"ruleId":"3879","severity":1,"message":"3880","line":29,"column":11,"nodeType":"3881","messageId":"3882","endLine":29,"endColumn":50},{"ruleId":"3879","severity":1,"message":"3880","line":33,"column":7,"nodeType":"4068","messageId":"3882","endLine":33,"endColumn":12},{"ruleId":"3849","severity":1,"message":"3850","line":37,"column":3,"nodeType":"3867","messageId":"3852","endLine":37,"endColumn":35},{"ruleId":"3849","severity":1,"message":"3850","line":51,"column":3,"nodeType":"3867","messageId":"3852","endLine":51,"endColumn":18},{"ruleId":"3875","severity":1,"message":"3876","line":4,"column":32,"nodeType":"3877","messageId":"3878","endLine":4,"endColumn":38},{"ruleId":"3875","severity":1,"message":"3876","line":7,"column":34,"nodeType":"3877","messageId":"3878","endLine":7,"endColumn":40},{"ruleId":"3875","severity":1,"message":"3999","line":9,"column":37,"nodeType":"3854","messageId":"3878","endLine":9,"endColumn":45},{"ruleId":"3837","severity":1,"message":"3838","line":9,"column":81,"nodeType":"3839","messageId":"3840","endLine":9,"endColumn":84,"suggestions":"4145"},{"ruleId":"3837","severity":1,"message":"3838","line":11,"column":43,"nodeType":"3839","messageId":"3840","endLine":11,"endColumn":46,"suggestions":"4146"},{"ruleId":"3837","severity":1,"message":"3838","line":11,"column":51,"nodeType":"3839","messageId":"3840","endLine":11,"endColumn":54,"suggestions":"4147"},{"ruleId":"3837","severity":1,"message":"3838","line":12,"column":36,"nodeType":"3839","messageId":"3840","endLine":12,"endColumn":39,"suggestions":"4148"},{"ruleId":"3837","severity":1,"message":"3838","line":12,"column":44,"nodeType":"3839","messageId":"3840","endLine":12,"endColumn":47,"suggestions":"4149"},{"ruleId":"3875","severity":1,"message":"3977","line":14,"column":36,"nodeType":"3978","messageId":"3878","endLine":14,"endColumn":38},{"ruleId":"3837","severity":1,"message":"3838","line":20,"column":48,"nodeType":"3839","messageId":"3840","endLine":20,"endColumn":51,"suggestions":"4150"},{"ruleId":"3837","severity":1,"message":"3838","line":20,"column":55,"nodeType":"3839","messageId":"3840","endLine":20,"endColumn":58,"suggestions":"4151"},{"ruleId":"3837","severity":1,"message":"3838","line":22,"column":34,"nodeType":"3839","messageId":"3840","endLine":22,"endColumn":37,"suggestions":"4152"},{"ruleId":"3875","severity":1,"message":"3977","line":24,"column":31,"nodeType":"3978","messageId":"3878","endLine":24,"endColumn":33},{"ruleId":"3837","severity":1,"message":"3838","line":28,"column":56,"nodeType":"3839","messageId":"3840","endLine":28,"endColumn":59,"suggestions":"4153"},{"ruleId":"3837","severity":1,"message":"3838","line":28,"column":66,"nodeType":"3839","messageId":"3840","endLine":28,"endColumn":69,"suggestions":"4154"},{"ruleId":"3837","severity":1,"message":"3838","line":28,"column":90,"nodeType":"3839","messageId":"3840","endLine":28,"endColumn":93,"suggestions":"4155"},{"ruleId":"3837","severity":1,"message":"3838","line":28,"column":117,"nodeType":"3839","messageId":"3840","endLine":28,"endColumn":120,"suggestions":"4156"},{"ruleId":"3875","severity":1,"message":"3999","line":32,"column":36,"nodeType":"3854","messageId":"3878","endLine":32,"endColumn":44},{"ruleId":"3837","severity":1,"message":"3838","line":32,"column":62,"nodeType":"3839","messageId":"3840","endLine":32,"endColumn":65,"suggestions":"4157"},{"ruleId":"3849","severity":1,"message":"4014","line":17,"column":39,"nodeType":"3854","messageId":"3855","endLine":17,"endColumn":51},{"ruleId":"3849","severity":1,"message":"4014","line":18,"column":39,"nodeType":"3854","messageId":"3855","endLine":18,"endColumn":51},{"ruleId":"3849","severity":1,"message":"4014","line":30,"column":11,"nodeType":"3854","messageId":"3855","endLine":30,"endColumn":23},{"ruleId":"3849","severity":1,"message":"4014","line":31,"column":11,"nodeType":"3854","messageId":"3855","endLine":31,"endColumn":23},{"ruleId":"3849","severity":1,"message":"4014","line":35,"column":6,"nodeType":"3854","messageId":"3855","endLine":35,"endColumn":18},{"ruleId":"3849","severity":1,"message":"4014","line":36,"column":6,"nodeType":"3854","messageId":"3855","endLine":36,"endColumn":18},{"ruleId":"3875","severity":1,"message":"3999","line":75,"column":9,"nodeType":"3854","messageId":"3878","endLine":75,"endColumn":17},{"ruleId":"3837","severity":1,"message":"3838","line":6,"column":37,"nodeType":"3839","messageId":"3840","endLine":6,"endColumn":40,"suggestions":"4158"},{"ruleId":"3837","severity":1,"message":"3838","line":6,"column":45,"nodeType":"3839","messageId":"3840","endLine":6,"endColumn":48,"suggestions":"4159"},{"ruleId":"3837","severity":1,"message":"3838","line":8,"column":28,"nodeType":"3839","messageId":"3840","endLine":8,"endColumn":31,"suggestions":"4160"},{"ruleId":"3837","severity":1,"message":"3838","line":5,"column":40,"nodeType":"3839","messageId":"3840","endLine":5,"endColumn":43,"suggestions":"4161"},{"ruleId":"3837","severity":1,"message":"3838","line":5,"column":48,"nodeType":"3839","messageId":"3840","endLine":5,"endColumn":51,"suggestions":"4162"},{"ruleId":"3837","severity":1,"message":"3838","line":8,"column":25,"nodeType":"3839","messageId":"3840","endLine":8,"endColumn":28,"suggestions":"4163"},{"ruleId":"3837","severity":1,"message":"3838","line":6,"column":47,"nodeType":"3839","messageId":"3840","endLine":6,"endColumn":50,"suggestions":"4164"},{"ruleId":"3837","severity":1,"message":"3838","line":6,"column":55,"nodeType":"3839","messageId":"3840","endLine":6,"endColumn":58,"suggestions":"4165"},{"ruleId":"3837","severity":1,"message":"3838","line":9,"column":32,"nodeType":"3839","messageId":"3840","endLine":9,"endColumn":35,"suggestions":"4166"},{"ruleId":"3875","severity":1,"message":"3876","line":18,"column":30,"nodeType":"3877","messageId":"3878","endLine":18,"endColumn":36},{"ruleId":"3837","severity":1,"message":"3838","line":7,"column":21,"nodeType":"3839","messageId":"3840","endLine":7,"endColumn":24,"suggestions":"4167"},{"ruleId":"3979","severity":1,"message":"3980","line":13,"column":20,"nodeType":"3854","messageId":"3981","endLine":13,"endColumn":41,"suggestions":"4168"},{"ruleId":"3837","severity":1,"message":"3838","line":18,"column":23,"nodeType":"3839","messageId":"3840","endLine":18,"endColumn":26,"suggestions":"4169"},{"ruleId":"3837","severity":1,"message":"3838","line":19,"column":21,"nodeType":"3839","messageId":"3840","endLine":19,"endColumn":24,"suggestions":"4170"},{"ruleId":"3875","severity":1,"message":"3977","line":43,"column":20,"nodeType":"3978","messageId":"3878","endLine":43,"endColumn":22},{"ruleId":"3896","severity":1,"message":"3897","line":50,"column":5,"nodeType":"3898","endLine":50,"endColumn":33},{"ruleId":"3849","severity":1,"message":"4014","line":50,"column":17,"nodeType":"3854","messageId":"3855","endLine":50,"endColumn":29},{"ruleId":"3837","severity":1,"message":"3838","line":50,"column":26,"nodeType":"3839","messageId":"3840","endLine":50,"endColumn":29,"suggestions":"4171"},{"ruleId":"3899","severity":1,"message":"3900","line":50,"column":31,"nodeType":"3867","messageId":"3901"},{"ruleId":"3979","severity":1,"message":"3980","line":6,"column":18,"nodeType":"3854","messageId":"3981","endLine":6,"endColumn":26,"fix":"4172"},{"ruleId":"3849","severity":1,"message":"4173","line":4,"column":46,"nodeType":"3854","messageId":"3855","endLine":4,"endColumn":52},{"ruleId":"3837","severity":1,"message":"3838","line":4,"column":49,"nodeType":"3839","messageId":"3840","endLine":4,"endColumn":52,"suggestions":"4174"},{"ruleId":"3837","severity":1,"message":"3838","line":4,"column":66,"nodeType":"3839","messageId":"3840","endLine":4,"endColumn":69,"suggestions":"4175"},{"ruleId":"3837","severity":1,"message":"3838","line":21,"column":71,"nodeType":"3839","messageId":"3840","endLine":21,"endColumn":74,"suggestions":"4176"},{"ruleId":"3837","severity":1,"message":"3838","line":21,"column":96,"nodeType":"3839","messageId":"3840","endLine":21,"endColumn":99,"suggestions":"4177"},{"ruleId":"3837","severity":1,"message":"3838","line":39,"column":64,"nodeType":"3839","messageId":"3840","endLine":39,"endColumn":67,"suggestions":"4178"},{"ruleId":"3837","severity":1,"message":"3838","line":39,"column":89,"nodeType":"3839","messageId":"3840","endLine":39,"endColumn":92,"suggestions":"4179"},{"ruleId":"3849","severity":1,"message":"4180","line":61,"column":60,"nodeType":"3854","messageId":"3855","endLine":61,"endColumn":75},{"ruleId":"3837","severity":1,"message":"3838","line":61,"column":72,"nodeType":"3839","messageId":"3840","endLine":61,"endColumn":75,"suggestions":"4181"},{"ruleId":"3837","severity":1,"message":"3838","line":61,"column":110,"nodeType":"3839","messageId":"3840","endLine":61,"endColumn":113,"suggestions":"4182"},{"ruleId":"3837","severity":1,"message":"3838","line":66,"column":33,"nodeType":"3839","messageId":"3840","endLine":66,"endColumn":36,"suggestions":"4183"},{"ruleId":"3837","severity":1,"message":"3838","line":74,"column":69,"nodeType":"3839","messageId":"3840","endLine":74,"endColumn":72,"suggestions":"4184"},{"ruleId":"3849","severity":1,"message":"3850","line":99,"column":48,"nodeType":"3851","messageId":"3852","endLine":99,"endColumn":73},{"ruleId":"3837","severity":1,"message":"3838","line":115,"column":90,"nodeType":"3839","messageId":"3840","endLine":115,"endColumn":93,"suggestions":"4185"},{"ruleId":"3837","severity":1,"message":"3838","line":122,"column":18,"nodeType":"3839","messageId":"3840","endLine":122,"endColumn":21,"suggestions":"4186"},{"ruleId":"3879","severity":1,"message":"3880","line":125,"column":5,"nodeType":"3928","messageId":"3882","endLine":125,"endColumn":21},{"ruleId":"3837","severity":1,"message":"3838","line":195,"column":58,"nodeType":"3839","messageId":"3840","endLine":195,"endColumn":61,"suggestions":"4187"},{"ruleId":"3837","severity":1,"message":"3838","line":195,"column":80,"nodeType":"3839","messageId":"3840","endLine":195,"endColumn":83,"suggestions":"4188"},{"ruleId":"3849","severity":1,"message":"3904","line":1,"column":30,"nodeType":"3854","messageId":"3855","endLine":1,"endColumn":36},{"ruleId":"3837","severity":1,"message":"3838","line":1,"column":33,"nodeType":"3839","messageId":"3840","endLine":1,"endColumn":36,"suggestions":"4189"},{"ruleId":"3879","severity":1,"message":"3880","line":23,"column":5,"nodeType":"3928","messageId":"3882","endLine":23,"endColumn":40},{"ruleId":"3837","severity":1,"message":"3838","line":13,"column":45,"nodeType":"3839","messageId":"3840","endLine":13,"endColumn":48,"suggestions":"4190"},{"ruleId":"3837","severity":1,"message":"3838","line":13,"column":50,"nodeType":"3839","messageId":"3840","endLine":13,"endColumn":53,"suggestions":"4191"},{"ruleId":"3837","severity":1,"message":"3838","line":13,"column":61,"nodeType":"3839","messageId":"3840","endLine":13,"endColumn":64,"suggestions":"4192"},{"ruleId":"3837","severity":1,"message":"3838","line":13,"column":74,"nodeType":"3839","messageId":"3840","endLine":13,"endColumn":77,"suggestions":"4193"},{"ruleId":"3875","severity":1,"message":"3977","line":13,"column":81,"nodeType":"3978","messageId":"3878","endLine":13,"endColumn":83},{"ruleId":"3849","severity":1,"message":"4194","line":4,"column":34,"nodeType":"3854","messageId":"3855","endLine":4,"endColumn":40},{"ruleId":"3837","severity":1,"message":"3838","line":4,"column":37,"nodeType":"3839","messageId":"3840","endLine":4,"endColumn":40,"suggestions":"4195"},{"ruleId":"3875","severity":1,"message":"3876","line":4,"column":48,"nodeType":"3877","messageId":"3878","endLine":4,"endColumn":54},{"ruleId":"3849","severity":1,"message":"4194","line":8,"column":31,"nodeType":"3854","messageId":"3855","endLine":8,"endColumn":37},{"ruleId":"3837","severity":1,"message":"3838","line":8,"column":34,"nodeType":"3839","messageId":"3840","endLine":8,"endColumn":37,"suggestions":"4196"},{"ruleId":"3875","severity":1,"message":"3876","line":12,"column":34,"nodeType":"3877","messageId":"3878","endLine":12,"endColumn":40},{"ruleId":"3849","severity":1,"message":"4194","line":15,"column":32,"nodeType":"3854","messageId":"3855","endLine":15,"endColumn":38},{"ruleId":"3837","severity":1,"message":"3838","line":15,"column":35,"nodeType":"3839","messageId":"3840","endLine":15,"endColumn":38,"suggestions":"4197"},{"ruleId":"3875","severity":1,"message":"3876","line":15,"column":46,"nodeType":"3877","messageId":"3878","endLine":15,"endColumn":52},{"ruleId":"3837","severity":1,"message":"3838","line":28,"column":46,"nodeType":"3839","messageId":"3840","endLine":28,"endColumn":49,"suggestions":"4198"},{"ruleId":"3837","severity":1,"message":"3838","line":28,"column":74,"nodeType":"3839","messageId":"3840","endLine":28,"endColumn":77,"suggestions":"4199"},{"ruleId":"3845","severity":1,"message":"3872","line":19,"column":5,"nodeType":"3863","messageId":"3848","endLine":19,"endColumn":16},{"ruleId":"3875","severity":1,"message":"3876","line":16,"column":66,"nodeType":"3877","messageId":"3878","endLine":16,"endColumn":72},{"ruleId":"3849","severity":1,"message":"3850","line":27,"column":10,"nodeType":"3851","messageId":"3852","endLine":27,"endColumn":82},{"ruleId":"3875","severity":1,"message":"3876","line":27,"column":19,"nodeType":"3877","messageId":"3878","endLine":27,"endColumn":25},{"ruleId":"3879","severity":1,"message":"3880","line":30,"column":11,"nodeType":"3881","messageId":"3882","endLine":30,"endColumn":88},{"ruleId":"3875","severity":1,"message":"3876","line":17,"column":47,"nodeType":"3877","messageId":"3878","endLine":17,"endColumn":53},{"ruleId":"3875","severity":1,"message":"3977","line":51,"column":94,"nodeType":"3978","messageId":"3878","endLine":51,"endColumn":96},{"ruleId":"3849","severity":1,"message":"3929","line":33,"column":3,"nodeType":"3854","messageId":"3855","endLine":33,"endColumn":11},{"ruleId":"3837","severity":1,"message":"3838","line":33,"column":8,"nodeType":"3839","messageId":"3840","endLine":33,"endColumn":11,"suggestions":"4200"},{"ruleId":"3883","severity":1,"message":"4201","line":38,"column":7,"nodeType":"3885","messageId":"3886","endLine":38,"endColumn":57},{"ruleId":"3883","severity":1,"message":"4202","line":39,"column":28,"nodeType":"3885","messageId":"3886","endLine":39,"endColumn":79},{"ruleId":"3845","severity":1,"message":"3872","line":54,"column":5,"nodeType":"3863","messageId":"3848","endLine":54,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":67,"column":5,"nodeType":"3863","messageId":"3848","endLine":67,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":89,"column":5,"nodeType":"3863","messageId":"3848","endLine":89,"endColumn":16},{"ruleId":"3879","severity":1,"message":"3880","line":113,"column":9,"nodeType":"4068","messageId":"3882","endLine":113,"endColumn":67},{"ruleId":"3879","severity":1,"message":"3880","line":114,"column":9,"nodeType":"4068","messageId":"3882","endLine":114,"endColumn":69},{"ruleId":"3845","severity":1,"message":"3872","line":148,"column":5,"nodeType":"3863","messageId":"3848","endLine":148,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":161,"column":5,"nodeType":"3863","messageId":"3848","endLine":161,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":186,"column":5,"nodeType":"3863","messageId":"3848","endLine":186,"endColumn":16},{"ruleId":"3868","severity":1,"message":"3869","line":209,"column":38,"nodeType":"3870","messageId":"3871","endLine":209,"endColumn":57},{"ruleId":"3837","severity":1,"message":"3838","line":210,"column":44,"nodeType":"3839","messageId":"3840","endLine":210,"endColumn":47,"suggestions":"4203"},{"ruleId":"3845","severity":1,"message":"3846","line":211,"column":25,"nodeType":"4204","messageId":"3848","endLine":211,"endColumn":35},{"ruleId":"3879","severity":1,"message":"3880","line":212,"column":13,"nodeType":"3881","messageId":"3882","endLine":212,"endColumn":40},{"ruleId":"3879","severity":1,"message":"3880","line":213,"column":11,"nodeType":"3881","messageId":"3882","endLine":213,"endColumn":39},{"ruleId":"3879","severity":1,"message":"3880","line":225,"column":9,"nodeType":"4068","messageId":"3882","endLine":225,"endColumn":67},{"ruleId":"3879","severity":1,"message":"3880","line":226,"column":9,"nodeType":"4068","messageId":"3882","endLine":226,"endColumn":69},{"ruleId":"3845","severity":1,"message":"3872","line":231,"column":5,"nodeType":"3863","messageId":"3848","endLine":231,"endColumn":16},{"ruleId":"3879","severity":1,"message":"3880","line":241,"column":13,"nodeType":"3881","messageId":"3882","endLine":241,"endColumn":54},{"ruleId":"3883","severity":1,"message":"4205","line":243,"column":23,"nodeType":"3885","messageId":"3886","endLine":243,"endColumn":81},{"ruleId":"3883","severity":1,"message":"4205","line":244,"column":20,"nodeType":"3885","messageId":"3886","endLine":244,"endColumn":78},{"ruleId":"3883","severity":1,"message":"4205","line":250,"column":11,"nodeType":"3885","messageId":"3886","endLine":250,"endColumn":69},{"ruleId":"3883","severity":1,"message":"4202","line":251,"column":11,"nodeType":"3885","messageId":"3886","endLine":251,"endColumn":72},{"ruleId":"3879","severity":1,"message":"3880","line":259,"column":11,"nodeType":"3928","messageId":"3882","endLine":259,"endColumn":106},{"ruleId":"3883","severity":1,"message":"4202","line":259,"column":11,"nodeType":"3885","messageId":"3886","endLine":259,"endColumn":72},{"ruleId":"3845","severity":1,"message":"3872","line":272,"column":5,"nodeType":"3863","messageId":"3848","endLine":272,"endColumn":16},{"ruleId":"3879","severity":1,"message":"3880","line":285,"column":11,"nodeType":"3881","messageId":"3882","endLine":285,"endColumn":44},{"ruleId":"3845","severity":1,"message":"3872","line":289,"column":5,"nodeType":"3863","messageId":"3848","endLine":289,"endColumn":16},{"ruleId":"3879","severity":1,"message":"3880","line":329,"column":11,"nodeType":"3881","messageId":"3882","endLine":329,"endColumn":84},{"ruleId":"3845","severity":1,"message":"3872","line":331,"column":5,"nodeType":"3863","messageId":"3848","endLine":331,"endColumn":66},{"ruleId":"3879","severity":1,"message":"3880","line":2,"column":3,"nodeType":"3928","messageId":"3882","endLine":2,"endColumn":68},{"ruleId":"3879","severity":1,"message":"3880","line":3,"column":3,"nodeType":"3928","messageId":"3882","endLine":3,"endColumn":76},{"ruleId":"3879","severity":1,"message":"3880","line":4,"column":3,"nodeType":"3928","messageId":"3882","endLine":4,"endColumn":79},{"ruleId":"3883","severity":1,"message":"4206","line":4,"column":3,"nodeType":"3885","messageId":"3886","endLine":4,"endColumn":29},{"ruleId":"3837","severity":1,"message":"3838","line":4,"column":14,"nodeType":"3839","messageId":"3840","endLine":4,"endColumn":17,"suggestions":"4207"},{"ruleId":"3873","severity":1,"message":"4208","line":8,"column":32,"nodeType":"3854","endLine":8,"endColumn":49},{"ruleId":"3845","severity":1,"message":"3872","line":20,"column":5,"nodeType":"3863","messageId":"3848","endLine":20,"endColumn":16},{"ruleId":"3873","severity":1,"message":"4209","line":1,"column":44,"nodeType":"3854","endLine":1,"endColumn":62},{"ruleId":"3845","severity":1,"message":"3872","line":32,"column":5,"nodeType":"3863","messageId":"3848","endLine":32,"endColumn":16},{"ruleId":"3849","severity":1,"message":"3904","line":10,"column":38,"nodeType":"3854","messageId":"3855","endLine":10,"endColumn":44},{"ruleId":"3837","severity":1,"message":"3838","line":10,"column":41,"nodeType":"3839","messageId":"3840","endLine":10,"endColumn":44,"suggestions":"4210"},{"ruleId":"3849","severity":1,"message":"3904","line":14,"column":38,"nodeType":"3854","messageId":"3855","endLine":14,"endColumn":44},{"ruleId":"3837","severity":1,"message":"3838","line":14,"column":41,"nodeType":"3839","messageId":"3840","endLine":14,"endColumn":44,"suggestions":"4211"},{"ruleId":"3849","severity":1,"message":"3904","line":20,"column":41,"nodeType":"3854","messageId":"3855","endLine":20,"endColumn":47},{"ruleId":"3837","severity":1,"message":"3838","line":20,"column":44,"nodeType":"3839","messageId":"3840","endLine":20,"endColumn":47,"suggestions":"4212"},{"ruleId":"3849","severity":1,"message":"3904","line":24,"column":40,"nodeType":"3854","messageId":"3855","endLine":24,"endColumn":46},{"ruleId":"3837","severity":1,"message":"3838","line":24,"column":43,"nodeType":"3839","messageId":"3840","endLine":24,"endColumn":46,"suggestions":"4213"},{"ruleId":"3849","severity":1,"message":"3904","line":28,"column":44,"nodeType":"3854","messageId":"3855","endLine":28,"endColumn":50},{"ruleId":"3837","severity":1,"message":"3838","line":28,"column":47,"nodeType":"3839","messageId":"3840","endLine":28,"endColumn":50,"suggestions":"4214"},{"ruleId":"3849","severity":1,"message":"3904","line":18,"column":29,"nodeType":"3854","messageId":"3855","endLine":18,"endColumn":35},{"ruleId":"3837","severity":1,"message":"3838","line":18,"column":32,"nodeType":"3839","messageId":"3840","endLine":18,"endColumn":35,"suggestions":"4215"},{"ruleId":"3849","severity":1,"message":"4216","line":20,"column":33,"nodeType":"3854","messageId":"3855","endLine":20,"endColumn":45},{"ruleId":"3837","severity":1,"message":"3838","line":20,"column":42,"nodeType":"3839","messageId":"3840","endLine":20,"endColumn":45,"suggestions":"4217"},{"ruleId":"3883","severity":1,"message":"4218","line":21,"column":53,"nodeType":"3885","messageId":"3886","endLine":21,"endColumn":70},{"ruleId":"3883","severity":1,"message":"4219","line":21,"column":109,"nodeType":"3885","messageId":"3886","endLine":21,"endColumn":127},{"ruleId":"3849","severity":1,"message":"4220","line":36,"column":37,"nodeType":"3854","messageId":"3855","endLine":36,"endColumn":51},{"ruleId":"3837","severity":1,"message":"3838","line":36,"column":48,"nodeType":"3839","messageId":"3840","endLine":36,"endColumn":51,"suggestions":"4221"},{"ruleId":"3849","severity":1,"message":"4220","line":39,"column":39,"nodeType":"3854","messageId":"3855","endLine":39,"endColumn":53},{"ruleId":"3837","severity":1,"message":"3838","line":39,"column":50,"nodeType":"3839","messageId":"3840","endLine":39,"endColumn":53,"suggestions":"4222"},{"ruleId":"3849","severity":1,"message":"4220","line":42,"column":43,"nodeType":"3854","messageId":"3855","endLine":42,"endColumn":57},{"ruleId":"3837","severity":1,"message":"3838","line":42,"column":54,"nodeType":"3839","messageId":"3840","endLine":42,"endColumn":57,"suggestions":"4223"},{"ruleId":"3849","severity":1,"message":"4220","line":45,"column":43,"nodeType":"3854","messageId":"3855","endLine":45,"endColumn":57},{"ruleId":"3837","severity":1,"message":"3838","line":45,"column":54,"nodeType":"3839","messageId":"3840","endLine":45,"endColumn":57,"suggestions":"4224"},{"ruleId":"3849","severity":1,"message":"4216","line":48,"column":49,"nodeType":"3854","messageId":"3855","endLine":48,"endColumn":61},{"ruleId":"3837","severity":1,"message":"3838","line":48,"column":58,"nodeType":"3839","messageId":"3840","endLine":48,"endColumn":61,"suggestions":"4225"},{"ruleId":"3875","severity":1,"message":"3876","line":52,"column":34,"nodeType":"3877","messageId":"3878","endLine":52,"endColumn":40},{"ruleId":"3849","severity":1,"message":"3929","line":73,"column":24,"nodeType":"3854","messageId":"3855","endLine":73,"endColumn":32},{"ruleId":"3837","severity":1,"message":"3838","line":73,"column":29,"nodeType":"3839","messageId":"3840","endLine":73,"endColumn":32,"suggestions":"4226"},{"ruleId":"3879","severity":1,"message":"3880","line":74,"column":7,"nodeType":"3881","messageId":"3882","endLine":74,"endColumn":22},{"ruleId":"3879","severity":1,"message":"3880","line":78,"column":7,"nodeType":"3928","messageId":"3882","endLine":78,"endColumn":34},{"ruleId":"3845","severity":1,"message":"3872","line":80,"column":7,"nodeType":"3863","messageId":"3848","endLine":80,"endColumn":16},{"ruleId":"3849","severity":1,"message":"3929","line":92,"column":31,"nodeType":"3854","messageId":"3855","endLine":92,"endColumn":39},{"ruleId":"3837","severity":1,"message":"3838","line":92,"column":36,"nodeType":"3839","messageId":"3840","endLine":92,"endColumn":39,"suggestions":"4227"},{"ruleId":"3849","severity":1,"message":"3929","line":94,"column":30,"nodeType":"3854","messageId":"3855","endLine":94,"endColumn":38},{"ruleId":"3837","severity":1,"message":"3838","line":94,"column":35,"nodeType":"3839","messageId":"3840","endLine":94,"endColumn":38,"suggestions":"4228"},{"ruleId":"3875","severity":1,"message":"3876","line":7,"column":51,"nodeType":"3877","messageId":"3878","endLine":7,"endColumn":57},{"ruleId":"3875","severity":1,"message":"3876","line":29,"column":47,"nodeType":"3877","messageId":"3878","endLine":29,"endColumn":53},{"ruleId":"3845","severity":1,"message":"3872","line":26,"column":5,"nodeType":"3863","messageId":"3848","endLine":26,"endColumn":16},{"ruleId":"3875","severity":1,"message":"3876","line":32,"column":43,"nodeType":"3877","messageId":"3878","endLine":32,"endColumn":49},{"ruleId":"3873","severity":1,"message":"4229","line":15,"column":24,"nodeType":"3854","endLine":15,"endColumn":33},{"ruleId":"3845","severity":1,"message":"3872","line":36,"column":5,"nodeType":"3863","messageId":"3848","endLine":36,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":55,"column":5,"nodeType":"3863","messageId":"3848","endLine":55,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":80,"column":5,"nodeType":"3863","messageId":"3848","endLine":80,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":109,"column":5,"nodeType":"3863","messageId":"3848","endLine":109,"endColumn":16},{"ruleId":"3873","severity":1,"message":"4230","line":25,"column":10,"nodeType":"3854","endLine":25,"endColumn":38},{"ruleId":"3849","severity":1,"message":"3929","line":30,"column":3,"nodeType":"3854","messageId":"3855","endLine":30,"endColumn":11},{"ruleId":"3837","severity":1,"message":"3838","line":30,"column":8,"nodeType":"3839","messageId":"3840","endLine":30,"endColumn":11,"suggestions":"4231"},{"ruleId":"3883","severity":1,"message":"4232","line":35,"column":7,"nodeType":"3885","messageId":"3886","endLine":35,"endColumn":47},{"ruleId":"3883","severity":1,"message":"4233","line":36,"column":28,"nodeType":"3885","messageId":"3886","endLine":36,"endColumn":69},{"ruleId":"3845","severity":1,"message":"3872","line":48,"column":5,"nodeType":"3863","messageId":"3848","endLine":48,"endColumn":16},{"ruleId":"3849","severity":1,"message":"3850","line":56,"column":32,"nodeType":"3851","messageId":"3852","endLine":56,"endColumn":65},{"ruleId":"3849","severity":1,"message":"3850","line":60,"column":40,"nodeType":"3851","messageId":"3852","endLine":60,"endColumn":73},{"ruleId":"3879","severity":1,"message":"3880","line":89,"column":9,"nodeType":"4068","messageId":"3882","endLine":89,"endColumn":57},{"ruleId":"3879","severity":1,"message":"3880","line":90,"column":9,"nodeType":"4068","messageId":"3882","endLine":90,"endColumn":59},{"ruleId":"3845","severity":1,"message":"3872","line":124,"column":5,"nodeType":"3863","messageId":"3848","endLine":124,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":137,"column":5,"nodeType":"3863","messageId":"3848","endLine":137,"endColumn":16},{"ruleId":"3875","severity":1,"message":"3876","line":141,"column":32,"nodeType":"3877","messageId":"3878","endLine":141,"endColumn":38},{"ruleId":"3875","severity":1,"message":"3876","line":147,"column":38,"nodeType":"3877","messageId":"3878","endLine":147,"endColumn":44},{"ruleId":"3875","severity":1,"message":"3876","line":149,"column":39,"nodeType":"3877","messageId":"3878","endLine":149,"endColumn":45},{"ruleId":"3845","severity":1,"message":"3872","line":162,"column":13,"nodeType":"3863","messageId":"3848","endLine":162,"endColumn":24},{"ruleId":"3845","severity":1,"message":"3872","line":171,"column":13,"nodeType":"3863","messageId":"3848","endLine":171,"endColumn":24},{"ruleId":"3879","severity":1,"message":"3880","line":175,"column":13,"nodeType":"3881","messageId":"3882","endLine":175,"endColumn":40},{"ruleId":"3879","severity":1,"message":"3880","line":176,"column":11,"nodeType":"3881","messageId":"3882","endLine":176,"endColumn":39},{"ruleId":"3879","severity":1,"message":"3880","line":188,"column":9,"nodeType":"4068","messageId":"3882","endLine":188,"endColumn":57},{"ruleId":"3879","severity":1,"message":"3880","line":189,"column":9,"nodeType":"4068","messageId":"3882","endLine":189,"endColumn":59},{"ruleId":"3845","severity":1,"message":"3872","line":194,"column":5,"nodeType":"3863","messageId":"3848","endLine":194,"endColumn":16},{"ruleId":"3879","severity":1,"message":"3880","line":204,"column":13,"nodeType":"3881","messageId":"3882","endLine":204,"endColumn":54},{"ruleId":"3883","severity":1,"message":"4234","line":206,"column":23,"nodeType":"3885","messageId":"3886","endLine":206,"endColumn":71},{"ruleId":"3883","severity":1,"message":"4234","line":207,"column":20,"nodeType":"3885","messageId":"3886","endLine":207,"endColumn":68},{"ruleId":"3883","severity":1,"message":"4234","line":213,"column":11,"nodeType":"3885","messageId":"3886","endLine":213,"endColumn":59},{"ruleId":"3883","severity":1,"message":"4233","line":214,"column":11,"nodeType":"3885","messageId":"3886","endLine":214,"endColumn":62},{"ruleId":"3879","severity":1,"message":"3880","line":222,"column":11,"nodeType":"3928","messageId":"3882","endLine":222,"endColumn":96},{"ruleId":"3883","severity":1,"message":"4233","line":222,"column":11,"nodeType":"3885","messageId":"3886","endLine":222,"endColumn":62},{"ruleId":"3845","severity":1,"message":"3872","line":232,"column":5,"nodeType":"3863","messageId":"3848","endLine":232,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":240,"column":5,"nodeType":"3863","messageId":"3848","endLine":240,"endColumn":16},{"ruleId":"3879","severity":1,"message":"3880","line":277,"column":11,"nodeType":"3881","messageId":"3882","endLine":277,"endColumn":84},{"ruleId":"3845","severity":1,"message":"3872","line":279,"column":5,"nodeType":"3863","messageId":"3848","endLine":279,"endColumn":66},{"ruleId":"3845","severity":1,"message":"3872","line":14,"column":5,"nodeType":"3863","messageId":"3848","endLine":14,"endColumn":16},{"ruleId":"3849","severity":1,"message":"4235","line":38,"column":29,"nodeType":"3854","messageId":"3855","endLine":38,"endColumn":38},{"ruleId":"3849","severity":1,"message":"3850","line":3,"column":33,"nodeType":"3851","messageId":"3852","endLine":3,"endColumn":49},{"ruleId":"3849","severity":1,"message":"3850","line":10,"column":34,"nodeType":"3851","messageId":"3852","endLine":10,"endColumn":73},{"ruleId":"3845","severity":1,"message":"3872","line":21,"column":5,"nodeType":"3863","messageId":"3848","endLine":21,"endColumn":16},{"ruleId":"3849","severity":1,"message":"3850","line":3,"column":29,"nodeType":"3851","messageId":"3852","endLine":3,"endColumn":34},{"ruleId":"3873","severity":1,"message":"4236","line":21,"column":10,"nodeType":"3854","endLine":21,"endColumn":25},{"ruleId":"3837","severity":1,"message":"3838","line":24,"column":28,"nodeType":"3839","messageId":"3840","endLine":24,"endColumn":31,"suggestions":"4237"},{"ruleId":"3845","severity":1,"message":"3872","line":24,"column":36,"nodeType":"3854","messageId":"3848","endLine":24,"endColumn":42},{"ruleId":"3837","severity":1,"message":"3838","line":25,"column":29,"nodeType":"3839","messageId":"3840","endLine":25,"endColumn":32,"suggestions":"4238"},{"ruleId":"3845","severity":1,"message":"3872","line":25,"column":37,"nodeType":"3854","messageId":"3848","endLine":25,"endColumn":43},{"ruleId":"3849","severity":1,"message":"3850","line":30,"column":33,"nodeType":"3851","messageId":"3852","endLine":30,"endColumn":47},{"ruleId":"3849","severity":1,"message":"4239","line":30,"column":34,"nodeType":"3854","messageId":"3855","endLine":30,"endColumn":43},{"ruleId":"3837","severity":1,"message":"3838","line":30,"column":40,"nodeType":"3839","messageId":"3840","endLine":30,"endColumn":43,"suggestions":"4240"},{"ruleId":"3879","severity":1,"message":"3880","line":32,"column":9,"nodeType":"3881","messageId":"3882","endLine":32,"endColumn":33},{"ruleId":"3883","severity":1,"message":"4241","line":32,"column":20,"nodeType":"3885","messageId":"3886","endLine":32,"endColumn":33},{"ruleId":"3879","severity":1,"message":"3880","line":33,"column":9,"nodeType":"3881","messageId":"3882","endLine":33,"endColumn":33},{"ruleId":"3883","severity":1,"message":"4242","line":33,"column":20,"nodeType":"3885","messageId":"3886","endLine":33,"endColumn":33},{"ruleId":"3879","severity":1,"message":"3880","line":35,"column":9,"nodeType":"3881","messageId":"3882","endLine":35,"endColumn":46},{"ruleId":"3883","severity":1,"message":"4243","line":35,"column":25,"nodeType":"3885","messageId":"3886","endLine":35,"endColumn":36},{"ruleId":"3883","severity":1,"message":"4244","line":38,"column":3,"nodeType":"3885","messageId":"3886","endLine":38,"endColumn":22},{"ruleId":"3888","severity":1,"message":"3889","line":38,"column":3,"nodeType":"3885","messageId":"3890","endLine":38,"endColumn":26},{"ruleId":"3888","severity":1,"message":"3889","line":38,"column":27,"nodeType":"3854","messageId":"3890","endLine":38,"endColumn":36},{"ruleId":"3879","severity":1,"message":"3880","line":43,"column":9,"nodeType":"3881","messageId":"3882","endLine":43,"endColumn":75},{"ruleId":"3888","severity":1,"message":"4006","line":43,"column":30,"nodeType":"4007","messageId":"4008","endLine":43,"endColumn":75},{"ruleId":"3879","severity":1,"message":"3880","line":44,"column":9,"nodeType":"3881","messageId":"3882","endLine":44,"endColumn":97},{"ruleId":"3888","severity":1,"message":"4006","line":44,"column":33,"nodeType":"4007","messageId":"4008","endLine":44,"endColumn":97},{"ruleId":"3883","severity":1,"message":"4245","line":44,"column":60,"nodeType":"3885","messageId":"3886","endLine":44,"endColumn":71},{"ruleId":"3845","severity":1,"message":"3872","line":47,"column":3,"nodeType":"3863","messageId":"3848","endLine":181,"endColumn":5},{"ruleId":"3888","severity":1,"message":"4006","line":47,"column":10,"nodeType":"4007","messageId":"4008","endLine":181,"endColumn":4},{"ruleId":"3879","severity":1,"message":"3880","line":49,"column":7,"nodeType":"4068","messageId":"3882","endLine":49,"endColumn":15},{"ruleId":"3879","severity":1,"message":"3880","line":50,"column":7,"nodeType":"4068","messageId":"3882","endLine":50,"endColumn":15},{"ruleId":"3879","severity":1,"message":"3880","line":87,"column":9,"nodeType":"4068","messageId":"3882","endLine":87,"endColumn":20},{"ruleId":"3879","severity":1,"message":"3880","line":89,"column":9,"nodeType":"4068","messageId":"3882","endLine":89,"endColumn":29},{"ruleId":"3879","severity":1,"message":"3880","line":98,"column":13,"nodeType":"4068","messageId":"3882","endLine":98,"endColumn":32},{"ruleId":"3879","severity":1,"message":"3880","line":109,"column":13,"nodeType":"4068","messageId":"3882","endLine":109,"endColumn":28},{"ruleId":"3883","severity":1,"message":"4245","line":109,"column":17,"nodeType":"3885","messageId":"3886","endLine":109,"endColumn":28},{"ruleId":"3873","severity":1,"message":"4246","line":12,"column":10,"nodeType":"3854","endLine":12,"endColumn":29},{"ruleId":"3873","severity":1,"message":"4247","line":14,"column":7,"nodeType":"3854","endLine":14,"endColumn":17},{"ruleId":"3873","severity":1,"message":"4248","line":19,"column":7,"nodeType":"3854","endLine":19,"endColumn":21},{"ruleId":"3873","severity":1,"message":"4249","line":24,"column":7,"nodeType":"3854","endLine":24,"endColumn":21},{"ruleId":"3849","severity":1,"message":"3850","line":7,"column":38,"nodeType":"3851","messageId":"3852","endLine":7,"endColumn":116},{"ruleId":"3875","severity":1,"message":"3876","line":7,"column":55,"nodeType":"3877","messageId":"3878","endLine":7,"endColumn":61},{"ruleId":"3879","severity":1,"message":"3880","line":13,"column":11,"nodeType":"3881","messageId":"3882","endLine":15,"endColumn":7},{"ruleId":"3883","severity":1,"message":"4250","line":13,"column":24,"nodeType":"3885","messageId":"3886","endLine":13,"endColumn":35},{"ruleId":"3888","severity":1,"message":"3889","line":13,"column":24,"nodeType":"3885","messageId":"3890","endLine":13,"endColumn":35},{"ruleId":"3883","severity":1,"message":"4251","line":20,"column":11,"nodeType":"3885","messageId":"3886","endLine":20,"endColumn":22},{"ruleId":"3888","severity":1,"message":"3889","line":20,"column":11,"nodeType":"3885","messageId":"3890","endLine":20,"endColumn":32},{"ruleId":"3883","severity":1,"message":"4252","line":27,"column":11,"nodeType":"3885","messageId":"3886","endLine":27,"endColumn":36},{"ruleId":"3837","severity":1,"message":"3838","line":27,"column":22,"nodeType":"3839","messageId":"3840","endLine":27,"endColumn":25,"suggestions":"4253"},{"ruleId":"3883","severity":1,"message":"4251","line":28,"column":15,"nodeType":"3885","messageId":"3886","endLine":28,"endColumn":26},{"ruleId":"3888","severity":1,"message":"3889","line":28,"column":15,"nodeType":"3885","messageId":"3890","endLine":28,"endColumn":34},{"ruleId":"3845","severity":1,"message":"3872","line":32,"column":5,"nodeType":"3863","messageId":"3848","endLine":32,"endColumn":17},{"ruleId":"3868","severity":1,"message":"3869","line":34,"column":18,"nodeType":"3870","messageId":"3871","endLine":34,"endColumn":24},{"ruleId":"3845","severity":1,"message":"3872","line":21,"column":7,"nodeType":"3863","messageId":"3848","endLine":21,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":39,"column":5,"nodeType":"3863","messageId":"3848","endLine":39,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":68,"column":5,"nodeType":"3863","messageId":"3848","endLine":68,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":103,"column":5,"nodeType":"3863","messageId":"3848","endLine":103,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":120,"column":5,"nodeType":"3863","messageId":"3848","endLine":120,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":161,"column":5,"nodeType":"3863","messageId":"3848","endLine":161,"endColumn":16},{"ruleId":"3879","severity":1,"message":"3880","line":167,"column":11,"nodeType":"3881","messageId":"3882","endLine":167,"endColumn":110},{"ruleId":"3845","severity":1,"message":"3872","line":173,"column":5,"nodeType":"3863","messageId":"3848","endLine":173,"endColumn":16},{"ruleId":"3849","severity":1,"message":"3850","line":6,"column":8,"nodeType":"4057","messageId":"3852","endLine":6,"endColumn":63},{"ruleId":"3837","severity":1,"message":"3838","line":7,"column":66,"nodeType":"3839","messageId":"3840","endLine":7,"endColumn":69,"suggestions":"4254"},{"ruleId":"3849","severity":1,"message":"3850","line":9,"column":8,"nodeType":"4057","messageId":"3852","endLine":9,"endColumn":58},{"ruleId":"3849","severity":1,"message":"3850","line":35,"column":41,"nodeType":"3851","messageId":"3852","endLine":35,"endColumn":124},{"ruleId":"3845","severity":1,"message":"3872","line":76,"column":5,"nodeType":"3863","messageId":"3848","endLine":76,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":93,"column":5,"nodeType":"3863","messageId":"3848","endLine":93,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":119,"column":5,"nodeType":"3863","messageId":"3848","endLine":119,"endColumn":16},{"ruleId":"3845","severity":1,"message":"3872","line":130,"column":5,"nodeType":"3863","messageId":"3848","endLine":130,"endColumn":16},{"ruleId":"3875","severity":1,"message":"3876","line":21,"column":59,"nodeType":"3877","messageId":"3878","endLine":21,"endColumn":65},{"ruleId":"3875","severity":1,"message":"3876","line":23,"column":42,"nodeType":"3877","messageId":"3878","endLine":23,"endColumn":48},{"ruleId":"3849","severity":1,"message":"3963","line":23,"column":50,"nodeType":"3854","messageId":"3855","endLine":23,"endColumn":60},{"ruleId":"3837","severity":1,"message":"3838","line":23,"column":57,"nodeType":"3839","messageId":"3840","endLine":23,"endColumn":60,"suggestions":"4255"},{"ruleId":"3875","severity":1,"message":"3876","line":27,"column":66,"nodeType":"3877","messageId":"3878","endLine":27,"endColumn":72},{"ruleId":"3875","severity":1,"message":"3876","line":29,"column":49,"nodeType":"3877","messageId":"3878","endLine":29,"endColumn":55},{"ruleId":"3849","severity":1,"message":"3963","line":29,"column":57,"nodeType":"3854","messageId":"3855","endLine":29,"endColumn":67},{"ruleId":"3837","severity":1,"message":"3838","line":29,"column":64,"nodeType":"3839","messageId":"3840","endLine":29,"endColumn":67,"suggestions":"4256"},{"ruleId":"3849","severity":1,"message":"3850","line":10,"column":3,"nodeType":"3867","messageId":"3852","endLine":10,"endColumn":11},{"ruleId":"3849","severity":1,"message":"3850","line":72,"column":3,"nodeType":"3867","messageId":"3852","endLine":72,"endColumn":102},{"ruleId":"3849","severity":1,"message":"3850","line":77,"column":3,"nodeType":"3867","messageId":"3852","endLine":77,"endColumn":16},{"ruleId":"3849","severity":1,"message":"3850","line":81,"column":3,"nodeType":"3867","messageId":"3852","endLine":81,"endColumn":22},{"ruleId":"3837","severity":1,"message":"3838","line":203,"column":42,"nodeType":"3839","messageId":"3840","endLine":203,"endColumn":45,"suggestions":"4257"},{"ruleId":"3837","severity":1,"message":"3838","line":5,"column":46,"nodeType":"3839","messageId":"3840","endLine":5,"endColumn":49,"suggestions":"4258"},{"ruleId":"3873","severity":1,"message":"4259","line":57,"column":10,"nodeType":"3854","endLine":57,"endColumn":40},{"ruleId":"3849","severity":1,"message":"3850","line":132,"column":3,"nodeType":"3867","messageId":"3852","endLine":132,"endColumn":38},{"ruleId":"3845","severity":1,"message":"3872","line":242,"column":5,"nodeType":"3863","messageId":"3848","endLine":242,"endColumn":79},{"ruleId":"3888","severity":1,"message":"3889","line":242,"column":13,"nodeType":"4092","messageId":"3890","endLine":242,"endColumn":54},{"ruleId":"3837","severity":1,"message":"3838","line":242,"column":51,"nodeType":"3839","messageId":"3840","endLine":242,"endColumn":54,"suggestions":"4260"},{"ruleId":"3845","severity":1,"message":"3872","line":259,"column":5,"nodeType":"3863","messageId":"3848","endLine":259,"endColumn":76},{"ruleId":"3888","severity":1,"message":"3889","line":259,"column":13,"nodeType":"4092","messageId":"3890","endLine":259,"endColumn":51},{"ruleId":"3837","severity":1,"message":"3838","line":259,"column":48,"nodeType":"3839","messageId":"3840","endLine":259,"endColumn":51,"suggestions":"4261"},{"ruleId":"3845","severity":1,"message":"3872","line":270,"column":5,"nodeType":"3863","messageId":"3848","endLine":270,"endColumn":84},{"ruleId":"3888","severity":1,"message":"3889","line":270,"column":13,"nodeType":"4092","messageId":"3890","endLine":270,"endColumn":59},{"ruleId":"3837","severity":1,"message":"3838","line":270,"column":56,"nodeType":"3839","messageId":"3840","endLine":270,"endColumn":59,"suggestions":"4262"},{"ruleId":"3849","severity":1,"message":"3850","line":414,"column":34,"nodeType":"3851","messageId":"3852","endLine":414,"endColumn":105},{"ruleId":"3883","severity":1,"message":"4070","line":426,"column":60,"nodeType":"3885","messageId":"3886","endLine":426,"endColumn":71},{"ruleId":"3849","severity":1,"message":"3850","line":560,"column":41,"nodeType":"3851","messageId":"3852","endLine":567,"endColumn":7},{"ruleId":"3849","severity":1,"message":"3850","line":579,"column":44,"nodeType":"3851","messageId":"3852","endLine":591,"endColumn":7},{"ruleId":"3849","severity":1,"message":"3850","line":612,"column":43,"nodeType":"3851","messageId":"3852","endLine":622,"endColumn":7},{"ruleId":"3849","severity":1,"message":"3850","line":633,"column":3,"nodeType":"3867","messageId":"3852","endLine":633,"endColumn":34},{"ruleId":"3849","severity":1,"message":"3850","line":771,"column":3,"nodeType":"3867","messageId":"3852","endLine":771,"endColumn":40},{"ruleId":"3849","severity":1,"message":"3850","line":786,"column":3,"nodeType":"3867","messageId":"3852","endLine":786,"endColumn":42},{"ruleId":"3914","severity":1,"message":"4263","line":786,"column":3,"nodeType":"3867","messageId":"3916","endLine":786,"endColumn":40},{"ruleId":"3849","severity":1,"message":"3850","line":812,"column":3,"nodeType":"3867","messageId":"3852","endLine":812,"endColumn":47},{"ruleId":"3849","severity":1,"message":"3850","line":835,"column":3,"nodeType":"3867","messageId":"3852","endLine":841,"endColumn":4},{"ruleId":"3849","severity":1,"message":"3850","line":857,"column":3,"nodeType":"3867","messageId":"3852","endLine":868,"endColumn":4},{"ruleId":"3849","severity":1,"message":"3850","line":19,"column":3,"nodeType":"3867","messageId":"3852","endLine":19,"endColumn":16},{"ruleId":"3849","severity":1,"message":"3850","line":23,"column":3,"nodeType":"3867","messageId":"3852","endLine":23,"endColumn":17},{"ruleId":"3849","severity":1,"message":"3850","line":27,"column":12,"nodeType":"3851","messageId":"3852","endLine":27,"endColumn":17},{"ruleId":"3849","severity":1,"message":"3850","line":33,"column":3,"nodeType":"3867","messageId":"3852","endLine":33,"endColumn":11},{"ruleId":"3837","severity":1,"message":"3838","line":39,"column":53,"nodeType":"3839","messageId":"3840","endLine":39,"endColumn":56,"suggestions":"4264"},{"ruleId":"3837","severity":1,"message":"3838","line":49,"column":103,"nodeType":"3839","messageId":"3840","endLine":49,"endColumn":106,"suggestions":"4265"},{"ruleId":"3837","severity":1,"message":"3838","line":62,"column":100,"nodeType":"3839","messageId":"3840","endLine":62,"endColumn":103,"suggestions":"4266"},{"ruleId":"3837","severity":1,"message":"3838","line":68,"column":53,"nodeType":"3839","messageId":"3840","endLine":68,"endColumn":56,"suggestions":"4267"},{"ruleId":"3837","severity":1,"message":"3838","line":94,"column":119,"nodeType":"3839","messageId":"3840","endLine":94,"endColumn":122,"suggestions":"4268"},{"ruleId":"3849","severity":1,"message":"3850","line":102,"column":19,"nodeType":"3851","messageId":"3852","endLine":102,"endColumn":30},{"ruleId":"3849","severity":1,"message":"3850","line":113,"column":35,"nodeType":"3851","messageId":"3852","endLine":113,"endColumn":46},{"ruleId":"3837","severity":1,"message":"3838","line":119,"column":12,"nodeType":"3839","messageId":"3840","endLine":119,"endColumn":15,"suggestions":"4269"},{"ruleId":"3849","severity":1,"message":"3850","line":128,"column":21,"nodeType":"3851","messageId":"3852","endLine":128,"endColumn":101},{"ruleId":"3849","severity":1,"message":"3850","line":132,"column":28,"nodeType":"3851","messageId":"3852","endLine":132,"endColumn":105},{"ruleId":"3849","severity":1,"message":"3850","line":139,"column":19,"nodeType":"3851","messageId":"3852","endLine":139,"endColumn":30},{"ruleId":"3849","severity":1,"message":"3850","line":156,"column":18,"nodeType":"3851","messageId":"3852","endLine":156,"endColumn":29},{"ruleId":"3837","severity":1,"message":"3838","line":166,"column":40,"nodeType":"3839","messageId":"3840","endLine":166,"endColumn":43,"suggestions":"4270"},{"ruleId":"3914","severity":1,"message":"4271","line":166,"column":47,"nodeType":"3851","messageId":"3916","endLine":166,"endColumn":49},{"ruleId":"3879","severity":1,"message":"4272","line":174,"column":11,"nodeType":"4068","messageId":"4273","endLine":174,"endColumn":64},{"ruleId":"3849","severity":1,"message":"3850","line":244,"column":32,"nodeType":"3851","messageId":"3852","endLine":244,"endColumn":43},{"ruleId":"3883","severity":1,"message":"4070","line":278,"column":13,"nodeType":"3885","messageId":"3886","endLine":278,"endColumn":24},{"ruleId":"3849","severity":1,"message":"3850","line":282,"column":3,"nodeType":"3867","messageId":"3852","endLine":282,"endColumn":22},{"ruleId":"3849","severity":1,"message":"3850","line":290,"column":3,"nodeType":"3867","messageId":"3852","endLine":290,"endColumn":11},{"ruleId":"3883","severity":1,"message":"4070","line":322,"column":52,"nodeType":"3885","messageId":"3886","endLine":322,"endColumn":63},{"ruleId":"3873","severity":1,"message":"4259","line":6,"column":3,"nodeType":"3854","endLine":6,"endColumn":33},{"ruleId":"3849","severity":1,"message":"3850","line":95,"column":39,"nodeType":"3851","messageId":"3852","endLine":107,"endColumn":5},{"ruleId":"3849","severity":1,"message":"3850","line":52,"column":19,"nodeType":"3851","messageId":"3852","endLine":52,"endColumn":30},{"ruleId":"3849","severity":1,"message":"3850","line":69,"column":18,"nodeType":"3851","messageId":"3852","endLine":69,"endColumn":29},{"ruleId":"3837","severity":1,"message":"3838","line":79,"column":40,"nodeType":"3839","messageId":"3840","endLine":79,"endColumn":43,"suggestions":"4274"},{"ruleId":"3914","severity":1,"message":"4271","line":79,"column":47,"nodeType":"3851","messageId":"3916","endLine":79,"endColumn":49},{"ruleId":"3849","severity":1,"message":"4275","line":93,"column":5,"nodeType":"3854","messageId":"3855","endLine":93,"endColumn":26},{"ruleId":"3837","severity":1,"message":"3838","line":93,"column":23,"nodeType":"3839","messageId":"3840","endLine":93,"endColumn":26,"suggestions":"4276"},{"ruleId":"3837","severity":1,"message":"3838","line":94,"column":112,"nodeType":"3839","messageId":"3840","endLine":94,"endColumn":115,"suggestions":"4277"},{"ruleId":"3849","severity":1,"message":"3850","line":107,"column":32,"nodeType":"3851","messageId":"3852","endLine":107,"endColumn":43},{"ruleId":"3883","severity":1,"message":"4070","line":129,"column":13,"nodeType":"3885","messageId":"3886","endLine":129,"endColumn":24},{"ruleId":"3849","severity":1,"message":"3850","line":133,"column":3,"nodeType":"3867","messageId":"3852","endLine":133,"endColumn":11},{"ruleId":"3837","severity":1,"message":"3838","line":4,"column":58,"nodeType":"3839","messageId":"3840","endLine":4,"endColumn":61,"suggestions":"4278"},{"ruleId":"3837","severity":1,"message":"3838","line":8,"column":42,"nodeType":"3839","messageId":"3840","endLine":8,"endColumn":45,"suggestions":"4279"},{"ruleId":"3914","severity":1,"message":"3915","line":17,"column":3,"nodeType":"3867","messageId":"3916","endLine":17,"endColumn":23},{"ruleId":"3845","severity":1,"message":"3872","line":27,"column":7,"nodeType":"3863","messageId":"3848","endLine":27,"endColumn":18},{"ruleId":"3914","severity":1,"message":"4050","line":31,"column":3,"nodeType":"3867","messageId":"3916","endLine":31,"endColumn":26},{"ruleId":"3845","severity":1,"message":"3872","line":41,"column":7,"nodeType":"3863","messageId":"3848","endLine":41,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":60,"column":7,"nodeType":"3863","messageId":"3848","endLine":60,"endColumn":18},{"ruleId":"3914","severity":1,"message":"4052","line":64,"column":3,"nodeType":"3867","messageId":"3916","endLine":64,"endColumn":21},{"ruleId":"3845","severity":1,"message":"3872","line":70,"column":7,"nodeType":"3863","messageId":"3848","endLine":70,"endColumn":18},{"ruleId":"3914","severity":1,"message":"4051","line":74,"column":3,"nodeType":"3867","messageId":"3916","endLine":74,"endColumn":23},{"ruleId":"3845","severity":1,"message":"3872","line":80,"column":7,"nodeType":"3863","messageId":"3848","endLine":80,"endColumn":18},{"ruleId":"3914","severity":1,"message":"4053","line":97,"column":3,"nodeType":"3867","messageId":"3916","endLine":97,"endColumn":19},{"ruleId":"3845","severity":1,"message":"3872","line":102,"column":7,"nodeType":"3863","messageId":"3848","endLine":102,"endColumn":18},{"ruleId":"3845","severity":1,"message":"3872","line":123,"column":7,"nodeType":"3863","messageId":"3848","endLine":123,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":134,"column":3,"nodeType":"3867","messageId":"3852","endLine":134,"endColumn":30},{"ruleId":"3849","severity":1,"message":"3850","line":138,"column":3,"nodeType":"3867","messageId":"3852","endLine":138,"endColumn":32},{"ruleId":"3849","severity":1,"message":"3850","line":142,"column":3,"nodeType":"3867","messageId":"3852","endLine":142,"endColumn":28},{"ruleId":"3849","severity":1,"message":"3850","line":146,"column":3,"nodeType":"3867","messageId":"3852","endLine":146,"endColumn":23},{"ruleId":"3914","severity":1,"message":"3915","line":40,"column":3,"nodeType":"3867","messageId":"3916","endLine":40,"endColumn":16},{"ruleId":"3849","severity":1,"message":"3850","line":275,"column":3,"nodeType":"3867","messageId":"3852","endLine":275,"endColumn":31},{"ruleId":"3845","severity":1,"message":"3872","line":9,"column":3,"nodeType":"4280","messageId":"3848","endLine":20,"endColumn":4},{"ruleId":"3883","severity":1,"message":"4281","line":9,"column":3,"nodeType":"3885","messageId":"3886","endLine":9,"endColumn":38},{"ruleId":"3837","severity":1,"message":"3838","line":9,"column":14,"nodeType":"3839","messageId":"3840","endLine":9,"endColumn":17,"suggestions":"4282"},{"ruleId":"3845","severity":1,"message":"3872","line":23,"column":3,"nodeType":"4280","messageId":"3848","endLine":26,"endColumn":4},{"ruleId":"3883","severity":1,"message":"4283","line":23,"column":3,"nodeType":"3885","messageId":"3886","endLine":23,"endColumn":37},{"ruleId":"3837","severity":1,"message":"3838","line":23,"column":14,"nodeType":"3839","messageId":"3840","endLine":23,"endColumn":17,"suggestions":"4284"},{"ruleId":"3837","severity":1,"message":"3838","line":13,"column":51,"nodeType":"3839","messageId":"3840","endLine":13,"endColumn":54,"suggestions":"4285"},{"ruleId":"3914","severity":1,"message":"3917","line":195,"column":42,"nodeType":"3851","messageId":"3916","endLine":195,"endColumn":44},{"ruleId":"3849","severity":1,"message":"3850","line":204,"column":18,"nodeType":"3851","messageId":"3852","endLine":204,"endColumn":29},{"ruleId":"3914","severity":1,"message":"3917","line":204,"column":27,"nodeType":"3851","messageId":"3916","endLine":204,"endColumn":29},{"ruleId":"3849","severity":1,"message":"3850","line":212,"column":19,"nodeType":"3851","messageId":"3852","endLine":212,"endColumn":30},{"ruleId":"3849","severity":1,"message":"3850","line":294,"column":3,"nodeType":"3867","messageId":"3852","endLine":294,"endColumn":32},{"ruleId":"3849","severity":1,"message":"3850","line":300,"column":3,"nodeType":"3867","messageId":"3852","endLine":300,"endColumn":31},{"ruleId":"3849","severity":1,"message":"3850","line":304,"column":3,"nodeType":"3867","messageId":"3852","endLine":304,"endColumn":31},{"ruleId":"3849","severity":1,"message":"3850","line":308,"column":3,"nodeType":"3867","messageId":"3852","endLine":308,"endColumn":33},{"ruleId":"3849","severity":1,"message":"3850","line":312,"column":3,"nodeType":"3867","messageId":"3852","endLine":312,"endColumn":86},{"ruleId":"3849","severity":1,"message":"3850","line":316,"column":3,"nodeType":"3867","messageId":"3852","endLine":319,"endColumn":4},{"ruleId":"3849","severity":1,"message":"3850","line":335,"column":3,"nodeType":"3867","messageId":"3852","endLine":335,"endColumn":57},{"ruleId":"3849","severity":1,"message":"3850","line":375,"column":43,"nodeType":"3851","messageId":"3852","endLine":380,"endColumn":7},{"ruleId":"3849","severity":1,"message":"3850","line":402,"column":47,"nodeType":"3851","messageId":"3852","endLine":405,"endColumn":7},{"ruleId":"3849","severity":1,"message":"3850","line":409,"column":3,"nodeType":"3867","messageId":"3852","endLine":409,"endColumn":45},{"ruleId":"3849","severity":1,"message":"3850","line":413,"column":3,"nodeType":"3867","messageId":"3852","endLine":413,"endColumn":92},{"ruleId":"3849","severity":1,"message":"3850","line":417,"column":3,"nodeType":"3867","messageId":"3852","endLine":417,"endColumn":58},{"ruleId":"3849","severity":1,"message":"3850","line":423,"column":49,"nodeType":"3851","messageId":"3852","endLine":423,"endColumn":83},{"ruleId":"3849","severity":1,"message":"3850","line":428,"column":43,"nodeType":"3851","messageId":"3852","endLine":428,"endColumn":48},{"ruleId":"3849","severity":1,"message":"3850","line":432,"column":41,"nodeType":"3851","messageId":"3852","endLine":432,"endColumn":46},{"ruleId":"3849","severity":1,"message":"3850","line":436,"column":43,"nodeType":"3851","messageId":"3852","endLine":436,"endColumn":48},{"ruleId":"3849","severity":1,"message":"3850","line":605,"column":3,"nodeType":"3867","messageId":"3852","endLine":605,"endColumn":54},{"ruleId":"3849","severity":1,"message":"3850","line":609,"column":3,"nodeType":"3867","messageId":"3852","endLine":609,"endColumn":56},{"ruleId":"3849","severity":1,"message":"3850","line":726,"column":56,"nodeType":"3851","messageId":"3852","endLine":726,"endColumn":61},{"ruleId":"3849","severity":1,"message":"3850","line":890,"column":3,"nodeType":"3867","messageId":"3852","endLine":890,"endColumn":50},{"ruleId":"3883","severity":1,"message":"4070","line":915,"column":61,"nodeType":"3885","messageId":"3886","endLine":915,"endColumn":72},{"ruleId":"3849","severity":1,"message":"3850","line":931,"column":3,"nodeType":"3867","messageId":"3852","endLine":931,"endColumn":60},{"ruleId":"3883","severity":1,"message":"4070","line":1000,"column":57,"nodeType":"3885","messageId":"3886","endLine":1000,"endColumn":68},{"ruleId":"3914","severity":1,"message":"3917","line":1045,"column":20,"nodeType":"3851","messageId":"3916","endLine":1045,"endColumn":22},{"ruleId":"3849","severity":1,"message":"3850","line":1058,"column":3,"nodeType":"3867","messageId":"3852","endLine":1058,"endColumn":63},{"ruleId":"3849","severity":1,"message":"3850","line":1062,"column":3,"nodeType":"3867","messageId":"3852","endLine":1062,"endColumn":56},{"ruleId":"3849","severity":1,"message":"3850","line":1066,"column":3,"nodeType":"3867","messageId":"3852","endLine":1066,"endColumn":37},{"ruleId":"3849","severity":1,"message":"3850","line":1070,"column":3,"nodeType":"3867","messageId":"3852","endLine":1070,"endColumn":48},{"ruleId":"3849","severity":1,"message":"3850","line":1178,"column":3,"nodeType":"3867","messageId":"3852","endLine":1182,"endColumn":4},{"ruleId":"3849","severity":1,"message":"4286","line":20,"column":3,"nodeType":"3854","messageId":"3855","endLine":20,"endColumn":28},{"ruleId":"3837","severity":1,"message":"3838","line":20,"column":25,"nodeType":"3839","messageId":"3840","endLine":20,"endColumn":28,"suggestions":"4287"},{"ruleId":"3883","severity":1,"message":"4288","line":26,"column":12,"nodeType":"3885","messageId":"3886","endLine":26,"endColumn":39},{"ruleId":"3883","severity":1,"message":"4288","line":27,"column":17,"nodeType":"3885","messageId":"3886","endLine":27,"endColumn":44},{"ruleId":"3883","severity":1,"message":"4289","line":28,"column":12,"nodeType":"3885","messageId":"3886","endLine":28,"endColumn":47},{"ruleId":"3883","severity":1,"message":"4289","line":29,"column":17,"nodeType":"3885","messageId":"3886","endLine":29,"endColumn":52},{"ruleId":"3883","severity":1,"message":"4290","line":30,"column":7,"nodeType":"3885","messageId":"3886","endLine":30,"endColumn":31},{"ruleId":"3883","severity":1,"message":"4290","line":31,"column":19,"nodeType":"3885","messageId":"3886","endLine":31,"endColumn":43},{"ruleId":"3883","severity":1,"message":"4070","line":33,"column":38,"nodeType":"3885","messageId":"3886","endLine":33,"endColumn":66},{"ruleId":"3849","severity":1,"message":"4291","line":19,"column":52,"nodeType":"3854","messageId":"3855","endLine":19,"endColumn":64},{"ruleId":"3837","severity":1,"message":"3838","line":19,"column":61,"nodeType":"3839","messageId":"3840","endLine":19,"endColumn":64,"suggestions":"4292"},{"ruleId":"3883","severity":1,"message":"4293","line":21,"column":17,"nodeType":"3885","messageId":"3886","endLine":21,"endColumn":28},{"ruleId":"3849","severity":1,"message":"4291","line":34,"column":52,"nodeType":"3854","messageId":"3855","endLine":34,"endColumn":64},{"ruleId":"3837","severity":1,"message":"3838","line":34,"column":61,"nodeType":"3839","messageId":"3840","endLine":34,"endColumn":64,"suggestions":"4294"},{"ruleId":"3883","severity":1,"message":"4293","line":36,"column":17,"nodeType":"3885","messageId":"3886","endLine":36,"endColumn":28},{"ruleId":"3849","severity":1,"message":"4291","line":49,"column":64,"nodeType":"3854","messageId":"3855","endLine":49,"endColumn":76},{"ruleId":"3837","severity":1,"message":"3838","line":49,"column":73,"nodeType":"3839","messageId":"3840","endLine":49,"endColumn":76,"suggestions":"4295"},{"ruleId":"3883","severity":1,"message":"4293","line":51,"column":17,"nodeType":"3885","messageId":"3886","endLine":51,"endColumn":28},{"ruleId":"3849","severity":1,"message":"3904","line":3,"column":31,"nodeType":"3854","messageId":"3855","endLine":3,"endColumn":37},{"ruleId":"3837","severity":1,"message":"3838","line":3,"column":34,"nodeType":"3839","messageId":"3840","endLine":3,"endColumn":37,"suggestions":"4296"},{"ruleId":"3837","severity":1,"message":"3838","line":3,"column":61,"nodeType":"3839","messageId":"3840","endLine":3,"endColumn":64,"suggestions":"4297"},{"ruleId":"3883","severity":1,"message":"4298","line":4,"column":44,"nodeType":"3885","messageId":"3886","endLine":4,"endColumn":55},{"ruleId":"3837","severity":1,"message":"3838","line":1,"column":45,"nodeType":"3839","messageId":"3840","endLine":1,"endColumn":48,"suggestions":"4299"},{"ruleId":"3837","severity":1,"message":"3838","line":1,"column":50,"nodeType":"3839","messageId":"3840","endLine":1,"endColumn":53,"suggestions":"4300"},{"ruleId":"3837","severity":1,"message":"3838","line":1,"column":72,"nodeType":"3839","messageId":"3840","endLine":1,"endColumn":75,"suggestions":"4301"},{"ruleId":"3837","severity":1,"message":"3838","line":25,"column":42,"nodeType":"3839","messageId":"3840","endLine":25,"endColumn":45,"suggestions":"4302"},{"ruleId":"3837","severity":1,"message":"3838","line":25,"column":47,"nodeType":"3839","messageId":"3840","endLine":25,"endColumn":50,"suggestions":"4303"},{"ruleId":"3837","severity":1,"message":"3838","line":5,"column":41,"nodeType":"3839","messageId":"3840","endLine":5,"endColumn":44,"suggestions":"4304"},{"ruleId":"3837","severity":1,"message":"3838","line":5,"column":49,"nodeType":"3839","messageId":"3840","endLine":5,"endColumn":52,"suggestions":"4305"},{"ruleId":"3845","severity":1,"message":"4306","line":13,"column":7,"nodeType":"3863","messageId":"3864","endLine":13,"endColumn":27},{"ruleId":"3879","severity":1,"message":"3880","line":16,"column":11,"nodeType":"3881","messageId":"3882","endLine":16,"endColumn":40},{"ruleId":"3845","severity":1,"message":"3872","line":19,"column":5,"nodeType":"3863","messageId":"3848","endLine":19,"endColumn":19},{"ruleId":"3849","severity":1,"message":"3850","line":37,"column":41,"nodeType":"3851","messageId":"3852","endLine":37,"endColumn":87},{"ruleId":"3837","severity":1,"message":"3838","line":37,"column":61,"nodeType":"3839","messageId":"3840","endLine":37,"endColumn":64,"suggestions":"4307"},{"ruleId":"3837","severity":1,"message":"3838","line":37,"column":71,"nodeType":"3839","messageId":"3840","endLine":37,"endColumn":74,"suggestions":"4308"},{"ruleId":"3837","severity":1,"message":"3838","line":38,"column":17,"nodeType":"3839","messageId":"3840","endLine":38,"endColumn":20,"suggestions":"4309"},{"ruleId":"3879","severity":1,"message":"3880","line":46,"column":7,"nodeType":"3928","messageId":"3882","endLine":46,"endColumn":38},{"ruleId":"3845","severity":1,"message":"4310","line":48,"column":5,"nodeType":"3863","messageId":"3864","endLine":48,"endColumn":28},{"ruleId":"3837","severity":1,"message":"3838","line":22,"column":61,"nodeType":"3839","messageId":"3840","endLine":22,"endColumn":64,"suggestions":"4311"},{"ruleId":"3837","severity":1,"message":"3838","line":38,"column":61,"nodeType":"3839","messageId":"3840","endLine":38,"endColumn":64,"suggestions":"4312"},{"ruleId":"3849","severity":1,"message":"3850","line":42,"column":3,"nodeType":"3867","messageId":"3852","endLine":42,"endColumn":11},{"ruleId":"3849","severity":1,"message":"3850","line":1,"column":25,"nodeType":"3851","messageId":"3852","endLine":1,"endColumn":97},{"ruleId":"3879","severity":1,"message":"3880","line":1,"column":14,"nodeType":"3881","messageId":"3882","endLine":1,"endColumn":65},{"ruleId":"3837","severity":1,"message":"3838","line":56,"column":56,"nodeType":"3839","messageId":"3840","endLine":56,"endColumn":59,"suggestions":"4313"},{"ruleId":"3837","severity":1,"message":"3838","line":56,"column":64,"nodeType":"3839","messageId":"3840","endLine":56,"endColumn":67,"suggestions":"4314"},{"ruleId":"3845","severity":1,"message":"3872","line":57,"column":3,"nodeType":"3863","messageId":"3848","endLine":57,"endColumn":107},{"ruleId":"3845","severity":1,"message":"3872","line":57,"column":43,"nodeType":"3847","messageId":"3848","endLine":57,"endColumn":101},{"ruleId":"3883","severity":1,"message":"4315","line":57,"column":43,"nodeType":"3885","messageId":"3886","endLine":57,"endColumn":53},{"ruleId":"3888","severity":1,"message":"3889","line":57,"column":43,"nodeType":"3885","messageId":"3890","endLine":57,"endColumn":53},{"ruleId":"3849","severity":1,"message":"3850","line":8,"column":8,"nodeType":"4057","messageId":"3852","endLine":12,"endColumn":50},{"ruleId":"4316","severity":1,"message":"4317","line":133,"column":3,"nodeType":"4318","messageId":"4319","endLine":140,"endColumn":75},{"ruleId":"3849","severity":1,"message":"4320","line":20,"column":3,"nodeType":"3854","messageId":"3855","endLine":20,"endColumn":26},{"ruleId":"3837","severity":1,"message":"3838","line":20,"column":23,"nodeType":"3839","messageId":"3840","endLine":20,"endColumn":26,"suggestions":"4321"},{"ruleId":"3849","severity":1,"message":"3929","line":36,"column":3,"nodeType":"3854","messageId":"3855","endLine":36,"endColumn":11},{"ruleId":"3837","severity":1,"message":"3838","line":36,"column":8,"nodeType":"3839","messageId":"3840","endLine":36,"endColumn":11,"suggestions":"4322"},{"ruleId":"3849","severity":1,"message":"3850","line":51,"column":3,"nodeType":"3867","messageId":"3852","endLine":53,"endColumn":4},{"ruleId":"3899","severity":1,"message":"4323","line":53,"column":5,"nodeType":"3867","messageId":"3901"},{"ruleId":"3849","severity":1,"message":"3850","line":70,"column":3,"nodeType":"3867","messageId":"3852","endLine":70,"endColumn":31},{"ruleId":"3849","severity":1,"message":"3850","line":26,"column":3,"nodeType":"3867","messageId":"3852","endLine":26,"endColumn":22},{"ruleId":"3837","severity":1,"message":"3838","line":76,"column":28,"nodeType":"3839","messageId":"3840","endLine":76,"endColumn":31,"suggestions":"4324"},{"ruleId":"3837","severity":1,"message":"3838","line":90,"column":28,"nodeType":"3839","messageId":"3840","endLine":90,"endColumn":31,"suggestions":"4325"},{"ruleId":"3849","severity":1,"message":"3850","line":44,"column":3,"nodeType":"3867","messageId":"3852","endLine":44,"endColumn":28},{"ruleId":"3883","severity":1,"message":"4326","line":104,"column":14,"nodeType":"4099","messageId":"3886","endLine":104,"endColumn":101},{"ruleId":"3837","severity":1,"message":"3838","line":104,"column":49,"nodeType":"3839","messageId":"3840","endLine":104,"endColumn":52,"suggestions":"4327"},{"ruleId":"3883","severity":1,"message":"4328","line":108,"column":14,"nodeType":"4099","messageId":"3886","endLine":108,"endColumn":75},{"ruleId":"3837","severity":1,"message":"3838","line":108,"column":49,"nodeType":"3839","messageId":"3840","endLine":108,"endColumn":52,"suggestions":"4329"},{"ruleId":"3849","severity":1,"message":"3850","line":149,"column":3,"nodeType":"3867","messageId":"3852","endLine":149,"endColumn":41},{"ruleId":"3849","severity":1,"message":"3850","line":153,"column":3,"nodeType":"3867","messageId":"3852","endLine":156,"endColumn":4},{"ruleId":"3849","severity":1,"message":"3850","line":182,"column":3,"nodeType":"3867","messageId":"3852","endLine":182,"endColumn":39},{"ruleId":"3849","severity":1,"message":"3850","line":205,"column":3,"nodeType":"3867","messageId":"3852","endLine":209,"endColumn":4},{"ruleId":"3849","severity":1,"message":"3850","line":213,"column":3,"nodeType":"3867","messageId":"3852","endLine":213,"endColumn":99},{"ruleId":"3849","severity":1,"message":"3850","line":63,"column":3,"nodeType":"3867","messageId":"3852","endLine":63,"endColumn":10},{"ruleId":"3849","severity":1,"message":"3850","line":71,"column":3,"nodeType":"3867","messageId":"3852","endLine":71,"endColumn":10},{"ruleId":"3849","severity":1,"message":"3850","line":144,"column":3,"nodeType":"3867","messageId":"3852","endLine":147,"endColumn":4},{"ruleId":"3849","severity":1,"message":"3850","line":33,"column":3,"nodeType":"3867","messageId":"3852","endLine":33,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":149,"column":16,"nodeType":"3851","messageId":"3852","endLine":149,"endColumn":59},{"ruleId":"3849","severity":1,"message":"3850","line":176,"column":19,"nodeType":"3851","messageId":"3852","endLine":176,"endColumn":30},{"ruleId":"3849","severity":1,"message":"3850","line":196,"column":3,"nodeType":"3867","messageId":"3852","endLine":196,"endColumn":22},{"ruleId":"3899","severity":1,"message":"4330","line":196,"column":23,"nodeType":"3867","messageId":"3901"},{"ruleId":"3849","severity":1,"message":"3850","line":199,"column":3,"nodeType":"3867","messageId":"3852","endLine":199,"endColumn":25},{"ruleId":"3849","severity":1,"message":"3850","line":205,"column":3,"nodeType":"3867","messageId":"3852","endLine":205,"endColumn":24},{"ruleId":"3849","severity":1,"message":"3850","line":209,"column":3,"nodeType":"3867","messageId":"3852","endLine":209,"endColumn":26},{"ruleId":"3849","severity":1,"message":"3850","line":213,"column":3,"nodeType":"3867","messageId":"3852","endLine":213,"endColumn":25},{"ruleId":"3849","severity":1,"message":"3850","line":217,"column":3,"nodeType":"3867","messageId":"3852","endLine":217,"endColumn":27},{"ruleId":"3849","severity":1,"message":"3850","line":221,"column":3,"nodeType":"3867","messageId":"3852","endLine":221,"endColumn":28},{"ruleId":"3849","severity":1,"message":"3850","line":236,"column":3,"nodeType":"3867","messageId":"3852","endLine":236,"endColumn":81},{"ruleId":"3845","severity":1,"message":"3872","line":304,"column":7,"nodeType":"3863","messageId":"3848","endLine":304,"endColumn":18},{"ruleId":"3849","severity":1,"message":"3850","line":47,"column":3,"nodeType":"3867","messageId":"3852","endLine":47,"endColumn":76},{"ruleId":"3849","severity":1,"message":"3850","line":67,"column":3,"nodeType":"3867","messageId":"3852","endLine":67,"endColumn":31},{"ruleId":"3883","severity":1,"message":"4331","line":44,"column":45,"nodeType":"3885","messageId":"3886","endLine":44,"endColumn":64},{"ruleId":"3888","severity":1,"message":"3889","line":44,"column":45,"nodeType":"3885","messageId":"3890","endLine":44,"endColumn":64},{"ruleId":"3845","severity":1,"message":"3872","line":109,"column":5,"nodeType":"3863","messageId":"3848","endLine":109,"endColumn":103},{"ruleId":"3883","severity":1,"message":"4332","line":109,"column":12,"nodeType":"3885","messageId":"3886","endLine":109,"endColumn":102},{"ruleId":"3883","severity":1,"message":"4333","line":109,"column":12,"nodeType":"3885","messageId":"3886","endLine":109,"endColumn":39},{"ruleId":"3888","severity":1,"message":"3889","line":109,"column":12,"nodeType":"3885","messageId":"3890","endLine":109,"endColumn":39},{"ruleId":"3849","severity":1,"message":"3850","line":39,"column":27,"nodeType":"3851","messageId":"3852","endLine":39,"endColumn":61},{"ruleId":"3849","severity":1,"message":"3850","line":60,"column":39,"nodeType":"3851","messageId":"3852","endLine":60,"endColumn":74},{"ruleId":"3849","severity":1,"message":"3850","line":64,"column":37,"nodeType":"3851","messageId":"3852","endLine":64,"endColumn":48},{"ruleId":"3849","severity":1,"message":"3850","line":68,"column":26,"nodeType":"3851","messageId":"3852","endLine":68,"endColumn":31},{"ruleId":"3849","severity":1,"message":"3850","line":72,"column":3,"nodeType":"3867","messageId":"3852","endLine":72,"endColumn":30},{"ruleId":"3849","severity":1,"message":"3850","line":76,"column":3,"nodeType":"3867","messageId":"3852","endLine":76,"endColumn":32},{"ruleId":"3849","severity":1,"message":"3850","line":80,"column":3,"nodeType":"3867","messageId":"3852","endLine":80,"endColumn":31},{"ruleId":"3979","severity":1,"message":"3980","line":12,"column":18,"nodeType":"3854","messageId":"3981","endLine":12,"endColumn":29,"fix":"4334"},{"ruleId":"3875","severity":1,"message":"3999","line":10,"column":56,"nodeType":"3854","messageId":"3878","endLine":10,"endColumn":64},{"ruleId":"3837","severity":1,"message":"3838","line":12,"column":31,"nodeType":"3839","messageId":"3840","endLine":12,"endColumn":34,"suggestions":"4335"},{"ruleId":"3879","severity":1,"message":"3880","line":15,"column":9,"nodeType":"3881","messageId":"3882","endLine":15,"endColumn":44},{"ruleId":"3879","severity":1,"message":"3880","line":29,"column":11,"nodeType":"3881","messageId":"3882","endLine":29,"endColumn":44},{"ruleId":"3837","severity":1,"message":"3838","line":30,"column":49,"nodeType":"3839","messageId":"3840","endLine":30,"endColumn":52,"suggestions":"4336"},{"ruleId":"3845","severity":1,"message":"3872","line":33,"column":9,"nodeType":"3863","messageId":"3848","endLine":33,"endColumn":49},{"ruleId":"3883","severity":1,"message":"4337","line":33,"column":16,"nodeType":"3885","messageId":"3886","endLine":33,"endColumn":36},{"ruleId":"3888","severity":1,"message":"3889","line":33,"column":16,"nodeType":"3885","messageId":"3890","endLine":33,"endColumn":36},{"ruleId":"3849","severity":1,"message":"3850","line":85,"column":3,"nodeType":"3867","messageId":"3852","endLine":85,"endColumn":36},{"ruleId":"3837","severity":1,"message":"3838","line":119,"column":48,"nodeType":"3839","messageId":"3840","endLine":119,"endColumn":51,"suggestions":"4338"},{"ruleId":"3845","severity":1,"message":"3872","line":122,"column":7,"nodeType":"3863","messageId":"3848","endLine":122,"endColumn":21},{"ruleId":"3845","severity":1,"message":"4339","line":95,"column":3,"nodeType":"3863","messageId":"3864","endLine":95,"endColumn":57},{"ruleId":"3837","severity":1,"message":"3838","line":29,"column":15,"nodeType":"3839","messageId":"3840","endLine":29,"endColumn":18,"suggestions":"4340"},{"ruleId":"3849","severity":1,"message":"3850","line":25,"column":8,"nodeType":"4057","messageId":"3852","endLine":56,"endColumn":4},{"ruleId":"3849","severity":1,"message":"3850","line":20,"column":8,"nodeType":"4057","messageId":"3852","endLine":33,"endColumn":4},{"ruleId":"3914","severity":1,"message":"4341","line":19,"column":3,"nodeType":"3867","messageId":"3916","endLine":19,"endColumn":30},{"ruleId":"3914","severity":1,"message":"4342","line":30,"column":3,"nodeType":"3867","messageId":"3916","endLine":30,"endColumn":33},{"ruleId":"3837","severity":1,"message":"3838","line":70,"column":16,"nodeType":"3839","messageId":"3840","endLine":70,"endColumn":19,"suggestions":"4343"},{"ruleId":"3837","severity":1,"message":"3838","line":79,"column":16,"nodeType":"3839","messageId":"3840","endLine":79,"endColumn":19,"suggestions":"4344"},{"ruleId":"3873","severity":1,"message":"4345","line":105,"column":11,"nodeType":"3854","endLine":105,"endColumn":17},{"ruleId":"4346","severity":2,"message":"4347","line":130,"column":11,"nodeType":"3854","messageId":"4348","endLine":130,"endColumn":20,"fix":"4349"},{"ruleId":"4346","severity":2,"message":"4347","line":138,"column":11,"nodeType":"3854","messageId":"4348","endLine":138,"endColumn":20,"fix":"4350"},{"ruleId":"3837","severity":1,"message":"3838","line":207,"column":44,"nodeType":"3839","messageId":"3840","endLine":207,"endColumn":47,"suggestions":"4351"},{"ruleId":"3873","severity":1,"message":"4352","line":2,"column":10,"nodeType":"3854","endLine":2,"endColumn":47},{"ruleId":"3899","severity":1,"message":"4353","line":8,"column":62,"nodeType":"3851","messageId":"3901"},{"ruleId":"3849","severity":1,"message":"3850","line":24,"column":50,"nodeType":"3851","messageId":"3852","endLine":109,"endColumn":5},{"ruleId":"3873","severity":1,"message":"4354","line":1,"column":48,"nodeType":"3854","endLine":1,"endColumn":79},"Parsing error: \"parserOptions.project\" has been set for @typescript-eslint/parser.\nThe file does not match your project config: docs/assets/js/main.js.\nThe file must be included in at least one of the projects provided.","Parsing error: \"parserOptions.project\" has been set for @typescript-eslint/parser.\nThe file does not match your project config: docs/assets/js/search.js.\nThe file must be included in at least one of the projects provided.","Parsing error: \"parserOptions.project\" has been set for @typescript-eslint/parser.\nThe file does not match your project config: module-build/index.js.\nThe file must be included in at least one of the projects provided.","Parsing error: \"parserOptions.project\" has been set for @typescript-eslint/parser.\nThe file does not match your project config: module-build/module-build.js.\nThe file must be included in at least one of the projects provided.","@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["4355","4356"],["4357","4358"],["4359","4360"],["4361","4362"],"@typescript-eslint/no-unsafe-return","Unsafe return of an any[] typed value","CallExpression","unsafeReturn","@typescript-eslint/explicit-module-boundary-types","Missing return type on function.","ArrowFunctionExpression","missingReturnType","Argument 'promiseProvider' should be typed with a non-any type.","Identifier","anyTypedArg",["4363","4364"],["4365","4366"],["4367","4368"],["4369","4370"],["4371","4372"],["4373","4374"],"Unsafe return of type Promise<any> from function with return type Promise<T | Error>.","ReturnStatement","unsafeReturnAssignment",["4375","4376"],["4377","4378"],"FunctionExpression","@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull","Unsafe return of an any typed value","@typescript-eslint/no-unused-vars","'result' is assigned a value but never used.","@typescript-eslint/ban-types","Don't use `object` as a type. The `object` type is currently hard to use ([see this issue](https://github.com/microsoft/TypeScript/issues/21732)).\nConsider using `Record<string, unknown>` instead, as it allows you to more easily inspect and use the keys.","TSObjectKeyword","bannedTypeMessage","@typescript-eslint/no-unsafe-assignment","Unsafe assignment of an any value.","VariableDeclarator","anyAssignment","@typescript-eslint/no-unsafe-member-access","Unsafe member access .error on an any value.","MemberExpression","unsafeMemberExpression",["4379","4380"],"@typescript-eslint/no-unsafe-call","Unsafe call of an any typed value.","unsafeCall",["4381","4382"],"Unsafe member access .isURL on an any value.","Unsafe member access [methodRes] on an any value.",["4383","4384"],"'thirdParam' is assigned a value but never used.","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","@typescript-eslint/no-empty-function","Unexpected empty constructor.","unexpected","'validateUserIdentityDescriptionVersion' is defined but never used.","'TCentralAuthorityUserIdentity' is defined but never used.","Argument 'v' should be typed with a non-any type.",["4385","4386"],"Argument 'version' should be typed with a non-any type.",["4387","4388"],"Argument 'userIdentityDescription' should be typed with a non-any type.",["4389","4390"],"Argument 'userIdetnityDescription' should be typed with a non-any type.",["4391","4392"],"Unsafe member access [CA_AUTH_CREDENTIALS_USER_IDENTITY_PROP_NAME] on an any value.",["4393","4394"],"@typescript-eslint/require-await","Async method 'connect' has no 'await' expression.","missingAwait","Async arrow function has no 'await' expression.","Async method 'getUserProfileData' has no 'await' expression.","Unsafe return of type Promise<any> from function with return type Promise<boolean | Error>.",["4395"],"Unsafe member access .isDeleted_ on an any value.",["4396","4397"],["4398"],"Argument 'storedCredentialsValue' should be typed with a non-any type.",["4399","4400"],["4401","4402"],["4403","4404"],"AssignmentExpression","Argument 'key' should be typed with a non-any type.",["4405","4406"],["4407"],["4408"],["4409"],"Argument 'configuration' should be typed with a non-any type.",["4410","4411"],"Unsafe member access .databaseURL on an any value.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'errorMessage'.","unsafeRefs","Argument 'caAuthProvider' should be typed with a non-any type.",["4412","4413"],"Argument 'connectionConf' should be typed with a non-any type.",["4414","4415"],"Argument 'userIdentity' should be typed with a non-any type.","Argument 'cryptoCredentials' should be typed with a non-any type.","Async method 'disconnectFromSwarmConnectionsPool' has no 'await' expression.",["4416","4417"],"Argument 'keyPairs' should be typed with a non-any type.",["4418","4419"],["4420","4421"],"Argument 'keysPublic' should be typed with a non-any type.",["4422","4423"],"Unsafe member access [CA_CRYPTO_KEY_PAIRS_ENCRYPTION_PUBLIC_KEY_NAME] on an any value.","Unsafe member access [CA_CRYPTO_KEY_PAIRS_SIGN_PUBLIC_KEY_NAME] on an any value.","'TCACryptoPubilicKeys' is defined but never used.","Unsafe member access .isUUID on an any value.","Argument 'cryptoCredentialsExported' should be typed with a non-any type.",["4424","4425"],"Argument 'cryptoCredentialsString' should be typed with a non-any type.",["4426","4427"],"Unsafe member access .length on an any value.","Argument 'authCredentials' should be typed with a non-any type.","Argument 'value' should be typed with a non-any type.",["4428","4429"],["4430","4431"],["4432","4433"],["4434","4435"],["4436","4437"],"Argument 'cryptoCredentialsExportedAsString' should be typed with a non-any type.",["4438","4439"],"Argument 'profileData' should be typed with a non-any type.",["4440","4441"],["4442","4443"],"Async method 'closeMessageConstructor' has no 'await' expression.","Async method 'closeSwarmMessageEncryptedCacheFabric' has no 'await' expression.","Async method 'closeSwarmMessageConstructorFabric' has no 'await' expression.","Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `Record<string, unknown>` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","TSTypeLiteral","@typescript-eslint/no-empty-interface","An interface declaring no members is equivalent to its supertype.","noEmptyWithSuper",{"range":"4444","text":"4445"},{"range":"4446","text":"4447"},{"range":"4448","text":"4449"},["4450","4451"],["4452","4453"],["4454","4455"],["4456","4457"],["4458","4459"],["4460","4461"],["4462","4463"],["4464","4465"],["4466","4467"],"Unexpected empty async method 'close'.","An empty interface is equivalent to `{}`.","noEmpty",{"range":"4468","text":"4469"},"Async method 'close' has no 'await' expression.","Don't use `Function` as a type. The `Function` type accepts any function-like value.\nIt provides no type safety when calling the function, which can be a common source of bugs.\nIt also accepts things like class declarations, which will throw at runtime as they will not be called with `new`.\nIf you are expecting the function to accept certain arguments, you should explicitly define the function shape.",["4470"],"'nothing' is assigned a value but never used.","'prefix' is assigned a value but never used.",{"range":"4471","text":"4472"},"'IFileStorageService' is defined but never used.",["4473","4474"],"Unsafe construction of an any type value.","NewExpression","unsafeNew","Unsafe member access .default on an any value.","Unsafe member access .connect on an any value.","Unsafe member access .identifier on an any value.",["4475","4476"],"Unsafe member access .constructor on an any value.","Argument 'options' should be typed with a non-any type.",["4477","4478"],"Unsafe member access .server on an any value.",["4479"],["4480"],"Unsafe member access [fieldName] on an any value.",["4481","4482"],"Unsafe array destructuring of a tuple element with an any value.","unsafeArrayPatternFromTuple",["4483","4484"],["4485","4486"],"'status' is assigned a value but never used.","Async method 'stringifyDataForStorage' has no 'await' expression.","Argument 'data' should be typed with a non-any type.",["4487","4488"],"Async method 'setDataInAppendLogStorage' has no 'await' expression.","Async method 'setDataInKeyValueStorage' has no 'await' expression.","Argument 'storageProviderInstance' should be typed with a non-any type.","Argument 'password' should be typed with a non-any type.",["4489","4490"],"Argument 'login' should be typed with a non-any type.",["4491","4492"],["4493","4494"],"Argument 'valueEncrypted' should be typed with a non-any type.",["4495","4496"],{"range":"4497","text":"4498"},{"range":"4499","text":"4500"},["4501","4502"],["4503","4504"],["4505","4506"],["4507","4508"],"Unsafe member access .clear on an any value.",["4509","4510"],["4511","4512"],["4513"],["4514"],"Async method 'disconnect' has no 'await' expression.","Async method 'clearDb' has no 'await' expression.","Async method 'unset' has no 'await' expression.","Async method 'get' has no 'await' expression.","Async method 'runSwarmMessageParser' has no 'await' expression.","'TSwarmMessageUserIdentifierSerialized' is defined but never used.","'ISwarmMessageSubclassFieldsValidator' is defined but never used.","FunctionDeclaration","Argument 'isPrivateField' should be typed with a non-any type.",["4515","4516"],"array-callback-return","Expected to return a value at the end of arrow function.","expectedAtEnd","'TSwarmMessageSignatureAlgorithm' is defined but never used.","'ISwarmMessageStoreOptions' is defined but never used.","'ISwarmStoreConnectorOrbitDbDatabaseOptions' is defined but never used.","'ISwarmStoreDatabasesOptions' is defined but never used.","'ISwarmStoreDatabasesCommonStatusList' is defined but never used.","Property","'ISwarmMessageInstanceDecrypted' is defined but never used.","Unsafe member access .message on an any value.",["4517","4518"],"Unsafe member access .construct on an any value.","Unsafe return of type Promise<any[]> from function with return type Promise<(Error | MD)[]>.",["4519"],["4520"],["4521"],["4522"],"Async method 'handleDatabaseClosed' has no 'await' expression.",["4523","4524"],{"range":"4525","text":"4526"},["4527","4528"],"Static async method 'create' has no 'await' expression.","Async method 'save' has no 'await' expression.","Unsafe member access .verifyIdentity on an any value.",["4529","4530"],["4531","4532"],"Argument 'opt' should be typed with a non-any type.",["4533","4534"],["4535","4536"],"Unsafe member access ._oplog on an any value.",["4537","4538"],"TSAsExpression",["4539","4540"],["4541","4542"],["4543","4544"],["4545","4546"],["4547","4548"],"Unsafe member access ._cache on an any value.","OptionalMemberExpression",["4549","4550"],["4551","4552"],["4553","4554"],["4555","4556"],{"range":"4557","text":"4558"},{"range":"4559","text":"4560"},"Async method 'getId' has no 'await' expression.",["4561","4562"],["4563"],"Unsafe member access .sign on an any value.",["4564","4565"],"'IStore' is defined but never used.","'ISecretStoreCredentials' is defined but never used.",["4566","4567"],["4568","4569"],["4570","4571"],["4572","4573"],["4574","4575"],"Async method 'disconnectFromSwarm' has no 'await' expression.",["4576","4577"],["4578","4579"],"Async method 'setListenersDatabaseEvents' has no 'await' expression.",{"range":"4580","text":"4581"},"'FileStoreAddFile' is defined but never used.","'ConnectToSwarm' is defined but never used.","'SensitiveDataStorage' is defined but never used.",["4582","4583"],["4584","4585"],["4586","4587"],["4588","4589"],["4590","4591"],["4592","4593"],"Unsafe member access .messagingSending on an any value.",["4594","4595"],"Unsafe spread of an any value in an array.","SpreadElement","unsafeArraySpread",["4596","4597"],["4598","4599"],["4600","4601"],"jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","'FileStorageClassProviderIPFS' is defined but never used.","'FileStorageClassProviderHTTP' is defined but never used.",["4602","4603"],["4604","4605"],["4606","4607"],["4608","4609"],["4610","4611"],["4612","4613"],["4614","4615"],["4616","4617"],["4618","4619"],["4620","4621"],["4622","4623"],["4624","4625"],["4626","4627"],["4628","4629"],["4630","4631"],["4632","4633"],["4634","4635"],["4636","4637"],["4638","4639"],["4640","4641"],["4642","4643"],["4644","4645"],["4646","4647"],["4648"],["4649","4650"],["4651","4652"],["4653","4654"],{"range":"4655","text":"4656"},"Argument 'a' should be typed with a non-any type.",["4657","4658"],["4659","4660"],["4661","4662"],["4663","4664"],["4665","4666"],["4667","4668"],"Argument 'firstArray' should be typed with a non-any type.",["4669","4670"],["4671","4672"],["4673","4674"],["4675","4676"],["4677","4678"],["4679","4680"],["4681","4682"],["4683","4684"],["4685","4686"],["4687","4688"],["4689","4690"],["4691","4692"],["4693","4694"],"Argument 'o' should be typed with a non-any type.",["4695","4696"],["4697","4698"],["4699","4700"],["4701","4702"],["4703","4704"],["4705","4706"],"Unsafe member access [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME] on an any value.","Unsafe member access [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME] on an any value.",["4707","4708"],"ArrayExpression","Unsafe member access [DATA_SIGN_CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME] on an any value.","Unsafe member access .JsonWebKey on an any value.",["4709","4710"],"'dataSignExportKey' is defined but never used.","'typedArrayToString' is defined but never used.",["4711","4712"],["4713","4714"],["4715","4716"],["4717","4718"],["4719","4720"],["4721","4722"],"Argument 'keyPair' should be typed with a non-any type.",["4723","4724"],"Unsafe member access .publicKey on an any value.","Unsafe member access .privateKey on an any value.","Argument 'cryptoKey' should be typed with a non-any type.",["4725","4726"],["4727","4728"],["4729","4730"],["4731","4732"],["4733","4734"],["4735","4736"],["4737","4738"],["4739","4740"],"'exportKey' is defined but never used.","'encodeArrayBufferToDOMString' is defined but never used.",["4741","4742"],"Unsafe member access [CRYPTO_UTIL_KEYPAIR_PUBLIC_KEY_NAME] on an any value.","Unsafe member access [CRYPTO_UTIL_KEYPAIR_PRIVATE_KEY_NAME] on an any value.","Unsafe member access [CRYPTO_UTIL_KEYPAIR_SALT_KEY_NAME] on an any value.","Argument 'salt' should be typed with a non-any type.","'STARDUST_SERVER' is defined but never used.",["4743","4744"],["4745","4746"],"Argument 'opts' should be typed with a non-any type.",["4747","4748"],"Unsafe member access .peerInfo on an any value.","Unsafe member access .peerBook on an any value.","Unsafe member access .config on an any value.","Unsafe member access .multiaddrs on an any value.","Unsafe member access .id on an any value.","'WEB_RTC_STAR_SERVER' is defined but never used.","'API_SERVER' is assigned a value but never used.","'GATEWAY_SERVER' is assigned a value but never used.","'BOOTSTRAP_NODE' is assigned a value but never used.","Unsafe member access .create on an any value.","Unsafe member access .pubsub on an any value.","Unsafe member access .__sending on an any value.",["4749","4750"],["4751","4752"],["4753","4754"],["4755","4756"],["4757","4758"],["4759","4760"],"'ISwarmMessageInstanceEncrypted' is defined but never used.",["4761","4762"],["4763","4764"],["4765","4766"],"Async method '_handleDatabaseClosed' has no 'await' expression.",["4767","4768"],["4769","4770"],["4771","4772"],["4773","4774"],["4775","4776"],["4777","4778"],["4779","4780"],"Async arrow function 'grantAccess' has no 'await' expression.","Unsafe assignment of type ISwarmMessageStore<ESwarmStoreConnector, T, DbType, DBO, any, any, any, any, any, MSI, TSwarmMessagesStoreGrantAccessCallback<ESwarmStoreConnector, MSI>, undefined, any, any> to a variable of type ISwarmMessageStore<ESwarmStoreConnector, T, DbType, DBO, ISwarmStoreConnectorBasic<ESwarmStoreConnector, T, DbType, DBO>, ... 8 more ..., ISwarmMessageStoreOptionsWithConnectorFabric<...>>.","unsafeAssignment",["4781","4782"],"Argument 'connectionBridge' should be typed with a non-any type.",["4783","4784"],["4785","4786"],["4787","4788"],["4789","4790"],"LogicalExpression","Unsafe member access .requestIdleCallback on an any value.",["4791","4792"],"Unsafe member access .cancelIdleCallback on an any value.",["4793","4794"],["4795","4796"],"Argument 'swarmMessageWithMeta' should be typed with a non-any type.",["4797","4798"],"Unsafe member access .dbName on an any value.","Unsafe member access .messageAddress on an any value.","Unsafe member access .key on an any value.","Argument 'message' should be typed with a non-any type.",["4799","4800"],"Unsafe member access .bdy on an any value.",["4801","4802"],["4803","4804"],["4805","4806"],["4807","4808"],"Unsafe member access .prototype on an any value.",["4809","4810"],["4811","4812"],["4813","4814"],["4815","4816"],["4817","4818"],["4819","4820"],["4821","4822"],"Unsafe return of type any from function with return type R.",["4823","4824"],["4825","4826"],["4827","4828"],"Unsafe return of type any from function with return type ReturnType<F>.",["4829","4830"],["4831","4832"],["4833","4834"],["4835","4836"],"Unsafe member access .concat on an any value.","@typescript-eslint/no-misused-new","Interfaces cannot be constructed, only classes.","TSMethodSignature","errorMessageInterface","Argument 'messageUniqAddress' should be typed with a non-any type.",["4837","4838"],["4839","4840"],"Unexpected empty method 'linkWithTempStore'.",["4841","4842"],["4843","4844"],"Unsafe member access ._addToDefferedReadAfterCurrentCacheUpdateBatch on an any value.",["4845","4846"],"Unsafe member access ._addToDefferedUpdate on an any value.",["4847","4848"],"Unexpected empty async method 'load'.","Unsafe member access .join on an any value.","Unsafe member access .path on an any value.","Unsafe member access .parseAddress on an any value.",{"range":"4849","text":"4850"},["4851","4852"],["4853","4854"],"Unsafe member access .apply on an any value.",["4855","4856"],"Unsafe return of type Promise<any> from function with return type Promise<IPFS>.",["4857","4858"],"Async method 'getCountEntriesLoaded' has no 'await' expression.","Async method 'getCountEntriesAllExists' has no 'await' expression.",["4859","4860"],["4861","4862"],"'result' is defined but never used.","prefer-const","'signature' is never reassigned. Use 'const' instead.","useConst",{"range":"4863","text":"4864"},{"range":"4865","text":"4864"},["4866","4867"],"'SwarmMessgeSubclassSignatureValidator' is defined but never used.","Unexpected empty arrow function.","'ISwarmMessagesDatabaseConnector' is defined but never used.",{"messageId":"4868","fix":"4869","desc":"4870"},{"messageId":"4871","fix":"4872","desc":"4873"},{"messageId":"4868","fix":"4874","desc":"4870"},{"messageId":"4871","fix":"4875","desc":"4873"},{"messageId":"4868","fix":"4876","desc":"4870"},{"messageId":"4871","fix":"4877","desc":"4873"},{"messageId":"4868","fix":"4878","desc":"4870"},{"messageId":"4871","fix":"4879","desc":"4873"},{"messageId":"4868","fix":"4880","desc":"4870"},{"messageId":"4871","fix":"4881","desc":"4873"},{"messageId":"4868","fix":"4882","desc":"4870"},{"messageId":"4871","fix":"4883","desc":"4873"},{"messageId":"4868","fix":"4884","desc":"4870"},{"messageId":"4871","fix":"4885","desc":"4873"},{"messageId":"4868","fix":"4886","desc":"4870"},{"messageId":"4871","fix":"4887","desc":"4873"},{"messageId":"4868","fix":"4888","desc":"4870"},{"messageId":"4871","fix":"4889","desc":"4873"},{"messageId":"4868","fix":"4890","desc":"4870"},{"messageId":"4871","fix":"4891","desc":"4873"},{"messageId":"4868","fix":"4892","desc":"4870"},{"messageId":"4871","fix":"4893","desc":"4873"},{"messageId":"4868","fix":"4894","desc":"4870"},{"messageId":"4871","fix":"4895","desc":"4873"},{"messageId":"4868","fix":"4896","desc":"4870"},{"messageId":"4871","fix":"4897","desc":"4873"},{"messageId":"4868","fix":"4898","desc":"4870"},{"messageId":"4871","fix":"4899","desc":"4873"},{"messageId":"4868","fix":"4900","desc":"4870"},{"messageId":"4871","fix":"4901","desc":"4873"},{"messageId":"4868","fix":"4902","desc":"4870"},{"messageId":"4871","fix":"4903","desc":"4873"},{"messageId":"4868","fix":"4904","desc":"4870"},{"messageId":"4871","fix":"4905","desc":"4873"},{"messageId":"4868","fix":"4906","desc":"4870"},{"messageId":"4871","fix":"4907","desc":"4873"},{"messageId":"4868","fix":"4908","desc":"4870"},{"messageId":"4871","fix":"4909","desc":"4873"},{"messageId":"4868","fix":"4910","desc":"4870"},{"messageId":"4871","fix":"4911","desc":"4873"},{"messageId":"4912","fix":"4913","desc":"4914"},{"messageId":"4868","fix":"4915","desc":"4870"},{"messageId":"4871","fix":"4916","desc":"4873"},{"messageId":"4912","fix":"4917","desc":"4914"},{"messageId":"4868","fix":"4918","desc":"4870"},{"messageId":"4871","fix":"4919","desc":"4873"},{"messageId":"4868","fix":"4920","desc":"4870"},{"messageId":"4871","fix":"4921","desc":"4873"},{"messageId":"4868","fix":"4922","desc":"4870"},{"messageId":"4871","fix":"4923","desc":"4873"},{"messageId":"4868","fix":"4924","desc":"4870"},{"messageId":"4871","fix":"4925","desc":"4873"},{"messageId":"4912","fix":"4926","desc":"4914"},{"messageId":"4912","fix":"4927","desc":"4914"},{"messageId":"4912","fix":"4928","desc":"4914"},{"messageId":"4868","fix":"4929","desc":"4870"},{"messageId":"4871","fix":"4930","desc":"4873"},{"messageId":"4868","fix":"4931","desc":"4870"},{"messageId":"4871","fix":"4932","desc":"4873"},{"messageId":"4868","fix":"4933","desc":"4870"},{"messageId":"4871","fix":"4934","desc":"4873"},{"messageId":"4868","fix":"4935","desc":"4870"},{"messageId":"4871","fix":"4936","desc":"4873"},{"messageId":"4868","fix":"4937","desc":"4870"},{"messageId":"4871","fix":"4938","desc":"4873"},{"messageId":"4868","fix":"4939","desc":"4870"},{"messageId":"4871","fix":"4940","desc":"4873"},{"messageId":"4868","fix":"4941","desc":"4870"},{"messageId":"4871","fix":"4942","desc":"4873"},{"messageId":"4868","fix":"4943","desc":"4870"},{"messageId":"4871","fix":"4944","desc":"4873"},{"messageId":"4868","fix":"4945","desc":"4870"},{"messageId":"4871","fix":"4946","desc":"4873"},{"messageId":"4868","fix":"4947","desc":"4870"},{"messageId":"4871","fix":"4948","desc":"4873"},{"messageId":"4868","fix":"4949","desc":"4870"},{"messageId":"4871","fix":"4950","desc":"4873"},{"messageId":"4868","fix":"4951","desc":"4870"},{"messageId":"4871","fix":"4952","desc":"4873"},{"messageId":"4868","fix":"4953","desc":"4870"},{"messageId":"4871","fix":"4954","desc":"4873"},{"messageId":"4868","fix":"4955","desc":"4870"},{"messageId":"4871","fix":"4956","desc":"4873"},{"messageId":"4868","fix":"4957","desc":"4870"},{"messageId":"4871","fix":"4958","desc":"4873"},{"messageId":"4868","fix":"4959","desc":"4870"},{"messageId":"4871","fix":"4960","desc":"4873"},{"messageId":"4868","fix":"4961","desc":"4870"},{"messageId":"4871","fix":"4962","desc":"4873"},[12786,14457],"type IConnectionBridgeOptionsDefault<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  CD extends boolean = true,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType> = TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T = TSwarmMessageInstance | T,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined = undefined,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI> = TSwarmMessagesStoreGrantAccessCallback<P, MSI>,\n  ACO extends ISwarmMessageStoreAccessControlOptions<P, T, MSI, GAC> | undefined = undefined,\n  ConnectorBasic extends ISwarmStoreConnectorBasic<P, T, DbType, DBO> = ISwarmStoreConnectorBasic<P, T, DbType, DBO>,\n  CBFO extends TSwarmStoreConnectorBasicFabric<P, T, DbType, DBO, ConnectorBasic> | undefined = undefined,\n  PO extends TSwarmStoreConnectorConnectionOptions<P, T, DbType, DBO, ConnectorBasic> = TSwarmStoreConnectorConnectionOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic\n  >,\n  CO extends ISwarmStoreProviderOptions<P, T, DbType, DBO, ConnectorBasic, PO> = ISwarmStoreProviderOptions<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO\n  >,\n  ConnectorMain extends ISwarmStoreConnector<P, T, DbType, DBO, ConnectorBasic, PO> = ISwarmStoreConnector<\n    P,\n    T,\n    DbType,\n    DBO,\n    ConnectorBasic,\n    PO\n  >,\n  CFO extends ISwarmStoreOptionsConnectorFabric<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain> | undefined = undefined\n> = IConnectionBridgeOptions<P, T, DbType, DBO, ConnectorBasic, PO, CO, ConnectorMain, MSI, GAC, MCF, ACO, CFO, CBFO, CD>",[14900,15334],"type IConnectionBridgeStorageOptionsDefault<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  CD extends boolean = true,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType> = TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T = TSwarmMessageInstance | T\n> = TConnectionBridgeOptionsDefault<P, T, DbType, CD, DBO, MSI>",[15343,16003],"type IConnectionBridgeUnknown<\n  P extends ESwarmStoreConnector,\n  T extends TSwarmMessageSerialized,\n  DbType extends TSwarmStoreDatabaseType<P>,\n  CD extends boolean = true,\n  DBO extends TSwarmStoreDatabaseOptions<P, T, DbType> = TSwarmStoreDatabaseOptions<P, T, DbType>,\n  MSI extends TSwarmMessageInstance | T = TSwarmMessageInstance | T,\n  MCF extends ISwarmMessageConstructorWithEncryptedCacheFabric | undefined = undefined,\n  GAC extends TSwarmMessagesStoreGrantAccessCallback<P, MSI> = TSwarmMessagesStoreGrantAccessCallback<P, MSI>\n> = IConnectionBridge<P, T, DbType, DBO, any, any, any, any, any, any, MSI, GAC, MCF, any, any, CD, any>",{"messageId":"4868","fix":"4963","desc":"4870"},{"messageId":"4871","fix":"4964","desc":"4873"},{"messageId":"4868","fix":"4965","desc":"4870"},{"messageId":"4871","fix":"4966","desc":"4873"},{"messageId":"4868","fix":"4967","desc":"4870"},{"messageId":"4871","fix":"4968","desc":"4873"},{"messageId":"4868","fix":"4969","desc":"4870"},{"messageId":"4871","fix":"4970","desc":"4873"},{"messageId":"4868","fix":"4971","desc":"4870"},{"messageId":"4871","fix":"4972","desc":"4873"},{"messageId":"4868","fix":"4973","desc":"4870"},{"messageId":"4871","fix":"4974","desc":"4873"},{"messageId":"4868","fix":"4975","desc":"4870"},{"messageId":"4871","fix":"4976","desc":"4873"},{"messageId":"4868","fix":"4977","desc":"4870"},{"messageId":"4871","fix":"4978","desc":"4873"},{"messageId":"4868","fix":"4979","desc":"4870"},{"messageId":"4871","fix":"4980","desc":"4873"},[181,265],"type IFileStorageClassProviderHTTPFileGetOptions = IHttpRequestOptions",{"messageId":"4912","fix":"4981","desc":"4914"},[1415,1528],"type IFileStorageClassProviderIPFSFileDownloadOptions = IFileStorageClassProviderIPFSFileGetOptions",{"messageId":"4868","fix":"4982","desc":"4870"},{"messageId":"4871","fix":"4983","desc":"4873"},{"messageId":"4868","fix":"4984","desc":"4870"},{"messageId":"4871","fix":"4985","desc":"4873"},{"messageId":"4868","fix":"4986","desc":"4870"},{"messageId":"4871","fix":"4987","desc":"4873"},{"messageId":"4912","fix":"4988","desc":"4914"},{"messageId":"4912","fix":"4989","desc":"4914"},{"messageId":"4868","fix":"4990","desc":"4870"},{"messageId":"4871","fix":"4991","desc":"4873"},{"messageId":"4868","fix":"4992","desc":"4870"},{"messageId":"4871","fix":"4993","desc":"4873"},{"messageId":"4868","fix":"4994","desc":"4870"},{"messageId":"4871","fix":"4995","desc":"4873"},{"messageId":"4868","fix":"4996","desc":"4870"},{"messageId":"4871","fix":"4997","desc":"4873"},{"messageId":"4868","fix":"4998","desc":"4870"},{"messageId":"4871","fix":"4999","desc":"4873"},{"messageId":"4868","fix":"5000","desc":"4870"},{"messageId":"4871","fix":"5001","desc":"4873"},{"messageId":"4868","fix":"5002","desc":"4870"},{"messageId":"4871","fix":"5003","desc":"4873"},{"messageId":"4868","fix":"5004","desc":"4870"},{"messageId":"4871","fix":"5005","desc":"4873"},[464,531],"type IISecretStorageOptions = IStorageProviderOptions",[944,1020],"type ISecretStoreCredentials = ISecretStoreCredentialsPassword",{"messageId":"4868","fix":"5006","desc":"4870"},{"messageId":"4871","fix":"5007","desc":"4873"},{"messageId":"4868","fix":"5008","desc":"4870"},{"messageId":"4871","fix":"5009","desc":"4873"},{"messageId":"4868","fix":"5010","desc":"4870"},{"messageId":"4871","fix":"5011","desc":"4873"},{"messageId":"4868","fix":"5012","desc":"4870"},{"messageId":"4871","fix":"5013","desc":"4873"},{"messageId":"4868","fix":"5014","desc":"4870"},{"messageId":"4871","fix":"5015","desc":"4873"},{"messageId":"4868","fix":"5016","desc":"4870"},{"messageId":"4871","fix":"5017","desc":"4873"},{"messageId":"4912","fix":"5018","desc":"4914"},{"messageId":"4912","fix":"5019","desc":"4914"},{"messageId":"4868","fix":"5020","desc":"4870"},{"messageId":"4871","fix":"5021","desc":"4873"},{"messageId":"4868","fix":"5022","desc":"4870"},{"messageId":"4871","fix":"5023","desc":"4873"},{"messageId":"4912","fix":"5024","desc":"4914"},{"messageId":"4912","fix":"5025","desc":"4914"},{"messageId":"4912","fix":"5026","desc":"4914"},{"messageId":"4912","fix":"5027","desc":"4914"},{"messageId":"4868","fix":"5028","desc":"4870"},{"messageId":"4871","fix":"5029","desc":"4873"},[3451,3588],"type ISwarmStoreDatabasesStatuses = Record<string, ESwarmStoreDatabaseStatus | typeof SWARM_STORE_DATABASE_STATUS_ABSENT>",{"messageId":"4868","fix":"5030","desc":"4870"},{"messageId":"4871","fix":"5031","desc":"4873"},{"messageId":"4868","fix":"5032","desc":"4870"},{"messageId":"4871","fix":"5033","desc":"4873"},{"messageId":"4868","fix":"5034","desc":"4870"},{"messageId":"4871","fix":"5035","desc":"4873"},{"messageId":"4868","fix":"5036","desc":"4870"},{"messageId":"4871","fix":"5037","desc":"4873"},{"messageId":"4868","fix":"5038","desc":"4870"},{"messageId":"4871","fix":"5039","desc":"4873"},{"messageId":"4868","fix":"5040","desc":"4870"},{"messageId":"4871","fix":"5041","desc":"4873"},{"messageId":"4868","fix":"5042","desc":"4870"},{"messageId":"4871","fix":"5043","desc":"4873"},{"messageId":"4868","fix":"5044","desc":"4870"},{"messageId":"4871","fix":"5045","desc":"4873"},{"messageId":"4868","fix":"5046","desc":"4870"},{"messageId":"4871","fix":"5047","desc":"4873"},{"messageId":"4868","fix":"5048","desc":"4870"},{"messageId":"4871","fix":"5049","desc":"4873"},{"messageId":"4868","fix":"5050","desc":"4870"},{"messageId":"4871","fix":"5051","desc":"4873"},{"messageId":"4868","fix":"5052","desc":"4870"},{"messageId":"4871","fix":"5053","desc":"4873"},{"messageId":"4868","fix":"5054","desc":"4870"},{"messageId":"4871","fix":"5055","desc":"4873"},{"messageId":"4868","fix":"5056","desc":"4870"},{"messageId":"4871","fix":"5057","desc":"4873"},{"messageId":"4868","fix":"5058","desc":"4870"},{"messageId":"4871","fix":"5059","desc":"4873"},[3182,3286],"type ISwarmStoreConnectorOrbitDbDatabaseValue<TStoreValueType> = LogEntry<TStoreValueType>",[5184,5405],"type ISwarmStoreConnectorOrbitDbDatabaseIteratorOptions<\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>\n> = Partial<ISwarmStoreConnectorOrbitDbDatabaseIteratorOptionsRequired<DbType>>",{"messageId":"4868","fix":"5060","desc":"4870"},{"messageId":"4871","fix":"5061","desc":"4873"},{"messageId":"4912","fix":"5062","desc":"4914"},{"messageId":"4868","fix":"5063","desc":"4870"},{"messageId":"4871","fix":"5064","desc":"4873"},{"messageId":"4868","fix":"5065","desc":"4870"},{"messageId":"4871","fix":"5066","desc":"4873"},{"messageId":"4868","fix":"5067","desc":"4870"},{"messageId":"4871","fix":"5068","desc":"4873"},{"messageId":"4868","fix":"5069","desc":"4870"},{"messageId":"4871","fix":"5070","desc":"4873"},{"messageId":"4868","fix":"5071","desc":"4870"},{"messageId":"4871","fix":"5072","desc":"4873"},{"messageId":"4868","fix":"5073","desc":"4870"},{"messageId":"4871","fix":"5074","desc":"4873"},{"messageId":"4868","fix":"5075","desc":"4870"},{"messageId":"4871","fix":"5076","desc":"4873"},{"messageId":"4868","fix":"5077","desc":"4870"},{"messageId":"4871","fix":"5078","desc":"4873"},[621,943],"type ISwarmStoreConnectorOrbitDBEvents<\n  P extends ESwarmStoreConnector.OrbitDB,\n  ItemType extends TSwarmStoreValueTypes<P>,\n  DbType extends TSwarmStoreDatabaseType<ESwarmStoreConnector.OrbitDB>,\n  DBO extends TSwarmStoreDatabaseOptions<P, ItemType, DbType>\n> = ISwarmStoreEvents<P, ItemType, DbType, DBO>",{"messageId":"4868","fix":"5079","desc":"4870"},{"messageId":"4871","fix":"5080","desc":"4873"},{"messageId":"4868","fix":"5081","desc":"4870"},{"messageId":"4871","fix":"5082","desc":"4873"},{"messageId":"4868","fix":"5083","desc":"4870"},{"messageId":"4871","fix":"5084","desc":"4873"},{"messageId":"4868","fix":"5085","desc":"4870"},{"messageId":"4871","fix":"5086","desc":"4873"},{"messageId":"4868","fix":"5087","desc":"4870"},{"messageId":"4871","fix":"5088","desc":"4873"},{"messageId":"4868","fix":"5089","desc":"4870"},{"messageId":"4871","fix":"5090","desc":"4873"},{"messageId":"4868","fix":"5091","desc":"4870"},{"messageId":"4871","fix":"5092","desc":"4873"},{"messageId":"4868","fix":"5093","desc":"4870"},{"messageId":"4871","fix":"5094","desc":"4873"},{"messageId":"4868","fix":"5095","desc":"4870"},{"messageId":"4871","fix":"5096","desc":"4873"},{"messageId":"4868","fix":"5097","desc":"4870"},{"messageId":"4871","fix":"5098","desc":"4873"},{"messageId":"4868","fix":"5099","desc":"4870"},{"messageId":"4871","fix":"5100","desc":"4873"},{"messageId":"4868","fix":"5101","desc":"4870"},{"messageId":"4871","fix":"5102","desc":"4873"},{"messageId":"4868","fix":"5103","desc":"4870"},{"messageId":"4871","fix":"5104","desc":"4873"},{"messageId":"4868","fix":"5105","desc":"4870"},{"messageId":"4871","fix":"5106","desc":"4873"},{"messageId":"4868","fix":"5107","desc":"4870"},{"messageId":"4871","fix":"5108","desc":"4873"},{"messageId":"4868","fix":"5109","desc":"4870"},{"messageId":"4871","fix":"5110","desc":"4873"},{"messageId":"4868","fix":"5111","desc":"4870"},{"messageId":"4871","fix":"5112","desc":"4873"},{"messageId":"4868","fix":"5113","desc":"4870"},{"messageId":"4871","fix":"5114","desc":"4873"},{"messageId":"4868","fix":"5115","desc":"4870"},{"messageId":"4871","fix":"5116","desc":"4873"},{"messageId":"4868","fix":"5117","desc":"4870"},{"messageId":"4871","fix":"5118","desc":"4873"},{"messageId":"4868","fix":"5119","desc":"4870"},{"messageId":"4871","fix":"5120","desc":"4873"},{"messageId":"4868","fix":"5121","desc":"4870"},{"messageId":"4871","fix":"5122","desc":"4873"},{"messageId":"4868","fix":"5123","desc":"4870"},{"messageId":"4871","fix":"5124","desc":"4873"},{"messageId":"4868","fix":"5125","desc":"4870"},{"messageId":"4871","fix":"5126","desc":"4873"},{"messageId":"4868","fix":"5127","desc":"4870"},{"messageId":"4871","fix":"5128","desc":"4873"},{"messageId":"4868","fix":"5129","desc":"4870"},{"messageId":"4871","fix":"5130","desc":"4873"},{"messageId":"4868","fix":"5131","desc":"4870"},{"messageId":"4871","fix":"5132","desc":"4873"},{"messageId":"4868","fix":"5133","desc":"4870"},{"messageId":"4871","fix":"5134","desc":"4873"},{"messageId":"4868","fix":"5135","desc":"4870"},{"messageId":"4871","fix":"5136","desc":"4873"},{"messageId":"4868","fix":"5137","desc":"4870"},{"messageId":"4871","fix":"5138","desc":"4873"},{"messageId":"4868","fix":"5139","desc":"4870"},{"messageId":"4871","fix":"5140","desc":"4873"},{"messageId":"4868","fix":"5141","desc":"4870"},{"messageId":"4871","fix":"5142","desc":"4873"},{"messageId":"4868","fix":"5143","desc":"4870"},{"messageId":"4871","fix":"5144","desc":"4873"},{"messageId":"3981","fix":"5145","desc":"3980"},{"messageId":"4868","fix":"5146","desc":"4870"},{"messageId":"4871","fix":"5147","desc":"4873"},{"messageId":"4868","fix":"5148","desc":"4870"},{"messageId":"4871","fix":"5149","desc":"4873"},{"messageId":"4868","fix":"5150","desc":"4870"},{"messageId":"4871","fix":"5151","desc":"4873"},[197,247],"type IStorage<V> = IStorageCommon<V>",{"messageId":"4868","fix":"5152","desc":"4870"},{"messageId":"4871","fix":"5153","desc":"4873"},{"messageId":"4868","fix":"5154","desc":"4870"},{"messageId":"4871","fix":"5155","desc":"4873"},{"messageId":"4868","fix":"5156","desc":"4870"},{"messageId":"4871","fix":"5157","desc":"4873"},{"messageId":"4868","fix":"5158","desc":"4870"},{"messageId":"4871","fix":"5159","desc":"4873"},{"messageId":"4868","fix":"5160","desc":"4870"},{"messageId":"4871","fix":"5161","desc":"4873"},{"messageId":"4868","fix":"5162","desc":"4870"},{"messageId":"4871","fix":"5163","desc":"4873"},{"messageId":"4868","fix":"5164","desc":"4870"},{"messageId":"4871","fix":"5165","desc":"4873"},{"messageId":"4868","fix":"5166","desc":"4870"},{"messageId":"4871","fix":"5167","desc":"4873"},{"messageId":"4868","fix":"5168","desc":"4870"},{"messageId":"4871","fix":"5169","desc":"4873"},{"messageId":"4868","fix":"5170","desc":"4870"},{"messageId":"4871","fix":"5171","desc":"4873"},{"messageId":"4868","fix":"5172","desc":"4870"},{"messageId":"4871","fix":"5173","desc":"4873"},{"messageId":"4868","fix":"5174","desc":"4870"},{"messageId":"4871","fix":"5175","desc":"4873"},{"messageId":"4868","fix":"5176","desc":"4870"},{"messageId":"4871","fix":"5177","desc":"4873"},{"messageId":"4868","fix":"5178","desc":"4870"},{"messageId":"4871","fix":"5179","desc":"4873"},{"messageId":"4868","fix":"5180","desc":"4870"},{"messageId":"4871","fix":"5181","desc":"4873"},{"messageId":"4868","fix":"5182","desc":"4870"},{"messageId":"4871","fix":"5183","desc":"4873"},{"messageId":"4868","fix":"5184","desc":"4870"},{"messageId":"4871","fix":"5185","desc":"4873"},{"messageId":"4868","fix":"5186","desc":"4870"},{"messageId":"4871","fix":"5187","desc":"4873"},{"messageId":"4868","fix":"5188","desc":"4870"},{"messageId":"4871","fix":"5189","desc":"4873"},{"messageId":"4868","fix":"5190","desc":"4870"},{"messageId":"4871","fix":"5191","desc":"4873"},{"messageId":"4868","fix":"5192","desc":"4870"},{"messageId":"4871","fix":"5193","desc":"4873"},{"messageId":"4868","fix":"5194","desc":"4870"},{"messageId":"4871","fix":"5195","desc":"4873"},{"messageId":"4868","fix":"5196","desc":"4870"},{"messageId":"4871","fix":"5197","desc":"4873"},{"messageId":"4868","fix":"5198","desc":"4870"},{"messageId":"4871","fix":"5199","desc":"4873"},{"messageId":"4868","fix":"5200","desc":"4870"},{"messageId":"4871","fix":"5201","desc":"4873"},{"messageId":"4868","fix":"5202","desc":"4870"},{"messageId":"4871","fix":"5203","desc":"4873"},{"messageId":"4868","fix":"5204","desc":"4870"},{"messageId":"4871","fix":"5205","desc":"4873"},{"messageId":"4868","fix":"5206","desc":"4870"},{"messageId":"4871","fix":"5207","desc":"4873"},{"messageId":"4868","fix":"5208","desc":"4870"},{"messageId":"4871","fix":"5209","desc":"4873"},{"messageId":"4868","fix":"5210","desc":"4870"},{"messageId":"4871","fix":"5211","desc":"4873"},{"messageId":"4868","fix":"5212","desc":"4870"},{"messageId":"4871","fix":"5213","desc":"4873"},{"messageId":"4868","fix":"5214","desc":"4870"},{"messageId":"4871","fix":"5215","desc":"4873"},{"messageId":"4868","fix":"5216","desc":"4870"},{"messageId":"4871","fix":"5217","desc":"4873"},{"messageId":"4868","fix":"5218","desc":"4870"},{"messageId":"4871","fix":"5219","desc":"4873"},{"messageId":"4868","fix":"5220","desc":"4870"},{"messageId":"4871","fix":"5221","desc":"4873"},{"messageId":"4868","fix":"5222","desc":"4870"},{"messageId":"4871","fix":"5223","desc":"4873"},{"messageId":"4868","fix":"5224","desc":"4870"},{"messageId":"4871","fix":"5225","desc":"4873"},{"messageId":"4868","fix":"5226","desc":"4870"},{"messageId":"4871","fix":"5227","desc":"4873"},{"messageId":"4868","fix":"5228","desc":"4870"},{"messageId":"4871","fix":"5229","desc":"4873"},{"messageId":"4868","fix":"5230","desc":"4870"},{"messageId":"4871","fix":"5231","desc":"4873"},{"messageId":"4868","fix":"5232","desc":"4870"},{"messageId":"4871","fix":"5233","desc":"4873"},{"messageId":"4868","fix":"5234","desc":"4870"},{"messageId":"4871","fix":"5235","desc":"4873"},{"messageId":"4868","fix":"5236","desc":"4870"},{"messageId":"4871","fix":"5237","desc":"4873"},{"messageId":"4868","fix":"5238","desc":"4870"},{"messageId":"4871","fix":"5239","desc":"4873"},{"messageId":"4868","fix":"5240","desc":"4870"},{"messageId":"4871","fix":"5241","desc":"4873"},{"messageId":"4868","fix":"5242","desc":"4870"},{"messageId":"4871","fix":"5243","desc":"4873"},{"messageId":"4868","fix":"5244","desc":"4870"},{"messageId":"4871","fix":"5245","desc":"4873"},{"messageId":"4868","fix":"5246","desc":"4870"},{"messageId":"4871","fix":"5247","desc":"4873"},{"messageId":"4868","fix":"5248","desc":"4870"},{"messageId":"4871","fix":"5249","desc":"4873"},{"messageId":"4868","fix":"5250","desc":"4870"},{"messageId":"4871","fix":"5251","desc":"4873"},{"messageId":"4868","fix":"5252","desc":"4870"},{"messageId":"4871","fix":"5253","desc":"4873"},{"messageId":"4868","fix":"5254","desc":"4870"},{"messageId":"4871","fix":"5255","desc":"4873"},{"messageId":"4868","fix":"5256","desc":"4870"},{"messageId":"4871","fix":"5257","desc":"4873"},{"messageId":"4868","fix":"5258","desc":"4870"},{"messageId":"4871","fix":"5259","desc":"4873"},{"messageId":"4868","fix":"5260","desc":"4870"},{"messageId":"4871","fix":"5261","desc":"4873"},{"messageId":"4868","fix":"5262","desc":"4870"},{"messageId":"4871","fix":"5263","desc":"4873"},{"messageId":"4868","fix":"5264","desc":"4870"},{"messageId":"4871","fix":"5265","desc":"4873"},{"messageId":"4868","fix":"5266","desc":"4870"},{"messageId":"4871","fix":"5267","desc":"4873"},{"messageId":"4868","fix":"5268","desc":"4870"},{"messageId":"4871","fix":"5269","desc":"4873"},{"messageId":"4868","fix":"5270","desc":"4870"},{"messageId":"4871","fix":"5271","desc":"4873"},{"messageId":"4868","fix":"5272","desc":"4870"},{"messageId":"4871","fix":"5273","desc":"4873"},{"messageId":"4868","fix":"5274","desc":"4870"},{"messageId":"4871","fix":"5275","desc":"4873"},{"messageId":"4868","fix":"5276","desc":"4870"},{"messageId":"4871","fix":"5277","desc":"4873"},{"messageId":"4868","fix":"5278","desc":"4870"},{"messageId":"4871","fix":"5279","desc":"4873"},{"messageId":"4868","fix":"5280","desc":"4870"},{"messageId":"4871","fix":"5281","desc":"4873"},{"messageId":"4868","fix":"5282","desc":"4870"},{"messageId":"4871","fix":"5283","desc":"4873"},{"messageId":"4868","fix":"5284","desc":"4870"},{"messageId":"4871","fix":"5285","desc":"4873"},{"messageId":"4868","fix":"5286","desc":"4870"},{"messageId":"4871","fix":"5287","desc":"4873"},{"messageId":"4868","fix":"5288","desc":"4870"},{"messageId":"4871","fix":"5289","desc":"4873"},{"messageId":"4868","fix":"5290","desc":"4870"},{"messageId":"4871","fix":"5291","desc":"4873"},{"messageId":"4868","fix":"5292","desc":"4870"},{"messageId":"4871","fix":"5293","desc":"4873"},{"messageId":"4868","fix":"5294","desc":"4870"},{"messageId":"4871","fix":"5295","desc":"4873"},{"messageId":"4868","fix":"5296","desc":"4870"},{"messageId":"4871","fix":"5297","desc":"4873"},{"messageId":"4868","fix":"5298","desc":"4870"},{"messageId":"4871","fix":"5299","desc":"4873"},{"messageId":"4868","fix":"5300","desc":"4870"},{"messageId":"4871","fix":"5301","desc":"4873"},{"messageId":"4868","fix":"5302","desc":"4870"},{"messageId":"4871","fix":"5303","desc":"4873"},{"messageId":"4868","fix":"5304","desc":"4870"},{"messageId":"4871","fix":"5305","desc":"4873"},{"messageId":"4868","fix":"5306","desc":"4870"},{"messageId":"4871","fix":"5307","desc":"4873"},{"messageId":"4868","fix":"5308","desc":"4870"},{"messageId":"4871","fix":"5309","desc":"4873"},{"messageId":"4868","fix":"5310","desc":"4870"},{"messageId":"4871","fix":"5311","desc":"4873"},{"messageId":"4868","fix":"5312","desc":"4870"},{"messageId":"4871","fix":"5313","desc":"4873"},{"messageId":"4868","fix":"5314","desc":"4870"},{"messageId":"4871","fix":"5315","desc":"4873"},{"messageId":"4868","fix":"5316","desc":"4870"},{"messageId":"4871","fix":"5317","desc":"4873"},{"messageId":"4868","fix":"5318","desc":"4870"},{"messageId":"4871","fix":"5319","desc":"4873"},{"messageId":"4868","fix":"5320","desc":"4870"},{"messageId":"4871","fix":"5321","desc":"4873"},{"messageId":"4868","fix":"5322","desc":"4870"},{"messageId":"4871","fix":"5323","desc":"4873"},{"messageId":"4868","fix":"5324","desc":"4870"},{"messageId":"4871","fix":"5325","desc":"4873"},{"messageId":"4868","fix":"5326","desc":"4870"},{"messageId":"4871","fix":"5327","desc":"4873"},{"messageId":"4868","fix":"5328","desc":"4870"},{"messageId":"4871","fix":"5329","desc":"4873"},{"messageId":"4868","fix":"5330","desc":"4870"},{"messageId":"4871","fix":"5331","desc":"4873"},{"messageId":"4868","fix":"5332","desc":"4870"},{"messageId":"4871","fix":"5333","desc":"4873"},{"messageId":"4868","fix":"5334","desc":"4870"},{"messageId":"4871","fix":"5335","desc":"4873"},{"messageId":"4868","fix":"5336","desc":"4870"},{"messageId":"4871","fix":"5337","desc":"4873"},{"messageId":"4868","fix":"5338","desc":"4870"},{"messageId":"4871","fix":"5339","desc":"4873"},{"messageId":"4868","fix":"5340","desc":"4870"},{"messageId":"4871","fix":"5341","desc":"4873"},{"messageId":"4868","fix":"5342","desc":"4870"},{"messageId":"4871","fix":"5343","desc":"4873"},[256,345],"type IJobPromise<T, E extends MaybeError> = IPromisePendingRejectable<T, E>",{"messageId":"4868","fix":"5344","desc":"4870"},{"messageId":"4871","fix":"5345","desc":"4873"},{"messageId":"4868","fix":"5346","desc":"4870"},{"messageId":"4871","fix":"5347","desc":"4873"},{"messageId":"4868","fix":"5348","desc":"4870"},{"messageId":"4871","fix":"5349","desc":"4873"},{"messageId":"4868","fix":"5350","desc":"4870"},{"messageId":"4871","fix":"5351","desc":"4873"},{"messageId":"4868","fix":"5352","desc":"4870"},{"messageId":"4871","fix":"5353","desc":"4873"},{"messageId":"4868","fix":"5354","desc":"4870"},{"messageId":"4871","fix":"5355","desc":"4873"},[4378,4381],"const",[4779,4782],{"messageId":"4868","fix":"5356","desc":"4870"},{"messageId":"4871","fix":"5357","desc":"4873"},"suggestUnknown",{"range":"5358","text":"5359"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"5358","text":"5360"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"5361","text":"5359"},{"range":"5361","text":"5360"},{"range":"5362","text":"5359"},{"range":"5362","text":"5360"},{"range":"5363","text":"5359"},{"range":"5363","text":"5360"},{"range":"5364","text":"5359"},{"range":"5364","text":"5360"},{"range":"5365","text":"5359"},{"range":"5365","text":"5360"},{"range":"5366","text":"5359"},{"range":"5366","text":"5360"},{"range":"5367","text":"5359"},{"range":"5367","text":"5360"},{"range":"5368","text":"5359"},{"range":"5368","text":"5360"},{"range":"5369","text":"5359"},{"range":"5369","text":"5360"},{"range":"5370","text":"5359"},{"range":"5370","text":"5360"},{"range":"5371","text":"5359"},{"range":"5371","text":"5360"},{"range":"5372","text":"5359"},{"range":"5372","text":"5360"},{"range":"5373","text":"5359"},{"range":"5373","text":"5360"},{"range":"5374","text":"5359"},{"range":"5374","text":"5360"},{"range":"5375","text":"5359"},{"range":"5375","text":"5360"},{"range":"5376","text":"5359"},{"range":"5376","text":"5360"},{"range":"5377","text":"5359"},{"range":"5377","text":"5360"},{"range":"5378","text":"5359"},{"range":"5378","text":"5360"},{"range":"5379","text":"5359"},{"range":"5379","text":"5360"},"suggestOptionalChain",{"range":"5380","text":"5381"},"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator.",{"range":"5382","text":"5359"},{"range":"5382","text":"5360"},{"range":"5383","text":"5381"},{"range":"5384","text":"5359"},{"range":"5384","text":"5360"},{"range":"5385","text":"5359"},{"range":"5385","text":"5360"},{"range":"5386","text":"5359"},{"range":"5386","text":"5360"},{"range":"5387","text":"5359"},{"range":"5387","text":"5360"},{"range":"5388","text":"5381"},{"range":"5389","text":"5381"},{"range":"5390","text":"5381"},{"range":"5391","text":"5359"},{"range":"5391","text":"5360"},{"range":"5392","text":"5359"},{"range":"5392","text":"5360"},{"range":"5393","text":"5359"},{"range":"5393","text":"5360"},{"range":"5394","text":"5359"},{"range":"5394","text":"5360"},{"range":"5395","text":"5359"},{"range":"5395","text":"5360"},{"range":"5396","text":"5359"},{"range":"5396","text":"5360"},{"range":"5397","text":"5359"},{"range":"5397","text":"5360"},{"range":"5398","text":"5359"},{"range":"5398","text":"5360"},{"range":"5399","text":"5359"},{"range":"5399","text":"5360"},{"range":"5400","text":"5359"},{"range":"5400","text":"5360"},{"range":"5401","text":"5359"},{"range":"5401","text":"5360"},{"range":"5402","text":"5359"},{"range":"5402","text":"5360"},{"range":"5403","text":"5359"},{"range":"5403","text":"5360"},{"range":"5404","text":"5359"},{"range":"5404","text":"5360"},{"range":"5405","text":"5359"},{"range":"5405","text":"5360"},{"range":"5406","text":"5359"},{"range":"5406","text":"5360"},{"range":"5407","text":"5359"},{"range":"5407","text":"5360"},{"range":"5408","text":"5359"},{"range":"5408","text":"5360"},{"range":"5409","text":"5359"},{"range":"5409","text":"5360"},{"range":"5410","text":"5359"},{"range":"5410","text":"5360"},{"range":"5411","text":"5359"},{"range":"5411","text":"5360"},{"range":"5412","text":"5359"},{"range":"5412","text":"5360"},{"range":"5413","text":"5359"},{"range":"5413","text":"5360"},{"range":"5414","text":"5359"},{"range":"5414","text":"5360"},{"range":"5415","text":"5359"},{"range":"5415","text":"5360"},{"range":"5416","text":"5359"},{"range":"5416","text":"5360"},{"range":"5417","text":"5381"},{"range":"5418","text":"5359"},{"range":"5418","text":"5360"},{"range":"5419","text":"5359"},{"range":"5419","text":"5360"},{"range":"5420","text":"5359"},{"range":"5420","text":"5360"},{"range":"5421","text":"5381"},{"range":"5422","text":"5423"},{"range":"5424","text":"5359"},{"range":"5424","text":"5360"},{"range":"5425","text":"5359"},{"range":"5425","text":"5360"},{"range":"5426","text":"5359"},{"range":"5426","text":"5360"},{"range":"5427","text":"5359"},{"range":"5427","text":"5360"},{"range":"5428","text":"5359"},{"range":"5428","text":"5360"},{"range":"5429","text":"5359"},{"range":"5429","text":"5360"},{"range":"5430","text":"5359"},{"range":"5430","text":"5360"},{"range":"5431","text":"5359"},{"range":"5431","text":"5360"},{"range":"5432","text":"5359"},{"range":"5432","text":"5360"},{"range":"5433","text":"5359"},{"range":"5433","text":"5360"},{"range":"5434","text":"5359"},{"range":"5434","text":"5360"},{"range":"5435","text":"5359"},{"range":"5435","text":"5360"},{"range":"5436","text":"5359"},{"range":"5436","text":"5360"},{"range":"5437","text":"5359"},{"range":"5437","text":"5360"},{"range":"5438","text":"5381"},{"range":"5439","text":"5381"},{"range":"5440","text":"5359"},{"range":"5440","text":"5360"},{"range":"5441","text":"5359"},{"range":"5441","text":"5360"},{"range":"5442","text":"5381"},{"range":"5443","text":"5381"},{"range":"5444","text":"5381"},{"range":"5445","text":"5381"},{"range":"5446","text":"5359"},{"range":"5446","text":"5360"},{"range":"5447","text":"5359"},{"range":"5447","text":"5360"},{"range":"5448","text":"5359"},{"range":"5448","text":"5360"},{"range":"5449","text":"5359"},{"range":"5449","text":"5360"},{"range":"5450","text":"5359"},{"range":"5450","text":"5360"},{"range":"5451","text":"5359"},{"range":"5451","text":"5360"},{"range":"5452","text":"5359"},{"range":"5452","text":"5360"},{"range":"5453","text":"5359"},{"range":"5453","text":"5360"},{"range":"5454","text":"5359"},{"range":"5454","text":"5360"},{"range":"5455","text":"5359"},{"range":"5455","text":"5360"},{"range":"5456","text":"5359"},{"range":"5456","text":"5360"},{"range":"5457","text":"5359"},{"range":"5457","text":"5360"},{"range":"5458","text":"5359"},{"range":"5458","text":"5360"},{"range":"5459","text":"5359"},{"range":"5459","text":"5360"},{"range":"5460","text":"5359"},{"range":"5460","text":"5360"},{"range":"5461","text":"5359"},{"range":"5461","text":"5360"},{"range":"5462","text":"5359"},{"range":"5462","text":"5360"},{"range":"5463","text":"5381"},{"range":"5464","text":"5359"},{"range":"5464","text":"5360"},{"range":"5465","text":"5359"},{"range":"5465","text":"5360"},{"range":"5466","text":"5359"},{"range":"5466","text":"5360"},{"range":"5467","text":"5359"},{"range":"5467","text":"5360"},{"range":"5468","text":"5359"},{"range":"5468","text":"5360"},{"range":"5469","text":"5359"},{"range":"5469","text":"5360"},{"range":"5470","text":"5359"},{"range":"5470","text":"5360"},{"range":"5471","text":"5359"},{"range":"5471","text":"5360"},{"range":"5472","text":"5359"},{"range":"5472","text":"5360"},{"range":"5473","text":"5359"},{"range":"5473","text":"5360"},{"range":"5474","text":"5359"},{"range":"5474","text":"5360"},{"range":"5475","text":"5359"},{"range":"5475","text":"5360"},{"range":"5476","text":"5359"},{"range":"5476","text":"5360"},{"range":"5477","text":"5359"},{"range":"5477","text":"5360"},{"range":"5478","text":"5359"},{"range":"5478","text":"5360"},{"range":"5479","text":"5359"},{"range":"5479","text":"5360"},{"range":"5480","text":"5359"},{"range":"5480","text":"5360"},{"range":"5481","text":"5359"},{"range":"5481","text":"5360"},{"range":"5482","text":"5359"},{"range":"5482","text":"5360"},{"range":"5483","text":"5359"},{"range":"5483","text":"5360"},{"range":"5484","text":"5359"},{"range":"5484","text":"5360"},{"range":"5485","text":"5359"},{"range":"5485","text":"5360"},{"range":"5486","text":"5359"},{"range":"5486","text":"5360"},{"range":"5487","text":"5359"},{"range":"5487","text":"5360"},{"range":"5488","text":"5359"},{"range":"5488","text":"5360"},{"range":"5489","text":"5359"},{"range":"5489","text":"5360"},{"range":"5490","text":"5359"},{"range":"5490","text":"5360"},{"range":"5491","text":"5359"},{"range":"5491","text":"5360"},{"range":"5492","text":"5359"},{"range":"5492","text":"5360"},{"range":"5493","text":"5359"},{"range":"5493","text":"5360"},{"range":"5494","text":"5359"},{"range":"5494","text":"5360"},{"range":"5495","text":"5359"},{"range":"5495","text":"5360"},{"range":"5496","text":"5359"},{"range":"5496","text":"5360"},{"range":"5497","text":"5359"},{"range":"5497","text":"5360"},{"range":"5498","text":"5359"},{"range":"5498","text":"5360"},{"range":"5499","text":"5359"},{"range":"5499","text":"5360"},{"range":"5500","text":"5359"},{"range":"5500","text":"5360"},{"range":"5501","text":"5359"},{"range":"5501","text":"5360"},{"range":"5502","text":"5359"},{"range":"5502","text":"5360"},{"range":"5503","text":"5359"},{"range":"5503","text":"5360"},{"range":"5504","text":"5359"},{"range":"5504","text":"5360"},{"range":"5505","text":"5506"},{"range":"5507","text":"5359"},{"range":"5507","text":"5360"},{"range":"5508","text":"5359"},{"range":"5508","text":"5360"},{"range":"5509","text":"5359"},{"range":"5509","text":"5360"},{"range":"5510","text":"5359"},{"range":"5510","text":"5360"},{"range":"5511","text":"5359"},{"range":"5511","text":"5360"},{"range":"5512","text":"5359"},{"range":"5512","text":"5360"},{"range":"5513","text":"5359"},{"range":"5513","text":"5360"},{"range":"5514","text":"5359"},{"range":"5514","text":"5360"},{"range":"5515","text":"5359"},{"range":"5515","text":"5360"},{"range":"5516","text":"5359"},{"range":"5516","text":"5360"},{"range":"5517","text":"5359"},{"range":"5517","text":"5360"},{"range":"5518","text":"5359"},{"range":"5518","text":"5360"},{"range":"5519","text":"5359"},{"range":"5519","text":"5360"},{"range":"5520","text":"5359"},{"range":"5520","text":"5360"},{"range":"5521","text":"5359"},{"range":"5521","text":"5360"},{"range":"5522","text":"5359"},{"range":"5522","text":"5360"},{"range":"5523","text":"5359"},{"range":"5523","text":"5360"},{"range":"5524","text":"5359"},{"range":"5524","text":"5360"},{"range":"5525","text":"5359"},{"range":"5525","text":"5360"},{"range":"5526","text":"5359"},{"range":"5526","text":"5360"},{"range":"5527","text":"5359"},{"range":"5527","text":"5360"},{"range":"5528","text":"5359"},{"range":"5528","text":"5360"},{"range":"5529","text":"5359"},{"range":"5529","text":"5360"},{"range":"5530","text":"5359"},{"range":"5530","text":"5360"},{"range":"5531","text":"5359"},{"range":"5531","text":"5360"},{"range":"5532","text":"5359"},{"range":"5532","text":"5360"},{"range":"5533","text":"5359"},{"range":"5533","text":"5360"},{"range":"5534","text":"5359"},{"range":"5534","text":"5360"},{"range":"5535","text":"5359"},{"range":"5535","text":"5360"},{"range":"5536","text":"5359"},{"range":"5536","text":"5360"},{"range":"5537","text":"5359"},{"range":"5537","text":"5360"},{"range":"5538","text":"5359"},{"range":"5538","text":"5360"},{"range":"5539","text":"5359"},{"range":"5539","text":"5360"},{"range":"5540","text":"5359"},{"range":"5540","text":"5360"},{"range":"5541","text":"5359"},{"range":"5541","text":"5360"},{"range":"5542","text":"5359"},{"range":"5542","text":"5360"},{"range":"5543","text":"5359"},{"range":"5543","text":"5360"},{"range":"5544","text":"5359"},{"range":"5544","text":"5360"},{"range":"5545","text":"5359"},{"range":"5545","text":"5360"},{"range":"5546","text":"5359"},{"range":"5546","text":"5360"},{"range":"5547","text":"5359"},{"range":"5547","text":"5360"},{"range":"5548","text":"5359"},{"range":"5548","text":"5360"},{"range":"5549","text":"5359"},{"range":"5549","text":"5360"},{"range":"5550","text":"5359"},{"range":"5550","text":"5360"},{"range":"5551","text":"5359"},{"range":"5551","text":"5360"},{"range":"5552","text":"5359"},{"range":"5552","text":"5360"},{"range":"5553","text":"5359"},{"range":"5553","text":"5360"},{"range":"5554","text":"5359"},{"range":"5554","text":"5360"},{"range":"5555","text":"5359"},{"range":"5555","text":"5360"},{"range":"5556","text":"5359"},{"range":"5556","text":"5360"},{"range":"5557","text":"5359"},{"range":"5557","text":"5360"},{"range":"5558","text":"5359"},{"range":"5558","text":"5360"},{"range":"5559","text":"5359"},{"range":"5559","text":"5360"},{"range":"5560","text":"5359"},{"range":"5560","text":"5360"},{"range":"5561","text":"5359"},{"range":"5561","text":"5360"},{"range":"5562","text":"5359"},{"range":"5562","text":"5360"},{"range":"5563","text":"5359"},{"range":"5563","text":"5360"},{"range":"5564","text":"5359"},{"range":"5564","text":"5360"},{"range":"5565","text":"5359"},{"range":"5565","text":"5360"},{"range":"5566","text":"5359"},{"range":"5566","text":"5360"},{"range":"5567","text":"5359"},{"range":"5567","text":"5360"},{"range":"5568","text":"5359"},{"range":"5568","text":"5360"},{"range":"5569","text":"5359"},{"range":"5569","text":"5360"},{"range":"5570","text":"5359"},{"range":"5570","text":"5360"},{"range":"5571","text":"5359"},{"range":"5571","text":"5360"},{"range":"5572","text":"5359"},{"range":"5572","text":"5360"},{"range":"5573","text":"5359"},{"range":"5573","text":"5360"},{"range":"5574","text":"5359"},{"range":"5574","text":"5360"},{"range":"5575","text":"5359"},{"range":"5575","text":"5360"},{"range":"5576","text":"5359"},{"range":"5576","text":"5360"},{"range":"5577","text":"5359"},{"range":"5577","text":"5360"},{"range":"5578","text":"5359"},{"range":"5578","text":"5360"},{"range":"5579","text":"5359"},{"range":"5579","text":"5360"},{"range":"5580","text":"5359"},{"range":"5580","text":"5360"},{"range":"5581","text":"5359"},{"range":"5581","text":"5360"},{"range":"5582","text":"5359"},{"range":"5582","text":"5360"},{"range":"5583","text":"5359"},{"range":"5583","text":"5360"},{"range":"5584","text":"5359"},{"range":"5584","text":"5360"},{"range":"5585","text":"5359"},{"range":"5585","text":"5360"},{"range":"5586","text":"5359"},{"range":"5586","text":"5360"},{"range":"5587","text":"5359"},{"range":"5587","text":"5360"},{"range":"5588","text":"5359"},{"range":"5588","text":"5360"},{"range":"5589","text":"5359"},{"range":"5589","text":"5360"},{"range":"5590","text":"5359"},{"range":"5590","text":"5360"},{"range":"5591","text":"5359"},{"range":"5591","text":"5360"},{"range":"5592","text":"5359"},{"range":"5592","text":"5360"},{"range":"5593","text":"5359"},{"range":"5593","text":"5360"},{"range":"5594","text":"5359"},{"range":"5594","text":"5360"},{"range":"5595","text":"5359"},{"range":"5595","text":"5360"},{"range":"5596","text":"5359"},{"range":"5596","text":"5360"},{"range":"5597","text":"5359"},{"range":"5597","text":"5360"},{"range":"5598","text":"5359"},{"range":"5598","text":"5360"},{"range":"5599","text":"5359"},{"range":"5599","text":"5360"},{"range":"5600","text":"5359"},{"range":"5600","text":"5360"},{"range":"5601","text":"5359"},{"range":"5601","text":"5360"},{"range":"5602","text":"5359"},{"range":"5602","text":"5360"},{"range":"5603","text":"5359"},{"range":"5603","text":"5360"},{"range":"5604","text":"5359"},{"range":"5604","text":"5360"},{"range":"5605","text":"5359"},{"range":"5605","text":"5360"},{"range":"5606","text":"5359"},{"range":"5606","text":"5360"},{"range":"5607","text":"5359"},{"range":"5607","text":"5360"},{"range":"5608","text":"5359"},{"range":"5608","text":"5360"},{"range":"5609","text":"5359"},{"range":"5609","text":"5360"},{"range":"5610","text":"5359"},{"range":"5610","text":"5360"},{"range":"5611","text":"5359"},{"range":"5611","text":"5360"},{"range":"5612","text":"5359"},{"range":"5612","text":"5360"},[726,729],"unknown","never",[767,770],[1217,1220],[1487,1490],[2421,2424],[2587,2590],[2659,2662],[1492,1495],[1707,1710],[187,190],[144,147],[285,288],[1927,1930],[1994,1997],[3648,3651],[59,62],[789,792],[1808,1811],[2384,2387],[1763,1766],[7274,7275],"?",[13062,13065],[2796,2797],[5914,5917],[6888,6891],[8142,8145],[985,988],[2772,2773],[3563,3564],[3995,3996],[475,478],[456,459],[942,945],[640,643],[915,918],[1762,1765],[2508,2511],[7506,7509],[8658,8661],[1042,1045],[1357,1360],[2675,2678],[2717,2720],[4058,4061],[4390,4393],[367,370],[25306,25309],[15937,15940],[15942,15945],[15947,15950],[15952,15955],[15957,15960],[15962,15965],[15982,15985],[15987,15990],[15996,15999],[4498,4499],[930,933],[1959,1962],[3685,3688],[5383,5384],[6506,6507],"?.",[10216,10219],[110,113],[954,957],[27489,27492],[3696,3699],[4242,4245],[20706,20709],[30271,30274],[715,718],[1691,1694],[1125,1128],[1178,1181],[3298,3301],[3441,3444],[4591,4592],[5156,5157],[9389,9392],[15918,15921],[1926,1927],[2309,2310],[3089,3090],[6111,6112],[3235,3238],[15869,15872],[4996,4999],[4580,4583],[6541,6544],[10105,10108],[16967,16970],[22422,22425],[24201,24204],[26814,26817],[27899,27902],[28054,28057],[31582,31585],[33271,33274],[2945,2948],[3006,3009],[2453,2456],[2679,2680],[2816,2819],[2554,2557],[6295,6298],[6887,6890],[6897,6900],[12923,12926],[30681,30684],[35291,35294],[3272,3275],[3909,3912],[4368,4371],[4558,4561],[5341,5344],[6881,6884],[14500,14503],[16317,16320],[16444,16447],[17226,17229],[398,401],[458,461],[466,469],[572,575],[580,583],[853,856],[860,863],[926,929],[1140,1143],[1150,1153],[1174,1177],[1201,1204],[1284,1287],[146,149],[154,157],[187,190],[138,141],[146,149],[209,212],[160,163],[168,171],[245,248],[165,168],[372,442],"type IOrbitDBKeystoreStore = IOrbitDBKeystoreStoreCustom",[549,552],[581,584],[1294,1297],[154,157],[171,174],[624,627],[649,652],[1152,1155],[1177,1180],[1886,1889],[1924,1927],[2144,2147],[2370,2373],[3547,3550],[3737,3740],[5664,5667],[5686,5689],[32,35],[462,465],[467,470],[478,481],[491,494],[149,152],[275,278],[510,513],[825,828],[853,856],[1576,1579],[7458,7461],[181,184],[367,370],[490,493],[642,645],[771,774],[902,905],[890,893],[980,983],[1591,1594],[1771,1774],[1957,1960],[2144,2147],[2335,2338],[3186,3189],[3703,3706],[3807,3810],[1249,1252],[1265,1268],[1309,1312],[1487,1490],[980,983],[281,284],[682,685],[945,948],[7949,7952],[357,360],[9702,9705],[10615,10618],[11131,11134],[3171,3174],[3684,3687],[4161,4164],[4355,4358],[5343,5346],[6079,6082],[7506,7509],[3278,3281],[3561,3564],[3676,3679],[144,147],[293,296],[328,331],[702,705],[305,308],[827,830],[755,758],[1285,1288],[1805,1808],[88,91],[115,118],[44,47],[49,52],[71,74],[512,515],[517,520],[224,227],[232,235],[1075,1078],[1085,1088],[1120,1123],[1503,1506],[2136,2139],[1374,1377],[1382,1385],[1625,1628],[2150,2153],[3689,3692],[4079,4082],[4887,4890],[5120,5123],[544,547],[1126,1129],[5019,5022],[1249,1252],[2233,2236],[2507,2510],[7724,7727]]