import { IStore } from 'orbit-db-cache';
import { ISecretStoreCredentials } from 'classes/secret-storage-class/secret-storage-class.types';
import { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';
import { ISwarmStoreConnectorOrbitDBSubclassStorageFabric } from './swarm-store-connector-orbit-db-subclass-storage-fabric.types';
import { SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter } from '../swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter/swarm-store-connector-orbit-db-subclass-store-to-secret-storage-adapter';

export class SwarmStoreConnectorOrbitDBSubclassStorageFabric
  implements ISwarmStoreConnectorOrbitDBSubclassStorageFabric {
  private key?: CryptoKey;

  private ready?: Promise<void>;

  constructor(credentials: ISecretStoreCredentials) {
    this.applyCredentials(credentials);
  }

  /**
   * create an instance of OrbitDB Cache
   * for a path provided
   *
   * @param {string} path
   * @returns {Cache}
   * @memberof SwarmStoreConnectorOrbitDBSubclassStorageFabric
   * @throws
   */
  public async createStore(path: string): Promise<IStore> {
    await this.ready;

    const { key } = this;

    if (!key) {
      throw new Error('A CryptoKey is not exists');
    }
    if (!(key instanceof CryptoKey)) {
      throw new Error('The key must be an instance of CryptoKey');
    }

    const cache = new SwarmStoreConnectorOrbitDBSubclassStoreToSecretStorageAdapter(
      { key },
      { dbName: path }
    );

    return cache;
  }

  protected applyCredentials(credentials: ISecretStoreCredentials): void {
    const validateCredentialsResult = SecretStorage.validateCredentials(
      credentials
    );

    if (validateCredentialsResult instanceof Error) {
      console.error(`applyCredentials::${validateCredentialsResult}`);
      throw new Error('The credentials provided are not valid');
    }
    this.ready = this.createKey(credentials);
  }

  /**
   *
   *
   * @protected
   * @param {ISecretStoreCredentials} credentials
   * @returns {Promise<void>}
   * @memberof SwarmStoreConnectorOrbitDBSubclassStorageFabric
   * @throws
   */
  protected async createKey(
    credentials: ISecretStoreCredentials
  ): Promise<void> {
    const key = await SecretStorage.generatePasswordKeyByPasswordString(
      credentials.password
    );

    if (key instanceof Error) {
      console.error(`createKey::${key}`);
      throw new Error('Failed to generate a key');
    }
    if (!(key instanceof CryptoKey)) {
      throw new Error(
        'createKey::the key generated by a password string must be a CryptoKey'
      );
    }
    this.key = key;
  }
}
