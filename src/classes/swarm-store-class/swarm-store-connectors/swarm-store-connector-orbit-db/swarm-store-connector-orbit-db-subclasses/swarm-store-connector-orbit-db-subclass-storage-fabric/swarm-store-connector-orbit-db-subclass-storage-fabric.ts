import Cache from 'orbit-db-cache';
import { ISecretStoreCredentials } from 'classes/secret-storage-class/secret-storage-class.types';
import { SecretStorage } from 'classes/secret-storage-class/secret-storage-class';
import { ISwarmStoreConnectorOrbitDBSubclassStorageFabric } from './swarm-store-connector-orbit-db-subclass-storage-fabric.types';
import { SwarmStoreConnectorOrbitDBSubclassStorageCache } from '../swarm-store-connector-orbit-db-subclass-storage-cache/swarm-store-connector-orbit-db-subclass-storage-cache';

export class SwarmStoreConnectorOrbitDBSubclassStorageFabric implements ISwarmStoreConnectorOrbitDBSubclassStorageFabric {
    private key?: CryptoKey;
    
    constructor(credentials: ISecretStoreCredentials) {
        this.applyCredentials(credentials);
    }

    /**
     * create an instance of OrbitDB Cache
     * for a path provided
     *
     * @param {string} path
     * @returns {Cache}
     * @memberof SwarmStoreConnectorOrbitDBSubclassStorageFabric
     * @throws
     */
    public createStore(path: string): Cache {
        const { key } = this;

        if (!key) {
            throw new Error('A CryptoKey is not exists');
        }
        if (!(key instanceof CryptoKey)) {
            throw new Error('The key must be an instance of CryptoKey');
        }

        const cache = new SwarmStoreConnectorOrbitDBSubclassStorageCache(
            { key },
            { dbName: path }
        );

        return cache;
    }

    protected applyCredentials(credentials: ISecretStoreCredentials): void {
        const validateCredentialsResult = SecretStorage.validateCredentials(credentials);

        if (validateCredentialsResult instanceof Error) {
            console.error(`applyCredentials::${validateCredentialsResult}`);
            throw new Error('The credentials provided are not valid');
        }
        this.createKey(credentials);
    }

    protected createKey(credentials: ISecretStoreCredentials): void {
        const key = SecretStorage.generatePasswordKeyByPasswordString(credentials.password);

        if (key instanceof Error) {
            console.error(`createKey::${key}`);
            throw new Error();
        }
        if (!(key instanceof CryptoKey)) {
            throw new Error('createKey::the key generated by a password string must be a CryptoKey');
        }
        this.key = key;
    }
}